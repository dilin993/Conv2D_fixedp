// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2017.1
// Copyright (C) 1986-2017 Xilinx, Inc. All Rights Reserved.
// 
// ==============================================================

#1 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"
#1 "<built-in>"
#1 "<command-line>"
#1 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h" 1
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 1
#46 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h" 1
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 1
#55 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
#1 "/usr/include/assert.h" 1 3 4
#35 "/usr/include/assert.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/features.h" 1 3 4
#339 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/features.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
#410 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#411 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
#340 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/features.h" 2 3 4
#362 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/features.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
#10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
#11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
#363 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/features.h" 2 3 4
#36 "/usr/include/assert.h" 2 3 4
#66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
#56 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 2
#1 "/usr/include/stdlib.h" 1 3 4
#32 "/usr/include/stdlib.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#212 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 3 4
typedef long unsigned int size_t;
#33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






#1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
#50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
#42 "/usr/include/stdlib.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
#64 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
#1 "/usr/include/endian.h" 1 3 4
#36 "/usr/include/endian.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
#37 "/usr/include/endian.h" 2 3 4
#60 "/usr/include/endian.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
#27 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
#27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
#121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
#122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
#28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






#1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
#36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
#44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
#108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
#61 "/usr/include/endian.h" 2 3 4
#65 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
#43 "/usr/include/stdlib.h" 2 3 4
#95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


#139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

#235 "/usr/include/stdlib.h" 3 4
#1 "/usr/include/xlocale.h" 1 3 4
#27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
#236 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
#305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




#1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
#27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
#132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#1 "/usr/include/time.h" 1 3 4
#57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



#73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



#91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
#103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
#133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
#194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
#219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
#30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
#22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
#31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
#22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
#34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





#1 "/usr/include/time.h" 1 3 4
#120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
#44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

#1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
#30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
#46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
#54 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
#64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
#96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
#106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
#118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
#131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
#220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
#24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
#58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
#223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
#262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





#1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
#21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
#60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
#90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
#125 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];


    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
#220 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
#271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
#315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



#1 "/usr/include/alloca.h" 1 3 4
#24 "/usr/include/alloca.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
#493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;
#513 "/usr/include/stdlib.h" 3 4


extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));
#530 "/usr/include/stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));













extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
#606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
#619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
#629 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
#641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
#651 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
#662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
#673 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
#683 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
#693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
#705 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
#733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

#811 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
#898 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));
#923 "/usr/include/stdlib.h" 3 4
extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));


#1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
#955 "/usr/include/stdlib.h" 2 3 4
#967 "/usr/include/stdlib.h" 3 4
}
#57 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 2
#1 "/usr/include/string.h" 1 3 4
#27 "/usr/include/string.h" 3 4
extern "C" {




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
#90 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

#162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
#206 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
#229 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
#256 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
#308 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
#335 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
#377 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

#433 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
#482 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
#510 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
#658 "/usr/include/string.h" 3 4
}
#58 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/float.h" 1 3 4
#59 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 2


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stdint.h" 1 3 4


#1 "/usr/include/stdint.h" 1 3 4
#26 "/usr/include/stdint.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
#27 "/usr/include/stdint.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#28 "/usr/include/stdint.h" 2 3 4
#48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
#65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
#90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
#103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
#119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
#134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
#4 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stdint.h" 2 3 4
#62 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 2
#87 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 1 3 4
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 1 3 4
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/mmintrin.h" 1 3 4
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/mmintrin.h" 3 4
typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));


typedef int __v2si __attribute__ ((__vector_size__ (8)));
typedef short __v4hi __attribute__ ((__vector_size__ (8)));
typedef char __v8qi __attribute__ ((__vector_size__ (8)));
typedef long long __v1di __attribute__ ((__vector_size__ (8)));
typedef float __v2sf __attribute__ ((__vector_size__ (8)));


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_empty (void)
{
  __builtin_ia32_emms ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_empty (void)
{
  _mm_empty ();
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si64 (int __i)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int (int __i)
{
  return _mm_cvtsi32_si64 (__i);
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_m64 (long long __i)
{
  return (__m64) __i;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi64x (long long __i)
{
  return (__m64) __i;
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si32 (__m64 __i)
{
  return __builtin_ia32_vec_ext_v2si ((__v2si)__i, 0);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int (__m64 __i)
{
  return _mm_cvtsi64_si32 (__i);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int64 (__m64 __i)
{
  return (long long)__i;
}

extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtm64_si64 (__m64 __i)
{
  return (long long)__i;
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si64x (__m64 __i)
{
  return (long long)__i;
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packsswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packsswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packssdw ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packssdw (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi32 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packuswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packuswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pu16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhdq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhdq (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckldq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckldq (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddb (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddw (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddd (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddq ((__v1di)__m1, (__v1di)__m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubb (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubw (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubd (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubq ((__v1di)__m1, (__v1di)__m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmaddwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaddwd (__m64 __m1, __m64 __m2)
{
  return _mm_madd_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmulhw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhw (__m64 __m1, __m64 __m2)
{
  return _mm_mulhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmullw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmullw (__m64 __m1, __m64 __m2)
{
  return _mm_mullo_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllw (__m64 __m, __m64 __count)
{
  return _mm_sll_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllwi (__m64 __m, int __count)
{
  return _mm_slli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_pslld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslld (__m64 __m, __m64 __count)
{
  return _mm_sll_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_pslldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslldi (__m64 __m, int __count)
{
  return _mm_slli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllq (__m64 __m, __m64 __count)
{
  return _mm_sll_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllqi (__m64 __m, int __count)
{
  return _mm_slli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psraw (__m64 __m, __m64 __count)
{
  return _mm_sra_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrawi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrawi (__m64 __m, int __count)
{
  return _mm_srai_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrad ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrad (__m64 __m, __m64 __count)
{
  return _mm_sra_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psradi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psradi (__m64 __m, int __count)
{
  return _mm_srai_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlw (__m64 __m, __m64 __count)
{
  return _mm_srl_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlwi (__m64 __m, int __count)
{
  return _mm_srli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrld (__m64 __m, __m64 __count)
{
  return _mm_srl_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrldi (__m64 __m, int __count)
{
  return _mm_srli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlq (__m64 __m, __m64 __count)
{
  return _mm_srl_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlqi (__m64 __m, int __count)
{
  return _mm_srli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pand (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pand (__m64 __m1, __m64 __m2)
{
  return _mm_and_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pandn (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pandn (__m64 __m1, __m64 __m2)
{
  return _mm_andnot_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_por (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_por (__m64 __m1, __m64 __m2)
{
  return _mm_or_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pxor (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pxor (__m64 __m1, __m64 __m2)
{
  return _mm_xor_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi8 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi16 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi32 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si64 (void)
{
  return (__m64)0LL;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi32 (int __i1, int __i0)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i0, __i1);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
{
  return (__m64) __builtin_ia32_vec_init_v4hi (__w0, __w1, __w2, __w3);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
      char __b3, char __b2, char __b1, char __b0)
{
  return (__m64) __builtin_ia32_vec_init_v8qi (__b0, __b1, __b2, __b3,
            __b4, __b5, __b6, __b7);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi32 (int __i0, int __i1)
{
  return _mm_set_pi32 (__i1, __i0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)
{
  return _mm_set_pi16 (__w3, __w2, __w1, __w0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
       char __b4, char __b5, char __b6, char __b7)
{
  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi32 (int __i)
{
  return _mm_set_pi32 (__i, __i);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi16 (short __w)
{
  return _mm_set_pi16 (__w, __w, __w, __w);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi8 (char __b)
{
  return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);
}
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 2 3 4


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/mm_malloc.h" 1 3 4
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/mm_malloc.h" 3 4
extern "C" int posix_memalign (void **, size_t, size_t) throw ();


static __inline void *
_mm_malloc (size_t size, size_t alignment)
{
  void *ptr;
  if (alignment == 1)
    return malloc (size);
  if (alignment == 2 || (sizeof (void *) == 8 && alignment == 4))
    alignment = sizeof (void *);
  if (posix_memalign (&ptr, alignment, size) == 0)
    return ptr;
  else
    return __null;
}

static __inline void
_mm_free (void * ptr)
{
  free (ptr);
}
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 2 3 4



typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));


typedef float __v4sf __attribute__ ((__vector_size__ (16)));






enum _mm_hint
{
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};
#89 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_ps (void)
{
  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andnps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_orps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_xorps (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpltss ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpless ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnltss ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnless ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);
}




extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si32 (__m128 __A)
{
  return __builtin_ia32_cvtss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ss2si (__m128 __A)
{
  return _mm_cvtss_si32 (__A);
}






extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64 (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64x (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ps2pi (__m128 __A)
{
  return _mm_cvtps_pi32 (__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si32 (__m128 __A)
{
  return __builtin_ia32_cvttss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ss2si (__m128 __A)
{
  return _mm_cvttss_si32 (__A);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64 (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64x (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ps2pi (__m128 __A)
{
  return _mm_cvttps_pi32 (__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_ss (__m128 __A, int __B)
{
  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_si2ss (__m128 __A, int __B)
{
  return _mm_cvtsi32_ss (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_ps (__m128 __A, __m64 __B)
{
  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_pi2ps (__m128 __A, __m64 __B)
{
  return _mm_cvtpi32_ps (__A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi16_ps (__m64 __A)
{
  __v4hi __sign;
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;




  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu16_ps (__m64 __A)
{
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi8_ps (__m64 __A)
{
  __v8qi __sign;




  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);


  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);

  return _mm_cvtpi16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu8_ps(__m64 __A)
{
  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);
  return _mm_cvtpu16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)
{
  __v4sf __zero = (__v4sf) _mm_setzero_ps ();
  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);
  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__sfa, (__v2si)__B);
  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi16(__m128 __A)
{
  __v4sf __hisf = (__v4sf)__A;
  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);
  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);
  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);
  return (__m64) __builtin_ia32_packssdw (__hisi, __losi);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi8(__m128 __A)
{
  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);
  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);
}
#727 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storehps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movehl_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movelh_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storelps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_ps (__m128 __A)
{
  return __builtin_ia32_movmskps ((__v4sf)__A);
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_getcsr (void)
{
  return __builtin_ia32_stmxcsr ();
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_STATE (void)
{
  return _mm_getcsr() & 0x003f;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_MASK (void)
{
  return _mm_getcsr() & 0x1f80;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_ROUNDING_MODE (void)
{
  return _mm_getcsr() & 0x6000;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_FLUSH_ZERO_MODE (void)
{
  return _mm_getcsr() & 0x8000;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setcsr (unsigned int __I)
{
  __builtin_ia32_ldmxcsr (__I);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_STATE(unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x003f) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_MASK (unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x1f80) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_ROUNDING_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x6000) | __mode);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x8000) | __mode);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ss (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_ps (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps1 (float __F)
{
  return _mm_set1_ps (__F);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ss (float const *__P)
{
  return _mm_set_ss (*__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_ps (float const *__P)
{
  return _mm_set1_ps (*__P);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps1 (float const *__P)
{
  return _mm_load1_ps (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps (float const *__P)
{
  return (__m128) *(__v4sf *)__P;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_ps (float const *__P)
{
  return (__m128) __builtin_ia32_loadups (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_ps (float const *__P)
{
  __v4sf __tmp = *(__v4sf *)__P;
  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)
{
  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_ps (float __Z, float __Y, float __X, float __W)
{
  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ss (float *__P, __m128 __A)
{
  *__P = __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);
}

extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_f32 (__m128 __A)
{
  return __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps (float *__P, __m128 __A)
{
  *(__v4sf *)__P = (__v4sf)__A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_ps (float *__P, __m128 __A)
{
  __builtin_ia32_storeups (__P, (__v4sf)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((0) << 4) | ((0) << 2) | (0)));
  _mm_storeu_ps (__P, __tmp);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps1 (float *__P, __m128 __A)
{
  _mm_store1_ps (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
  _mm_store_ps (__P, __tmp);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf)__A, (__v4sf)__B);
}
#1032 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 3 4
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxsw (__m64 __A, __m64 __B)
{
  return _mm_max_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxub (__m64 __A, __m64 __B)
{
  return _mm_max_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminsw (__m64 __A, __m64 __B)
{
  return _mm_min_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminub (__m64 __A, __m64 __B)
{
  return _mm_min_pu8 (__A, __B);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pi8 (__m64 __A)
{
  return __builtin_ia32_pmovmskb ((__v8qi)__A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmovmskb (__m64 __A)
{
  return _mm_movemask_pi8 (__A);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhuw (__m64 __A, __m64 __B)
{
  return _mm_mulhi_pu16 (__A, __B);
}
#1134 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
{
  __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_maskmovq (__m64 __A, __m64 __N, char *__P)
{
  _mm_maskmove_si64 (__A, __N, __P);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgb (__m64 __A, __m64 __B)
{
  return _mm_avg_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgw (__m64 __A, __m64 __B)
{
  return _mm_avg_pu16 (__A, __B);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psadbw (__m64 __A, __m64 __B)
{
  return _mm_sad_pu8 (__A, __B);
}
#1201 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pi (__m64 *__P, __m64 __A)
{
  __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_ps (float *__P, __m128 __A)
{
  __builtin_ia32_movntps (__P, (__v4sf)__A);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sfence (void)
{
  __builtin_ia32_sfence ();
}




extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_pause (void)
{
  __asm__ __volatile__ ("rep; nop" : : );
}
#1247 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 1 3 4
#1248 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/xmmintrin.h" 2 3 4
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 2 3 4


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef int __v4si __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__ ((__vector_size__ (16)));
typedef char __v16qi __attribute__ ((__vector_size__ (16)));



typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));






extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_sd (double __F)
{
  return __extension__ (__m128d){ __F, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pd (double __F)
{
  return __extension__ (__m128d){ __F, __F };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd1 (double __F)
{
  return _mm_set1_pd (__F);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __X, __W };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __W, __X };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_pd (void)
{
  return __extension__ (__m128d){ 0.0, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd (double const *__P)
{
  return *(__m128d *)__P;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_pd (double const *__P)
{
  return __builtin_ia32_loadupd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_pd (double const *__P)
{
  return _mm_set1_pd (*__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_sd (double const *__P)
{
  return _mm_set_sd (*__P);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd1 (double const *__P)
{
  return _mm_load1_pd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_pd (double const *__P)
{
  __m128d __tmp = _mm_load_pd (__P);
  return __builtin_ia32_shufpd (__tmp, __tmp, (((0) << 1) | (1)));
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd (double *__P, __m128d __A)
{
  *(__m128d *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_pd (double *__P, __m128d __A)
{
  __builtin_ia32_storeupd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_sd (double *__P, __m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df (__A, 0);
}

extern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_f64 (__m128d __A)
{
  return __builtin_ia32_vec_ext_v2df (__A, 0);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pd (double *__P, __m128d __A)
{
  _mm_store_sd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pd (double *__P, __m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df (__A, 1);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (0))));
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd1 (double *__P, __m128d __A)
{
  _mm_store1_pd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (1))));
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si32 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di ((__v2di)__A, 0);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64x (__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di ((__v2di)__A, 0);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_pd (__m128d __A)
{
  return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_sd (__m128d __A, __m128d __B)
{
  __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
  return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpltsd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmplesd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnltsd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnlesd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64x (long long __q1, long long __q0)
{
  return __extension__ (__m128i)(__v2di){ __q0, __q1 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64 (__m64 __q1, __m64 __q0)
{
  return _mm_set_epi64x ((long long)__q1, (long long)__q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)
{
  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,
        short __q3, short __q2, short __q1, short __q0)
{
  return __extension__ (__m128i)(__v8hi){
    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,
       char __q11, char __q10, char __q09, char __q08,
       char __q07, char __q06, char __q05, char __q04,
       char __q03, char __q02, char __q01, char __q00)
{
  return __extension__ (__m128i)(__v16qi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15
  };
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64x (long long __A)
{
  return _mm_set_epi64x (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64 (__m64 __A)
{
  return _mm_set_epi64 (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi32 (int __A)
{
  return _mm_set_epi32 (__A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi16 (short __A)
{
  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi8 (char __A)
{
  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,
         __A, __A, __A, __A, __A, __A, __A, __A);
}




extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi64 (__m64 __q0, __m64 __q1)
{
  return _mm_set_epi64 (__q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)
{
  return _mm_set_epi32 (__q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,
         short __q4, short __q5, short __q6, short __q7)
{
  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,
        char __q04, char __q05, char __q06, char __q07,
        char __q08, char __q09, char __q10, char __q11,
        char __q12, char __q13, char __q14, char __q15)
{
  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
         __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_si128 (__m128i const *__P)
{
  return *__P;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si128 (__m128i const *__P)
{
  return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_epi64 (__m128i const *__P)
{
  return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_si128 (__m128i *__P, __m128i __B)
{
  *__P = __B;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si128 (__m128i *__P, __m128i __B)
{
  __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_epi64 (__m128i *__P, __m128i __B)
{
  *(long long *)__P = __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi64_pi64 (__m128i __B)
{
  return (__m64) __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movpi64_epi64 (__m64 __A)
{
  return _mm_set_epi64 ((__m64)0LL, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_epi64 (__m128i __A)
{
  return (__m128i)__builtin_ia32_movq128 ((__v2di) __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si128 (void)
{
  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_pd (__m128i __A)
{
  return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_ps (__m128i __A)
{
  return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_ps (__m128d __A)
{
  return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_pd (__m64 __A)
{
  return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pd (__m128 __A)
{
  return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_ss (__m128 __A, __m128d __B)
{
  return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_sd (__m128d __A, int __B)
{
  return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);
}



extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_sd (__m128d __A, __m128 __B)
{
  return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);
}
#893 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 3 4
extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pd (__m128d __A)
{
  return __builtin_ia32_movmskpd ((__v2df)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packus_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmullw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_su32 (__m64 __A, __m64 __B)
{
  return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);
}
#1164 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pand128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_por128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pxor128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__B, (__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__B, (__v8hi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__B, (__v4si)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__A, (__v4si)__B);
}
#1328 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_epi8 (__m128i __A)
{
  return __builtin_ia32_pmovmskb128 ((__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);
}
#1391 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/emmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
{
  __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si32 (int *__A, int __B)
{
  __builtin_ia32_movnti (__A, __B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si128 (__m128i *__A, __m128i __B)
{
  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pd (double *__A, __m128d __B)
{
  __builtin_ia32_movntpd (__A, (__v2df)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clflush (void const *__A)
{
  __builtin_ia32_clflush (__A);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_lfence (void)
{
  __builtin_ia32_lfence ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mfence (void)
{
  __builtin_ia32_mfence ();
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si128 (int __A)
{
  return _mm_set_epi32 (0, 0, 0, __A);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_ps(__m128d __A)
{
  return (__m128) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_si128(__m128d __A)
{
  return (__m128i) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_pd(__m128 __A)
{
  return (__m128d) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_si128(__m128 __A)
{
  return (__m128i) __A;
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_ps(__m128i __A)
{
  return (__m128) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_pd(__m128i __A)
{
  return (__m128d) __A;
}
#88 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 2






#1 "/usr/include/math.h" 1 3 4
#28 "/usr/include/math.h" 3 4
extern "C" {


#1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
#25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
#26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
#32 "/usr/include/math.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
#36 "/usr/include/math.h" 2 3 4

#1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
#38 "/usr/include/math.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
#39 "/usr/include/math.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
#42 "/usr/include/math.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
#45 "/usr/include/math.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
#28 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
#49 "/usr/include/math.h" 2 3 4
#83 "/usr/include/math.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
#52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();





 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));








extern int isinf (double __value) throw () __attribute__ ((__const__));



extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));






extern int isnan (double __value) throw () __attribute__ ((__const__));





extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));






extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
#84 "/usr/include/math.h" 2 3 4
#104 "/usr/include/math.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
#52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();





 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));








extern int isinff (float __value) throw () __attribute__ ((__const__));



extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));






extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));






extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
#105 "/usr/include/math.h" 2 3 4
#151 "/usr/include/math.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
#52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();





 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));








extern int isinfl (long double __value) throw () __attribute__ ((__const__));



extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));






extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));






extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
#152 "/usr/include/math.h" 2 3 4
#168 "/usr/include/math.h" 3 4
extern int signgam;
#209 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
#347 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
#370 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
#534 "/usr/include/math.h" 3 4
}
#95 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h" 2
#163 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
   typedef int64_t int64;
   typedef uint64_t uint64;





   typedef unsigned char uchar;
   typedef unsigned short ushort;


typedef signed char schar;
#196 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef void CvArr;

typedef union Cv32suf
{
    int i;
    unsigned u;
    float f;
}
Cv32suf;

typedef union Cv64suf
{
    int64 i;
    uint64 u;
    double f;
}
Cv64suf;

typedef int CVStatus;

enum {
 CV_StsOk= 0,
 CV_StsBackTrace= -1,
 CV_StsError= -2,
 CV_StsInternal= -3,
 CV_StsNoMem= -4,
 CV_StsBadArg= -5,
 CV_StsBadFunc= -6,
 CV_StsNoConv= -7,
 CV_StsAutoTrace= -8,
 CV_HeaderIsNull= -9,
 CV_BadImageSize= -10,
 CV_BadOffset= -11,
 CV_BadDataPtr= -12,
 CV_BadStep= -13,
 CV_BadModelOrChSeq= -14,
 CV_BadNumChannels= -15,
 CV_BadNumChannel1U= -16,
 CV_BadDepth= -17,
 CV_BadAlphaChannel= -18,
 CV_BadOrder= -19,
 CV_BadOrigin= -20,
 CV_BadAlign= -21,
 CV_BadCallBack= -22,
 CV_BadTileSize= -23,
 CV_BadCOI= -24,
 CV_BadROISize= -25,
 CV_MaskIsTiled= -26,
 CV_StsNullPtr= -27,
 CV_StsVecLengthErr= -28,
 CV_StsFilterStructContentErr= -29,
 CV_StsKernelStructContentErr= -30,
 CV_StsFilterOffsetErr= -31,
 CV_StsBadSize= -201,
 CV_StsDivByZero= -202,
 CV_StsInplaceNotSupported= -203,
 CV_StsObjectNotFound= -204,
 CV_StsUnmatchedFormats= -205,
 CV_StsBadFlag= -206,
 CV_StsBadPoint= -207,
 CV_StsBadMask= -208,
 CV_StsUnmatchedSizes= -209,
 CV_StsUnsupportedFormat= -210,
 CV_StsOutOfRange= -211,
 CV_StsParseError= -212,
 CV_StsNotImplemented= -213,
 CV_StsBadMemBlock= -214,
 CV_StsAssert= -215,
 CV_GpuNotSupported= -216,
 CV_GpuApiCallError= -217,
 CV_OpenGlNotSupported= -218,
 CV_OpenGlApiCallError= -219
};
#305 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
inline int cvRound( double value )
{

    __m128d t = _mm_set_sd( value );
    return _mm_cvtsd_si32(t);
#334 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
}





inline int cvFloor( double value )
{

    __m128d t = _mm_set_sd( value );
    int i = _mm_cvtsd_si32(t);
    return i - _mm_movemask_pd(_mm_cmplt_sd(t, _mm_cvtsi32_sd(t,i)));
#354 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
}


inline int cvCeil( double value )
{

    __m128d t = _mm_set_sd( value );
    int i = _mm_cvtsd_si32(t);
    return i + _mm_movemask_pd(_mm_cmplt_sd(_mm_cvtsi32_sd(t,i), t));
#371 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
}




inline int cvIsNaN( double value )
{
    Cv64suf ieee754;
    ieee754.f = value;
    return ((unsigned)(ieee754.u >> 32) & 0x7fffffff) +
           ((unsigned)ieee754.u != 0) > 0x7ff00000;
}


inline int cvIsInf( double value )
{
    Cv64suf ieee754;
    ieee754.f = value;
    return ((unsigned)(ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&
           (unsigned)ieee754.u == 0;
}




typedef uint64 CvRNG;



inline CvRNG cvRNG( int64 seed = -1)
{
    CvRNG rng = seed ? (uint64)seed : (uint64)(int64)-1;
    return rng;
}


inline unsigned cvRandInt( CvRNG* rng )
{
    uint64 temp = *rng;
    temp = (uint64)(unsigned)temp*4164903690U + (temp >> 32);
    *rng = temp;
    return (unsigned)temp;
}


inline double cvRandReal( CvRNG* rng )
{
    return cvRandInt(rng)*2.3283064365386962890625e-10 ;
}
#462 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct _IplImage
{
    int nSize;
    int ID;
    int nChannels;
    int alphaChannel;
    int depth;

    char colorModel[4];
    char channelSeq[4];
    int dataOrder;

    int origin;

    int align;

    int width;
    int height;
    struct _IplROI *roi;
    struct _IplImage *maskROI;
    void *imageId;
    struct _IplTileInfo *tileInfo;
    int imageSize;


    char *imageData;
    int widthStep;
    int BorderMode[4];
    int BorderConst[4];
    char *imageDataOrigin;


}
IplImage;

typedef struct _IplTileInfo IplTileInfo;

typedef struct _IplROI
{
    int coi;
    int xOffset;
    int yOffset;
    int width;
    int height;
}
IplROI;

typedef struct _IplConvKernel
{
    int nCols;
    int nRows;
    int anchorX;
    int anchorY;
    int *values;
    int nShiftR;
}
IplConvKernel;

typedef struct _IplConvKernelFP
{
    int nCols;
    int nRows;
    int anchorX;
    int anchorY;
    float *values;
}
IplConvKernelFP;
#642 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvMat
{
    int type;
    int step;


    int* refcount;
    int hdr_refcount;

    union
    {
        uchar* ptr;
        short* s;
        int* i;
        float* fl;
        double* db;
    } data;


    union
    {
        int rows;
        int height;
    };

    union
    {
        int cols;
        int width;
    };





}
CvMat;
#730 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
inline CvMat cvMat( int rows, int cols, int type, void* data = __null)
{
    CvMat m;

    (((unsigned)((type) & ((1 << 3) - 1)) <= 6) ? static_cast<void> (0) : __assert_fail ("(unsigned)CV_MAT_DEPTH(type) <= CV_64F", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h", 734, __PRETTY_FUNCTION__));
    type = ((type) & ((1 << 3)*512 - 1));
    m.type = 0x42420000 | (1 << 14) | type;
    m.cols = cols;
    m.rows = rows;
    m.step = m.cols*(((((type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((type) & ((1 << 3) - 1))*2) & 3));
    m.data.ptr = (uchar*)data;
    m.refcount = __null;
    m.hdr_refcount = 0;

    return m;
}
#760 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
inline double cvmGet( const CvMat* mat, int row, int col )
{
    int type;

    type = ((mat->type) & ((1 << 3)*512 - 1));
    (((unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols) ? static_cast<void> (0) : __assert_fail ("(unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
#765 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
    ,
 766
#765 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
    , __PRETTY_FUNCTION__))
                                                 ;

    if( type == (((5) & ((1 << 3) - 1)) + (((1)-1) << 3)) )
        return ((float*)(mat->data.ptr + (size_t)mat->step*row))[col];
    else
    {
        ((type == (((6) & ((1 << 3) - 1)) + (((1)-1) << 3))) ? static_cast<void> (0) : __assert_fail ("type == CV_64FC1", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h", 772, __PRETTY_FUNCTION__));
        return ((double*)(mat->data.ptr + (size_t)mat->step*row))[col];
    }
}


inline void cvmSet( CvMat* mat, int row, int col, double value )
{
    int type;
    type = ((mat->type) & ((1 << 3)*512 - 1));
    (((unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols) ? static_cast<void> (0) : __assert_fail ("(unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
#782 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
    ,
 783
#782 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
    , __PRETTY_FUNCTION__))
                                                 ;

    if( type == (((5) & ((1 << 3) - 1)) + (((1)-1) << 3)) )
        ((float*)(mat->data.ptr + (size_t)mat->step*row))[col] = (float)value;
    else
    {
        ((type == (((6) & ((1 << 3) - 1)) + (((1)-1) << 3))) ? static_cast<void> (0) : __assert_fail ("type == CV_64FC1", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h", 789, __PRETTY_FUNCTION__));
        ((double*)(mat->data.ptr + (size_t)mat->step*row))[col] = (double)value;
    }
}


inline int cvIplDepth( int type )
{
    int depth = ((type) & ((1 << 3) - 1));
    return ((((sizeof(size_t)<<28)|0x8442211) >> ((depth) & ((1 << 3) - 1))*4) & 15)*8 | (depth == 1 || depth == 3 ||
           depth == 4 ? 0x80000000 : 0);
}
#813 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvMatND
{
    int type;
    int dims;

    int* refcount;
    int hdr_refcount;

    union
    {
        uchar* ptr;
        float* fl;
        double* db;
        int* i;
        short* s;
    } data;

    struct
    {
        int size;
        int step;
    }
    dim[32];
}
CvMatND;
#853 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
struct CvSet;

typedef struct CvSparseMat
{
    int type;
    int dims;
    int* refcount;
    int hdr_refcount;

    struct CvSet* heap;
    void** hashtable;
    int hashsize;
    int valoffset;
    int idxoffset;
    int size[32];
}
CvSparseMat;
#880 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvSparseNode
{
    unsigned hashval;
    struct CvSparseNode* next;
}
CvSparseNode;

typedef struct CvSparseMatIterator
{
    CvSparseMat* mat;
    CvSparseNode* node;
    int curidx;
}
CvSparseMatIterator;
#902 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef int CvHistType;
#918 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvHistogram
{
    int type;
    CvArr* bins;
    float thresh[32][2];
    float** thresh2;
    CvMatND mat;
}
CvHistogram;
#948 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvRect
{
    int x;
    int y;
    int width;
    int height;
}
CvRect;

inline CvRect cvRect( int x, int y, int width, int height )
{
    CvRect r;

    r.x = x;
    r.y = y;
    r.width = width;
    r.height = height;

    return r;
}


inline IplROI cvRectToROI( CvRect rect, int coi )
{
    IplROI roi;
    roi.xOffset = rect.x;
    roi.yOffset = rect.y;
    roi.width = rect.width;
    roi.height = rect.height;
    roi.coi = coi;

    return roi;
}


inline CvRect cvROIToRect( IplROI roi )
{
    return cvRect( roi.xOffset, roi.yOffset, roi.width, roi.height );
}







typedef struct CvTermCriteria
{
    int type;


    int max_iter;
    double epsilon;
}
CvTermCriteria;

inline CvTermCriteria cvTermCriteria( int type, int max_iter, double epsilon )
{
    CvTermCriteria t;

    t.type = type;
    t.max_iter = max_iter;
    t.epsilon = (float)epsilon;

    return t;
}




typedef struct CvPoint
{
    int x;
    int y;
}
CvPoint;


inline CvPoint cvPoint( int x, int y )
{
    CvPoint p;

    p.x = x;
    p.y = y;

    return p;
}


typedef struct CvPoint2D32f
{
    float x;
    float y;
}
CvPoint2D32f;


inline CvPoint2D32f cvPoint2D32f( double x, double y )
{
    CvPoint2D32f p;

    p.x = (float)x;
    p.y = (float)y;

    return p;
}


inline CvPoint2D32f cvPointTo32f( CvPoint point )
{
    return cvPoint2D32f( (float)point.x, (float)point.y );
}


inline CvPoint cvPointFrom32f( CvPoint2D32f point )
{
    CvPoint ipt;
    ipt.x = cvRound(point.x);
    ipt.y = cvRound(point.y);

    return ipt;
}


typedef struct CvPoint3D32f
{
    float x;
    float y;
    float z;
}
CvPoint3D32f;


inline CvPoint3D32f cvPoint3D32f( double x, double y, double z )
{
    CvPoint3D32f p;

    p.x = (float)x;
    p.y = (float)y;
    p.z = (float)z;

    return p;
}


typedef struct CvPoint2D64f
{
    double x;
    double y;
}
CvPoint2D64f;


inline CvPoint2D64f cvPoint2D64f( double x, double y )
{
    CvPoint2D64f p;

    p.x = x;
    p.y = y;

    return p;
}


typedef struct CvPoint3D64f
{
    double x;
    double y;
    double z;
}
CvPoint3D64f;


inline CvPoint3D64f cvPoint3D64f( double x, double y, double z )
{
    CvPoint3D64f p;

    p.x = x;
    p.y = y;
    p.z = z;

    return p;
}




typedef struct CvSize
{
    int width;
    int height;
}
CvSize;

inline CvSize cvSize( int width, int height )
{
    CvSize s;

    s.width = width;
    s.height = height;

    return s;
}

typedef struct CvSize2D32f
{
    float width;
    float height;
}
CvSize2D32f;


inline CvSize2D32f cvSize2D32f( double width, double height )
{
    CvSize2D32f s;

    s.width = (float)width;
    s.height = (float)height;

    return s;
}

typedef struct CvBox2D
{
    CvPoint2D32f center;
    CvSize2D32f size;
    float angle;

}
CvBox2D;



typedef struct CvLineIterator
{

    uchar* ptr;


    int err;
    int plus_delta;
    int minus_delta;
    int plus_step;
    int minus_step;
}
CvLineIterator;





typedef struct CvSlice
{
    int start_index, end_index;
}
CvSlice;

inline CvSlice cvSlice( int start, int end )
{
    CvSlice slice;
    slice.start_index = start;
    slice.end_index = end;

    return slice;
}







typedef struct CvScalar
{
    double val[4];
}
CvScalar;

inline CvScalar cvScalar( double val0, double val1 = 0,
                               double val2 = 0, double val3 = 0)
{
    CvScalar scalar;
    scalar.val[0] = val0; scalar.val[1] = val1;
    scalar.val[2] = val2; scalar.val[3] = val3;
    return scalar;
}


inline CvScalar cvRealScalar( double val0 )
{
    CvScalar scalar;
    scalar.val[0] = val0;
    scalar.val[1] = scalar.val[2] = scalar.val[3] = 0;
    return scalar;
}

inline CvScalar cvScalarAll( double val0123 )
{
    CvScalar scalar;
    scalar.val[0] = val0123;
    scalar.val[1] = val0123;
    scalar.val[2] = val0123;
    scalar.val[3] = val0123;
    return scalar;
}







typedef struct CvMemBlock
{
    struct CvMemBlock* prev;
    struct CvMemBlock* next;
}
CvMemBlock;



typedef struct CvMemStorage
{
    int signature;
    CvMemBlock* bottom;
    CvMemBlock* top;
    struct CvMemStorage* parent;
    int block_size;
    int free_space;
}
CvMemStorage;






typedef struct CvMemStoragePos
{
    CvMemBlock* top;
    int free_space;
}
CvMemStoragePos;




typedef struct CvSeqBlock
{
    struct CvSeqBlock* prev;
    struct CvSeqBlock* next;
  int start_index;

    int count;
    schar* data;
}
CvSeqBlock;
#1330 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvSeq
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first;
}
CvSeq;
#1350 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvSetElem
{
    int flags; struct CvSetElem* next_free;
}
CvSetElem;






typedef struct CvSet
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first; CvSetElem* free_elems; int active_count;
}
CvSet;
#1406 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvGraphEdge
{
    int flags; float weight; struct CvGraphEdge* next[2]; struct CvGraphVtx* vtx[2];
}
CvGraphEdge;

typedef struct CvGraphVtx
{
    int flags; struct CvGraphEdge* first;
}
CvGraphVtx;

typedef struct CvGraphVtx2D
{
    int flags; struct CvGraphEdge* first;
    CvPoint2D32f* ptr;
}
CvGraphVtx2D;
#1433 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvGraph
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first; CvSetElem* free_elems; int active_count; CvSet* edges;
}
CvGraph;





typedef struct CvChain
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first;
    CvPoint origin;
}
CvChain;







typedef struct CvContour
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first; CvRect rect; int color; int reserved[3];
}
CvContour;

typedef CvContour CvPoint2DSeq;
#1599 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvSeqWriter
{
    int header_size; CvSeq* seq; CvSeqBlock* block; schar* ptr; schar* block_min; schar* block_max;
}
CvSeqWriter;
#1617 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvSeqReader
{
    int header_size; CvSeq* seq; CvSeqBlock* block; schar* ptr; schar* block_min; schar* block_max; int delta_index; schar* prev_elem;
}
CvSeqReader;
#1737 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvFileStorage CvFileStorage;
#1752 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvAttrList
{
    const char** attr;
    struct CvAttrList* next;
}
CvAttrList;

inline CvAttrList cvAttrList( const char** attr = __null,
                                 CvAttrList* next = __null )
{
    CvAttrList l;
    l.attr = attr;
    l.next = next;

    return l;
}

struct CvTypeInfo;
#1805 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/types_c.h"
typedef struct CvString
{
    int len;
    char* ptr;
}
CvString;



typedef struct CvStringHashNode
{
    unsigned hashval;
    CvString str;
    struct CvStringHashNode* next;
}
CvStringHashNode;

typedef struct CvGenericHash CvFileNodeHash;


typedef struct CvFileNode
{
    int tag;
    struct CvTypeInfo* info;

    union
    {
        double f;
        int i;
        CvString str;
        CvSeq* seq;
        CvFileNodeHash* map;
    } data;
}
CvFileNode;


extern "C" {

typedef int ( *CvIsInstanceFunc)( const void* struct_ptr );
typedef void ( *CvReleaseFunc)( void** struct_dblptr );
typedef void* ( *CvReadFunc)( CvFileStorage* storage, CvFileNode* node );
typedef void ( *CvWriteFunc)( CvFileStorage* storage, const char* name,
                                      const void* struct_ptr, CvAttrList attributes );
typedef void* ( *CvCloneFunc)( const void* struct_ptr );

}


typedef struct CvTypeInfo
{
    int flags;
    int header_size;
    struct CvTypeInfo* prev;
    struct CvTypeInfo* next;
    const char* type_name;
    CvIsInstanceFunc is_instance;
    CvReleaseFunc release;
    CvReadFunc read;
    CvWriteFunc write;
    CvCloneFunc clone;
}
CvTypeInfo;




typedef struct CvPluginFuncInfo
{
    void** func_addr;
    void* default_func_addr;
    const char* func_names;
    int search_modules;
    int loaded_from;
}
CvPluginFuncInfo;

typedef struct CvModuleInfo
{
    struct CvModuleInfo* next;
    const char* name;
    const char* version;
    CvPluginFuncInfo* func_tab;
}
CvModuleInfo;
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h" 2


extern "C" {
#61 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void* cvAlloc( size_t size );







extern "C" void cvFree_( void* ptr );



extern "C" IplImage* cvCreateImageHeader( CvSize size, int depth, int channels );


extern "C" IplImage* cvInitImageHeader( IplImage* image, CvSize size, int depth,
                                   int channels, int origin = 0,
                                   int align = 4);


extern "C" IplImage* cvCreateImage( CvSize size, int depth, int channels );


extern "C" void cvReleaseImageHeader( IplImage** image );


extern "C" void cvReleaseImage( IplImage** image );


extern "C" IplImage* cvCloneImage( const IplImage* image );



extern "C" void cvSetImageCOI( IplImage* image, int coi );


extern "C" int cvGetImageCOI( const IplImage* image );


extern "C" void cvSetImageROI( IplImage* image, CvRect rect );


extern "C" void cvResetImageROI( IplImage* image );


extern "C" CvRect cvGetImageROI( const IplImage* image );


extern "C" CvMat* cvCreateMatHeader( int rows, int cols, int type );




extern "C" CvMat* cvInitMatHeader( CvMat* mat, int rows, int cols,
                              int type, void* data = __null,
                              int step = 0x7fffffff );


extern "C" CvMat* cvCreateMat( int rows, int cols, int type );



extern "C" void cvReleaseMat( CvMat** mat );



inline void cvDecRefData( CvArr* arr )
{
    if( (((arr) != __null && (((const CvMat*)(arr))->type & 0xFFFF0000) == 0x42420000 && ((const CvMat*)(arr))->cols > 0 && ((const CvMat*)(arr))->rows > 0) && ((const CvMat*)(arr))->data.ptr != __null))
    {
        CvMat* mat = (CvMat*)arr;
        mat->data.ptr = __null;
        if( mat->refcount != __null && --*mat->refcount == 0 )
            (cvFree_(*(&mat->refcount)), *(&mat->refcount)=0);
        mat->refcount = __null;
    }
    else if( (((arr) != __null && (((const CvMatND*)(arr))->type & 0xFFFF0000) == 0x42430000) && ((const CvMatND*)(arr))->data.ptr != __null))
    {
        CvMatND* mat = (CvMatND*)arr;
        mat->data.ptr = __null;
        if( mat->refcount != __null && --*mat->refcount == 0 )
            (cvFree_(*(&mat->refcount)), *(&mat->refcount)=0);
        mat->refcount = __null;
    }
}


inline int cvIncRefData( CvArr* arr )
{
    int refcount = 0;
    if( (((arr) != __null && (((const CvMat*)(arr))->type & 0xFFFF0000) == 0x42420000 && ((const CvMat*)(arr))->cols > 0 && ((const CvMat*)(arr))->rows > 0) && ((const CvMat*)(arr))->data.ptr != __null))
    {
        CvMat* mat = (CvMat*)arr;
        if( mat->refcount != __null )
            refcount = ++*mat->refcount;
    }
    else if( (((arr) != __null && (((const CvMatND*)(arr))->type & 0xFFFF0000) == 0x42430000) && ((const CvMatND*)(arr))->data.ptr != __null))
    {
        CvMatND* mat = (CvMatND*)arr;
        if( mat->refcount != __null )
            refcount = ++*mat->refcount;
    }
    return refcount;
}



extern "C" CvMat* cvCloneMat( const CvMat* mat );




extern "C" CvMat* cvGetSubRect( const CvArr* arr, CvMat* submat, CvRect rect );




extern "C" CvMat* cvGetRows( const CvArr* arr, CvMat* submat,
                        int start_row, int end_row,
                        int delta_row = 1);

inline CvMat* cvGetRow( const CvArr* arr, CvMat* submat, int row )
{
    return cvGetRows( arr, submat, row, row + 1, 1 );
}




extern "C" CvMat* cvGetCols( const CvArr* arr, CvMat* submat,
                        int start_col, int end_col );

inline CvMat* cvGetCol( const CvArr* arr, CvMat* submat, int col )
{
    return cvGetCols( arr, submat, col, col + 1 );
}





extern "C" CvMat* cvGetDiag( const CvArr* arr, CvMat* submat,
                            int diag = 0);


extern "C" void cvScalarToRawData( const CvScalar* scalar, void* data, int type,
                              int extend_to_12 = 0 );

extern "C" void cvRawDataToScalar( const void* data, int type, CvScalar* scalar );


extern "C" CvMatND* cvCreateMatNDHeader( int dims, const int* sizes, int type );


extern "C" CvMatND* cvCreateMatND( int dims, const int* sizes, int type );


extern "C" CvMatND* cvInitMatNDHeader( CvMatND* mat, int dims, const int* sizes,
                                    int type, void* data = __null );


inline void cvReleaseMatND( CvMatND** mat )
{
    cvReleaseMat( (CvMat**)mat );
}


extern "C" CvMatND* cvCloneMatND( const CvMatND* mat );


extern "C" CvSparseMat* cvCreateSparseMat( int dims, const int* sizes, int type );


extern "C" void cvReleaseSparseMat( CvSparseMat** mat );


extern "C" CvSparseMat* cvCloneSparseMat( const CvSparseMat* mat );



extern "C" CvSparseNode* cvInitSparseMatIterator( const CvSparseMat* mat,
                                              CvSparseMatIterator* mat_iterator );


inline CvSparseNode* cvGetNextSparseNode( CvSparseMatIterator* mat_iterator )
{
    if( mat_iterator->node->next )
        return mat_iterator->node = mat_iterator->node->next;
    else
    {
        int idx;
        for( idx = ++mat_iterator->curidx; idx < mat_iterator->mat->hashsize; idx++ )
        {
            CvSparseNode* node = (CvSparseNode*)mat_iterator->mat->hashtable[idx];
            if( node )
            {
                mat_iterator->curidx = idx;
                return mat_iterator->node = node;
            }
        }
        return __null;
    }
}





typedef struct CvNArrayIterator
{
    int count;
    int dims;
    CvSize size;
    uchar* ptr[10];
    int stack[32];
    CvMatND* hdr[10];

}
CvNArrayIterator;
#288 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" int cvInitNArrayIterator( int count, CvArr** arrs,
                                 const CvArr* mask, CvMatND* stubs,
                                 CvNArrayIterator* array_iterator,
                                 int flags = 0 );


extern "C" int cvNextNArraySlice( CvNArrayIterator* array_iterator );




extern "C" int cvGetElemType( const CvArr* arr );



extern "C" int cvGetDims( const CvArr* arr, int* sizes = __null );





extern "C" int cvGetDimSize( const CvArr* arr, int index );




extern "C" uchar* cvPtr1D( const CvArr* arr, int idx0, int* type = __null);
extern "C" uchar* cvPtr2D( const CvArr* arr, int idx0, int idx1, int* type = __null );
extern "C" uchar* cvPtr3D( const CvArr* arr, int idx0, int idx1, int idx2,
                      int* type = __null);





extern "C" uchar* cvPtrND( const CvArr* arr, const int* idx, int* type = __null,
                      int create_node = 1,
                      unsigned* precalc_hashval = __null);


extern "C" CvScalar cvGet1D( const CvArr* arr, int idx0 );
extern "C" CvScalar cvGet2D( const CvArr* arr, int idx0, int idx1 );
extern "C" CvScalar cvGet3D( const CvArr* arr, int idx0, int idx1, int idx2 );
extern "C" CvScalar cvGetND( const CvArr* arr, const int* idx );


extern "C" double cvGetReal1D( const CvArr* arr, int idx0 );
extern "C" double cvGetReal2D( const CvArr* arr, int idx0, int idx1 );
extern "C" double cvGetReal3D( const CvArr* arr, int idx0, int idx1, int idx2 );
extern "C" double cvGetRealND( const CvArr* arr, const int* idx );


extern "C" void cvSet1D( CvArr* arr, int idx0, CvScalar value );
extern "C" void cvSet2D( CvArr* arr, int idx0, int idx1, CvScalar value );
extern "C" void cvSet3D( CvArr* arr, int idx0, int idx1, int idx2, CvScalar value );
extern "C" void cvSetND( CvArr* arr, const int* idx, CvScalar value );


extern "C" void cvSetReal1D( CvArr* arr, int idx0, double value );
extern "C" void cvSetReal2D( CvArr* arr, int idx0, int idx1, double value );
extern "C" void cvSetReal3D( CvArr* arr, int idx0,
                        int idx1, int idx2, double value );
extern "C" void cvSetRealND( CvArr* arr, const int* idx, double value );



extern "C" void cvClearND( CvArr* arr, const int* idx );






extern "C" CvMat* cvGetMat( const CvArr* arr, CvMat* header,
                       int* coi = __null,
                       int allowND = 0);


extern "C" IplImage* cvGetImage( const CvArr* arr, IplImage* image_header );
#379 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" CvArr* cvReshapeMatND( const CvArr* arr,
                             int sizeof_header, CvArr* header,
                             int new_cn, int new_dims, int* new_sizes );





extern "C" CvMat* cvReshape( const CvArr* arr, CvMat* header,
                        int new_cn, int new_rows = 0 );



extern "C" void cvRepeat( const CvArr* src, CvArr* dst );


extern "C" void cvCreateData( CvArr* arr );


extern "C" void cvReleaseData( CvArr* arr );




extern "C" void cvSetData( CvArr* arr, void* data, int step );




extern "C" void cvGetRawData( const CvArr* arr, uchar** data,
                         int* step = __null,
                         CvSize* roi_size = __null);


extern "C" CvSize cvGetSize( const CvArr* arr );


extern "C" void cvCopy( const CvArr* src, CvArr* dst,
                     const CvArr* mask = __null );



extern "C" void cvSet( CvArr* arr, CvScalar value,
                    const CvArr* mask = __null );


extern "C" void cvSetZero( CvArr* arr );





extern "C" void cvSplit( const CvArr* src, CvArr* dst0, CvArr* dst1,
                      CvArr* dst2, CvArr* dst3 );



extern "C" void cvMerge( const CvArr* src0, const CvArr* src1,
                      const CvArr* src2, const CvArr* src3,
                      CvArr* dst );



extern "C" void cvMixChannels( const CvArr** src, int src_count,
                            CvArr** dst, int dst_count,
                            const int* from_to, int pair_count );






extern "C" void cvConvertScale( const CvArr* src, CvArr* dst,
                             double scale = 1,
                             double shift = 0 );
#464 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvConvertScaleAbs( const CvArr* src, CvArr* dst,
                                double scale = 1,
                                double shift = 0 );







extern "C" CvTermCriteria cvCheckTermCriteria( CvTermCriteria criteria,
                                           double default_eps,
                                           int default_max_iters );






extern "C" void cvAdd( const CvArr* src1, const CvArr* src2, CvArr* dst,
                    const CvArr* mask = __null);


extern "C" void cvAddS( const CvArr* src, CvScalar value, CvArr* dst,
                     const CvArr* mask = __null);


extern "C" void cvSub( const CvArr* src1, const CvArr* src2, CvArr* dst,
                    const CvArr* mask = __null);


inline void cvSubS( const CvArr* src, CvScalar value, CvArr* dst,
                         const CvArr* mask = __null)
{
    cvAddS( src, cvScalar( -value.val[0], -value.val[1], -value.val[2], -value.val[3]),
            dst, mask );
}


extern "C" void cvSubRS( const CvArr* src, CvScalar value, CvArr* dst,
                      const CvArr* mask = __null);



extern "C" void cvMul( const CvArr* src1, const CvArr* src2,
                    CvArr* dst, double scale = 1 );




extern "C" void cvDiv( const CvArr* src1, const CvArr* src2,
                    CvArr* dst, double scale = 1);


extern "C" void cvScaleAdd( const CvArr* src1, CvScalar scale,
                         const CvArr* src2, CvArr* dst );



extern "C" void cvAddWeighted( const CvArr* src1, double alpha,
                            const CvArr* src2, double beta,
                            double gamma, CvArr* dst );


extern "C" double cvDotProduct( const CvArr* src1, const CvArr* src2 );


extern "C" void cvAnd( const CvArr* src1, const CvArr* src2,
                  CvArr* dst, const CvArr* mask = __null);


extern "C" void cvAndS( const CvArr* src, CvScalar value,
                   CvArr* dst, const CvArr* mask = __null);


extern "C" void cvOr( const CvArr* src1, const CvArr* src2,
                 CvArr* dst, const CvArr* mask = __null);


extern "C" void cvOrS( const CvArr* src, CvScalar value,
                  CvArr* dst, const CvArr* mask = __null);


extern "C" void cvXor( const CvArr* src1, const CvArr* src2,
                  CvArr* dst, const CvArr* mask = __null);


extern "C" void cvXorS( const CvArr* src, CvScalar value,
                   CvArr* dst, const CvArr* mask = __null);


extern "C" void cvNot( const CvArr* src, CvArr* dst );


extern "C" void cvInRange( const CvArr* src, const CvArr* lower,
                      const CvArr* upper, CvArr* dst );


extern "C" void cvInRangeS( const CvArr* src, CvScalar lower,
                       CvScalar upper, CvArr* dst );
#576 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvCmp( const CvArr* src1, const CvArr* src2, CvArr* dst, int cmp_op );


extern "C" void cvCmpS( const CvArr* src, double value, CvArr* dst, int cmp_op );


extern "C" void cvMin( const CvArr* src1, const CvArr* src2, CvArr* dst );


extern "C" void cvMax( const CvArr* src1, const CvArr* src2, CvArr* dst );


extern "C" void cvMinS( const CvArr* src, double value, CvArr* dst );


extern "C" void cvMaxS( const CvArr* src, double value, CvArr* dst );


extern "C" void cvAbsDiff( const CvArr* src1, const CvArr* src2, CvArr* dst );


extern "C" void cvAbsDiffS( const CvArr* src, CvArr* dst, CvScalar value );
#606 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvCartToPolar( const CvArr* x, const CvArr* y,
                            CvArr* magnitude, CvArr* angle = __null,
                            int angle_in_degrees = 0);




extern "C" void cvPolarToCart( const CvArr* magnitude, const CvArr* angle,
                            CvArr* x, CvArr* y,
                            int angle_in_degrees = 0);


extern "C" void cvPow( const CvArr* src, CvArr* dst, double power );




extern "C" void cvExp( const CvArr* src, CvArr* dst );





extern "C" void cvLog( const CvArr* src, CvArr* dst );


extern "C" float cvFastArctan( float y, float x );


extern "C" float cvCbrt( float value );







extern "C" int cvCheckArr( const CvArr* arr, int flags = 0,
                        double min_val = 0, double max_val = 0);




extern "C" void cvRandArr( CvRNG* rng, CvArr* arr, int dist_type,
                      CvScalar param1, CvScalar param2 );

extern "C" void cvRandShuffle( CvArr* mat, CvRNG* rng,
                           double iter_factor = 1.);






extern "C" void cvSort( const CvArr* src, CvArr* dst = __null,
                    CvArr* idxmat = __null,
                    int flags = 0);


extern "C" int cvSolveCubic( const CvMat* coeffs, CvMat* roots );


extern "C" void cvSolvePoly(const CvMat* coeffs, CvMat *roots2,
      int maxiter = 20, int fig = 100);






extern "C" void cvCrossProduct( const CvArr* src1, const CvArr* src2, CvArr* dst );
#687 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvGEMM( const CvArr* src1, const CvArr* src2, double alpha,
                     const CvArr* src3, double beta, CvArr* dst,
                     int tABC = 0);




extern "C" void cvTransform( const CvArr* src, CvArr* dst,
                          const CvMat* transmat,
                          const CvMat* shiftvec = __null);



extern "C" void cvPerspectiveTransform( const CvArr* src, CvArr* dst,
                                     const CvMat* mat );


extern "C" void cvMulTransposed( const CvArr* src, CvArr* dst, int order,
                             const CvArr* delta = __null,
                             double scale = 1. );


extern "C" void cvTranspose( const CvArr* src, CvArr* dst );



extern "C" void cvCompleteSymm( CvMat* matrix, int LtoR = 0 );




extern "C" void cvFlip( const CvArr* src, CvArr* dst = __null,
                     int flip_mode = 0);
#728 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvSVD( CvArr* A, CvArr* W, CvArr* U = __null,
                     CvArr* V = __null, int flags = 0);



extern "C" void cvSVBkSb( const CvArr* W, const CvArr* U,
                        const CvArr* V, const CvArr* B,
                        CvArr* X, int flags );
#745 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" double cvInvert( const CvArr* src, CvArr* dst,
                         int method = 0);




extern "C" int cvSolve( const CvArr* src1, const CvArr* src2, CvArr* dst,
                     int method = 0);


extern "C" double cvDet( const CvArr* mat );


extern "C" CvScalar cvTrace( const CvArr* mat );


extern "C" void cvEigenVV( CvArr* mat, CvArr* evects, CvArr* evals,
                        double eps = 0,
                        int lowindex = -1,
                        int highindex = -1);






extern "C" void cvSetIdentity( CvArr* mat, CvScalar value = cvRealScalar(1) );


extern "C" CvArr* cvRange( CvArr* mat, double start, double end );
#796 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvCalcCovarMatrix( const CvArr** vects, int count,
                                CvArr* cov_mat, CvArr* avg, int flags );




extern "C" void cvCalcPCA( const CvArr* data, CvArr* mean,
                        CvArr* eigenvals, CvArr* eigenvects, int flags );

extern "C" void cvProjectPCA( const CvArr* data, const CvArr* mean,
                           const CvArr* eigenvects, CvArr* result );

extern "C" void cvBackProjectPCA( const CvArr* proj, const CvArr* mean,
                               const CvArr* eigenvects, CvArr* result );


extern "C" double cvMahalanobis( const CvArr* vec1, const CvArr* vec2, const CvArr* mat );







extern "C" CvScalar cvSum( const CvArr* arr );


extern "C" int cvCountNonZero( const CvArr* arr );


extern "C" CvScalar cvAvg( const CvArr* arr, const CvArr* mask = __null );


extern "C" void cvAvgSdv( const CvArr* arr, CvScalar* mean, CvScalar* std_dev,
                       const CvArr* mask = __null );


extern "C" void cvMinMaxLoc( const CvArr* arr, double* min_val, double* max_val,
                          CvPoint* min_loc = __null,
                          CvPoint* max_loc = __null,
                          const CvArr* mask = __null );
#855 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" double cvNorm( const CvArr* arr1, const CvArr* arr2 = __null,
                       int norm_type = 4,
                       const CvArr* mask = __null );

extern "C" void cvNormalize( const CvArr* src, CvArr* dst,
                          double a = 1., double b = 0.,
                          int norm_type = 4,
                          const CvArr* mask = __null );







extern "C" void cvReduce( const CvArr* src, CvArr* dst, int dim = -1,
                       int op = 0 );
#889 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvDFT( const CvArr* src, CvArr* dst, int flags,
                    int nonzero_rows = 0 );



extern "C" void cvMulSpectrums( const CvArr* src1, const CvArr* src2,
                             CvArr* dst, int flags );


extern "C" int cvGetOptimalDFTSize( int size0 );


extern "C" void cvDCT( const CvArr* src, CvArr* dst, int flags );






extern "C" int cvSliceLength( CvSlice slice, const CvSeq* seq );





extern "C" CvMemStorage* cvCreateMemStorage( int block_size = 0);



extern "C" CvMemStorage* cvCreateChildMemStorage( CvMemStorage* parent );




extern "C" void cvReleaseMemStorage( CvMemStorage** storage );






extern "C" void cvClearMemStorage( CvMemStorage* storage );


extern "C" void cvSaveMemStoragePos( const CvMemStorage* storage, CvMemStoragePos* pos );


extern "C" void cvRestoreMemStoragePos( CvMemStorage* storage, CvMemStoragePos* pos );


extern "C" void* cvMemStorageAlloc( CvMemStorage* storage, size_t size );


extern "C" CvString cvMemStorageAllocString( CvMemStorage* storage, const char* ptr,
                                         int len = -1 );


extern "C" CvSeq* cvCreateSeq( int seq_flags, size_t header_size,
                            size_t elem_size, CvMemStorage* storage );



extern "C" void cvSetSeqBlockSize( CvSeq* seq, int delta_elems );



extern "C" schar* cvSeqPush( CvSeq* seq, const void* element = __null);



extern "C" schar* cvSeqPushFront( CvSeq* seq, const void* element = __null);



extern "C" void cvSeqPop( CvSeq* seq, void* element = __null);



extern "C" void cvSeqPopFront( CvSeq* seq, void* element = __null);





extern "C" void cvSeqPushMulti( CvSeq* seq, const void* elements,
                             int count, int in_front = 0 );


extern "C" void cvSeqPopMulti( CvSeq* seq, void* elements,
                            int count, int in_front = 0 );



extern "C" schar* cvSeqInsert( CvSeq* seq, int before_index,
                            const void* element = __null);


extern "C" void cvSeqRemove( CvSeq* seq, int index );





extern "C" void cvClearSeq( CvSeq* seq );





extern "C" schar* cvGetSeqElem( const CvSeq* seq, int index );



extern "C" int cvSeqElemIdx( const CvSeq* seq, const void* element,
                         CvSeqBlock** block = __null );


extern "C" void cvStartAppendToSeq( CvSeq* seq, CvSeqWriter* writer );



extern "C" void cvStartWriteSeq( int seq_flags, int header_size,
                              int elem_size, CvMemStorage* storage,
                              CvSeqWriter* writer );





extern "C" CvSeq* cvEndWriteSeq( CvSeqWriter* writer );




extern "C" void cvFlushSeqWriter( CvSeqWriter* writer );




extern "C" void cvStartReadSeq( const CvSeq* seq, CvSeqReader* reader,
                           int reverse = 0 );



extern "C" int cvGetSeqReaderPos( CvSeqReader* reader );




extern "C" void cvSetSeqReaderPos( CvSeqReader* reader, int index,
                                 int is_relative = 0);


extern "C" void* cvCvtSeqToArray( const CvSeq* seq, void* elements,
                               CvSlice slice = cvSlice(0, 0x3fffffff) );




extern "C" CvSeq* cvMakeSeqHeaderForArray( int seq_type, int header_size,
                                       int elem_size, void* elements, int total,
                                       CvSeq* seq, CvSeqBlock* block );


extern "C" CvSeq* cvSeqSlice( const CvSeq* seq, CvSlice slice,
                         CvMemStorage* storage = __null,
                         int copy_data = 0);

inline CvSeq* cvCloneSeq( const CvSeq* seq, CvMemStorage* storage = __null)
{
    return cvSeqSlice( seq, cvSlice(0, 0x3fffffff), storage, 1 );
}


extern "C" void cvSeqRemoveSlice( CvSeq* seq, CvSlice slice );


extern "C" void cvSeqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );


typedef int (* CvCmpFunc)(const void* a, const void* b, void* userdata );


extern "C" void cvSeqSort( CvSeq* seq, CvCmpFunc func, void* userdata = __null );


extern "C" schar* cvSeqSearch( CvSeq* seq, const void* elem, CvCmpFunc func,
                           int is_sorted, int* elem_idx,
                           void* userdata = __null );


extern "C" void cvSeqInvert( CvSeq* seq );


extern "C" int cvSeqPartition( const CvSeq* seq, CvMemStorage* storage,
                            CvSeq** labels, CvCmpFunc is_equal, void* userdata );


extern "C" void cvChangeSeqBlock( void* reader, int direction );
extern "C" void cvCreateSeqBlock( CvSeqWriter* writer );



extern "C" CvSet* cvCreateSet( int set_flags, int header_size,
                            int elem_size, CvMemStorage* storage );


extern "C" int cvSetAdd( CvSet* set_header, CvSetElem* elem = __null,
                      CvSetElem** inserted_elem = __null );


inline CvSetElem* cvSetNew( CvSet* set_header )
{
    CvSetElem* elem = set_header->free_elems;
    if( elem )
    {
        set_header->free_elems = elem->next_free;
        elem->flags = elem->flags & ((1 << 26) - 1);
        set_header->active_count++;
    }
    else
        cvSetAdd( set_header, __null, (CvSetElem**)&elem );
    return elem;
}


inline void cvSetRemoveByPtr( CvSet* set_header, void* elem )
{
    CvSetElem* _elem = (CvSetElem*)elem;
    ((_elem->flags >= 0) ? static_cast<void> (0) : __assert_fail ("_elem->flags >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h", 1118, __PRETTY_FUNCTION__));
    _elem->next_free = set_header->free_elems;
    _elem->flags = (_elem->flags & ((1 << 26) - 1)) | (1 << (sizeof(int)*8-1));
    set_header->free_elems = _elem;
    set_header->active_count--;
}


extern "C" void cvSetRemove( CvSet* set_header, int index );



inline CvSetElem* cvGetSetElem( const CvSet* set_header, int idx )
{
    CvSetElem* elem = (CvSetElem*)cvGetSeqElem( (CvSeq*)set_header, idx );
    return elem && (((CvSetElem*)(elem))->flags >= 0) ? elem : 0;
}


extern "C" void cvClearSet( CvSet* set_header );


extern "C" CvGraph* cvCreateGraph( int graph_flags, int header_size,
                                int vtx_size, int edge_size,
                                CvMemStorage* storage );


extern "C" int cvGraphAddVtx( CvGraph* graph, const CvGraphVtx* vtx = __null,
                           CvGraphVtx** inserted_vtx = __null );



extern "C" int cvGraphRemoveVtx( CvGraph* graph, int index );
extern "C" int cvGraphRemoveVtxByPtr( CvGraph* graph, CvGraphVtx* vtx );






extern "C" int cvGraphAddEdge( CvGraph* graph,
                            int start_idx, int end_idx,
                            const CvGraphEdge* edge = __null,
                            CvGraphEdge** inserted_edge = __null );

extern "C" int cvGraphAddEdgeByPtr( CvGraph* graph,
                               CvGraphVtx* start_vtx, CvGraphVtx* end_vtx,
                               const CvGraphEdge* edge = __null,
                               CvGraphEdge** inserted_edge = __null );


extern "C" void cvGraphRemoveEdge( CvGraph* graph, int start_idx, int end_idx );
extern "C" void cvGraphRemoveEdgeByPtr( CvGraph* graph, CvGraphVtx* start_vtx,
                                     CvGraphVtx* end_vtx );


extern "C" CvGraphEdge* cvFindGraphEdge( const CvGraph* graph, int start_idx, int end_idx );
extern "C" CvGraphEdge* cvFindGraphEdgeByPtr( const CvGraph* graph,
                                           const CvGraphVtx* start_vtx,
                                           const CvGraphVtx* end_vtx );




extern "C" void cvClearGraph( CvGraph* graph );



extern "C" int cvGraphVtxDegree( const CvGraph* graph, int vtx_idx );
extern "C" int cvGraphVtxDegreeByPtr( const CvGraph* graph, const CvGraphVtx* vtx );
#1223 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
typedef struct CvGraphScanner
{
    CvGraphVtx* vtx;
    CvGraphVtx* dst;
    CvGraphEdge* edge;

    CvGraph* graph;
    CvSeq* stack;
    int index;
    int mask;
}
CvGraphScanner;


extern "C" CvGraphScanner* cvCreateGraphScanner( CvGraph* graph,
                                             CvGraphVtx* vtx = __null,
                                             int mask = -1);


extern "C" void cvReleaseGraphScanner( CvGraphScanner** scanner );


extern "C" int cvNextGraphItem( CvGraphScanner* scanner );


extern "C" CvGraph* cvCloneGraph( const CvGraph* graph, CvMemStorage* storage );
#1270 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2,
                     CvScalar color, int thickness = 1,
                     int line_type = 8, int shift = 0 );



extern "C" void cvRectangle( CvArr* img, CvPoint pt1, CvPoint pt2,
                          CvScalar color, int thickness = 1,
                          int line_type = 8,
                          int shift = 0);


extern "C" void cvRectangleR( CvArr* img, CvRect r,
                           CvScalar color, int thickness = 1,
                           int line_type = 8,
                           int shift = 0);




extern "C" void cvCircle( CvArr* img, CvPoint center, int radius,
                       CvScalar color, int thickness = 1,
                       int line_type = 8, int shift = 0);




extern "C" void cvEllipse( CvArr* img, CvPoint center, CvSize axes,
                        double angle, double start_angle, double end_angle,
                        CvScalar color, int thickness = 1,
                        int line_type = 8, int shift = 0);

inline void cvEllipseBox( CvArr* img, CvBox2D box, CvScalar color,
                               int thickness = 1,
                               int line_type = 8, int shift = 0 )
{
    CvSize axes;
    axes.width = cvRound(box.size.width*0.5);
    axes.height = cvRound(box.size.height*0.5);

    cvEllipse( img, cvPointFrom32f( box.center ), axes, box.angle,
               0, 360, color, thickness, line_type, shift );
}


extern "C" void cvFillConvexPoly( CvArr* img, const CvPoint* pts, int npts, CvScalar color,
                               int line_type = 8, int shift = 0);


extern "C" void cvFillPoly( CvArr* img, CvPoint** pts, const int* npts,
                         int contours, CvScalar color,
                         int line_type = 8, int shift = 0 );


extern "C" void cvPolyLine( CvArr* img, CvPoint** pts, const int* npts, int contours,
                         int is_closed, CvScalar color, int thickness = 1,
                         int line_type = 8, int shift = 0 );
#1337 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" int cvClipLine( CvSize img_size, CvPoint* pt1, CvPoint* pt2 );




extern "C" int cvInitLineIterator( const CvArr* image, CvPoint pt1, CvPoint pt2,
                                CvLineIterator* line_iterator,
                                int connectivity = 8,
                                int left_to_right = 0);
#1375 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
typedef struct CvFont
{
  const char* nameFont;
  CvScalar color;
    int font_face;
    const int* ascii;
    const int* greek;
    const int* cyrillic;
    float hscale, vscale;
    float shear;
    int thickness;
    float dx;
    int line_type;
}
CvFont;


extern "C" void cvInitFont( CvFont* font, int font_face,
                         double hscale, double vscale,
                         double shear = 0,
                         int thickness = 1,
                         int line_type = 8);

inline CvFont cvFont( double scale, int thickness = 1 )
{
    CvFont font;
    cvInitFont( &font, 1, scale, scale, 0, thickness, 16 );
    return font;
}



extern "C" void cvPutText( CvArr* img, const char* text, CvPoint org,
                        const CvFont* font, CvScalar color );


extern "C" void cvGetTextSize( const char* text_string, const CvFont* font,
                            CvSize* text_size, int* baseline );






extern "C" CvScalar cvColorToScalar( double packed_color, int arrtype );







extern "C" int cvEllipse2Poly( CvPoint center, CvSize axes,
                 int angle, int arc_start, int arc_end, CvPoint * pts, int delta );


extern "C" void cvDrawContours( CvArr *img, CvSeq* contour,
                             CvScalar external_color, CvScalar hole_color,
                             int max_level, int thickness = 1,
                             int line_type = 8,
                             CvPoint offset = cvPoint(0,0));



extern "C" void cvLUT( const CvArr* src, CvArr* dst, const CvArr* lut );



typedef struct CvTreeNodeIterator
{
    const void* node;
    int level;
    int max_level;
}
CvTreeNodeIterator;

extern "C" void cvInitTreeNodeIterator( CvTreeNodeIterator* tree_iterator,
                                   const void* first, int max_level );
extern "C" void* cvNextTreeNode( CvTreeNodeIterator* tree_iterator );
extern "C" void* cvPrevTreeNode( CvTreeNodeIterator* tree_iterator );




extern "C" void cvInsertNodeIntoTree( void* node, void* parent, void* frame );


extern "C" void cvRemoveNodeFromTree( void* node, void* frame );



extern "C" CvSeq* cvTreeToNodeSeq( const void* first, int header_size,
                              CvMemStorage* storage );




extern "C" int cvKMeans2( const CvArr* samples, int cluster_count, CvArr* labels,
                      CvTermCriteria termcrit, int attempts = 1,
                      CvRNG* rng = 0, int flags = 0,
                      CvArr* _centers = 0, double* compactness = 0 );






extern "C" int cvRegisterModule( const CvModuleInfo* module_info );


extern "C" int cvUseOptimized( int on_off );


extern "C" void cvGetModuleInfo( const char* module_name,
                              const char** version,
                              const char** loaded_addon_plugins );

typedef void* ( *CvAllocFunc)(size_t size, void* userdata);
typedef int ( *CvFreeFunc)(void* pptr, void* userdata);



extern "C" void cvSetMemoryManager( CvAllocFunc alloc_func = __null,
                               CvFreeFunc free_func = __null,
                               void* userdata = __null);


typedef IplImage* (* Cv_iplCreateImageHeader)
                            (int,int,int,char*,char*,int,int,int,int,int,
                            IplROI*,IplImage*,void*,IplTileInfo*);
typedef void (* Cv_iplAllocateImageData)(IplImage*,int,int);
typedef void (* Cv_iplDeallocate)(IplImage*,int);
typedef IplROI* (* Cv_iplCreateROI)(int,int,int,int,int);
typedef IplImage* (* Cv_iplCloneImage)(const IplImage*);


extern "C" void cvSetIPLAllocators( Cv_iplCreateImageHeader create_header,
                               Cv_iplAllocateImageData allocate_data,
                               Cv_iplDeallocate deallocate,
                               Cv_iplCreateROI create_roi,
                               Cv_iplCloneImage clone_image );
#1528 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" CvFileStorage* cvOpenFileStorage( const char* filename, CvMemStorage* memstorage,
                                          int flags, const char* encoding = __null );


extern "C" void cvReleaseFileStorage( CvFileStorage** fs );


extern "C" const char* cvAttrValue( const CvAttrList* attr, const char* attr_name );


extern "C" void cvStartWriteStruct( CvFileStorage* fs, const char* name,
                                int struct_flags, const char* type_name = __null,
                                CvAttrList attributes = cvAttrList());


extern "C" void cvEndWriteStruct( CvFileStorage* fs );


extern "C" void cvWriteInt( CvFileStorage* fs, const char* name, int value );


extern "C" void cvWriteReal( CvFileStorage* fs, const char* name, double value );


extern "C" void cvWriteString( CvFileStorage* fs, const char* name,
                           const char* str, int quote = 0 );


extern "C" void cvWriteComment( CvFileStorage* fs, const char* comment,
                            int eol_comment );



extern "C" void cvWrite( CvFileStorage* fs, const char* name, const void* ptr,
                         CvAttrList attributes = cvAttrList());


extern "C" void cvStartNextStream( CvFileStorage* fs );


extern "C" void cvWriteRawData( CvFileStorage* fs, const void* src,
                                int len, const char* dt );



extern "C" CvStringHashNode* cvGetHashedKey( CvFileStorage* fs, const char* name,
                                        int len = -1,
                                        int create_missing = 0);



extern "C" CvFileNode* cvGetRootFileNode( const CvFileStorage* fs,
                                     int stream_index = 0 );



extern "C" CvFileNode* cvGetFileNode( CvFileStorage* fs, CvFileNode* map,
                                 const CvStringHashNode* key,
                                 int create_missing = 0 );


extern "C" CvFileNode* cvGetFileNodeByName( const CvFileStorage* fs,
                                       const CvFileNode* map,
                                       const char* name );

inline int cvReadInt( const CvFileNode* node, int default_value = 0 )
{
    return !node ? default_value :
        (((node->tag) & 7) == 1) ? node->data.i :
        (((node->tag) & 7) == 2) ? cvRound(node->data.f) : 0x7fffffff;
}


inline int cvReadIntByName( const CvFileStorage* fs, const CvFileNode* map,
                         const char* name, int default_value = 0 )
{
    return cvReadInt( cvGetFileNodeByName( fs, map, name ), default_value );
}


inline double cvReadReal( const CvFileNode* node, double default_value = 0. )
{
    return !node ? default_value :
        (((node->tag) & 7) == 1) ? (double)node->data.i :
        (((node->tag) & 7) == 2) ? node->data.f : 1e300;
}


inline double cvReadRealByName( const CvFileStorage* fs, const CvFileNode* map,
                        const char* name, double default_value = 0. )
{
    return cvReadReal( cvGetFileNodeByName( fs, map, name ), default_value );
}


inline const char* cvReadString( const CvFileNode* node,
                        const char* default_value = __null )
{
    return !node ? default_value : (((node->tag) & 7) == 3) ? node->data.str.ptr : 0;
}


inline const char* cvReadStringByName( const CvFileStorage* fs, const CvFileNode* map,
                        const char* name, const char* default_value = __null )
{
    return cvReadString( cvGetFileNodeByName( fs, map, name ), default_value );
}



extern "C" void* cvRead( CvFileStorage* fs, CvFileNode* node,
                        CvAttrList* attributes = __null);


inline void* cvReadByName( CvFileStorage* fs, const CvFileNode* map,
                              const char* name, CvAttrList* attributes = __null )
{
    return cvRead( fs, cvGetFileNodeByName( fs, map, name ), attributes );
}



extern "C" void cvStartReadRawData( const CvFileStorage* fs, const CvFileNode* src,
                               CvSeqReader* reader );


extern "C" void cvReadRawDataSlice( const CvFileStorage* fs, CvSeqReader* reader,
                               int count, void* dst, const char* dt );


extern "C" void cvReadRawData( const CvFileStorage* fs, const CvFileNode* src,
                          void* dst, const char* dt );


extern "C" void cvWriteFileNode( CvFileStorage* fs, const char* new_node_name,
                            const CvFileNode* node, int embed );


extern "C" const char* cvGetFileNodeName( const CvFileNode* node );



extern "C" void cvRegisterType( const CvTypeInfo* info );
extern "C" void cvUnregisterType( const char* type_name );
extern "C" CvTypeInfo* cvFirstType(void);
extern "C" CvTypeInfo* cvFindType( const char* type_name );
extern "C" CvTypeInfo* cvTypeOf( const void* struct_ptr );


extern "C" void cvRelease( void** struct_ptr );
extern "C" void* cvClone( const void* struct_ptr );


extern "C" void cvSave( const char* filename, const void* struct_ptr,
                    const char* name = __null,
                    const char* comment = __null,
                    CvAttrList attributes = cvAttrList());
extern "C" void* cvLoad( const char* filename,
                     CvMemStorage* memstorage = __null,
                     const char* name = __null,
                     const char** real_name = __null );





extern "C" int64 cvGetTickCount( void );
extern "C" double cvGetTickFrequency( void );
#1711 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
extern "C" int cvCheckHardwareSupport(int feature);




extern "C" int cvGetNumThreads( void );
extern "C" void cvSetNumThreads( int threads = 0 );

extern "C" int cvGetThreadNum( void );





extern "C" int cvGetErrStatus( void );


extern "C" void cvSetErrStatus( int status );






extern "C" int cvGetErrMode( void );


extern "C" int cvSetErrMode( int mode );




extern "C" void cvError( int status, const char* func_name,
                    const char* err_msg, const char* file_name, int line );


extern "C" const char* cvErrorStr( int status );


extern "C" int cvGetErrInfo( const char** errcode_desc, const char** description,
                        const char** filename, int* line );


extern "C" int cvErrorFromIppStatus( int ipp_status );

typedef int ( *CvErrorCallback)( int status, const char* func_name,
                                        const char* err_msg, const char* file_name, int line, void* userdata );


extern "C" CvErrorCallback cvRedirectError( CvErrorCallback error_handler,
                                       void* userdata = __null,
                                       void** prev_userdata = __null );







extern "C" int cvNulDevReport( int status, const char* func_name, const char* err_msg,
                          const char* file_name, int line, void* userdata );

extern "C" int cvStdErrReport( int status, const char* func_name, const char* err_msg,
                          const char* file_name, int line, void* userdata );

extern "C" int cvGuiBoxReport( int status, const char* func_name, const char* err_msg,
                          const char* file_name, int line, void* userdata );
#1858 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core_c.h"
}


struct CvModule
{
    CvModule( CvModuleInfo* _info );
    ~CvModule();
    CvModuleInfo* info;

    static CvModuleInfo* first;
    static CvModuleInfo* last;
};

struct CvType
{
    CvType( const char* type_name,
            CvIsInstanceFunc is_instance, CvReleaseFunc release=0,
            CvReadFunc read=0, CvWriteFunc write=0, CvCloneFunc clone=0 );
    ~CvType();
    CvTypeInfo* info;

    static CvTypeInfo* first;
    static CvTypeInfo* last;
};
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 1
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/version.hpp" 1
#51 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 1 3 4
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/syslimits.h" 1 3 4






#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 1 3 4
#169 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 3 4
#1 "/usr/include/limits.h" 1 3 4
#143 "/usr/include/limits.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
#160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
#38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
#1 "/usr/include/linux/limits.h" 1 3 4
#39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
#161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
#144 "/usr/include/limits.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
#148 "/usr/include/limits.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
#33 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
#34 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
#152 "/usr/include/limits.h" 2 3 4
#170 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 2 3 4
#8 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/syslimits.h" 2 3 4
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 2 3 4
#56 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/algorithm" 1 3
#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/algorithm" 3

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/algorithm" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/utility" 1 3
#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/utility" 3

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/utility" 3
#69 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/utility" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 1 3
#153 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;




}
#393 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/os_defines.h" 1 3
#394 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/cpu_defines.h" 1 3
#397 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3
#70 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/utility" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_relops.h" 1 3
#68 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {

#86 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
#99 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
#112 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
#125 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }


  }

}
#71 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/utility" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 1 3
#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 1 3
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 1 3
#33 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 3

#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 3
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
#109 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#120 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }


}
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

#86 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
#196 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
#270 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }



}
#72 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/utility" 2 3
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/algorithm" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 1 3
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functexcept.h" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functexcept.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/exception_defines.h" 1 3
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
#69 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#199 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#422 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3

}
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 1 3
#33 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 3

#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 1 3
#32 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3

#33 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

#54 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
#99 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 1 3
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3

#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

#90 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
#117 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
#163 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


}
#67 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 1 3
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3

#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
#111 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
#169 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
#200 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3

}
#68 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 1 3
#68 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#96 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
#283 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
#395 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
#422 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
#445 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
#471 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
#486 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
#512 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
#535 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
#561 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
#580 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
#623 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
#649 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
#675 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

#699 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
#797 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}
#69 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/debug/debug.h" 1 3
#47 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
#71 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{





  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
#116 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;











      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
#157 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
#185 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
#208 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
#231 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
#252 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
#319 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
#357 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
#442 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#494 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
#522 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
#552 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
#611 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#669 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
#713 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
#773 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
#934 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




#1008 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
#1040 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
#1071 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;




      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
#1105 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;




      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
#1145 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#1182 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/algorithm" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 1 3
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
#98 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }


}
#158 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
#193 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 1 3
#33 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3

#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 1 3
#33 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 3

#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#201 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);
#230 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
#269 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
#332 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
#417 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);
#434 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
#455 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
#538 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&)[_Nm], _Tp (&)[_Nm]);

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,



     _Generator&);


  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 1 3
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
#154 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
#203 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value));
    }
#276 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value), __comp);
    }
#350 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
#373 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
#413 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
#452 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
#481 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
#578 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_heap.h" 3

}
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tempbuf.h" 1 3
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tempbuf.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_construct.h" 1 3
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_construct.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 1 3
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3

#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
#118 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

#143 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
#93 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_construct.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

#78 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_construct.h" 3
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }





  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#84 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
#111 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator __first, _ForwardIterator __last,
       _Tp& __value)
        {
   if(__first == __last)
     return;

   _ForwardIterator __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         (__value));
       _ForwardIterator __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    (*__prev));
       __value = (*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator, _ForwardIterator, _Tp&) { }
    };
#230 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tempbuf.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_construct_buf(_ForwardIterator __first,
      _ForwardIterator __last,
      _Tp& __value)
    {
      typedef typename std::iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __value);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if(_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            *__first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 2 3
#73 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c)
    {




      if (*__a < *__b)
 {
   if (*__b < *__c)
     std::iter_swap(__a, __b);
   else if (*__a < *__c)
     std::iter_swap(__a, __c);
 }
      else if (*__a < *__c)
 return;
      else if (*__b < *__c)
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }


  template<typename _Iterator, typename _Compare>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c,
   _Compare __comp)
    {





      if (__comp(*__a, *__b))
 {
   if (__comp(*__b, *__c))
     std::iter_swap(__a, __b);
   else if (__comp(*__a, *__c))
     std::iter_swap(__a, __c);
 }
      else if (__comp(*__a, *__c))
 return;
      else if (__comp(*__b, *__c))
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
#326 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
#411 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
#649 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
#695 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
#874 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






      ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
#911 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






      ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
#1086 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





      ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
#1129 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





      ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
#1169 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = (*__first);
      return ++__dest;
    }
#1209 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = (*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
#1437 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
#1464 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      _RandomAccessIterator __p = __first;

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*__p);
    std::copy(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*(__p + __n - 1));
    std::copy_backward(__p, __p + __n - 1, __p + __n);
    *__p = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
     }
 }
    }
#1668 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
#1702 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




      ;
      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }




  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }


  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = (*__first);
  ++__result1;
       }
     else
       {
  *__result2 = (*__first);
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
#1860 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
#1942 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;








      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
#2008 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;











      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (*__i < *__first)
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(*__i, *__first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, const _Tp& __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     const _Tp& __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1));
      return std::__unguarded_partition(__first + 1, __last, *__first);
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1), __comp);
      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
#2392 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
#2439 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
#2488 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
#2541 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





      ;
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
#2603 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;








                    ;

                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val, __comp);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
#2663 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      ;
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
#2696 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

                    ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::copy(__first1, __last1, __result);
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::copy(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 {
   std::copy_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = (*__last1);
       if (__first1 == __last1)
  {
    std::copy_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = (*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::copy_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = (*__last1);
       if (__first1 == __last1)
  {
    std::copy_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = (*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::copy(__middle, __last, __buffer);
       std::copy_backward(__first, __middle, __last);
       return std::copy(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::copy(__first, __middle, __buffer);
       std::copy(__middle, __last, __first);
       return std::copy_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
#3120 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
#3175 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1, __result))

                  ;
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step, __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first,__first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
#3513 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
#3562 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;








      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
#3617 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#3674 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#3730 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#3787 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
#3847 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






      ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
#3884 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






      ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
#4355 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3



#4371 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return (__f);
    }
#4392 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
#4416 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
#4445 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
#4484 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
#4516 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
#4548 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
#4580 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
#4605 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
#4645 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
#4716 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
#4790 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
#4826 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
#4868 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





      ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
#4904 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






      ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
#4937 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
#4969 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
#5001 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
#5032 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
#5069 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
#5108 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
#5140 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
#5168 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



     _RandomNumberGenerator& __rand)

    {



      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
#5204 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
#5238 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





      ;
      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
#5277 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






      ;
      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
#5315 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
#5354 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
#5392 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
#5428 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
#5469 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;









      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#5532 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;










      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#5592 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
#5634 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
#5680 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;










      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#5747 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;












      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
#5814 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;








      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
#5871 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;










      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
#5929 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;








      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
#5990 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;










      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
#6048 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;










      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
#6114 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;












      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
#6171 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
#6199 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
#6227 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
#6255 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }


}
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/algorithm" 2 3
#57 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
#77 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
#481 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#731 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(0, 1, 4,
      3, 2, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }




}
#58 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#150 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 3 4
typedef long int ptrdiff_t;
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 2 3
#59 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
#47 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3

#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 1 3
#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3

#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 3

#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 1 3
#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 3

#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;
#85 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 3

}
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 1 3
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3

#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 1 3 4
#46 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
#1 "/usr/include/stdio.h" 1 3 4
#44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





#64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
#47 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 2 3 4


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stdarg.h" 1 3 4
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
#50 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 2 3 4







#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#353 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 3 4
typedef unsigned int wint_t;
#58 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 2 3 4
#85 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
#102 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



#127 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));


extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));




extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));




extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));


extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();

#357 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();





extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
#476 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();





extern double __wcstod_internal (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __group)
     throw ();
extern float __wcstof_internal (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr, int __group)
     throw ();
extern long double __wcstold_internal (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __group) throw ();
#602 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();
#616 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;











extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;










extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

#777 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
#803 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
#813 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
#867 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/wchar.h" 3 4
}
#47 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 2 3
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
#137 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
#259 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 2 3
#70 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#90 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
  typedef long streamoff;
#100 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
#113 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
#135 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
#241 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3

}
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#76 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3



#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
#84 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

#228 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 1 3
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3

#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 3


#1 "/usr/include/locale.h" 1 3 4
#28 "/usr/include/locale.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#29 "/usr/include/locale.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
#30 "/usr/include/locale.h" 2 3 4

extern "C" {
#50 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
#120 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


#151 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
#186 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
#45 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 2 3
#53 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
#89 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3


#1 "/usr/include/ctype.h" 1 3 4
#28 "/usr/include/ctype.h" 3 4
extern "C" {
#46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
#79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
#104 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
#271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
#347 "/usr/include/ctype.h" 3 4
}
#45 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 2 3
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
#45 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#57 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 1 3
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 1 3
#30 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
#170 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
#1 "/usr/include/pthread.h" 1 3 4
#23 "/usr/include/pthread.h" 3 4
#1 "/usr/include/sched.h" 1 3 4
#28 "/usr/include/sched.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#29 "/usr/include/sched.h" 2 3 4





#1 "/usr/include/time.h" 1 3 4
#35 "/usr/include/sched.h" 2 3 4
#43 "/usr/include/sched.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
#72 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
#118 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
#201 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
#44 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
#118 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
#24 "/usr/include/pthread.h" 2 3 4
#1 "/usr/include/time.h" 1 3 4
#29 "/usr/include/time.h" 3 4
extern "C" {







#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#38 "/usr/include/time.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
#88 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
#25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
#89 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
#42 "/usr/include/time.h" 2 3 4
#131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
#186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
#319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
#334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
#403 "/usr/include/time.h" 3 4
extern int getdate_err;
#412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
#426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
#25 "/usr/include/pthread.h" 2 3 4


#1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
#26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
#28 "/usr/include/pthread.h" 2 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
#114 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
#155 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
#190 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
#228 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
#494 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
#506 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
#540 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
#742 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
#806 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
#888 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
#1000 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
#1044 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
#1111 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
#1145 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
#1159 "/usr/include/pthread.h" 3 4
}
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3
#1 "/usr/include/unistd.h" 1 3 4
#27 "/usr/include/unistd.h" 3 4
extern "C" {
#205 "/usr/include/unistd.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
#206 "/usr/include/unistd.h" 2 3 4



#1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
#22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
#23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
#210 "/usr/include/unistd.h" 2 3 4
#229 "/usr/include/unistd.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#230 "/usr/include/unistd.h" 2 3 4
#277 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
#290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
#337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
#348 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
#379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
#407 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
#435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
#447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
#472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
#514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





#1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
#24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
#613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
#663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
#874 "/usr/include/unistd.h" 3 4
#1 "/usr/include/getopt.h" 1 3 4
#48 "/usr/include/getopt.h" 3 4
extern "C" {
#57 "/usr/include/getopt.h" 3 4
extern char *optarg;
#71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
#150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
#185 "/usr/include/getopt.h" 3 4
}
#875 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
#996 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
#1008 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
#1019 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
#1029 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
#1040 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
#1061 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
#1084 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
#1094 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
#1115 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
#1154 "/usr/include/unistd.h" 3 4
}
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
#118 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
#239 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &





 __gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
#657 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
#800 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
#171 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/atomic_word.h" 1 3
#32 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 1 3
#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 3

#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 3




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 1 3
#48 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 1 3
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 1 3
#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
#53 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
#117 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 2 3
#49 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
#91 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }




  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
#236 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3

}
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 1 3
#33 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 3

#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 1 3
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 3

#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
#47 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3



#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 1 3
#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#101 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
#140 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
#204 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
#268 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
#351 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
#422 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
#508 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
#541 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/backward/binders.h" 1 3
#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#99 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
#732 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 2 3
#51 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 1 3
#33 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 3

#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 3
#54 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

#106 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
#143 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
#168 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
#478 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
#526 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
#559 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
#599 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
#705 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
#734 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
#747 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
#767 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
#788 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
#817 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
#834 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
#855 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
#908 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
#964 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
#979 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
#1011 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
#1033 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
#1089 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
#1105 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
#1117 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
#1133 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
#1145 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
#1173 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
#1188 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
#1219 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
#1241 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
#1264 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
#1282 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
#1305 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
#1322 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#1346 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
#1362 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#1382 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
#1401 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
#1423 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
#1447 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
#1466 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
#1489 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
#1507 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
#1525 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
#1546 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
#1567 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
#1589 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
#1664 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
#1745 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
#1755 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
#1765 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
#1797 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
#1810 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
#1824 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
#1841 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
#1854 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
#1869 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
#1882 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
#1899 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
#1912 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
#1927 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
#1940 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
#1959 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
#1973 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
#1988 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
#2001 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
#2020 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
#2034 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
#2049 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
#2063 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
#2080 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
#2093 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
#2109 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
#2122 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
#2139 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
#2154 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
#2172 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
#2202 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
#2226 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
#2244 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
#2267 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
#2292 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
#2304 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
#2425 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
#2471 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
#2508 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
#2545 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
#2582 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
#2619 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
#2656 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
#2673 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
#2691 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
#2714 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
#2732 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
#55 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 1 3
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3

#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
#242 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
#579 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
#56 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
#100 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
#119 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale() throw();
#128 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
#138 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
#153 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
#166 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
#178 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
#192 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
#207 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
#226 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
#254 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
#270 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
#305 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
#339 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
#370 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
#437 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
#583 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
#600 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
#617 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
#644 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
#658 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
#675 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
#694 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
#708 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
#737 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
#753 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
#766 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 3

#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
#824 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 2 3
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
#201 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
#257 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
#332 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
#363 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
#395 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
#421 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
#438 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
#450 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
#563 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
#579 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
#596 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
#622 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
#673 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
#685 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
#696 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
#707 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
#726 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    static int
    xalloc() throw();
#742 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
#763 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
#780 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3

#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
#46 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
#116 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
#182 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
#206 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
#223 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
#236 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
#263 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
#277 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
#295 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
#317 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
#336 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
#351 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
#376 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
#403 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
#429 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
#443 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
#461 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
#477 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
#488 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
#508 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
#524 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
#534 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
#555 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
#570 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
#581 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#593 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#606 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int
      sync() { return 0; }
#628 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
#644 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
#666 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
#679 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
#703 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
#721 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
#747 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
#762 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 1 3
#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 3

#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
#809 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 2 3
#45 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 1 3
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3

#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3



#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3







#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#50 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 2 3


#1 "/usr/include/wctype.h" 1 3 4
#49 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

#71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
#171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
#213 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
#53 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 2 3
#82 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_base.h" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3






#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 1 3
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 3

#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

#51 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
#51 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#66 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
#144 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
#162 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
#179 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
#195 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
#211 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
#225 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#240 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#254 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#269 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#286 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
#305 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
#324 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
#346 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
#371 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
#390 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
#409 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
#428 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
#446 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
#463 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
#479 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
#496 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
#515 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
#536 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
#558 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
#582 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
#605 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
#674 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
#711 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
#724 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
#737 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
#752 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
#766 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
#780 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
#795 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#812 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#828 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#845 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#865 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
#892 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
#923 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
#956 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
#1005 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
#1022 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#1038 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
#1055 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#1075 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
#1098 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
#1124 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
#1150 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
#1175 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
#1208 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
#1219 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
#1243 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
#1262 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
#1280 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
#1298 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
#1315 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
#1332 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#1348 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
#1365 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#1385 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
#1407 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
#1430 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
#1456 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_inline.h" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
#1513 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
        { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
#1641 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
#1679 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
#1693 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
#1707 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
#1720 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
#1751 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
#1764 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
#1777 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
#1794 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
#1806 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
#1819 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
#1832 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
#1845 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


#1915 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
#1936 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
#1962 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#1998 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#2057 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#2099 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
#2170 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
#2235 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
#2253 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
#2274 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
#2292 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#2334 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#2397 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#2422 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
#2470 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 1 3
#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3

#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
#138 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#732 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
#968 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
#1029 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
#1154 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


#1191 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
#2609 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
#128 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
#139 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
#192 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
#213 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
#248 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
#286 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
#298 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
#338 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
#352 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
#381 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
#401 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
#421 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
#440 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 1 3
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 3

#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
#147 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
#474 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 2 3
#46 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 1 3
#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3

#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

#56 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
#83 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
#109 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
#166 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
#251 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
#284 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
#312 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
#325 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      flush();
#336 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      pos_type
      tellp();
#347 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      seekp(pos_type);
#359 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
#378 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
#397 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
#407 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#428 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
#449 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
#491 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
#541 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
#585 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3

}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
#589 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 2 3
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#56 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
#92 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
#121 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
#168 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
#240 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
#250 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
#282 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      int_type
      get();
#296 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(char_type& __c);
#323 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
#334 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
#357 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
#367 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
#396 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
#407 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
#431 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
#448 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      int_type
      peek();
#466 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
#485 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
#502 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      putback(char_type __c);
#518 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      unget();
#536 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      int
      sync();
#551 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      pos_type
      tellg();
#566 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      seekg(pos_type);
#582 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
#637 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
#673 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
#686 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      operator bool() const
      { return _M_ok; }
    };
#703 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
#745 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
#773 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
#834 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
#856 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3

}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#515 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
#860 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 2 3
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
#93 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
#106 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
#121 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
#145 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
#197 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
    };
#262 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#298 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
#316 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
#338 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#372 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#408 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
#426 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
#448 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#482 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#516 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
#532 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
#554 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };


}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/sstream.tcc" 1 3
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/sstream.tcc" 3

#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
#112 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
#581 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/sstream" 2 3
#48 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);



  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);


  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
#123 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }




      template<typename _Up>
        complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }
#151 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
      _Tp&
      real() { return _M_real; }


      const _Tp&
      real() const { return _M_real; }


      _Tp&
      imag() { return _M_imag; }


      const _Tp&
      imag() const { return _M_imag; }




      void
      real(_Tp __val) { _M_real = __val; }

      void
      imag(_Tp __val) { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);





      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      const complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else
 {
   __is.putback(__ch);
   __is >> __re_x;
   __x = __re_x;
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }
#543 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    inline _Tp&
    real(complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline const _Tp&
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline _Tp&
    imag(complex<_Tp>& __z)
    { return __z.imag(); }

  template<typename _Tp>
    inline const _Tp&
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }



  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
#601 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
#631 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
#762 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
#854 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
#898 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
#926 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
#956 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }



  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
        ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -__n)
        : std::__complex_pow_unsigned(__z, __n);
    }


  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar(pow(__x, __y.real()),
          __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(float __r = 0.0f, float __i = 0.0f)






      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }


      explicit complex(const complex<double>&);
      explicit complex(const complex<long double>&);
#1073 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
      float&
      real() { return __real__ _M_value; }

      const float&
      real() const { return __real__ _M_value; }

      float&
      imag() { return __imag__ _M_value; }

      const float&
      imag() const { return __imag__ _M_value; }




      void
      real(float __val) { __real__ _M_value = __val; }

      void
      imag(float __val) { __imag__ _M_value = __val; }

      complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(double __r = 0.0, double __i = 0.0)






      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }


      complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit complex(const complex<long double>&);
#1225 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
      double&
      real() { return __real__ _M_value; }

      const double&
      real() const { return __real__ _M_value; }

      double&
      imag() { return __imag__ _M_value; }

      const double&
      imag() const { return __imag__ _M_value; }




      void
      real(double __val) { __real__ _M_value = __val; }

      void
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(long double __r = 0.0L,
     long double __i = 0.0L)






      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }


      complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }
#1378 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/complex" 3
      long double&
      real() { return __real__ _M_value; }

      const long double&
      real() const { return __real__ _M_value; }

      long double&
      imag() { return __imag__ _M_value; }

      const long double&
      imag() const { return __imag__ _M_value; }




      void
      real(long double __val) { __real__ _M_value = __val; }

      void
      imag(long double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}
#60 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/map" 1 3
#58 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/map" 3

#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/map" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 1 3
#68 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#88 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;







    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const
      { return iterator(static_cast<typename iterator::_Link_type>
   (const_cast<typename iterator::_Base_ptr>(_M_node))); }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }


      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct
       (std::__addressof(__tmp->_M_value_field), __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(std::__addressof(__p->_M_value_field));
 _M_put_node(__p);
      }
#424 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
#579 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);


      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }

      void
      swap(_Rb_tree& __t);
#723 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);


      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:
#774 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
      void
      erase(iterator __position)
      { _M_erase_aux(__position); }

      void
      erase(const_iterator __position)
      { _M_erase_aux(__position); }

      size_type
      erase(const key_type& __x);
#795 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const_iterator __first, const_iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
#932 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_lower(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, (__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>
       (_M_insert_(__x, __y, (__v)), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>
   (_M_insert_(__x, __y, (__v)), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, (__v));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique_(const_iterator __position, const _Val& __v)

    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), (__v));
   else
     return _M_insert_unique((__v)).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(),
         (__v));
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node,
      (__v));
       else
  return _M_insert_(__position._M_node,
      __position._M_node,
      (__v));
     }
   else
     return _M_insert_unique((__v)).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(),
         (__v));
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node,
      (__v));
       else
  return _M_insert_(__after._M_node, __after._M_node,
      (__v));
     }
   else
     return _M_insert_unique((__v)).first;
 }
      else

 return __position._M_const_cast();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_(const_iterator __position, const _Val& __v)

    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(),
         (__v));
   else
     return _M_insert_equal((__v));
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(),
         (__v));
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node,
      (__v));
       else
  return _M_insert_(__position._M_node,
      __position._M_node,
      (__v));
     }
   else
     return _M_insert_equal((__v));
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(),
         (__v));
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node,
      (__v));
       else
  return _M_insert_(__after._M_node, __after._M_node,
      (__v));
     }
   else
     return _M_insert_equal_lower((__v));
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }


}
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/map" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 1 3
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#86 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
#172 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
#213 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
#229 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
#252 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
#298 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
#417 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
#444 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
#481 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
#516 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
#565 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_unique_(__position, __x); }
#591 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
#631 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#647 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
#681 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#697 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
#740 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
#755 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
#767 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
#782 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
#797 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
#836 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
#855 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
#880 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
#897 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/map" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 1 3
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#85 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
#170 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
#210 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
#226 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
#249 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
#295 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
#412 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
#439 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
#472 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_equal_(__position, __x); }
#499 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
#552 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#568 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
#606 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#622 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
#665 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
#680 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
#704 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
#719 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
#756 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
#773 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
#798 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
#815 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/map" 2 3
#61 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/vector" 1 3
#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/vector" 3

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/vector" 3




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_uninitialized.h" 1 3
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
#107 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
#164 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
#218 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
#332 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
#652 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_uninitialized.h" 3

}
#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/vector" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 1 3
#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
#141 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
#179 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
#262 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
#278 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
#333 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
#361 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
#411 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
#427 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
#454 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
#569 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
#628 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
#649 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
#679 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
#694 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
#709 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
#734 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
#752 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
#801 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      pointer

      data()
      { return std::__addressof(front()); }




      const_pointer

      data() const
      { return std::__addressof(front()); }
#825 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
#856 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
#892 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
#942 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
#960 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
#985 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
#1006 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
#1018 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
#1073 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
#1147 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
#1187 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
#1229 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
#1271 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
#1288 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
#66 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/vector" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_bvector.h" 1 3
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
#431 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

#478 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
#547 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
#596 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }







    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
#664 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}
#67 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/vector" 2 3



#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/vector.tcc" 1 3
#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
#106 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
#128 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::copy(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
#298 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1))
             );
   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;

   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       this->_M_impl.construct(__new_start + __elems_before,



                               __x);

       __new_finish = 0;

       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;

       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;

    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }
#519 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }


}
#71 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/vector" 2 3
#64 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2






namespace cv {






using std::vector;
using std::string;
using std::ptrdiff_t;

template<typename _Tp> class Size_;
template<typename _Tp> class Point_;
template<typename _Tp> class Rect_;
template<typename _Tp, int cn> class Vec;
template<typename _Tp, int m, int n> class Matx;

typedef std::string String;

class Mat;
class SparseMat;
typedef Mat MatND;

namespace ogl {
    class Buffer;
    class Texture2D;
    class Arrays;
}


class GlBuffer;
class GlTexture;
class GlArrays;
class GlCamera;


namespace gpu {
    class GpuMat;
}

class MatExpr;
class MatOp_Base;
class MatArg;
class MatConstIterator;

template<typename _Tp> class Mat_;
template<typename _Tp> class MatIterator_;
template<typename _Tp> class MatConstIterator_;
template<typename _Tp> class MatCommaInitializer_;


typedef std::basic_string<wchar_t> WString;

 string fromUtf16(const WString& str);
 WString toUtf16(const string& str);


 string format( const char* fmt, ... );
 string tempfile( const char* suffix = 0);


enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };
enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_L2SQR=5, NORM_HAMMING=6, NORM_HAMMING2=7, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32 };
enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };
enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };
enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,
    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };






class Exception : public std::exception
{
public:



    Exception();




    Exception(int _code, const string& _err, const string& _func, const string& _file, int _line);
    virtual ~Exception() throw();




    virtual const char *what() const throw();
    void formatMessage();

    string msg;

    int code;
    string err;
    string func;
    string file;
    int line;
};
#182 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 void error( const Exception& exc );
#192 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 bool setBreakOnError(bool flag);

typedef int ( *ErrorCallback)( int status, const char* func_name,
                                       const char* err_msg, const char* file_name,
                                       int line, void* userdata );
#209 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 ErrorCallback redirectError( ErrorCallback errCallback,
                                        void* userdata=0, void** prevUserdata=0);
#228 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 void setNumThreads(int nthreads);
 int getNumThreads();
 int getThreadNum();

 const string& getBuildInformation();
#242 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 int64 getTickCount();
#256 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 double getTickFrequency();
#266 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 int64 getCPUTickCount();
#287 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 bool checkHardwareSupport(int feature);


 int getNumberOfCPUs();
#302 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 void* fastMalloc(size_t bufSize);







 void fastFree(void* ptr);

template<typename _Tp> static inline _Tp* allocate(size_t n)
{
    return new _Tp[n];
}

template<typename _Tp> static inline void deallocate(_Tp* ptr, size_t)
{
    delete[] ptr;
}







template<typename _Tp> static inline _Tp* alignPtr(_Tp* ptr, int n=(int)sizeof(_Tp))
{
    return (_Tp*)(((size_t)ptr + n-1) & -n);
}






static inline size_t alignSize(size_t sz, int n)
{
    return (sz + n-1) & -n;
}
#352 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
 void setUseOptimized(bool onoff);






 bool useOptimized();




template<typename _Tp> class Allocator
{
public:
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    template<typename U> class rebind { typedef Allocator<U> other; };

    explicit Allocator() {}
    ~Allocator() {}
    explicit Allocator(Allocator const&) {}
    template<typename U>
    explicit Allocator(Allocator<U> const&) {}


    pointer address(reference r) { return &r; }
    const_pointer address(const_reference r) { return &r; }

    pointer allocate(size_type count, const void* =0)
    { return reinterpret_cast<pointer>(fastMalloc(count * sizeof (_Tp))); }

    void deallocate(pointer p, size_type) {fastFree(p); }

    size_type max_size() const
    { return max(static_cast<_Tp>(-1)/sizeof(_Tp), 1); }

    void construct(pointer p, const _Tp& v) { new(static_cast<void*>(p)) _Tp(v); }
    void destroy(pointer p) { p->~_Tp(); }
};
#406 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class DataDepth {};

template<> class DataDepth<bool> { public: enum { value = 0, fmt=(int)'u' }; };
template<> class DataDepth<uchar> { public: enum { value = 0, fmt=(int)'u' }; };
template<> class DataDepth<schar> { public: enum { value = 1, fmt=(int)'c' }; };
template<> class DataDepth<char> { public: enum { value = 1, fmt=(int)'c' }; };
template<> class DataDepth<ushort> { public: enum { value = 2, fmt=(int)'w' }; };
template<> class DataDepth<short> { public: enum { value = 3, fmt=(int)'s' }; };
template<> class DataDepth<int> { public: enum { value = 4, fmt=(int)'i' }; };

template<> class DataDepth<unsigned> { public: enum { value = 4, fmt=(int)'i' }; };
template<> class DataDepth<float> { public: enum { value = 5, fmt=(int)'f' }; };
template<> class DataDepth<double> { public: enum { value = 6, fmt=(int)'d' }; };
template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = 7, fmt=(int)'r' }; };
#440 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
struct Matx_AddOp {};
struct Matx_SubOp {};
struct Matx_ScaleOp {};
struct Matx_MulOp {};
struct Matx_MatMulOp {};
struct Matx_TOp {};

template<typename _Tp, int m, int n> class Matx
{
public:
    typedef _Tp value_type;
    typedef Matx<_Tp, (m < n ? m : n), 1> diag_type;
    typedef Matx<_Tp, m, n> mat_type;
    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };


    Matx();

    Matx(_Tp v0);
    Matx(_Tp v0, _Tp v1);
    Matx(_Tp v0, _Tp v1, _Tp v2);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
         _Tp v4, _Tp v5, _Tp v6, _Tp v7,
         _Tp v8, _Tp v9, _Tp v10, _Tp v11);
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
         _Tp v4, _Tp v5, _Tp v6, _Tp v7,
         _Tp v8, _Tp v9, _Tp v10, _Tp v11,
         _Tp v12, _Tp v13, _Tp v14, _Tp v15);
    explicit Matx(const _Tp* vals);

    static Matx all(_Tp alpha);
    static Matx zeros();
    static Matx ones();
    static Matx eye();
    static Matx diag(const diag_type& d);
    static Matx randu(_Tp a, _Tp b);
    static Matx randn(_Tp a, _Tp b);


    _Tp dot(const Matx<_Tp, m, n>& v) const;


    double ddot(const Matx<_Tp, m, n>& v) const;


    template<typename T2> operator Matx<T2, m, n>() const;


    template<int m1, int n1> Matx<_Tp, m1, n1> reshape() const;


    template<int m1, int n1> Matx<_Tp, m1, n1> get_minor(int i, int j) const;


    Matx<_Tp, 1, n> row(int i) const;


    Matx<_Tp, m, 1> col(int i) const;


    diag_type diag() const;


    Matx<_Tp, n, m> t() const;


    Matx<_Tp, n, m> inv(int method=DECOMP_LU) const;


    template<int l> Matx<_Tp, n, l> solve(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const;
    Vec<_Tp, n> solve(const Vec<_Tp, m>& rhs, int method) const;


    Matx<_Tp, m, n> mul(const Matx<_Tp, m, n>& a) const;


    const _Tp& operator ()(int i, int j) const;
    _Tp& operator ()(int i, int j);


    const _Tp& operator ()(int i) const;
    _Tp& operator ()(int i);

    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp);
    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp);
    template<typename _T2> Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp);
    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp);
    template<int l> Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp);
    Matx(const Matx<_Tp, n, m>& a, Matx_TOp);

    _Tp val[m*n];
};


typedef Matx<float, 1, 2> Matx12f;
typedef Matx<double, 1, 2> Matx12d;
typedef Matx<float, 1, 3> Matx13f;
typedef Matx<double, 1, 3> Matx13d;
typedef Matx<float, 1, 4> Matx14f;
typedef Matx<double, 1, 4> Matx14d;
typedef Matx<float, 1, 6> Matx16f;
typedef Matx<double, 1, 6> Matx16d;

typedef Matx<float, 2, 1> Matx21f;
typedef Matx<double, 2, 1> Matx21d;
typedef Matx<float, 3, 1> Matx31f;
typedef Matx<double, 3, 1> Matx31d;
typedef Matx<float, 4, 1> Matx41f;
typedef Matx<double, 4, 1> Matx41d;
typedef Matx<float, 6, 1> Matx61f;
typedef Matx<double, 6, 1> Matx61d;

typedef Matx<float, 2, 2> Matx22f;
typedef Matx<double, 2, 2> Matx22d;
typedef Matx<float, 2, 3> Matx23f;
typedef Matx<double, 2, 3> Matx23d;
typedef Matx<float, 3, 2> Matx32f;
typedef Matx<double, 3, 2> Matx32d;

typedef Matx<float, 3, 3> Matx33f;
typedef Matx<double, 3, 3> Matx33d;

typedef Matx<float, 3, 4> Matx34f;
typedef Matx<double, 3, 4> Matx34d;
typedef Matx<float, 4, 3> Matx43f;
typedef Matx<double, 4, 3> Matx43d;

typedef Matx<float, 4, 4> Matx44f;
typedef Matx<double, 4, 4> Matx44d;
typedef Matx<float, 6, 6> Matx66f;
typedef Matx<double, 6, 6> Matx66d;
#596 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp, int cn> class Vec : public Matx<_Tp, cn, 1>
{
public:
    typedef _Tp value_type;
    enum { depth = DataDepth<_Tp>::value, channels = cn, type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };


    Vec();

    Vec(_Tp v0);
    Vec(_Tp v0, _Tp v1);
    Vec(_Tp v0, _Tp v1, _Tp v2);
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3);
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4);
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5);
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6);
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7);
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8);
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9);
    explicit Vec(const _Tp* values);

    Vec(const Vec<_Tp, cn>& v);

    static Vec all(_Tp alpha);


    Vec mul(const Vec<_Tp, cn>& v) const;


    Vec conj() const;






    Vec cross(const Vec& v) const;

    template<typename T2> operator Vec<T2, cn>() const;

    operator CvScalar() const;


    const _Tp& operator [](int i) const;
    _Tp& operator[](int i);
    const _Tp& operator ()(int i) const;
    _Tp& operator ()(int i);

    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp);
    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp);
    template<typename _T2> Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp);
};






typedef Vec<uchar, 2> Vec2b;
typedef Vec<uchar, 3> Vec3b;
typedef Vec<uchar, 4> Vec4b;

typedef Vec<short, 2> Vec2s;
typedef Vec<short, 3> Vec3s;
typedef Vec<short, 4> Vec4s;

typedef Vec<ushort, 2> Vec2w;
typedef Vec<ushort, 3> Vec3w;
typedef Vec<ushort, 4> Vec4w;

typedef Vec<int, 2> Vec2i;
typedef Vec<int, 3> Vec3i;
typedef Vec<int, 4> Vec4i;
typedef Vec<int, 6> Vec6i;
typedef Vec<int, 8> Vec8i;

typedef Vec<float, 2> Vec2f;
typedef Vec<float, 3> Vec3f;
typedef Vec<float, 4> Vec4f;
typedef Vec<float, 6> Vec6f;

typedef Vec<double, 2> Vec2d;
typedef Vec<double, 3> Vec3d;
typedef Vec<double, 4> Vec4d;
typedef Vec<double, 6> Vec6d;
#692 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Complex
{
public:


    Complex();
    Complex( _Tp _re, _Tp _im=0 );
    Complex( const std::complex<_Tp>& c );


    template<typename T2> operator Complex<T2>() const;

    Complex conj() const;

    operator std::complex<_Tp>() const;

    _Tp re, im;
};





typedef Complex<float> Complexf;
typedef Complex<double> Complexd;
#728 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Point_
{
public:
    typedef _Tp value_type;


    Point_();
    Point_(_Tp _x, _Tp _y);
    Point_(const Point_& pt);
    Point_(const CvPoint& pt);
    Point_(const CvPoint2D32f& pt);
    Point_(const Size_<_Tp>& sz);
    Point_(const Vec<_Tp, 2>& v);

    Point_& operator = (const Point_& pt);

    template<typename _Tp2> operator Point_<_Tp2>() const;


    operator CvPoint() const;
    operator CvPoint2D32f() const;
    operator Vec<_Tp, 2>() const;


    _Tp dot(const Point_& pt) const;

    double ddot(const Point_& pt) const;

    double cross(const Point_& pt) const;

    bool inside(const Rect_<_Tp>& r) const;

    _Tp x, y;
};
#771 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Point3_
{
public:
    typedef _Tp value_type;


    Point3_();
    Point3_(_Tp _x, _Tp _y, _Tp _z);
    Point3_(const Point3_& pt);
    explicit Point3_(const Point_<_Tp>& pt);
    Point3_(const CvPoint3D32f& pt);
    Point3_(const Vec<_Tp, 3>& v);

    Point3_& operator = (const Point3_& pt);

    template<typename _Tp2> operator Point3_<_Tp2>() const;

    operator CvPoint3D32f() const;

    operator Vec<_Tp, 3>() const;


    _Tp dot(const Point3_& pt) const;

    double ddot(const Point3_& pt) const;

    Point3_ cross(const Point3_& pt) const;

    _Tp x, y, z;
};
#810 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Size_
{
public:
    typedef _Tp value_type;


    Size_();
    Size_(_Tp _width, _Tp _height);
    Size_(const Size_& sz);
    Size_(const CvSize& sz);
    Size_(const CvSize2D32f& sz);
    Size_(const Point_<_Tp>& pt);

    Size_& operator = (const Size_& sz);

    _Tp area() const;


    template<typename _Tp2> operator Size_<_Tp2>() const;


    operator CvSize() const;
    operator CvSize2D32f() const;

    _Tp width, height;
};
#845 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Rect_
{
public:
    typedef _Tp value_type;


    Rect_();
    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);
    Rect_(const Rect_& r);
    Rect_(const CvRect& r);
    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);
    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);

    Rect_& operator = ( const Rect_& r );

    Point_<_Tp> tl() const;

    Point_<_Tp> br() const;


    Size_<_Tp> size() const;

    _Tp area() const;


    template<typename _Tp2> operator Rect_<_Tp2>() const;

    operator CvRect() const;


    bool contains(const Point_<_Tp>& pt) const;

    _Tp x, y, width, height;
};







typedef Point_<int> Point2i;
typedef Point2i Point;
typedef Size_<int> Size2i;
typedef Size2i Size;
typedef Rect_<int> Rect;
typedef Point_<float> Point2f;
typedef Point_<double> Point2d;
typedef Size_<float> Size2f;
typedef Point3_<int> Point3i;
typedef Point3_<float> Point3f;
typedef Point3_<double> Point3d;
#906 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class RotatedRect
{
public:

    RotatedRect();
    RotatedRect(const Point2f& center, const Size2f& size, float angle);
    RotatedRect(const CvBox2D& box);


    void points(Point2f pts[]) const;

    Rect boundingRect() const;

    operator CvBox2D() const;

    Point2f center;
    Size2f size;
    float angle;
};
#934 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Scalar_ : public Vec<_Tp, 4>
{
public:

    Scalar_();
    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);
    Scalar_(const CvScalar& s);
    Scalar_(_Tp v0);


    static Scalar_<_Tp> all(_Tp v0);

    operator CvScalar() const;


    template<typename T2> operator Scalar_<T2>() const;


    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;


    Scalar_<_Tp> conj() const;


    bool isReal() const;
};

typedef Scalar_<double> Scalar;

 void scalarToRawData(const Scalar& s, void* buf, int type, int unroll_to=0);
#972 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class Range
{
public:
    Range();
    Range(int _start, int _end);
    Range(const CvSlice& slice);
    int size() const;
    bool empty() const;
    static Range all();
    operator CvSlice() const;

    int start, end;
};
#999 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class DataType
{
public:
    typedef _Tp value_type;
    typedef value_type work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,
        type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<bool>
{
public:
    typedef bool value_type;
    typedef int work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<uchar>
{
public:
    typedef uchar value_type;
    typedef int work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<schar>
{
public:
    typedef schar value_type;
    typedef int work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<char>
{
public:
    typedef schar value_type;
    typedef int work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<ushort>
{
public:
    typedef ushort value_type;
    typedef int work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<short>
{
public:
    typedef short value_type;
    typedef int work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<int>
{
public:
    typedef int value_type;
    typedef value_type work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<float>
{
public:
    typedef float value_type;
    typedef value_type work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<> class DataType<double>
{
public:
    typedef double value_type;
    typedef value_type work_type;
    typedef value_type channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,
           fmt=DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<typename _Tp, int m, int n> class DataType<Matx<_Tp, m, n> >
{
public:
    typedef Matx<_Tp, m, n> value_type;
    typedef Matx<typename DataType<_Tp>::work_type, m, n> work_type;
    typedef _Tp channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = m*n,
        fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
        type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<typename _Tp, int cn> class DataType<Vec<_Tp, cn> >
{
public:
    typedef Vec<_Tp, cn> value_type;
    typedef Vec<typename DataType<_Tp>::work_type, cn> work_type;
    typedef _Tp channel_type;
    typedef value_type vec_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
};

template<typename _Tp> class DataType<std::complex<_Tp> >
{
public:
    typedef std::complex<_Tp> value_type;
    typedef value_type work_type;
    typedef _Tp channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};

template<typename _Tp> class DataType<Complex<_Tp> >
{
public:
    typedef Complex<_Tp> value_type;
    typedef value_type work_type;
    typedef _Tp channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};

template<typename _Tp> class DataType<Point_<_Tp> >
{
public:
    typedef Point_<_Tp> value_type;
    typedef Point_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};

template<typename _Tp> class DataType<Point3_<_Tp> >
{
public:
    typedef Point3_<_Tp> value_type;
    typedef Point3_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};

template<typename _Tp> class DataType<Size_<_Tp> >
{
public:
    typedef Size_<_Tp> value_type;
    typedef Size_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};

template<typename _Tp> class DataType<Rect_<_Tp> >
{
public:
    typedef Rect_<_Tp> value_type;
    typedef Rect_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};

template<typename _Tp> class DataType<Scalar_<_Tp> >
{
public:
    typedef Scalar_<_Tp> value_type;
    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};

template<> class DataType<Range>
{
public:
    typedef Range value_type;
    typedef value_type work_type;
    typedef int channel_type;
    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,
           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };
    typedef Vec<channel_type, channels> vec_type;
};
#1261 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Ptr
{
public:

    Ptr();

    Ptr(_Tp* _obj);

    ~Ptr();

    Ptr(const Ptr& ptr);
    template<typename _Tp2> Ptr(const Ptr<_Tp2>& ptr);

    Ptr& operator = (const Ptr& ptr);

    void addref();

    void release();

    void delete_obj();

    bool empty() const;


    template<typename _Tp2> Ptr<_Tp2> ptr();
    template<typename _Tp2> const Ptr<_Tp2> ptr() const;


    _Tp* operator -> ();
    const _Tp* operator -> () const;

    operator _Tp* ();
    operator const _Tp*() const;

    _Tp* obj;
    int* refcount;
};







class _InputArray
{
public:
    enum {
        KIND_SHIFT = 16,
        FIXED_TYPE = 0x8000 << KIND_SHIFT,
        FIXED_SIZE = 0x4000 << KIND_SHIFT,
        KIND_MASK = ~(FIXED_TYPE|FIXED_SIZE) - (1 << KIND_SHIFT) + 1,

        NONE = 0 << KIND_SHIFT,
        MAT = 1 << KIND_SHIFT,
        MATX = 2 << KIND_SHIFT,
        STD_VECTOR = 3 << KIND_SHIFT,
        STD_VECTOR_VECTOR = 4 << KIND_SHIFT,
        STD_VECTOR_MAT = 5 << KIND_SHIFT,
        EXPR = 6 << KIND_SHIFT,
        OPENGL_BUFFER = 7 << KIND_SHIFT,
        OPENGL_TEXTURE = 8 << KIND_SHIFT,
        GPU_MAT = 9 << KIND_SHIFT
    };
    _InputArray();

    _InputArray(const Mat& m);
    _InputArray(const MatExpr& expr);
    template<typename _Tp> _InputArray(const _Tp* vec, int n);
    template<typename _Tp> _InputArray(const vector<_Tp>& vec);
    template<typename _Tp> _InputArray(const vector<vector<_Tp> >& vec);
    _InputArray(const vector<Mat>& vec);
    template<typename _Tp> _InputArray(const vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _InputArray(const Mat_<_Tp>& m);
    template<typename _Tp, int m, int n> _InputArray(const Matx<_Tp, m, n>& matx);
    _InputArray(const Scalar& s);
    _InputArray(const double& val);

    _InputArray(const GlBuffer& buf);
    _InputArray(const GlTexture& tex);

    _InputArray(const gpu::GpuMat& d_mat);
    _InputArray(const ogl::Buffer& buf);
    _InputArray(const ogl::Texture2D& tex);

    virtual Mat getMat(int i=-1) const;
    virtual void getMatVector(vector<Mat>& mv) const;

    virtual GlBuffer getGlBuffer() const;
    virtual GlTexture getGlTexture() const;

    virtual gpu::GpuMat getGpuMat() const;
                ogl::Buffer getOGlBuffer() const;
                ogl::Texture2D getOGlTexture2D() const;

    virtual int kind() const;
    virtual Size size(int i=-1) const;
    virtual size_t total(int i=-1) const;
    virtual int type(int i=-1) const;
    virtual int depth(int i=-1) const;
    virtual int channels(int i=-1) const;
    virtual bool empty() const;





    int flags;
    void* obj;
    Size sz;
};


enum
{
    DEPTH_MASK_8U = 1 << 0,
    DEPTH_MASK_8S = 1 << 1,
    DEPTH_MASK_16U = 1 << 2,
    DEPTH_MASK_16S = 1 << 3,
    DEPTH_MASK_32S = 1 << 4,
    DEPTH_MASK_32F = 1 << 5,
    DEPTH_MASK_64F = 1 << 6,
    DEPTH_MASK_ALL = (DEPTH_MASK_64F<<1)-1,
    DEPTH_MASK_ALL_BUT_8S = DEPTH_MASK_ALL & ~DEPTH_MASK_8S,
    DEPTH_MASK_FLT = DEPTH_MASK_32F + DEPTH_MASK_64F
};





class _OutputArray : public _InputArray
{
public:
    _OutputArray();

    _OutputArray(Mat& m);
    template<typename _Tp> _OutputArray(vector<_Tp>& vec);
    template<typename _Tp> _OutputArray(vector<vector<_Tp> >& vec);
    _OutputArray(vector<Mat>& vec);
    template<typename _Tp> _OutputArray(vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _OutputArray(Mat_<_Tp>& m);
    template<typename _Tp, int m, int n> _OutputArray(Matx<_Tp, m, n>& matx);
    template<typename _Tp> _OutputArray(_Tp* vec, int n);
    _OutputArray(gpu::GpuMat& d_mat);
    _OutputArray(ogl::Buffer& buf);
    _OutputArray(ogl::Texture2D& tex);

    _OutputArray(const Mat& m);
    template<typename _Tp> _OutputArray(const vector<_Tp>& vec);
    template<typename _Tp> _OutputArray(const vector<vector<_Tp> >& vec);
    _OutputArray(const vector<Mat>& vec);
    template<typename _Tp> _OutputArray(const vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _OutputArray(const Mat_<_Tp>& m);
    template<typename _Tp, int m, int n> _OutputArray(const Matx<_Tp, m, n>& matx);
    template<typename _Tp> _OutputArray(const _Tp* vec, int n);
    _OutputArray(const gpu::GpuMat& d_mat);
    _OutputArray(const ogl::Buffer& buf);
    _OutputArray(const ogl::Texture2D& tex);

    virtual bool fixedSize() const;
    virtual bool fixedType() const;
    virtual bool needed() const;
    virtual Mat& getMatRef(int i=-1) const;
                gpu::GpuMat& getGpuMatRef() const;
                ogl::Buffer& getOGlBufferRef() const;
                ogl::Texture2D& getOGlTexture2DRef() const;
    virtual void create(Size sz, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
    virtual void create(int rows, int cols, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
    virtual void create(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
    virtual void release() const;
    virtual void clear() const;




};

typedef const _InputArray& InputArray;
typedef InputArray InputArrayOfArrays;
typedef const _OutputArray& OutputArray;
typedef OutputArray OutputArrayOfArrays;
typedef OutputArray InputOutputArray;
typedef OutputArray InputOutputArrayOfArrays;

 OutputArray noArray();



enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };

static inline size_t getElemSize(int type) { return (((((type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((type) & ((1 << 3) - 1))*2) & 3)); }





class MatAllocator
{
public:
    MatAllocator() {}
    virtual ~MatAllocator() {}
    virtual void allocate(int dims, const int* sizes, int type, int*& refcount,
                          uchar*& datastart, uchar*& data, size_t* step) = 0;
    virtual void deallocate(int* refcount, uchar* datastart, uchar* data) = 0;
};
#1680 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class Mat
{
public:

    Mat();


    Mat(int rows, int cols, int type);
    Mat(Size size, int type);

    Mat(int rows, int cols, int type, const Scalar& s);
    Mat(Size size, int type, const Scalar& s);


    Mat(int ndims, const int* sizes, int type);
    Mat(int ndims, const int* sizes, int type, const Scalar& s);


    Mat(const Mat& m);

    Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP);
    Mat(Size size, int type, void* data, size_t step=AUTO_STEP);
    Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps=0);


    Mat(const Mat& m, const Range& rowRange, const Range& colRange=Range::all());
    Mat(const Mat& m, const Rect& roi);
    Mat(const Mat& m, const Range* ranges);

    Mat(const CvMat* m, bool copyData=false);

    Mat(const CvMatND* m, bool copyData=false);

    Mat(const IplImage* img, bool copyData=false);

    template<typename _Tp> explicit Mat(const vector<_Tp>& vec, bool copyData=false);

    template<typename _Tp, int n> explicit Mat(const Vec<_Tp, n>& vec, bool copyData=true);

    template<typename _Tp, int m, int n> explicit Mat(const Matx<_Tp, m, n>& mtx, bool copyData=true);

    template<typename _Tp> explicit Mat(const Point_<_Tp>& pt, bool copyData=true);

    template<typename _Tp> explicit Mat(const Point3_<_Tp>& pt, bool copyData=true);

    template<typename _Tp> explicit Mat(const MatCommaInitializer_<_Tp>& commaInitializer);


    explicit Mat(const gpu::GpuMat& m);


    ~Mat();

    Mat& operator = (const Mat& m);
    Mat& operator = (const MatExpr& expr);


    Mat row(int y) const;

    Mat col(int x) const;

    Mat rowRange(int startrow, int endrow) const;
    Mat rowRange(const Range& r) const;

    Mat colRange(int startcol, int endcol) const;
    Mat colRange(const Range& r) const;




    Mat diag(int d=0) const;

    static Mat diag(const Mat& d);


    Mat clone() const;


    void copyTo( OutputArray m ) const;

    void copyTo( OutputArray m, InputArray mask ) const;

    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;

    void assignTo( Mat& m, int type=-1 ) const;


    Mat& operator = (const Scalar& s);

    Mat& setTo(InputArray value, InputArray mask=noArray());


    Mat reshape(int cn, int rows=0) const;
    Mat reshape(int cn, int newndims, const int* newsz) const;


    MatExpr t() const;

    MatExpr inv(int method=DECOMP_LU) const;

    MatExpr mul(InputArray m, double scale=1) const;


    Mat cross(InputArray m) const;

    double dot(InputArray m) const;


    static MatExpr zeros(int rows, int cols, int type);
    static MatExpr zeros(Size size, int type);
    static MatExpr zeros(int ndims, const int* sz, int type);
    static MatExpr ones(int rows, int cols, int type);
    static MatExpr ones(Size size, int type);
    static MatExpr ones(int ndims, const int* sz, int type);
    static MatExpr eye(int rows, int cols, int type);
    static MatExpr eye(Size size, int type);



    void create(int rows, int cols, int type);
    void create(Size size, int type);
    void create(int ndims, const int* sizes, int type);


    void addref();


    void release();


    void deallocate();

    void copySize(const Mat& m);


    void reserve(size_t sz);

    void resize(size_t sz);

    void resize(size_t sz, const Scalar& s);

    void push_back_(const void* elem);

    template<typename _Tp> void push_back(const _Tp& elem);
    template<typename _Tp> void push_back(const Mat_<_Tp>& elem);
    void push_back(const Mat& m);

    void pop_back(size_t nelems=1);


    void locateROI( Size& wholeSize, Point& ofs ) const;

    Mat& adjustROI( int dtop, int dbottom, int dleft, int dright );


    Mat operator()( Range rowRange, Range colRange ) const;
    Mat operator()( const Rect& roi ) const;
    Mat operator()( const Range* ranges ) const;


    operator CvMat() const;

    operator CvMatND() const;

    operator IplImage() const;

    template<typename _Tp> operator vector<_Tp>() const;
    template<typename _Tp, int n> operator Vec<_Tp, n>() const;
    template<typename _Tp, int m, int n> operator Matx<_Tp, m, n>() const;




    bool isContinuous() const;


    bool isSubmatrix() const;



    size_t elemSize() const;

    size_t elemSize1() const;

    int type() const;

    int depth() const;

    int channels() const;

    size_t step1(int i=0) const;

    bool empty() const;

    size_t total() const;


    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;


    uchar* ptr(int i0=0);
    const uchar* ptr(int i0=0) const;


    uchar* ptr(int i0, int i1);
    const uchar* ptr(int i0, int i1) const;


    uchar* ptr(int i0, int i1, int i2);
    const uchar* ptr(int i0, int i1, int i2) const;


    uchar* ptr(const int* idx);

    const uchar* ptr(const int* idx) const;

    template<int n> uchar* ptr(const Vec<int, n>& idx);
    template<int n> const uchar* ptr(const Vec<int, n>& idx) const;


    template<typename _Tp> _Tp* ptr(int i0=0);
    template<typename _Tp> const _Tp* ptr(int i0=0) const;

    template<typename _Tp> _Tp* ptr(int i0, int i1);
    template<typename _Tp> const _Tp* ptr(int i0, int i1) const;

    template<typename _Tp> _Tp* ptr(int i0, int i1, int i2);
    template<typename _Tp> const _Tp* ptr(int i0, int i1, int i2) const;

    template<typename _Tp> _Tp* ptr(const int* idx);
    template<typename _Tp> const _Tp* ptr(const int* idx) const;

    template<typename _Tp, int n> _Tp* ptr(const Vec<int, n>& idx);
    template<typename _Tp, int n> const _Tp* ptr(const Vec<int, n>& idx) const;


    template<typename _Tp> _Tp& at(int i0=0);
    template<typename _Tp> const _Tp& at(int i0=0) const;

    template<typename _Tp> _Tp& at(int i0, int i1);
    template<typename _Tp> const _Tp& at(int i0, int i1) const;

    template<typename _Tp> _Tp& at(int i0, int i1, int i2);
    template<typename _Tp> const _Tp& at(int i0, int i1, int i2) const;

    template<typename _Tp> _Tp& at(const int* idx);
    template<typename _Tp> const _Tp& at(const int* idx) const;

    template<typename _Tp, int n> _Tp& at(const Vec<int, n>& idx);
    template<typename _Tp, int n> const _Tp& at(const Vec<int, n>& idx) const;


    template<typename _Tp> _Tp& at(Point pt);
    template<typename _Tp> const _Tp& at(Point pt) const;



    template<typename _Tp> MatIterator_<_Tp> begin();
    template<typename _Tp> MatIterator_<_Tp> end();
    template<typename _Tp> MatConstIterator_<_Tp> begin() const;
    template<typename _Tp> MatConstIterator_<_Tp> end() const;

    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=(1 << 14), SUBMATRIX_FLAG=(1 << 15) };







    int flags;

    int dims;

    int rows, cols;

    uchar* data;



    int* refcount;


    uchar* datastart;
    uchar* dataend;
    uchar* datalimit;


    MatAllocator* allocator;

    struct MSize
    {
        MSize(int* _p);
        Size operator()() const;
        const int& operator[](int i) const;
        int& operator[](int i);
        operator const int*() const;
        bool operator == (const MSize& sz) const;
        bool operator != (const MSize& sz) const;

        int* p;
    };

    struct MStep
    {
        MStep();
        MStep(size_t s);
        const size_t& operator[](int i) const;
        size_t& operator[](int i);
        operator size_t() const;
        MStep& operator = (size_t s);

        size_t* p;
        size_t buf[2];
    protected:
        MStep& operator = (const MStep&);
    };

    MSize size;
    MStep step;

protected:
    void initEmpty();
};







class RNG
{
public:
    enum { UNIFORM=0, NORMAL=1 };

    RNG();
    RNG(uint64 state);

    unsigned next();

    operator uchar();
    operator schar();
    operator ushort();
    operator short();
    operator unsigned();

    unsigned operator ()(unsigned N);
    unsigned operator ()();
    operator int();
    operator float();
    operator double();

    int uniform(int a, int b);

    float uniform(float a, float b);

    double uniform(double a, double b);
    void fill( InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange=false );

    double gaussian(double sigma);

    uint64 state;
};





class TermCriteria
{
public:
    enum
    {
        COUNT=1,
        MAX_ITER=COUNT,
        EPS=2
    };


    TermCriteria();

    TermCriteria(int type, int maxCount, double epsilon);

    TermCriteria(const CvTermCriteria& criteria);

    operator CvTermCriteria() const;

    int type;
    int maxCount;
    double epsilon;
};


typedef void (*BinaryFunc)(const uchar* src1, size_t step1,
                           const uchar* src2, size_t step2,
                           uchar* dst, size_t step, Size sz,
                           void*);

 BinaryFunc getConvertFunc(int sdepth, int ddepth);
 BinaryFunc getConvertScaleFunc(int sdepth, int ddepth);
 BinaryFunc getCopyMaskFunc(size_t esz);


 void swap(Mat& a, Mat& b);


 Mat cvarrToMat(const CvArr* arr, bool copyData=false,
                          bool allowND=true, int coiMode=0);

 void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi=-1);

 void insertImageCOI(InputArray coiimg, CvArr* arr, int coi=-1);


 void add(InputArray src1, InputArray src2, OutputArray dst,
                      InputArray mask=noArray(), int dtype=-1);

 void subtract(InputArray src1, InputArray src2, OutputArray dst,
                           InputArray mask=noArray(), int dtype=-1);


 void multiply(InputArray src1, InputArray src2,
                           OutputArray dst, double scale=1, int dtype=-1);


 void divide(InputArray src1, InputArray src2, OutputArray dst,
                         double scale=1, int dtype=-1);


 void divide(double scale, InputArray src2,
                         OutputArray dst, int dtype=-1);


 void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst);


 void addWeighted(InputArray src1, double alpha, InputArray src2,
                              double beta, double gamma, OutputArray dst, int dtype=-1);


 void convertScaleAbs(InputArray src, OutputArray dst,
                                  double alpha=1, double beta=0);

 void LUT(InputArray src, InputArray lut, OutputArray dst,
                      int interpolation=0);


 Scalar sum(InputArray src);

 int countNonZero( InputArray src );

 void findNonZero( InputArray src, OutputArray idx );


 Scalar mean(InputArray src, InputArray mask=noArray());

 void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev,
                             InputArray mask=noArray());

 double norm(InputArray src1, int normType=NORM_L2, InputArray mask=noArray());

 double norm(InputArray src1, InputArray src2,
                         int normType=NORM_L2, InputArray mask=noArray());


 void batchDistance(InputArray src1, InputArray src2,
                                OutputArray dist, int dtype, OutputArray nidx,
                                int normType=NORM_L2, int K=0,
                                InputArray mask=noArray(), int update=0,
                                bool crosscheck=false);


 void normalize( InputArray src, OutputArray dst, double alpha=1, double beta=0,
                             int norm_type=NORM_L2, int dtype=-1, InputArray mask=noArray());


 void minMaxLoc(InputArray src, double* minVal,
                           double* maxVal=0, Point* minLoc=0,
                           Point* maxLoc=0, InputArray mask=noArray());
 void minMaxIdx(InputArray src, double* minVal, double* maxVal,
                          int* minIdx=0, int* maxIdx=0, InputArray mask=noArray());


 void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype=-1);


 void merge(const Mat* mv, size_t count, OutputArray dst);
 void merge(const vector<Mat>& mv, OutputArray dst );


 void merge(InputArrayOfArrays mv, OutputArray dst);


 void split(const Mat& src, Mat* mvbegin);
 void split(const Mat& m, vector<Mat>& mv );


 void split(InputArray m, OutputArrayOfArrays mv);


 void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts,
                            const int* fromTo, size_t npairs);
 void mixChannels(const vector<Mat>& src, vector<Mat>& dst,
                            const int* fromTo, size_t npairs);
 void mixChannels(InputArrayOfArrays src, InputArrayOfArrays dst,
                              const vector<int>& fromTo);


 void extractChannel(InputArray src, OutputArray dst, int coi);


 void insertChannel(InputArray src, InputOutputArray dst, int coi);


 void flip(InputArray src, OutputArray dst, int flipCode);


 void repeat(InputArray src, int ny, int nx, OutputArray dst);
 Mat repeat(const Mat& src, int ny, int nx);

 void hconcat(const Mat* src, size_t nsrc, OutputArray dst);
 void hconcat(InputArray src1, InputArray src2, OutputArray dst);
 void hconcat(InputArrayOfArrays src, OutputArray dst);

 void vconcat(const Mat* src, size_t nsrc, OutputArray dst);
 void vconcat(InputArray src1, InputArray src2, OutputArray dst);
 void vconcat(InputArrayOfArrays src, OutputArray dst);


 void bitwise_and(InputArray src1, InputArray src2,
                              OutputArray dst, InputArray mask=noArray());

 void bitwise_or(InputArray src1, InputArray src2,
                             OutputArray dst, InputArray mask=noArray());

 void bitwise_xor(InputArray src1, InputArray src2,
                              OutputArray dst, InputArray mask=noArray());

 void bitwise_not(InputArray src, OutputArray dst,
                              InputArray mask=noArray());

 void absdiff(InputArray src1, InputArray src2, OutputArray dst);

 void inRange(InputArray src, InputArray lowerb,
                          InputArray upperb, OutputArray dst);

 void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop);

 void min(InputArray src1, InputArray src2, OutputArray dst);

 void max(InputArray src1, InputArray src2, OutputArray dst);


 void min(const Mat& src1, const Mat& src2, Mat& dst);

 void min(const Mat& src1, double src2, Mat& dst);

 void max(const Mat& src1, const Mat& src2, Mat& dst);

 void max(const Mat& src1, double src2, Mat& dst);


 void sqrt(InputArray src, OutputArray dst);

 void pow(InputArray src, double power, OutputArray dst);

 void exp(InputArray src, OutputArray dst);

 void log(InputArray src, OutputArray dst);

 float cubeRoot(float val);

 float fastAtan2(float y, float x);

 void exp(const float* src, float* dst, int n);
 void log(const float* src, float* dst, int n);
 void fastAtan2(const float* y, const float* x, float* dst, int n, bool angleInDegrees);
 void magnitude(const float* x, const float* y, float* dst, int n);


 void polarToCart(InputArray magnitude, InputArray angle,
                              OutputArray x, OutputArray y, bool angleInDegrees=false);

 void cartToPolar(InputArray x, InputArray y,
                              OutputArray magnitude, OutputArray angle,
                              bool angleInDegrees=false);

 void phase(InputArray x, InputArray y, OutputArray angle,
                        bool angleInDegrees=false);

 void magnitude(InputArray x, InputArray y, OutputArray magnitude);

 bool checkRange(InputArray a, bool quiet=true, Point* pos=0,
                            double minVal=-double(1.79769313486231570815e+308L), double maxVal=double(1.79769313486231570815e+308L));

 void patchNaNs(InputOutputArray a, double val=0);


 void gemm(InputArray src1, InputArray src2, double alpha,
                       InputArray src3, double gamma, OutputArray dst, int flags=0);

 void mulTransposed( InputArray src, OutputArray dst, bool aTa,
                                 InputArray delta=noArray(),
                                 double scale=1, int dtype=-1 );

 void transpose(InputArray src, OutputArray dst);

 void transform(InputArray src, OutputArray dst, InputArray m );

 void perspectiveTransform(InputArray src, OutputArray dst, InputArray m );


 void completeSymm(InputOutputArray mtx, bool lowerToUpper=false);

 void setIdentity(InputOutputArray mtx, const Scalar& s=Scalar(1));

 double determinant(InputArray mtx);

 Scalar trace(InputArray mtx);

 double invert(InputArray src, OutputArray dst, int flags=DECOMP_LU);

 bool solve(InputArray src1, InputArray src2,
                        OutputArray dst, int flags=DECOMP_LU);

enum
{
    SORT_EVERY_ROW=0,
    SORT_EVERY_COLUMN=1,
    SORT_ASCENDING=0,
    SORT_DESCENDING=16
};


 void sort(InputArray src, OutputArray dst, int flags);

 void sortIdx(InputArray src, OutputArray dst, int flags);

 int solveCubic(InputArray coeffs, OutputArray roots);

 double solvePoly(InputArray coeffs, OutputArray roots, int maxIters=300);

 bool eigen(InputArray src, OutputArray eigenvalues, int lowindex=-1,
                      int highindex=-1);

 bool eigen(InputArray src, OutputArray eigenvalues,
                      OutputArray eigenvectors,
                      int lowindex=-1, int highindex=-1);
 bool eigen(InputArray src, bool computeEigenvectors,
                        OutputArray eigenvalues, OutputArray eigenvectors);

enum
{
    COVAR_SCRAMBLED=0,
    COVAR_NORMAL=1,
    COVAR_USE_AVG=2,
    COVAR_SCALE=4,
    COVAR_ROWS=8,
    COVAR_COLS=16
};


 void calcCovarMatrix( const Mat* samples, int nsamples, Mat& covar, Mat& mean,
                                 int flags, int ctype=6);

 void calcCovarMatrix( InputArray samples, OutputArray covar,
                                   OutputArray mean, int flags, int ctype=6);
#2403 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class PCA
{
public:

    PCA();

    PCA(InputArray data, InputArray mean, int flags, int maxComponents=0);
    PCA(InputArray data, InputArray mean, int flags, double retainedVariance);

    PCA& operator()(InputArray data, InputArray mean, int flags, int maxComponents=0);
    PCA& computeVar(InputArray data, InputArray mean, int flags, double retainedVariance);

    Mat project(InputArray vec) const;

    void project(InputArray vec, OutputArray result) const;

    Mat backProject(InputArray vec) const;

    void backProject(InputArray vec, OutputArray result) const;

    Mat eigenvectors;
    Mat eigenvalues;
    Mat mean;
};

 void PCACompute(InputArray data, InputOutputArray mean,
                             OutputArray eigenvectors, int maxComponents=0);

 void PCAComputeVar(InputArray data, InputOutputArray mean,
                             OutputArray eigenvectors, double retainedVariance);

 void PCAProject(InputArray data, InputArray mean,
                             InputArray eigenvectors, OutputArray result);

 void PCABackProject(InputArray data, InputArray mean,
                                 InputArray eigenvectors, OutputArray result);
#2454 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class SVD
{
public:
    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };

    SVD();

    SVD( InputArray src, int flags=0 );

    SVD& operator ()( InputArray src, int flags=0 );


    static void compute( InputArray src, OutputArray w,
                         OutputArray u, OutputArray vt, int flags=0 );

    static void compute( InputArray src, OutputArray w, int flags=0 );

    static void backSubst( InputArray w, InputArray u,
                           InputArray vt, InputArray rhs,
                           OutputArray dst );

    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,
        Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt );
    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,
        Matx<_Tp, nm, 1>& w );
    template<typename _Tp, int m, int n, int nm, int nb> static void backSubst( const Matx<_Tp, nm, 1>& w,
        const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst );


    static void solveZ( InputArray src, OutputArray dst );

    void backSubst( InputArray rhs, OutputArray dst ) const;

    Mat u, w, vt;
};


 void SVDecomp( InputArray src, OutputArray w,
    OutputArray u, OutputArray vt, int flags=0 );


 void SVBackSubst( InputArray w, InputArray u, InputArray vt,
                               InputArray rhs, OutputArray dst );


 double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar);

 double Mahalonobis(InputArray v1, InputArray v2, InputArray icovar);


 void dft(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0);

 void idft(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0);

 void dct(InputArray src, OutputArray dst, int flags=0);

 void idct(InputArray src, OutputArray dst, int flags=0);

 void mulSpectrums(InputArray a, InputArray b, OutputArray c,
                               int flags, bool conjB=false);

 int getOptimalDFTSize(int vecsize);




enum
{
    KMEANS_RANDOM_CENTERS=0,
    KMEANS_PP_CENTERS=2,
    KMEANS_USE_INITIAL_LABELS=1
};

 double kmeans( InputArray data, int K, InputOutputArray bestLabels,
                            TermCriteria criteria, int attempts,
                            int flags, OutputArray centers=noArray() );


 RNG& theRNG();


template<typename _Tp> static inline _Tp randu() { return (_Tp)theRNG(); }


 void randu(InputOutputArray dst, InputArray low, InputArray high);


 void randn(InputOutputArray dst, InputArray mean, InputArray stddev);


 void randShuffle(InputOutputArray dst, double iterFactor=1., RNG* rng=0);
 void randShuffle_(InputOutputArray dst, double iterFactor=1.);


 void line( Mat& img, Point pt1, Point pt2, const Scalar& color,
                     int thickness=1, int lineType=8, int shift=0);


 void rectangle( Mat& img, Point pt1, Point pt2,
                          const Scalar& color, int thickness=1,
                          int lineType=8, int shift=0);


 void rectangle( Mat& img, Rect rec,
                          const Scalar& color, int thickness=1,
                          int lineType=8, int shift=0);


 void circle( Mat& img, Point center, int radius,
                       const Scalar& color, int thickness=1,
                       int lineType=8, int shift=0);


 void ellipse( Mat& img, Point center, Size axes,
                        double angle, double startAngle, double endAngle,
                        const Scalar& color, int thickness=1,
                        int lineType=8, int shift=0);


 void ellipse( Mat& img, const RotatedRect& box, const Scalar& color,
                        int thickness=1, int lineType=8);


 void fillConvexPoly(Mat& img, const Point* pts, int npts,
                               const Scalar& color, int lineType=8,
                               int shift=0);
 void fillConvexPoly(InputOutputArray img, InputArray points,
                                 const Scalar& color, int lineType=8,
                                 int shift=0);


 void fillPoly(Mat& img, const Point** pts,
                         const int* npts, int ncontours,
                         const Scalar& color, int lineType=8, int shift=0,
                         Point offset=Point() );

 void fillPoly(InputOutputArray img, InputArrayOfArrays pts,
                           const Scalar& color, int lineType=8, int shift=0,
                           Point offset=Point() );


 void polylines(Mat& img, const Point** pts, const int* npts,
                          int ncontours, bool isClosed, const Scalar& color,
                          int thickness=1, int lineType=8, int shift=0 );

 void polylines(InputOutputArray img, InputArrayOfArrays pts,
                            bool isClosed, const Scalar& color,
                            int thickness=1, int lineType=8, int shift=0 );


 bool clipLine(Size imgSize, Point& pt1, Point& pt2);


 bool clipLine(Rect imgRect, Point& pt1, Point& pt2);







class LineIterator
{
public:

    LineIterator( const Mat& img, Point pt1, Point pt2,
                  int connectivity=8, bool leftToRight=false );

    uchar* operator *();

    LineIterator& operator ++();

    LineIterator operator ++(int);

    Point pos() const;

    uchar* ptr;
    const uchar* ptr0;
    int step, elemSize;
    int err, count;
    int minusDelta, plusDelta;
    int minusStep, plusStep;
};


 void ellipse2Poly( Point center, Size axes, int angle,
                                int arcStart, int arcEnd, int delta,
                                vector<Point>& pts );

enum
{
    FONT_HERSHEY_SIMPLEX = 0,
    FONT_HERSHEY_PLAIN = 1,
    FONT_HERSHEY_DUPLEX = 2,
    FONT_HERSHEY_COMPLEX = 3,
    FONT_HERSHEY_TRIPLEX = 4,
    FONT_HERSHEY_COMPLEX_SMALL = 5,
    FONT_HERSHEY_SCRIPT_SIMPLEX = 6,
    FONT_HERSHEY_SCRIPT_COMPLEX = 7,
    FONT_ITALIC = 16
};


 void putText( Mat& img, const string& text, Point org,
                         int fontFace, double fontScale, Scalar color,
                         int thickness=1, int lineType=8,
                         bool bottomLeftOrigin=false );


 Size getTextSize(const string& text, int fontFace,
                            double fontScale, int thickness,
                            int* baseLine);
#2714 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Mat_ : public Mat
{
public:
    typedef _Tp value_type;
    typedef typename DataType<_Tp>::channel_type channel_type;
    typedef MatIterator_<_Tp> iterator;
    typedef MatConstIterator_<_Tp> const_iterator;


    Mat_();

    Mat_(int _rows, int _cols);

    Mat_(int _rows, int _cols, const _Tp& value);

    explicit Mat_(Size _size);

    Mat_(Size _size, const _Tp& value);

    Mat_(int _ndims, const int* _sizes);

    Mat_(int _ndims, const int* _sizes, const _Tp& value);

    Mat_(const Mat& m);

    Mat_(const Mat_& m);

    Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);

    Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);

    Mat_(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all());

    Mat_(const Mat_& m, const Rect& roi);

    Mat_(const Mat_& m, const Range* ranges);

    explicit Mat_(const MatExpr& e);

    explicit Mat_(const vector<_Tp>& vec, bool copyData=false);
    template<int n> explicit Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true);
    template<int m, int n> explicit Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true);
    explicit Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);
    explicit Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);
    explicit Mat_(const MatCommaInitializer_<_Tp>& commaInitializer);

    Mat_& operator = (const Mat& m);
    Mat_& operator = (const Mat_& m);

    Mat_& operator = (const _Tp& s);

    Mat_& operator = (const MatExpr& e);


    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;


    void create(int _rows, int _cols);

    void create(Size _size);

    void create(int _ndims, const int* _sizes);

    Mat_ cross(const Mat_& m) const;

    template<typename T2> operator Mat_<T2>() const;

    Mat_ row(int y) const;
    Mat_ col(int x) const;
    Mat_ diag(int d=0) const;
    Mat_ clone() const;


    size_t elemSize() const;
    size_t elemSize1() const;
    int type() const;
    int depth() const;
    int channels() const;
    size_t step1(int i=0) const;

    size_t stepT(int i=0) const;


    static MatExpr zeros(int rows, int cols);
    static MatExpr zeros(Size size);
    static MatExpr zeros(int _ndims, const int* _sizes);
    static MatExpr ones(int rows, int cols);
    static MatExpr ones(Size size);
    static MatExpr ones(int _ndims, const int* _sizes);
    static MatExpr eye(int rows, int cols);
    static MatExpr eye(Size size);


    Mat_& adjustROI( int dtop, int dbottom, int dleft, int dright );
    Mat_ operator()( const Range& rowRange, const Range& colRange ) const;
    Mat_ operator()( const Rect& roi ) const;
    Mat_ operator()( const Range* ranges ) const;


    _Tp* operator [](int y);
    const _Tp* operator [](int y) const;


    _Tp& operator ()(const int* idx);

    const _Tp& operator ()(const int* idx) const;


    template<int n> _Tp& operator ()(const Vec<int, n>& idx);

    template<int n> const _Tp& operator ()(const Vec<int, n>& idx) const;


    _Tp& operator ()(int idx0);

    const _Tp& operator ()(int idx0) const;

    _Tp& operator ()(int idx0, int idx1);

    const _Tp& operator ()(int idx0, int idx1) const;

    _Tp& operator ()(int idx0, int idx1, int idx2);

    const _Tp& operator ()(int idx0, int idx1, int idx2) const;

    _Tp& operator ()(Point pt);
    const _Tp& operator ()(Point pt) const;


    operator vector<_Tp>() const;

    template<int n> operator Vec<typename DataType<_Tp>::channel_type, n>() const;

    template<int m, int n> operator Matx<typename DataType<_Tp>::channel_type, m, n>() const;
};

typedef Mat_<uchar> Mat1b;
typedef Mat_<Vec2b> Mat2b;
typedef Mat_<Vec3b> Mat3b;
typedef Mat_<Vec4b> Mat4b;

typedef Mat_<short> Mat1s;
typedef Mat_<Vec2s> Mat2s;
typedef Mat_<Vec3s> Mat3s;
typedef Mat_<Vec4s> Mat4s;

typedef Mat_<ushort> Mat1w;
typedef Mat_<Vec2w> Mat2w;
typedef Mat_<Vec3w> Mat3w;
typedef Mat_<Vec4w> Mat4w;

typedef Mat_<int> Mat1i;
typedef Mat_<Vec2i> Mat2i;
typedef Mat_<Vec3i> Mat3i;
typedef Mat_<Vec4i> Mat4i;

typedef Mat_<float> Mat1f;
typedef Mat_<Vec2f> Mat2f;
typedef Mat_<Vec3f> Mat3f;
typedef Mat_<Vec4f> Mat4f;

typedef Mat_<double> Mat1d;
typedef Mat_<Vec2d> Mat2d;
typedef Mat_<Vec3d> Mat3d;
typedef Mat_<Vec4d> Mat4d;



class MatConstIterator
{
public:
    typedef uchar* value_type;
    typedef ptrdiff_t difference_type;
    typedef const uchar** pointer;
    typedef uchar* reference;
    typedef std::random_access_iterator_tag iterator_category;


    MatConstIterator();

    MatConstIterator(const Mat* _m);

    MatConstIterator(const Mat* _m, int _row, int _col=0);

    MatConstIterator(const Mat* _m, Point _pt);

    MatConstIterator(const Mat* _m, const int* _idx);

    MatConstIterator(const MatConstIterator& it);


    MatConstIterator& operator = (const MatConstIterator& it);

    uchar* operator *() const;

    uchar* operator [](ptrdiff_t i) const;


    MatConstIterator& operator += (ptrdiff_t ofs);

    MatConstIterator& operator -= (ptrdiff_t ofs);

    MatConstIterator& operator --();

    MatConstIterator operator --(int);

    MatConstIterator& operator ++();

    MatConstIterator operator ++(int);

    Point pos() const;

    void pos(int* _idx) const;
    ptrdiff_t lpos() const;
    void seek(ptrdiff_t ofs, bool relative=false);
    void seek(const int* _idx, bool relative=false);

    const Mat* m;
    size_t elemSize;
    uchar* ptr;
    uchar* sliceStart;
    uchar* sliceEnd;
};





template<typename _Tp>
class MatConstIterator_ : public MatConstIterator
{
public:
    typedef _Tp value_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp& reference;
    typedef std::random_access_iterator_tag iterator_category;


    MatConstIterator_();

    MatConstIterator_(const Mat_<_Tp>* _m);

    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col=0);

    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt);

    MatConstIterator_(const Mat_<_Tp>* _m, const int* _idx);

    MatConstIterator_(const MatConstIterator_& it);


    MatConstIterator_& operator = (const MatConstIterator_& it);

    _Tp operator *() const;

    _Tp operator [](ptrdiff_t i) const;


    MatConstIterator_& operator += (ptrdiff_t ofs);

    MatConstIterator_& operator -= (ptrdiff_t ofs);

    MatConstIterator_& operator --();

    MatConstIterator_ operator --(int);

    MatConstIterator_& operator ++();

    MatConstIterator_ operator ++(int);

    Point pos() const;
};






template<typename _Tp>
class MatIterator_ : public MatConstIterator_<_Tp>
{
public:
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef std::random_access_iterator_tag iterator_category;


    MatIterator_();

    MatIterator_(Mat_<_Tp>* _m);

    MatIterator_(Mat_<_Tp>* _m, int _row, int _col=0);

    MatIterator_(const Mat_<_Tp>* _m, Point _pt);

    MatIterator_(const Mat_<_Tp>* _m, const int* _idx);

    MatIterator_(const MatIterator_& it);

    MatIterator_& operator = (const MatIterator_<_Tp>& it );


    _Tp& operator *() const;

    _Tp& operator [](ptrdiff_t i) const;


    MatIterator_& operator += (ptrdiff_t ofs);

    MatIterator_& operator -= (ptrdiff_t ofs);

    MatIterator_& operator --();

    MatIterator_ operator --(int);

    MatIterator_& operator ++();

    MatIterator_ operator ++(int);
};

template<typename _Tp> class MatOp_Iter_;
#3053 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class MatCommaInitializer_
{
public:

    MatCommaInitializer_(Mat_<_Tp>* _m);

    template<typename T2> MatCommaInitializer_<_Tp>& operator , (T2 v);

    Mat_<_Tp> operator *() const;
    operator Mat_<_Tp>() const;
protected:
    MatIterator_<_Tp> it;
};


template<typename _Tp, int m, int n> class MatxCommaInitializer
{
public:
    MatxCommaInitializer(Matx<_Tp, m, n>* _mtx);
    template<typename T2> MatxCommaInitializer<_Tp, m, n>& operator , (T2 val);
    Matx<_Tp, m, n> operator *() const;

    Matx<_Tp, m, n>* dst;
    int idx;
};

template<typename _Tp, int m> class VecCommaInitializer : public MatxCommaInitializer<_Tp, m, 1>
{
public:
    VecCommaInitializer(Vec<_Tp, m>* _vec);
    template<typename T2> VecCommaInitializer<_Tp, m>& operator , (T2 val);
    Vec<_Tp, m> operator *() const;
};
#3114 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp, size_t fixed_size=4096/sizeof(_Tp)+8> class AutoBuffer
{
public:
    typedef _Tp value_type;
    enum { buffer_padding = (int)((16 + sizeof(_Tp) - 1)/sizeof(_Tp)) };


    AutoBuffer();

    AutoBuffer(size_t _size);

    ~AutoBuffer();


    void allocate(size_t _size);

    void deallocate();

    operator _Tp* ();

    operator const _Tp* () const;

protected:

    _Tp* ptr;

    size_t size;

    _Tp buf[fixed_size+buffer_padding];
};
#3197 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class NAryMatIterator
{
public:

    NAryMatIterator();

    NAryMatIterator(const Mat** arrays, uchar** ptrs, int narrays=-1);

    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);

    void init(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1);


    NAryMatIterator& operator ++();

    NAryMatIterator operator ++(int);


    const Mat** arrays;

    Mat* planes;

    uchar** ptrs;

    int narrays;

    size_t nplanes;

    size_t size;
protected:
    int iterdepth;
    size_t idx;
};



typedef void (*ConvertData)(const void* from, void* to, int cn);
typedef void (*ConvertScaleData)(const void* from, void* to, int cn, double alpha, double beta);


 ConvertData getConvertElem(int fromType, int toType);

 ConvertScaleData getConvertScaleElem(int fromType, int toType);




class SparseMatIterator;
class SparseMatConstIterator;
template<typename _Tp> class SparseMatIterator_;
template<typename _Tp> class SparseMatConstIterator_;
#3334 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class SparseMat
{
public:
    typedef SparseMatIterator iterator;
    typedef SparseMatConstIterator const_iterator;


    struct Hdr
    {
        Hdr(int _dims, const int* _sizes, int _type);
        void clear();
        int refcount;
        int dims;
        int valueOffset;
        size_t nodeSize;
        size_t nodeCount;
        size_t freeList;
        vector<uchar> pool;
        vector<size_t> hashtab;
        int size[32];
    };


    struct Node
    {

        size_t hashval;

        size_t next;

        int idx[32];
    };


    SparseMat();

    SparseMat(int dims, const int* _sizes, int _type);

    SparseMat(const SparseMat& m);






    explicit SparseMat(const Mat& m);

    SparseMat(const CvSparseMat* m);

    ~SparseMat();


    SparseMat& operator = (const SparseMat& m);

    SparseMat& operator = (const Mat& m);


    SparseMat clone() const;


    void copyTo( SparseMat& m ) const;

    void copyTo( Mat& m ) const;

    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;






    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;


    void assignTo( SparseMat& m, int type=-1 ) const;







    void create(int dims, const int* _sizes, int _type);

    void clear();

    void addref();

    void release();


    operator CvSparseMat*() const;

    size_t elemSize() const;

    size_t elemSize1() const;


    int type() const;

    int depth() const;

    int channels() const;


    const int* size() const;

    int size(int i) const;

    int dims() const;

    size_t nzcount() const;


    size_t hash(int i0) const;

    size_t hash(int i0, int i1) const;

    size_t hash(int i0, int i1, int i2) const;

    size_t hash(const int* idx) const;
#3471 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);

    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);

    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);

    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);
#3489 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);

    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);

    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);

    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);
#3511 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;

    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;

    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;

    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;
#3529 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;

    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;

    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;

    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;


    void erase(int i0, int i1, size_t* hashval=0);

    void erase(int i0, int i1, int i2, size_t* hashval=0);

    void erase(const int* idx, size_t* hashval=0);






    SparseMatIterator begin();

    template<typename _Tp> SparseMatIterator_<_Tp> begin();

    SparseMatConstIterator begin() const;

    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;





    SparseMatIterator end();

    SparseMatConstIterator end() const;

    template<typename _Tp> SparseMatIterator_<_Tp> end();

    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;


    template<typename _Tp> _Tp& value(Node* n);

    template<typename _Tp> const _Tp& value(const Node* n) const;


    Node* node(size_t nidx);
    const Node* node(size_t nidx) const;

    uchar* newNode(const int* idx, size_t hashval);
    void removeNode(size_t hidx, size_t nidx, size_t previdx);
    void resizeHashTab(size_t newsize);

    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=32, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };

    int flags;
    Hdr* hdr;
};


 void minMaxLoc(const SparseMat& a, double* minVal,
                          double* maxVal, int* minIdx=0, int* maxIdx=0);

 double norm( const SparseMat& src, int normType );

 void normalize( const SparseMat& src, SparseMat& dst, double alpha, int normType );
#3608 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class SparseMatConstIterator
{
public:

    SparseMatConstIterator();

    SparseMatConstIterator(const SparseMat* _m);

    SparseMatConstIterator(const SparseMatConstIterator& it);


    SparseMatConstIterator& operator = (const SparseMatConstIterator& it);


    template<typename _Tp> const _Tp& value() const;

    const SparseMat::Node* node() const;


    SparseMatConstIterator& operator --();

    SparseMatConstIterator operator --(int);

    SparseMatConstIterator& operator ++();

    SparseMatConstIterator operator ++(int);


    void seekEnd();

    const SparseMat* m;
    size_t hashidx;
    uchar* ptr;
};







class SparseMatIterator : public SparseMatConstIterator
{
public:

    SparseMatIterator();

    SparseMatIterator(SparseMat* _m);

    SparseMatIterator(SparseMat* _m, const int* idx);

    SparseMatIterator(const SparseMatIterator& it);


    SparseMatIterator& operator = (const SparseMatIterator& it);

    template<typename _Tp> _Tp& value() const;

    SparseMat::Node* node() const;


    SparseMatIterator& operator ++();

    SparseMatIterator operator ++(int);
};
#3687 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class SparseMat_ : public SparseMat
{
public:
    typedef SparseMatIterator_<_Tp> iterator;
    typedef SparseMatConstIterator_<_Tp> const_iterator;


    SparseMat_();

    SparseMat_(int dims, const int* _sizes);

    SparseMat_(const SparseMat& m);

    SparseMat_(const SparseMat_& m);

    SparseMat_(const Mat& m);

    SparseMat_(const CvSparseMat* m);

    SparseMat_& operator = (const SparseMat& m);

    SparseMat_& operator = (const SparseMat_& m);

    SparseMat_& operator = (const Mat& m);


    SparseMat_ clone() const;

    void create(int dims, const int* _sizes);

    operator CvSparseMat*() const;


    int type() const;

    int depth() const;

    int channels() const;


    _Tp& ref(int i0, size_t* hashval=0);

    _Tp& ref(int i0, int i1, size_t* hashval=0);

    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);

    _Tp& ref(const int* idx, size_t* hashval=0);


    _Tp operator()(int i0, size_t* hashval=0) const;

    _Tp operator()(int i0, int i1, size_t* hashval=0) const;

    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;

    _Tp operator()(const int* idx, size_t* hashval=0) const;


    SparseMatIterator_<_Tp> begin();

    SparseMatConstIterator_<_Tp> begin() const;

    SparseMatIterator_<_Tp> end();

    SparseMatConstIterator_<_Tp> end() const;
};
#3761 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class SparseMatConstIterator_ : public SparseMatConstIterator
{
public:
    typedef std::forward_iterator_tag iterator_category;


    SparseMatConstIterator_();

    SparseMatConstIterator_(const SparseMat_<_Tp>* _m);
    SparseMatConstIterator_(const SparseMat* _m);

    SparseMatConstIterator_(const SparseMatConstIterator_& it);


    SparseMatConstIterator_& operator = (const SparseMatConstIterator_& it);

    const _Tp& operator *() const;


    SparseMatConstIterator_& operator ++();

    SparseMatConstIterator_ operator ++(int);
};







template<typename _Tp> class SparseMatIterator_ : public SparseMatConstIterator_<_Tp>
{
public:
    typedef std::forward_iterator_tag iterator_category;


    SparseMatIterator_();

    SparseMatIterator_(SparseMat_<_Tp>* _m);
    SparseMatIterator_(SparseMat* _m);

    SparseMatIterator_(const SparseMatIterator_& it);


    SparseMatIterator_& operator = (const SparseMatIterator_& it);

    _Tp& operator *() const;


    SparseMatIterator_& operator ++();

    SparseMatIterator_ operator ++(int);
};
#3841 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class KDTree
{
public:



    struct Node
    {
        Node() : idx(-1), left(-1), right(-1), boundary(0.f) {}
        Node(int _idx, int _left, int _right, float _boundary)
            : idx(_idx), left(_left), right(_right), boundary(_boundary) {}

        int idx;

        int left, right;

        float boundary;
    };


    KDTree();

    KDTree(InputArray points, bool copyAndReorderPoints=false);

    KDTree(InputArray points, InputArray _labels,
                   bool copyAndReorderPoints=false);

    void build(InputArray points, bool copyAndReorderPoints=false);

    void build(InputArray points, InputArray labels,
                       bool copyAndReorderPoints=false);

    int findNearest(InputArray vec, int K, int Emax,
                            OutputArray neighborsIdx,
                            OutputArray neighbors=noArray(),
                            OutputArray dist=noArray(),
                            OutputArray labels=noArray()) const;

    void findOrthoRange(InputArray minBounds,
                                InputArray maxBounds,
                                OutputArray neighborsIdx,
                                OutputArray neighbors=noArray(),
                                OutputArray labels=noArray()) const;

    void getPoints(InputArray idx, OutputArray pts,
                           OutputArray labels=noArray()) const;

    const float* getPoint(int ptidx, int* label=0) const;

    int dims() const;

    vector<Node> nodes;
    Mat points;
    vector<int> labels;
    int maxDepth;
    int normType;
};



class FileNode;
#4000 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class FileStorage
{
public:

    enum
    {
        READ=0,
        WRITE=1,
        APPEND=2,
        MEMORY=4,
        FORMAT_MASK=(7<<3),
        FORMAT_AUTO=0,
        FORMAT_XML=(1<<3),
        FORMAT_YAML=(2<<3)
    };
    enum
    {
        UNDEFINED=0,
        VALUE_EXPECTED=1,
        NAME_EXPECTED=2,
        INSIDE_MAP=4
    };

    FileStorage();

    FileStorage(const string& source, int flags, const string& encoding=string());

    FileStorage(CvFileStorage* fs);

    virtual ~FileStorage();


    virtual bool open(const string& filename, int flags, const string& encoding=string());

    virtual bool isOpened() const;

    virtual void release();

    string releaseAndGetString();


    FileNode getFirstTopLevelNode() const;

    FileNode root(int streamidx=0) const;

    FileNode operator[](const string& nodename) const;

    FileNode operator[](const char* nodename) const;


    CvFileStorage* operator *() { return fs; }

    const CvFileStorage* operator *() const { return fs; }

    void writeRaw( const string& fmt, const uchar* vec, size_t len );

    void writeObj( const string& name, const void* obj );


    static string getDefaultObjectName(const string& filename);

    Ptr<CvFileStorage> fs;
    string elname;
    vector<char> structs;
    int state;
};

class FileNodeIterator;
#4079 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class FileNode
{
public:

    enum
    {
        NONE=0,
        INT=1,
        REAL=2,
        FLOAT=REAL,
        STR=3,
        STRING=STR,
        REF=4,
        SEQ=5,
        MAP=6,
        TYPE_MASK=7,
        FLOW=8,
        USER=16,
        EMPTY=32,
        NAMED=64
    };

    FileNode();

    FileNode(const CvFileStorage* fs, const CvFileNode* node);

    FileNode(const FileNode& node);

    FileNode operator[](const string& nodename) const;

    FileNode operator[](const char* nodename) const;

    FileNode operator[](int i) const;

    int type() const;


    bool empty() const;

    bool isNone() const;

    bool isSeq() const;

    bool isMap() const;

    bool isInt() const;

    bool isReal() const;

    bool isString() const;

    bool isNamed() const;

    string name() const;

    size_t size() const;

    operator int() const;

    operator float() const;

    operator double() const;

    operator string() const;


    CvFileNode* operator *();

    const CvFileNode* operator* () const;


    FileNodeIterator begin() const;

    FileNodeIterator end() const;


    void readRaw( const string& fmt, uchar* vec, size_t len ) const;

    void* readObj() const;


    const CvFileStorage* fs;
    const CvFileNode* node;
};







class FileNodeIterator
{
public:

    FileNodeIterator();

    FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0);

    FileNodeIterator(const FileNodeIterator& it);

    FileNode operator *() const;

    FileNode operator ->() const;


    FileNodeIterator& operator ++ ();

    FileNodeIterator operator ++ (int);

    FileNodeIterator& operator -- ();

    FileNodeIterator operator -- (int);

    FileNodeIterator& operator += (int ofs);

    FileNodeIterator& operator -= (int ofs);


    FileNodeIterator& readRaw( const string& fmt, uchar* vec,
                               size_t maxCount=(size_t)2147483647 );

    const CvFileStorage* fs;
    const CvFileNode* container;
    CvSeqReader reader;
    size_t remaining;
};



template<typename _Tp> class SeqIterator;

typedef Ptr<CvMemStorage> MemStorage;
#4223 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
template<typename _Tp> class Seq
{
public:
    typedef SeqIterator<_Tp> iterator;
    typedef SeqIterator<_Tp> const_iterator;


    Seq();

    Seq(const CvSeq* seq);

    Seq(MemStorage& storage, int headerSize = sizeof(CvSeq));

    _Tp& operator [](int idx);

    const _Tp& operator[](int idx) const;

    SeqIterator<_Tp> begin() const;

    SeqIterator<_Tp> end() const;

    size_t size() const;

    int type() const;

    int depth() const;

    int channels() const;

    size_t elemSize() const;

    size_t index(const _Tp& elem) const;

    void push_back(const _Tp& elem);

    void push_front(const _Tp& elem);

    void push_back(const _Tp* elems, size_t count);

    void push_front(const _Tp* elems, size_t count);

    void insert(int idx, const _Tp& elem);

    void insert(int idx, const _Tp* elems, size_t count);

    void remove(int idx);

    void remove(const Range& r);


    _Tp& front();

    const _Tp& front() const;

    _Tp& back();

    const _Tp& back() const;

    bool empty() const;


    void clear();

    void pop_front();

    void pop_back();

    void pop_front(_Tp* elems, size_t count);

    void pop_back(_Tp* elems, size_t count);


    void copyTo(vector<_Tp>& vec, const Range& range=Range::all()) const;

    operator vector<_Tp>() const;

    CvSeq* seq;
};





template<typename _Tp> class SeqIterator : public CvSeqReader
{
public:

    SeqIterator();

    SeqIterator(const Seq<_Tp>& seq, bool seekEnd=false);

    void seek(size_t pos);

    size_t tell() const;

    _Tp& operator *();

    const _Tp& operator *() const;

    SeqIterator& operator ++();

    SeqIterator operator ++(int) const;

    SeqIterator& operator --();

    SeqIterator operator --(int) const;


    SeqIterator& operator +=(int);

    SeqIterator& operator -=(int);



    int index;
};


class Algorithm;
class AlgorithmInfo;
struct AlgorithmInfoData;

template<typename _Tp> struct ParamType {};




class Algorithm
{
public:
    Algorithm();
    virtual ~Algorithm();
    string name() const;

    template<typename _Tp> typename ParamType<_Tp>::member_type get(const string& name) const;
    template<typename _Tp> typename ParamType<_Tp>::member_type get(const char* name) const;

    int getInt(const string& name) const;
    double getDouble(const string& name) const;
    bool getBool(const string& name) const;
    string getString(const string& name) const;
    Mat getMat(const string& name) const;
    vector<Mat> getMatVector(const string& name) const;
    Ptr<Algorithm> getAlgorithm(const string& name) const;

    void set(const string& name, int value);
    void set(const string& name, double value);
    void set(const string& name, bool value);
    void set(const string& name, const string& value);
    void set(const string& name, const Mat& value);
    void set(const string& name, const vector<Mat>& value);
    void set(const string& name, const Ptr<Algorithm>& value);
    template<typename _Tp> void set(const string& name, const Ptr<_Tp>& value);

    void setInt(const string& name, int value);
    void setDouble(const string& name, double value);
    void setBool(const string& name, bool value);
    void setString(const string& name, const string& value);
    void setMat(const string& name, const Mat& value);
    void setMatVector(const string& name, const vector<Mat>& value);
    void setAlgorithm(const string& name, const Ptr<Algorithm>& value);
    template<typename _Tp> void setAlgorithm(const string& name, const Ptr<_Tp>& value);

    void set(const char* name, int value);
    void set(const char* name, double value);
    void set(const char* name, bool value);
    void set(const char* name, const string& value);
    void set(const char* name, const Mat& value);
    void set(const char* name, const vector<Mat>& value);
    void set(const char* name, const Ptr<Algorithm>& value);
    template<typename _Tp> void set(const char* name, const Ptr<_Tp>& value);

    void setInt(const char* name, int value);
    void setDouble(const char* name, double value);
    void setBool(const char* name, bool value);
    void setString(const char* name, const string& value);
    void setMat(const char* name, const Mat& value);
    void setMatVector(const char* name, const vector<Mat>& value);
    void setAlgorithm(const char* name, const Ptr<Algorithm>& value);
    template<typename _Tp> void setAlgorithm(const char* name, const Ptr<_Tp>& value);

    string paramHelp(const string& name) const;
    int paramType(const char* name) const;
    int paramType(const string& name) const;
    void getParams( vector<string>& names) const;


    virtual void write(FileStorage& fs) const;
    virtual void read(const FileNode& fn);

    typedef Algorithm* (*Constructor)(void);
    typedef int (Algorithm::*Getter)() const;
    typedef void (Algorithm::*Setter)(int);

    static void getList( vector<string>& algorithms);
    static Ptr<Algorithm> _create(const string& name);
    template<typename _Tp> static Ptr<_Tp> create(const string& name);

    virtual AlgorithmInfo* info() const { return 0; }
};


class AlgorithmInfo
{
public:
    friend class Algorithm;
    AlgorithmInfo(const string& name, Algorithm::Constructor create);
    ~AlgorithmInfo();
    void get(const Algorithm* algo, const char* name, int argType, void* value) const;
    void addParam_(Algorithm& algo, const char* name, int argType,
                   void* value, bool readOnly,
                   Algorithm::Getter getter, Algorithm::Setter setter,
                   const string& help=string());
    string paramHelp(const char* name) const;
    int paramType(const char* name) const;
    void getParams(vector<string>& names) const;

    void write(const Algorithm* algo, FileStorage& fs) const;
    void read(Algorithm* algo, const FileNode& fn) const;
    string name() const;

    void addParam(Algorithm& algo, const char* name,
                  int& value, bool readOnly=false,
                  int (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(int)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  short& value, bool readOnly=false,
                  int (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(int)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  bool& value, bool readOnly=false,
                  int (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(int)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  double& value, bool readOnly=false,
                  double (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(double)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  string& value, bool readOnly=false,
                  string (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(const string&)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  Mat& value, bool readOnly=false,
                  Mat (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(const Mat&)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  vector<Mat>& value, bool readOnly=false,
                  vector<Mat> (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(const vector<Mat>&)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  Ptr<Algorithm>& value, bool readOnly=false,
                  Ptr<Algorithm> (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(const Ptr<Algorithm>&)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  float& value, bool readOnly=false,
                  float (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(float)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  unsigned int& value, bool readOnly=false,
                  unsigned int (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(unsigned int)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  uint64& value, bool readOnly=false,
                  uint64 (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(uint64)=0,
                  const string& help=string());
    void addParam(Algorithm& algo, const char* name,
                  uchar& value, bool readOnly=false,
                  uchar (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(uchar)=0,
                  const string& help=string());
    template<typename _Tp, typename _Base> void addParam(Algorithm& algo, const char* name,
                  Ptr<_Tp>& value, bool readOnly=false,
                  Ptr<_Tp> (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(const Ptr<_Tp>&)=0,
                  const string& help=string());
    template<typename _Tp> void addParam(Algorithm& algo, const char* name,
                  Ptr<_Tp>& value, bool readOnly=false,
                  Ptr<_Tp> (Algorithm::*getter)()=0,
                  void (Algorithm::*setter)(const Ptr<_Tp>&)=0,
                  const string& help=string());
protected:
    AlgorithmInfoData* data;
    void set(Algorithm* algo, const char* name, int argType,
              const void* value, bool force=false) const;
};


struct Param
{
    enum { INT=0, BOOLEAN=1, REAL=2, STRING=3, MAT=4, MAT_VECTOR=5, ALGORITHM=6, FLOAT=7, UNSIGNED_INT=8, UINT64=9, SHORT=10, UCHAR=11 };

    Param();
    Param(int _type, bool _readonly, int _offset,
          Algorithm::Getter _getter=0,
          Algorithm::Setter _setter=0,
          const string& _help=string());
    int type;
    int offset;
    bool readonly;
    Algorithm::Getter getter;
    Algorithm::Setter setter;
    string help;
};

template<> struct ParamType<bool>
{
    typedef bool const_param_type;
    typedef bool member_type;

    enum { type = Param::BOOLEAN };
};

template<> struct ParamType<int>
{
    typedef int const_param_type;
    typedef int member_type;

    enum { type = Param::INT };
};

template<> struct ParamType<short>
{
    typedef int const_param_type;
    typedef int member_type;

    enum { type = Param::SHORT };
};

template<> struct ParamType<double>
{
    typedef double const_param_type;
    typedef double member_type;

    enum { type = Param::REAL };
};

template<> struct ParamType<string>
{
    typedef const string& const_param_type;
    typedef string member_type;

    enum { type = Param::STRING };
};

template<> struct ParamType<Mat>
{
    typedef const Mat& const_param_type;
    typedef Mat member_type;

    enum { type = Param::MAT };
};

template<> struct ParamType<vector<Mat> >
{
    typedef const vector<Mat>& const_param_type;
    typedef vector<Mat> member_type;

    enum { type = Param::MAT_VECTOR };
};

template<> struct ParamType<Algorithm>
{
    typedef const Ptr<Algorithm>& const_param_type;
    typedef Ptr<Algorithm> member_type;

    enum { type = Param::ALGORITHM };
};

template<> struct ParamType<float>
{
    typedef float const_param_type;
    typedef float member_type;

    enum { type = Param::FLOAT };
};

template<> struct ParamType<unsigned>
{
    typedef unsigned const_param_type;
    typedef unsigned member_type;

    enum { type = Param::UNSIGNED_INT };
};

template<> struct ParamType<uint64>
{
    typedef uint64 const_param_type;
    typedef uint64 member_type;

    enum { type = Param::UINT64 };
};

template<> struct ParamType<uchar>
{
    typedef uchar const_param_type;
    typedef uchar member_type;

    enum { type = Param::UCHAR };
};
#4675 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp"
class CommandLineParser
{
    public:


      CommandLineParser(int argc, const char* const argv[], const char* key_map);


    template<typename _Tp>
    _Tp get(const std::string& name, bool space_delete=true)
    {
        if (!has(name))
        {
            return _Tp();
        }
        std::string str = getString(name);
        return analyzeValue<_Tp>(str, space_delete);
    }


    void printParams();

    protected:
    std::map<std::string, std::vector<std::string> > data;
    std::string getString(const std::string& name);

    bool has(const std::string& keys);

    template<typename _Tp>
    _Tp analyzeValue(const std::string& str, bool space_delete=false);

    template<typename _Tp>
    static _Tp getData(const std::string& str)
    {
        _Tp res = _Tp();
        std::stringstream s1(str);
        s1 >> res;
        return res;
    }

    template<typename _Tp>
     _Tp fromStringNumber(const std::string& str);

    };

template<>
bool CommandLineParser::get<bool>(const std::string& name, bool space_delete);

template<>
std::string CommandLineParser::analyzeValue<std::string>(const std::string& str, bool space_delete);

template<>
int CommandLineParser::analyzeValue<int>(const std::string& str, bool space_delete);

template<>
unsigned int CommandLineParser::analyzeValue<unsigned int>(const std::string& str, bool space_delete);

template<>
uint64 CommandLineParser::analyzeValue<uint64>(const std::string& str, bool space_delete);

template<>
float CommandLineParser::analyzeValue<float>(const std::string& str, bool space_delete);

template<>
double CommandLineParser::analyzeValue<double>(const std::string& str, bool space_delete);





class ParallelLoopBody
{
public:
    virtual ~ParallelLoopBody();
    virtual void operator() (const Range& range) const = 0;
};

 void parallel_for_(const Range& range, const ParallelLoopBody& body, double nstripes=-1.);



class Mutex
{
public:
    Mutex();
    ~Mutex();
    Mutex(const Mutex& m);
    Mutex& operator = (const Mutex& m);

    void lock();
    bool trylock();
    void unlock();

    struct Impl;
protected:
    Impl* impl;
};

class AutoLock
{
public:
    AutoLock(Mutex& m) : mutex(&m) { mutex->lock(); }
    ~AutoLock() { mutex->unlock(); }
protected:
    Mutex* mutex;
};

}



#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp" 1
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 1 3 4
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp" 2
#94 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
#148 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
#192 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;


    static const int digits10 = 0;
#213 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
    static const bool is_signed = false;



    static const bool is_integer = false;





    static const bool is_exact = false;



    static const int radix = 0;



    static const int min_exponent = 0;



    static const int min_exponent10 = 0;




    static const int max_exponent = 0;



    static const int max_exponent10 = 0;


    static const bool has_infinity = false;



    static const bool has_quiet_NaN = false;



    static const bool has_signaling_NaN = false;


    static const float_denorm_style has_denorm = denorm_absent;



    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;




    static const bool is_bounded = false;





    static const bool is_modulo = false;


    static const bool traps = false;


    static const bool tinyness_before = false;




    static const float_round_style round_style =
          round_toward_zero;
  };
#303 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp
      min() throw() { return static_cast<_Tp>(0); }


      static _Tp
      max() throw() { return static_cast<_Tp>(0); }
#324 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
      static _Tp
      epsilon() throw() { return static_cast<_Tp>(0); }


      static _Tp
      round_error() throw() { return static_cast<_Tp>(0); }


      static _Tp
      infinity() throw() { return static_cast<_Tp>(0); }



      static _Tp
      quiet_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp
      signaling_NaN() throw() { return static_cast<_Tp>(0); }




      static _Tp
      denorm_min() throw() { return static_cast<_Tp>(0); }
    };
#370 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool
      min() throw() { return false; }

      static bool
      max() throw() { return true; }





      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static bool
      epsilon() throw() { return false; }

      static bool
      round_error() throw() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool
      infinity() throw() { return false; }

      static bool
      quiet_NaN() throw() { return false; }

      static bool
      signaling_NaN() throw() { return false; }

      static bool
      denorm_min() throw() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char
      min() throw() { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }

      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }






      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static char
      epsilon() throw() { return 0; }

      static char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
      char infinity() throw() { return char(); }

      static char
      quiet_NaN() throw() { return char(); }

      static char
      signaling_NaN() throw() { return char(); }

      static char
      denorm_min() throw() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char
      min() throw() { return -127 - 1; }

      static signed char
      max() throw() { return 127; }






      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static signed char
      epsilon() throw() { return 0; }

      static signed char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      signaling_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      denorm_min() throw() { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char
      min() throw() { return 0; }

      static unsigned char
      max() throw() { return 127 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned char
      epsilon() throw() { return 0; }

      static unsigned char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char
      infinity() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      quiet_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      signaling_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      denorm_min() throw() { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }

      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }






      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static wchar_t
      epsilon() throw() { return 0; }

      static wchar_t
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t
      infinity() throw() { return wchar_t(); }

      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static wchar_t
      denorm_min() throw() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#852 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short
      min() throw() { return -32767 - 1; }

      static short
      max() throw() { return 32767; }






      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static short
      epsilon() throw() { return 0; }

      static short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static short
      infinity() throw() { return short(); }

      static short
      quiet_NaN() throw() { return short(); }

      static short
      signaling_NaN() throw() { return short(); }

      static short
      denorm_min() throw() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short
      min() throw() { return 0; }

      static unsigned short
      max() throw() { return 32767 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned short
      epsilon() throw() { return 0; }

      static unsigned short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short
      infinity() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      quiet_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      signaling_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      denorm_min() throw() { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int
      min() throw() { return -2147483647 - 1; }

      static int
      max() throw() { return 2147483647; }






      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static int
      epsilon() throw() { return 0; }

      static int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static int
      infinity() throw() { return static_cast<int>(0); }

      static int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static int
      denorm_min() throw() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int
      min() throw() { return 0; }

      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned int
      epsilon() throw() { return 0; }

      static unsigned int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      quiet_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      signaling_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      denorm_min() throw() { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long
      min() throw() { return -9223372036854775807L - 1; }

      static long
      max() throw() { return 9223372036854775807L; }






      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long
      epsilon() throw() { return 0; }

      static long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long
      infinity() throw() { return static_cast<long>(0); }

      static long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static long
      denorm_min() throw() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long
      min() throw() { return 0; }

      static unsigned long
      max() throw() { return 9223372036854775807L * 2UL + 1; }






      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long
      epsilon() throw() { return 0; }

      static unsigned long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long
      infinity() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      quiet_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      signaling_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      denorm_min() throw() { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long
      min() throw() { return -9223372036854775807LL - 1; }

      static long long
      max() throw() { return 9223372036854775807LL; }






      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long long
      epsilon() throw() { return 0; }

      static long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long
      infinity() throw() { return static_cast<long long>(0); }

      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static long long
      signaling_NaN() throw() { return static_cast<long long>(0); }

      static long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long
      min() throw() { return 0; }

      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }






      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long long
      epsilon() throw() { return 0; }

      static unsigned long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long
      infinity() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      quiet_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      signaling_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      denorm_min() throw() { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float
      min() throw() { return 1.17549435082228750797e-38F; }

      static float
      max() throw() { return 3.40282346638528859812e+38F; }






      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static float
      epsilon() throw() { return 1.19209289550781250000e-7F; }

      static float
      round_error() throw() { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;

      static float
      infinity() throw() { return __builtin_huge_valf (); }

      static float
      quiet_NaN() throw() { return __builtin_nanf (""); }

      static float
      signaling_NaN() throw() { return __builtin_nansf (""); }

      static float
      denorm_min() throw() { return 1.40129846432481707092e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double
      min() throw() { return double(2.22507385850720138309e-308L); }

      static double
      max() throw() { return double(1.79769313486231570815e+308L); }






      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static double
      epsilon() throw() { return double(2.22044604925031308085e-16L); }

      static double
      round_error() throw() { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static double
      infinity() throw() { return __builtin_huge_val(); }

      static double
      quiet_NaN() throw() { return __builtin_nan (""); }

      static double
      signaling_NaN() throw() { return __builtin_nans (""); }

      static double
      denorm_min() throw() { return double(4.94065645841246544177e-324L); }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double
      min() throw() { return 3.36210314311209350626e-4932L; }

      static long double
      max() throw() { return 1.18973149535723176502e+4932L; }






      static const int digits = 64;
      static const int digits10 = 18;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }

      static long double
      round_error() throw() { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double
      infinity() throw() { return __builtin_huge_vall (); }

      static long double
      quiet_NaN() throw() { return __builtin_nanl (""); }

      static long double
      signaling_NaN() throw() { return __builtin_nansl (""); }

      static long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };






}
#95 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp" 2






namespace cv
{

using std::cos;
using std::sin;
using std::max;
using std::min;
using std::exp;
using std::log;
using std::pow;
using std::sqrt;




template<typename _Tp> static inline _Tp saturate_cast(uchar v) { return _Tp(v); }
template<typename _Tp> static inline _Tp saturate_cast(schar v) { return _Tp(v); }
template<typename _Tp> static inline _Tp saturate_cast(ushort v) { return _Tp(v); }
template<typename _Tp> static inline _Tp saturate_cast(short v) { return _Tp(v); }
template<typename _Tp> static inline _Tp saturate_cast(unsigned v) { return _Tp(v); }
template<typename _Tp> static inline _Tp saturate_cast(int v) { return _Tp(v); }
template<typename _Tp> static inline _Tp saturate_cast(float v) { return _Tp(v); }
template<typename _Tp> static inline _Tp saturate_cast(double v) { return _Tp(v); }

template<> inline uchar saturate_cast<uchar>(schar v)
{ return (uchar)std::max((int)v, 0); }
template<> inline uchar saturate_cast<uchar>(ushort v)
{ return (uchar)std::min((unsigned)v, (unsigned)(127 * 2 + 1)); }
template<> inline uchar saturate_cast<uchar>(int v)
{ return (uchar)((unsigned)v <= (127 * 2 + 1) ? v : v > 0 ? (127 * 2 + 1) : 0); }
template<> inline uchar saturate_cast<uchar>(short v)
{ return saturate_cast<uchar>((int)v); }
template<> inline uchar saturate_cast<uchar>(unsigned v)
{ return (uchar)std::min(v, (unsigned)(127 * 2 + 1)); }
template<> inline uchar saturate_cast<uchar>(float v)
{ int iv = cvRound(v); return saturate_cast<uchar>(iv); }
template<> inline uchar saturate_cast<uchar>(double v)
{ int iv = cvRound(v); return saturate_cast<uchar>(iv); }

template<> inline schar saturate_cast<schar>(uchar v)
{ return (schar)std::min((int)v, 127); }
template<> inline schar saturate_cast<schar>(ushort v)
{ return (schar)std::min((unsigned)v, (unsigned)127); }
template<> inline schar saturate_cast<schar>(int v)
{
    return (schar)((unsigned)(v-(-127 - 1)) <= (unsigned)(127 * 2 + 1) ?
                v : v > 0 ? 127 : (-127 - 1));
}
template<> inline schar saturate_cast<schar>(short v)
{ return saturate_cast<schar>((int)v); }
template<> inline schar saturate_cast<schar>(unsigned v)
{ return (schar)std::min(v, (unsigned)127); }

template<> inline schar saturate_cast<schar>(float v)
{ int iv = cvRound(v); return saturate_cast<schar>(iv); }
template<> inline schar saturate_cast<schar>(double v)
{ int iv = cvRound(v); return saturate_cast<schar>(iv); }

template<> inline ushort saturate_cast<ushort>(schar v)
{ return (ushort)std::max((int)v, 0); }
template<> inline ushort saturate_cast<ushort>(short v)
{ return (ushort)std::max((int)v, 0); }
template<> inline ushort saturate_cast<ushort>(int v)
{ return (ushort)((unsigned)v <= (unsigned)(32767 * 2 + 1) ? v : v > 0 ? (32767 * 2 + 1) : 0); }
template<> inline ushort saturate_cast<ushort>(unsigned v)
{ return (ushort)std::min(v, (unsigned)(32767 * 2 + 1)); }
template<> inline ushort saturate_cast<ushort>(float v)
{ int iv = cvRound(v); return saturate_cast<ushort>(iv); }
template<> inline ushort saturate_cast<ushort>(double v)
{ int iv = cvRound(v); return saturate_cast<ushort>(iv); }

template<> inline short saturate_cast<short>(ushort v)
{ return (short)std::min((int)v, 32767); }
template<> inline short saturate_cast<short>(int v)
{
    return (short)((unsigned)(v - (-32767 - 1)) <= (unsigned)(32767 * 2 + 1) ?
            v : v > 0 ? 32767 : (-32767 - 1));
}
template<> inline short saturate_cast<short>(unsigned v)
{ return (short)std::min(v, (unsigned)32767); }
template<> inline short saturate_cast<short>(float v)
{ int iv = cvRound(v); return saturate_cast<short>(iv); }
template<> inline short saturate_cast<short>(double v)
{ int iv = cvRound(v); return saturate_cast<short>(iv); }

template<> inline int saturate_cast<int>(float v) { return cvRound(v); }
template<> inline int saturate_cast<int>(double v) { return cvRound(v); }


template<> inline unsigned saturate_cast<unsigned>(float v){ return cvRound(v); }
template<> inline unsigned saturate_cast<unsigned>(double v) { return cvRound(v); }

inline int fast_abs(uchar v) { return v; }
inline int fast_abs(schar v) { return std::abs((int)v); }
inline int fast_abs(ushort v) { return v; }
inline int fast_abs(short v) { return std::abs((int)v); }
inline int fast_abs(int v) { return std::abs(v); }
inline float fast_abs(float v) { return std::abs(v); }
inline double fast_abs(double v) { return std::abs(v); }




template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx()
{
    for(int i = 0; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0)
{
    val[0] = v0;
    for(int i = 1; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1)
{
    ((channels >= 2) ? static_cast<void> (0) : __assert_fail ("channels >= 2", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 217, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1;
    for(int i = 2; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2)
{
    ((channels >= 3) ? static_cast<void> (0) : __assert_fail ("channels >= 3", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 224, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2;
    for(int i = 3; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
{
    ((channels >= 4) ? static_cast<void> (0) : __assert_fail ("channels >= 4", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 231, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    for(int i = 4; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
{
    ((channels >= 5) ? static_cast<void> (0) : __assert_fail ("channels >= 5", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 238, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3; val[4] = v4;
    for(int i = 5; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5)
{
    ((channels >= 6) ? static_cast<void> (0) : __assert_fail ("channels >= 6", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 246, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5;
    for(int i = 6; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6)
{
    ((channels >= 7) ? static_cast<void> (0) : __assert_fail ("channels >= 7", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 255, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6;
    for(int i = 7; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7)
{
    ((channels >= 8) ? static_cast<void> (0) : __assert_fail ("channels >= 8", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 264, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    for(int i = 8; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                        _Tp v8)
{
    ((channels >= 9) ? static_cast<void> (0) : __assert_fail ("channels >= 9", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 274, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8;
    for(int i = 9; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                        _Tp v8, _Tp v9)
{
    ((channels >= 10) ? static_cast<void> (0) : __assert_fail ("channels >= 10", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 285, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8; val[9] = v9;
    for(int i = 10; i < channels; i++) val[i] = _Tp(0);
}


template<typename _Tp, int m, int n>
inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                            _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                            _Tp v8, _Tp v9, _Tp v10, _Tp v11)
{
    ((channels == 12) ? static_cast<void> (0) : __assert_fail ("channels == 12", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 298, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8; val[9] = v9; val[10] = v10; val[11] = v11;
}

template<typename _Tp, int m, int n>
inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                           _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                           _Tp v8, _Tp v9, _Tp v10, _Tp v11,
                           _Tp v12, _Tp v13, _Tp v14, _Tp v15)
{
    ((channels == 16) ? static_cast<void> (0) : __assert_fail ("channels == 16", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 310, __PRETTY_FUNCTION__));
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8; val[9] = v9; val[10] = v10; val[11] = v11;
    val[12] = v12; val[13] = v13; val[14] = v14; val[15] = v15;
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(const _Tp* values)
{
    for( int i = 0; i < channels; i++ ) val[i] = values[i];
}

template<typename _Tp, int m, int n> inline Matx<_Tp, m, n> Matx<_Tp, m, n>::all(_Tp alpha)
{
    Matx<_Tp, m, n> M;
    for( int i = 0; i < m*n; i++ ) M.val[i] = alpha;
    return M;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::zeros()
{
    return all(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::ones()
{
    return all(1);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::eye()
{
    Matx<_Tp,m,n> M;
    for(int i = 0; i < ((m) > (n) ? (n) : (m)); i++)
        M(i,i) = 1;
    return M;
}

template<typename _Tp, int m, int n> inline _Tp Matx<_Tp, m, n>::dot(const Matx<_Tp, m, n>& M) const
{
    _Tp s = 0;
    for( int i = 0; i < m*n; i++ ) s += val[i]*M.val[i];
    return s;
}


template<typename _Tp, int m, int n> inline double Matx<_Tp, m, n>::ddot(const Matx<_Tp, m, n>& M) const
{
    double s = 0;
    for( int i = 0; i < m*n; i++ ) s += (double)val[i]*M.val[i];
    return s;
}



template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::diag(const typename Matx<_Tp,m,n>::diag_type& d)
{
    Matx<_Tp,m,n> M;
    for(int i = 0; i < ((m) > (n) ? (n) : (m)); i++)
        M(i,i) = d(i, 0);
    return M;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::randu(_Tp a, _Tp b)
{
    Matx<_Tp,m,n> M;
    Mat matM(M, false);
    cv::randu(matM, Scalar(a), Scalar(b));
    return M;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::randn(_Tp a, _Tp b)
{
    Matx<_Tp,m,n> M;
    Mat matM(M, false);
    cv::randn(matM, Scalar(a), Scalar(b));
    return M;
}

template<typename _Tp, int m, int n> template<typename T2>
inline Matx<_Tp, m, n>::operator Matx<T2, m, n>() const
{
    Matx<T2, m, n> M;
    for( int i = 0; i < m*n; i++ ) M.val[i] = saturate_cast<T2>(val[i]);
    return M;
}


template<typename _Tp, int m, int n> template<int m1, int n1> inline
Matx<_Tp, m1, n1> Matx<_Tp, m, n>::reshape() const
{
    ;
    return (const Matx<_Tp, m1, n1>&)*this;
}


template<typename _Tp, int m, int n>
template<int m1, int n1> inline
Matx<_Tp, m1, n1> Matx<_Tp, m, n>::get_minor(int i, int j) const
{
    ;
    Matx<_Tp, m1, n1> s;
    for( int di = 0; di < m1; di++ )
        for( int dj = 0; dj < n1; dj++ )
            s(di, dj) = (*this)(i+di, j+dj);
    return s;
}


template<typename _Tp, int m, int n> inline
Matx<_Tp, 1, n> Matx<_Tp, m, n>::row(int i) const
{
    ;
    return Matx<_Tp, 1, n>(&val[i*n]);
}


template<typename _Tp, int m, int n> inline
Matx<_Tp, m, 1> Matx<_Tp, m, n>::col(int j) const
{
    ;
    Matx<_Tp, m, 1> v;
    for( int i = 0; i < m; i++ )
        v.val[i] = val[i*n + j];
    return v;
}


template<typename _Tp, int m, int n> inline
typename Matx<_Tp, m, n>::diag_type Matx<_Tp, m, n>::diag() const
{
    diag_type d;
    for( int i = 0; i < ((m) > (n) ? (n) : (m)); i++ )
        d.val[i] = val[i*n + i];
    return d;
}


template<typename _Tp, int m, int n> inline
const _Tp& Matx<_Tp, m, n>::operator ()(int i, int j) const
{
    ;
    return this->val[i*n + j];
}


template<typename _Tp, int m, int n> inline
_Tp& Matx<_Tp, m, n>::operator ()(int i, int j)
{
    ;
    return val[i*n + j];
}


template<typename _Tp, int m, int n> inline
const _Tp& Matx<_Tp, m, n>::operator ()(int i) const
{
    ;
    return val[i];
}


template<typename _Tp, int m, int n> inline
_Tp& Matx<_Tp, m, n>::operator ()(int i)
{
    ;
    return val[i];
}


template<typename _Tp1, typename _Tp2, int m, int n> static inline
Matx<_Tp1, m, n>& operator += (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] + b.val[i]);
    return a;
}


template<typename _Tp1, typename _Tp2, int m, int n> static inline
Matx<_Tp1, m, n>& operator -= (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] - b.val[i]);
    return a;
}


template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
{
    for( int i = 0; i < m*n; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] + b.val[i]);
}


template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
{
    for( int i = 0; i < m*n; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] - b.val[i]);
}


template<typename _Tp, int m, int n> template<typename _T2> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
{
    for( int i = 0; i < m*n; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
}


template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
{
    for( int i = 0; i < m*n; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] * b.val[i]);
}


template<typename _Tp, int m, int n> template<int l> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
{
    for( int i = 0; i < m; i++ )
        for( int j = 0; j < n; j++ )
        {
            _Tp s = 0;
            for( int k = 0; k < l; k++ )
                s += a(i, k) * b(k, j);
            val[i*n + j] = s;
        }
}


template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, n, m>& a, Matx_TOp)
{
    for( int i = 0; i < m; i++ )
        for( int j = 0; j < n; j++ )
            val[i*n + j] = a(j, i);
}


template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator + (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    return Matx<_Tp, m, n>(a, b, Matx_AddOp());
}


template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    return Matx<_Tp, m, n>(a, b, Matx_SubOp());
}


template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, int alpha)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
    return a;
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, float alpha)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
    return a;
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, double alpha)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
    return a;
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, -1, Matx_ScaleOp());
}


template<typename _Tp, int m, int n, int l> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)
{
    return Matx<_Tp, m, n>(a, b, Matx_MatMulOp());
}


template<typename _Tp, int m, int n> static inline
Vec<_Tp, m> operator * (const Matx<_Tp, m, n>& a, const Vec<_Tp, n>& b)
{
    Matx<_Tp, m, 1> c(a, b, Matx_MatMulOp());
    return reinterpret_cast<const Vec<_Tp, m>&>(c);
}


template<typename _Tp> static inline
Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
{
    Matx<_Tp, 2, 1> tmp = a*Vec<_Tp,2>(b.x, b.y);
    return Point_<_Tp>(tmp.val[0], tmp.val[1]);
}


template<typename _Tp> static inline
Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
{
    Matx<_Tp, 3, 1> tmp = a*Vec<_Tp,3>(b.x, b.y, b.z);
    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
}


template<typename _Tp> static inline
Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
{
    Matx<_Tp, 3, 1> tmp = a*Vec<_Tp,3>(b.x, b.y, 1);
    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
}


template<typename _Tp> static inline
Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
{
    return a*Matx<_Tp, 4, 1>(b.x, b.y, b.z, 1);
}


template<typename _Tp> static inline
Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)
{
    Matx<double, 4, 1> c(Matx<double, 4, 4>(a), b, Matx_MatMulOp());
    return reinterpret_cast<const Scalar&>(c);
}


static inline
Scalar operator * (const Matx<double, 4, 4>& a, const Scalar& b)
{
    Matx<double, 4, 1> c(a, b, Matx_MatMulOp());
    return reinterpret_cast<const Scalar&>(c);
}


template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n> Matx<_Tp, m, n>::mul(const Matx<_Tp, m, n>& a) const
{
    return Matx<_Tp, m, n>(*this, a, Matx_MulOp());
}


 int LU(float* A, size_t astep, int m, float* b, size_t bstep, int n);
 int LU(double* A, size_t astep, int m, double* b, size_t bstep, int n);
 bool Cholesky(float* A, size_t astep, int m, float* b, size_t bstep, int n);
 bool Cholesky(double* A, size_t astep, int m, double* b, size_t bstep, int n);


template<typename _Tp, int m> struct Matx_DetOp
{
    double operator ()(const Matx<_Tp, m, m>& a) const
    {
        Matx<_Tp, m, m> temp = a;
        double p = LU(temp.val, m*sizeof(_Tp), m, 0, 0, 0);
        if( p == 0 )
            return p;
        for( int i = 0; i < m; i++ )
            p *= temp(i, i);
        return 1./p;
    }
};


template<typename _Tp> struct Matx_DetOp<_Tp, 1>
{
    double operator ()(const Matx<_Tp, 1, 1>& a) const
    {
        return a(0,0);
    }
};


template<typename _Tp> struct Matx_DetOp<_Tp, 2>
{
    double operator ()(const Matx<_Tp, 2, 2>& a) const
    {
        return a(0,0)*a(1,1) - a(0,1)*a(1,0);
    }
};


template<typename _Tp> struct Matx_DetOp<_Tp, 3>
{
    double operator ()(const Matx<_Tp, 3, 3>& a) const
    {
        return a(0,0)*(a(1,1)*a(2,2) - a(2,1)*a(1,2)) -
            a(0,1)*(a(1,0)*a(2,2) - a(2,0)*a(1,2)) +
            a(0,2)*(a(1,0)*a(2,1) - a(2,0)*a(1,1));
    }
};

template<typename _Tp, int m> static inline
double determinant(const Matx<_Tp, m, m>& a)
{
    return Matx_DetOp<_Tp, m>()(a);
}


template<typename _Tp, int m, int n> static inline
double trace(const Matx<_Tp, m, n>& a)
{
    _Tp s = 0;
    for( int i = 0; i < std::min(m, n); i++ )
        s += a(i,i);
    return s;
}


template<typename _Tp, int m, int n> inline
Matx<_Tp, n, m> Matx<_Tp, m, n>::t() const
{
    return Matx<_Tp, n, m>(*this, Matx_TOp());
}


template<typename _Tp, int m> struct Matx_FastInvOp
{
    bool operator()(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const
    {
        Matx<_Tp, m, m> temp = a;


        for( int i = 0; i < m; i++ )
            b(i, i) = (_Tp)1;

        if( method == DECOMP_CHOLESKY )
            return Cholesky(temp.val, m*sizeof(_Tp), m, b.val, m*sizeof(_Tp), m);

        return LU(temp.val, m*sizeof(_Tp), m, b.val, m*sizeof(_Tp), m) != 0;
    }
};


template<typename _Tp> struct Matx_FastInvOp<_Tp, 2>
{
    bool operator()(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const
    {
        _Tp d = determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        b(1,1) = a(0,0)*d;
        b(0,0) = a(1,1)*d;
        b(0,1) = -a(0,1)*d;
        b(1,0) = -a(1,0)*d;
        return true;
    }
};


template<typename _Tp> struct Matx_FastInvOp<_Tp, 3>
{
    bool operator()(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const
    {
        _Tp d = (_Tp)determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        b(0,0) = (a(1,1) * a(2,2) - a(1,2) * a(2,1)) * d;
        b(0,1) = (a(0,2) * a(2,1) - a(0,1) * a(2,2)) * d;
        b(0,2) = (a(0,1) * a(1,2) - a(0,2) * a(1,1)) * d;

        b(1,0) = (a(1,2) * a(2,0) - a(1,0) * a(2,2)) * d;
        b(1,1) = (a(0,0) * a(2,2) - a(0,2) * a(2,0)) * d;
        b(1,2) = (a(0,2) * a(1,0) - a(0,0) * a(1,2)) * d;

        b(2,0) = (a(1,0) * a(2,1) - a(1,1) * a(2,0)) * d;
        b(2,1) = (a(0,1) * a(2,0) - a(0,0) * a(2,1)) * d;
        b(2,2) = (a(0,0) * a(1,1) - a(0,1) * a(1,0)) * d;
        return true;
    }
};


template<typename _Tp, int m, int n> inline
Matx<_Tp, n, m> Matx<_Tp, m, n>::inv(int method) const
{
    Matx<_Tp, n, m> b;
    bool ok;
    if( method == DECOMP_LU || method == DECOMP_CHOLESKY )
        ok = Matx_FastInvOp<_Tp, m>()(*this, b, method);
    else
    {
        Mat A(*this, false), B(b, false);
        ok = (invert(A, B, method) != 0);
    }
    return ok ? b : Matx<_Tp, n, m>::zeros();
}


template<typename _Tp, int m, int n> struct Matx_FastSolveOp
{
    bool operator()(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b,
                    Matx<_Tp, m, n>& x, int method) const
    {
        Matx<_Tp, m, m> temp = a;
        x = b;
        if( method == DECOMP_CHOLESKY )
            return Cholesky(temp.val, m*sizeof(_Tp), m, x.val, n*sizeof(_Tp), n);

        return LU(temp.val, m*sizeof(_Tp), m, x.val, n*sizeof(_Tp), n) != 0;
    }
};


template<typename _Tp> struct Matx_FastSolveOp<_Tp, 2, 1>
{
    bool operator()(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b,
                    Matx<_Tp, 2, 1>& x, int) const
    {
        _Tp d = determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        x(0) = (b(0)*a(1,1) - b(1)*a(0,1))*d;
        x(1) = (b(1)*a(0,0) - b(0)*a(1,0))*d;
        return true;
    }
};


template<typename _Tp> struct Matx_FastSolveOp<_Tp, 3, 1>
{
    bool operator()(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b,
                    Matx<_Tp, 3, 1>& x, int) const
    {
        _Tp d = (_Tp)determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        x(0) = d*(b(0)*(a(1,1)*a(2,2) - a(1,2)*a(2,1)) -
                a(0,1)*(b(1)*a(2,2) - a(1,2)*b(2)) +
                a(0,2)*(b(1)*a(2,1) - a(1,1)*b(2)));

        x(1) = d*(a(0,0)*(b(1)*a(2,2) - a(1,2)*b(2)) -
                b(0)*(a(1,0)*a(2,2) - a(1,2)*a(2,0)) +
                a(0,2)*(a(1,0)*b(2) - b(1)*a(2,0)));

        x(2) = d*(a(0,0)*(a(1,1)*b(2) - b(1)*a(2,1)) -
                a(0,1)*(a(1,0)*b(2) - b(1)*a(2,0)) +
                b(0)*(a(1,0)*a(2,1) - a(1,1)*a(2,0)));
        return true;
    }
};


template<typename _Tp, int m, int n> template<int l> inline
Matx<_Tp, n, l> Matx<_Tp, m, n>::solve(const Matx<_Tp, m, l>& rhs, int method) const
{
    Matx<_Tp, n, l> x;
    bool ok;
    if( method == DECOMP_LU || method == DECOMP_CHOLESKY )
        ok = Matx_FastSolveOp<_Tp, m, l>()(*this, rhs, x, method);
    else
    {
        Mat A(*this, false), B(rhs, false), X(x, false);
        ok = cv::solve(A, B, X, method);
    }

    return ok ? x : Matx<_Tp, n, l>::zeros();
}

template<typename _Tp, int m, int n> inline
Vec<_Tp, n> Matx<_Tp, m, n>::solve(const Vec<_Tp, m>& rhs, int method) const
{
    Matx<_Tp, n, 1> x = solve(reinterpret_cast<const Matx<_Tp, m, 1>&>(rhs), method);
    return reinterpret_cast<Vec<_Tp, n>&>(x);
}

template<typename _Tp, typename _AccTp> static inline
_AccTp normL2Sqr(const _Tp* a, int n)
{
    _AccTp s = 0;
    int i=0;

    for( ; i <= n - 4; i += 4 )
    {
        _AccTp v0 = a[i], v1 = a[i+1], v2 = a[i+2], v3 = a[i+3];
        s += v0*v0 + v1*v1 + v2*v2 + v3*v3;
    }

    for( ; i < n; i++ )
    {
        _AccTp v = a[i];
        s += v*v;
    }
    return s;
}


template<typename _Tp, typename _AccTp> static inline
_AccTp normL1(const _Tp* a, int n)
{
    _AccTp s = 0;
    int i = 0;

    for(; i <= n - 4; i += 4 )
    {
        s += (_AccTp)fast_abs(a[i]) + (_AccTp)fast_abs(a[i+1]) +
            (_AccTp)fast_abs(a[i+2]) + (_AccTp)fast_abs(a[i+3]);
    }

    for( ; i < n; i++ )
        s += fast_abs(a[i]);
    return s;
}


template<typename _Tp, typename _AccTp> static inline
_AccTp normInf(const _Tp* a, int n)
{
    _AccTp s = 0;
    for( int i = 0; i < n; i++ )
        s = std::max(s, (_AccTp)fast_abs(a[i]));
    return s;
}


template<typename _Tp, typename _AccTp> static inline
_AccTp normL2Sqr(const _Tp* a, const _Tp* b, int n)
{
    _AccTp s = 0;
    int i= 0;

    for(; i <= n - 4; i += 4 )
    {
        _AccTp v0 = _AccTp(a[i] - b[i]), v1 = _AccTp(a[i+1] - b[i+1]), v2 = _AccTp(a[i+2] - b[i+2]), v3 = _AccTp(a[i+3] - b[i+3]);
        s += v0*v0 + v1*v1 + v2*v2 + v3*v3;
    }

    for( ; i < n; i++ )
    {
        _AccTp v = _AccTp(a[i] - b[i]);
        s += v*v;
    }
    return s;
}

 float normL2Sqr_(const float* a, const float* b, int n);
 float normL1_(const float* a, const float* b, int n);
 int normL1_(const uchar* a, const uchar* b, int n);
 int normHamming(const uchar* a, const uchar* b, int n);
 int normHamming(const uchar* a, const uchar* b, int n, int cellSize);

template<> inline float normL2Sqr(const float* a, const float* b, int n)
{
    if( n >= 8 )
        return normL2Sqr_(a, b, n);
    float s = 0;
    for( int i = 0; i < n; i++ )
    {
        float v = a[i] - b[i];
        s += v*v;
    }
    return s;
}


template<typename _Tp, typename _AccTp> static inline
_AccTp normL1(const _Tp* a, const _Tp* b, int n)
{
    _AccTp s = 0;
    int i= 0;

    for(; i <= n - 4; i += 4 )
    {
        _AccTp v0 = _AccTp(a[i] - b[i]), v1 = _AccTp(a[i+1] - b[i+1]), v2 = _AccTp(a[i+2] - b[i+2]), v3 = _AccTp(a[i+3] - b[i+3]);
        s += std::abs(v0) + std::abs(v1) + std::abs(v2) + std::abs(v3);
    }

    for( ; i < n; i++ )
    {
        _AccTp v = _AccTp(a[i] - b[i]);
        s += std::abs(v);
    }
    return s;
}

template<> inline float normL1(const float* a, const float* b, int n)
{
    if( n >= 8 )
        return normL1_(a, b, n);
    float s = 0;
    for( int i = 0; i < n; i++ )
    {
        float v = a[i] - b[i];
        s += std::abs(v);
    }
    return s;
}

template<> inline int normL1(const uchar* a, const uchar* b, int n)
{
    return normL1_(a, b, n);
}

template<typename _Tp, typename _AccTp> static inline
_AccTp normInf(const _Tp* a, const _Tp* b, int n)
{
    _AccTp s = 0;
    for( int i = 0; i < n; i++ )
    {
        _AccTp v0 = a[i] - b[i];
        s = std::max(s, std::abs(v0));
    }
    return s;
}


template<typename _Tp, int m, int n> static inline
double norm(const Matx<_Tp, m, n>& M)
{
    return std::sqrt(normL2Sqr<_Tp, double>(M.val, m*n));
}


template<typename _Tp, int m, int n> static inline
double norm(const Matx<_Tp, m, n>& M, int normType)
{
    return normType == NORM_INF ? (double)normInf<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n) :
        normType == NORM_L1 ? (double)normL1<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n) :
        std::sqrt((double)normL2Sqr<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n));
}


template<typename _Tp, int m, int n> static inline
bool operator == (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    for( int i = 0; i < m*n; i++ )
        if( a.val[i] != b.val[i] ) return false;
    return true;
}

template<typename _Tp, int m, int n> static inline
bool operator != (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    return !(a == b);
}


template<typename _Tp, typename _T2, int m, int n> static inline
MatxCommaInitializer<_Tp, m, n> operator << (const Matx<_Tp, m, n>& mtx, _T2 val)
{
    MatxCommaInitializer<_Tp, m, n> commaInitializer((Matx<_Tp, m, n>*)&mtx);
    return (commaInitializer, val);
}

template<typename _Tp, int m, int n> inline
MatxCommaInitializer<_Tp, m, n>::MatxCommaInitializer(Matx<_Tp, m, n>* _mtx)
    : dst(_mtx), idx(0)
{}

template<typename _Tp, int m, int n> template<typename _T2> inline
MatxCommaInitializer<_Tp, m, n>& MatxCommaInitializer<_Tp, m, n>::operator , (_T2 value)
{
    ;
    dst->val[idx++] = saturate_cast<_Tp>(value);
    return *this;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n> MatxCommaInitializer<_Tp, m, n>::operator *() const
{
    ;
    return *dst;
}



template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec()
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0)
    : Matx<_Tp, cn, 1>(v0)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1)
    : Matx<_Tp, cn, 1>(v0, v1)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2)
    : Matx<_Tp, cn, 1>(v0, v1, v2)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                        _Tp v8)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7, v8)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                        _Tp v8, _Tp v9)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const _Tp* values)
    : Matx<_Tp, cn, 1>(values)
{}


template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const Vec<_Tp, cn>& m)
    : Matx<_Tp, cn, 1>(m.val)
{}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp op)
: Matx<_Tp, cn, 1>(a, b, op)
{}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp op)
: Matx<_Tp, cn, 1>(a, b, op)
{}

template<typename _Tp, int cn> template<typename _T2> inline
Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)
: Matx<_Tp, cn, 1>(a, alpha, op)
{}

template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::all(_Tp alpha)
{
    Vec v;
    for( int i = 0; i < cn; i++ ) v.val[i] = alpha;
    return v;
}

template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::mul(const Vec<_Tp, cn>& v) const
{
    Vec<_Tp, cn> w;
    for( int i = 0; i < cn; i++ ) w.val[i] = saturate_cast<_Tp>(this->val[i]*v.val[i]);
    return w;
}

template<typename _Tp> Vec<_Tp, 2> conjugate(const Vec<_Tp, 2>& v)
{
    return Vec<_Tp, 2>(v[0], -v[1]);
}

template<typename _Tp> Vec<_Tp, 4> conjugate(const Vec<_Tp, 4>& v)
{
    return Vec<_Tp, 4>(v[0], -v[1], -v[2], -v[3]);
}

template<> inline Vec<float, 2> Vec<float, 2>::conj() const
{
    return conjugate(*this);
}

template<> inline Vec<double, 2> Vec<double, 2>::conj() const
{
    return conjugate(*this);
}

template<> inline Vec<float, 4> Vec<float, 4>::conj() const
{
    return conjugate(*this);
}

template<> inline Vec<double, 4> Vec<double, 4>::conj() const
{
    return conjugate(*this);
}

template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::cross(const Vec<_Tp, cn>&) const
{
    cv::error( cv::Exception(CV_StsError, "for arbitrary-size vector there is no cross-product defined", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 1254) );
    return Vec<_Tp, cn>();
}

template<typename _Tp, int cn> template<typename T2>
inline Vec<_Tp, cn>::operator Vec<T2, cn>() const
{
    Vec<T2, cn> v;
    for( int i = 0; i < cn; i++ ) v.val[i] = saturate_cast<T2>(this->val[i]);
    return v;
}

template<typename _Tp, int cn> inline Vec<_Tp, cn>::operator CvScalar() const
{
    CvScalar s = {{0,0,0,0}};
    int i;
    for( i = 0; i < std::min(cn, 4); i++ ) s.val[i] = this->val[i];
    for( ; i < 4; i++ ) s.val[i] = 0;
    return s;
}

template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator [](int i) const
{
    ;
    return this->val[i];
}

template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator [](int i)
{
    ;
    return this->val[i];
}

template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator ()(int i) const
{
    ;
    return this->val[i];
}

template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator ()(int i)
{
    ;
    return this->val[i];
}

template<typename _Tp1, typename _Tp2, int cn> static inline Vec<_Tp1, cn>&
operator += (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
{
    for( int i = 0; i < cn; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] + b.val[i]);
    return a;
}

template<typename _Tp1, typename _Tp2, int cn> static inline Vec<_Tp1, cn>&
operator -= (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
{
    for( int i = 0; i < cn; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] - b.val[i]);
    return a;
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator + (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
{
    return Vec<_Tp, cn>(a, b, Matx_AddOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator - (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
{
    return Vec<_Tp, cn>(a, b, Matx_SubOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, int alpha)
{
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*alpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, float alpha)
{
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*alpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, double alpha)
{
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*alpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, int alpha)
{
    double ialpha = 1./alpha;
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, float alpha)
{
    float ialpha = 1.f/alpha;
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, double alpha)
{
    double ialpha = 1./alpha;
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
    return a;
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator * (const Vec<_Tp, cn>& a, int alpha)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator * (int alpha, const Vec<_Tp, cn>& a)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator * (const Vec<_Tp, cn>& a, float alpha)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator * (float alpha, const Vec<_Tp, cn>& a)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator * (const Vec<_Tp, cn>& a, double alpha)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator * (double alpha, const Vec<_Tp, cn>& a)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator / (const Vec<_Tp, cn>& a, int alpha)
{
    return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator / (const Vec<_Tp, cn>& a, float alpha)
{
    return Vec<_Tp, cn>(a, 1.f/alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator / (const Vec<_Tp, cn>& a, double alpha)
{
    return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline Vec<_Tp, cn>
operator - (const Vec<_Tp, cn>& a)
{
    Vec<_Tp,cn> t;
    for( int i = 0; i < cn; i++ ) t.val[i] = saturate_cast<_Tp>(-a.val[i]);
    return t;
}

template<typename _Tp> inline Vec<_Tp, 4> operator * (const Vec<_Tp, 4>& v1, const Vec<_Tp, 4>& v2)
{
    return Vec<_Tp, 4>(saturate_cast<_Tp>(v1[0]*v2[0] - v1[1]*v2[1] - v1[2]*v2[2] - v1[3]*v2[3]),
                       saturate_cast<_Tp>(v1[0]*v2[1] + v1[1]*v2[0] + v1[2]*v2[3] - v1[3]*v2[2]),
                       saturate_cast<_Tp>(v1[0]*v2[2] - v1[1]*v2[3] + v1[2]*v2[0] + v1[3]*v2[1]),
                       saturate_cast<_Tp>(v1[0]*v2[3] + v1[1]*v2[2] - v1[2]*v2[1] + v1[3]*v2[0]));
}

template<typename _Tp> inline Vec<_Tp, 4>& operator *= (Vec<_Tp, 4>& v1, const Vec<_Tp, 4>& v2)
{
    v1 = v1 * v2;
    return v1;
}

template<> inline Vec<float, 3> Vec<float, 3>::cross(const Vec<float, 3>& v) const
{
    return Vec<float,3>(val[1]*v.val[2] - val[2]*v.val[1],
                     val[2]*v.val[0] - val[0]*v.val[2],
                     val[0]*v.val[1] - val[1]*v.val[0]);
}

template<> inline Vec<double, 3> Vec<double, 3>::cross(const Vec<double, 3>& v) const
{
    return Vec<double,3>(val[1]*v.val[2] - val[2]*v.val[1],
                     val[2]*v.val[0] - val[0]*v.val[2],
                     val[0]*v.val[1] - val[1]*v.val[0]);
}

template<typename _Tp, int cn> inline Vec<_Tp, cn> normalize(const Vec<_Tp, cn>& v)
{
    double nv = norm(v);
    return v * (nv ? 1./nv : 0.);
}

template<typename _Tp, typename _T2, int cn> static inline
VecCommaInitializer<_Tp, cn> operator << (const Vec<_Tp, cn>& vec, _T2 val)
{
    VecCommaInitializer<_Tp, cn> commaInitializer((Vec<_Tp, cn>*)&vec);
    return (commaInitializer, val);
}

template<typename _Tp, int cn> inline
VecCommaInitializer<_Tp, cn>::VecCommaInitializer(Vec<_Tp, cn>* _vec)
    : MatxCommaInitializer<_Tp, cn, 1>(_vec)
{}

template<typename _Tp, int cn> template<typename _T2> inline
VecCommaInitializer<_Tp, cn>& VecCommaInitializer<_Tp, cn>::operator , (_T2 value)
{
    ;
    this->dst->val[this->idx++] = saturate_cast<_Tp>(value);
    return *this;
}

template<typename _Tp, int cn> inline
Vec<_Tp, cn> VecCommaInitializer<_Tp, cn>::operator *() const
{
    ;
    return *this->dst;
}



template<typename _Tp> inline Complex<_Tp>::Complex() : re(0), im(0) {}
template<typename _Tp> inline Complex<_Tp>::Complex( _Tp _re, _Tp _im ) : re(_re), im(_im) {}
template<typename _Tp> template<typename T2> inline Complex<_Tp>::operator Complex<T2>() const
{ return Complex<T2>(saturate_cast<T2>(re), saturate_cast<T2>(im)); }
template<typename _Tp> inline Complex<_Tp> Complex<_Tp>::conj() const
{ return Complex<_Tp>(re, -im); }

template<typename _Tp> static inline
bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)
{ return a.re == b.re && a.im == b.im; }

template<typename _Tp> static inline
bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)
{ return a.re != b.re || a.im != b.im; }

template<typename _Tp> static inline
Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)
{ return Complex<_Tp>( a.re + b.re, a.im + b.im ); }

template<typename _Tp> static inline
Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)
{ a.re += b.re; a.im += b.im; return a; }

template<typename _Tp> static inline
Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)
{ return Complex<_Tp>( a.re - b.re, a.im - b.im ); }

template<typename _Tp> static inline
Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)
{ a.re -= b.re; a.im -= b.im; return a; }

template<typename _Tp> static inline
Complex<_Tp> operator - (const Complex<_Tp>& a)
{ return Complex<_Tp>(-a.re, -a.im); }

template<typename _Tp> static inline
Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)
{ return Complex<_Tp>( a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re ); }

template<typename _Tp> static inline
Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)
{ return Complex<_Tp>( a.re*b, a.im*b ); }

template<typename _Tp> static inline
Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)
{ return Complex<_Tp>( a.re*b, a.im*b ); }

template<typename _Tp> static inline
Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)
{ return Complex<_Tp>( a.re + b, a.im ); }

template<typename _Tp> static inline
Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)
{ return Complex<_Tp>( a.re - b, a.im ); }

template<typename _Tp> static inline
Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)
{ return Complex<_Tp>( a.re + b, a.im ); }

template<typename _Tp> static inline
Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)
{ return Complex<_Tp>( b - a.re, -a.im ); }

template<typename _Tp> static inline
Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)
{ a.re += b; return a; }

template<typename _Tp> static inline
Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)
{ a.re -= b; return a; }

template<typename _Tp> static inline
Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)
{ a.re *= b; a.im *= b; return a; }

template<typename _Tp> static inline
double abs(const Complex<_Tp>& a)
{ return std::sqrt( (double)a.re*a.re + (double)a.im*a.im); }

template<typename _Tp> static inline
Complex<_Tp> operator / (const Complex<_Tp>& a, const Complex<_Tp>& b)
{
    double t = 1./((double)b.re*b.re + (double)b.im*b.im);
    return Complex<_Tp>( (_Tp)((a.re*b.re + a.im*b.im)*t),
                        (_Tp)((-a.re*b.im + a.im*b.re)*t) );
}

template<typename _Tp> static inline
Complex<_Tp>& operator /= (Complex<_Tp>& a, const Complex<_Tp>& b)
{
    return (a = a / b);
}

template<typename _Tp> static inline
Complex<_Tp> operator / (const Complex<_Tp>& a, _Tp b)
{
    _Tp t = (_Tp)1/b;
    return Complex<_Tp>( a.re*t, a.im*t );
}

template<typename _Tp> static inline
Complex<_Tp> operator / (_Tp b, const Complex<_Tp>& a)
{
    return Complex<_Tp>(b)/a;
}

template<typename _Tp> static inline
Complex<_Tp> operator /= (const Complex<_Tp>& a, _Tp b)
{
    _Tp t = (_Tp)1/b;
    a.re *= t; a.im *= t; return a;
}



template<typename _Tp> inline Point_<_Tp>::Point_() : x(0), y(0) {}
template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}
template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}
template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint& pt) : x((_Tp)pt.x), y((_Tp)pt.y) {}
template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint2D32f& pt)
    : x(saturate_cast<_Tp>(pt.x)), y(saturate_cast<_Tp>(pt.y)) {}
template<typename _Tp> inline Point_<_Tp>::Point_(const Size_<_Tp>& sz) : x(sz.width), y(sz.height) {}
template<typename _Tp> inline Point_<_Tp>::Point_(const Vec<_Tp,2>& v) : x(v[0]), y(v[1]) {}
template<typename _Tp> inline Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)
{ x = pt.x; y = pt.y; return *this; }

template<typename _Tp> template<typename _Tp2> inline Point_<_Tp>::operator Point_<_Tp2>() const
{ return Point_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y)); }
template<typename _Tp> inline Point_<_Tp>::operator CvPoint() const
{ return cvPoint(saturate_cast<int>(x), saturate_cast<int>(y)); }
template<typename _Tp> inline Point_<_Tp>::operator CvPoint2D32f() const
{ return cvPoint2D32f((float)x, (float)y); }
template<typename _Tp> inline Point_<_Tp>::operator Vec<_Tp, 2>() const
{ return Vec<_Tp, 2>(x, y); }

template<typename _Tp> inline _Tp Point_<_Tp>::dot(const Point_& pt) const
{ return saturate_cast<_Tp>(x*pt.x + y*pt.y); }
template<typename _Tp> inline double Point_<_Tp>::ddot(const Point_& pt) const
{ return (double)x*pt.x + (double)y*pt.y; }

template<typename _Tp> inline double Point_<_Tp>::cross(const Point_& pt) const
{ return (double)x*pt.y - (double)y*pt.x; }

template<typename _Tp> static inline Point_<_Tp>&
operator += (Point_<_Tp>& a, const Point_<_Tp>& b)
{
    a.x = saturate_cast<_Tp>(a.x + b.x);
    a.y = saturate_cast<_Tp>(a.y + b.y);
    return a;
}

template<typename _Tp> static inline Point_<_Tp>&
operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)
{
    a.x = saturate_cast<_Tp>(a.x - b.x);
    a.y = saturate_cast<_Tp>(a.y - b.y);
    return a;
}

template<typename _Tp> static inline Point_<_Tp>&
operator *= (Point_<_Tp>& a, int b)
{
    a.x = saturate_cast<_Tp>(a.x*b);
    a.y = saturate_cast<_Tp>(a.y*b);
    return a;
}

template<typename _Tp> static inline Point_<_Tp>&
operator *= (Point_<_Tp>& a, float b)
{
    a.x = saturate_cast<_Tp>(a.x*b);
    a.y = saturate_cast<_Tp>(a.y*b);
    return a;
}

template<typename _Tp> static inline Point_<_Tp>&
operator *= (Point_<_Tp>& a, double b)
{
    a.x = saturate_cast<_Tp>(a.x*b);
    a.y = saturate_cast<_Tp>(a.y*b);
    return a;
}

template<typename _Tp> static inline double norm(const Point_<_Tp>& pt)
{ return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y); }

template<typename _Tp> static inline bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)
{ return a.x == b.x && a.y == b.y; }

template<typename _Tp> static inline bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)
{ return a.x != b.x || a.y != b.y; }

template<typename _Tp> static inline Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)
{ return Point_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y) ); }

template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)
{ return Point_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y) ); }

template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a)
{ return Point_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y) ); }

template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, int b)
{ return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) ); }

template<typename _Tp> static inline Point_<_Tp> operator * (int a, const Point_<_Tp>& b)
{ return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) ); }

template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, float b)
{ return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) ); }

template<typename _Tp> static inline Point_<_Tp> operator * (float a, const Point_<_Tp>& b)
{ return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) ); }

template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, double b)
{ return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) ); }

template<typename _Tp> static inline Point_<_Tp> operator * (double a, const Point_<_Tp>& b)
{ return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) ); }



template<typename _Tp> inline Point3_<_Tp>::Point3_() : x(0), y(0), z(0) {}
template<typename _Tp> inline Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) {}
template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point3_& pt) : x(pt.x), y(pt.y), z(pt.z) {}
template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point_<_Tp>& pt) : x(pt.x), y(pt.y), z(_Tp()) {}
template<typename _Tp> inline Point3_<_Tp>::Point3_(const CvPoint3D32f& pt) :
    x(saturate_cast<_Tp>(pt.x)), y(saturate_cast<_Tp>(pt.y)), z(saturate_cast<_Tp>(pt.z)) {}
template<typename _Tp> inline Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v) : x(v[0]), y(v[1]), z(v[2]) {}

template<typename _Tp> template<typename _Tp2> inline Point3_<_Tp>::operator Point3_<_Tp2>() const
{ return Point3_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(z)); }

template<typename _Tp> inline Point3_<_Tp>::operator CvPoint3D32f() const
{ return cvPoint3D32f((float)x, (float)y, (float)z); }

template<typename _Tp> inline Point3_<_Tp>::operator Vec<_Tp, 3>() const
{ return Vec<_Tp, 3>(x, y, z); }

template<typename _Tp> inline Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)
{ x = pt.x; y = pt.y; z = pt.z; return *this; }

template<typename _Tp> inline _Tp Point3_<_Tp>::dot(const Point3_& pt) const
{ return saturate_cast<_Tp>(x*pt.x + y*pt.y + z*pt.z); }
template<typename _Tp> inline double Point3_<_Tp>::ddot(const Point3_& pt) const
{ return (double)x*pt.x + (double)y*pt.y + (double)z*pt.z; }

template<typename _Tp> inline Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const
{
    return Point3_<_Tp>(y*pt.z - z*pt.y, z*pt.x - x*pt.z, x*pt.y - y*pt.x);
}

template<typename _Tp> static inline Point3_<_Tp>&
operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    a.x = saturate_cast<_Tp>(a.x + b.x);
    a.y = saturate_cast<_Tp>(a.y + b.y);
    a.z = saturate_cast<_Tp>(a.z + b.z);
    return a;
}

template<typename _Tp> static inline Point3_<_Tp>&
operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    a.x = saturate_cast<_Tp>(a.x - b.x);
    a.y = saturate_cast<_Tp>(a.y - b.y);
    a.z = saturate_cast<_Tp>(a.z - b.z);
    return a;
}

template<typename _Tp> static inline Point3_<_Tp>&
operator *= (Point3_<_Tp>& a, int b)
{
    a.x = saturate_cast<_Tp>(a.x*b);
    a.y = saturate_cast<_Tp>(a.y*b);
    a.z = saturate_cast<_Tp>(a.z*b);
    return a;
}

template<typename _Tp> static inline Point3_<_Tp>&
operator *= (Point3_<_Tp>& a, float b)
{
    a.x = saturate_cast<_Tp>(a.x*b);
    a.y = saturate_cast<_Tp>(a.y*b);
    a.z = saturate_cast<_Tp>(a.z*b);
    return a;
}

template<typename _Tp> static inline Point3_<_Tp>&
operator *= (Point3_<_Tp>& a, double b)
{
    a.x = saturate_cast<_Tp>(a.x*b);
    a.y = saturate_cast<_Tp>(a.y*b);
    a.z = saturate_cast<_Tp>(a.z*b);
    return a;
}

template<typename _Tp> static inline double norm(const Point3_<_Tp>& pt)
{ return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y + (double)pt.z*pt.z); }

template<typename _Tp> static inline bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{ return a.x == b.x && a.y == b.y && a.z == b.z; }

template<typename _Tp> static inline bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{ return a.x != b.x || a.y != b.y || a.z != b.z; }

template<typename _Tp> static inline Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(a.x + b.x),
                      saturate_cast<_Tp>(a.y + b.y),
                      saturate_cast<_Tp>(a.z + b.z)); }

template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(a.x - b.x),
                        saturate_cast<_Tp>(a.y - b.y),
                        saturate_cast<_Tp>(a.z - b.z)); }

template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a)
{ return Point3_<_Tp>( saturate_cast<_Tp>(-a.x),
                      saturate_cast<_Tp>(-a.y),
                      saturate_cast<_Tp>(-a.z) ); }

template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b),
                      saturate_cast<_Tp>(a.y*b),
                      saturate_cast<_Tp>(a.z*b) ); }

template<typename _Tp> static inline Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(b.x*a),
                      saturate_cast<_Tp>(b.y*a),
                      saturate_cast<_Tp>(b.z*a) ); }

template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b),
                      saturate_cast<_Tp>(a.y*b),
                      saturate_cast<_Tp>(a.z*b) ); }

template<typename _Tp> static inline Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(b.x*a),
                      saturate_cast<_Tp>(b.y*a),
                      saturate_cast<_Tp>(b.z*a) ); }

template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b),
                      saturate_cast<_Tp>(a.y*b),
                      saturate_cast<_Tp>(a.z*b) ); }

template<typename _Tp> static inline Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)
{ return Point3_<_Tp>( saturate_cast<_Tp>(b.x*a),
                      saturate_cast<_Tp>(b.y*a),
                      saturate_cast<_Tp>(b.z*a) ); }



template<typename _Tp> inline Size_<_Tp>::Size_()
    : width(0), height(0) {}
template<typename _Tp> inline Size_<_Tp>::Size_(_Tp _width, _Tp _height)
    : width(_width), height(_height) {}
template<typename _Tp> inline Size_<_Tp>::Size_(const Size_& sz)
    : width(sz.width), height(sz.height) {}
template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize& sz)
    : width(saturate_cast<_Tp>(sz.width)), height(saturate_cast<_Tp>(sz.height)) {}
template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize2D32f& sz)
    : width(saturate_cast<_Tp>(sz.width)), height(saturate_cast<_Tp>(sz.height)) {}
template<typename _Tp> inline Size_<_Tp>::Size_(const Point_<_Tp>& pt) : width(pt.x), height(pt.y) {}

template<typename _Tp> template<typename _Tp2> inline Size_<_Tp>::operator Size_<_Tp2>() const
{ return Size_<_Tp2>(saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height)); }
template<typename _Tp> inline Size_<_Tp>::operator CvSize() const
{ return cvSize(saturate_cast<int>(width), saturate_cast<int>(height)); }
template<typename _Tp> inline Size_<_Tp>::operator CvSize2D32f() const
{ return cvSize2D32f((float)width, (float)height); }

template<typename _Tp> inline Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)
{ width = sz.width; height = sz.height; return *this; }
template<typename _Tp> static inline Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)
{ return Size_<_Tp>(a.width * b, a.height * b); }
template<typename _Tp> static inline Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)
{ return Size_<_Tp>(a.width + b.width, a.height + b.height); }
template<typename _Tp> static inline Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)
{ return Size_<_Tp>(a.width - b.width, a.height - b.height); }
template<typename _Tp> inline _Tp Size_<_Tp>::area() const { return width*height; }

template<typename _Tp> static inline Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)
{ a.width += b.width; a.height += b.height; return a; }
template<typename _Tp> static inline Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)
{ a.width -= b.width; a.height -= b.height; return a; }

template<typename _Tp> static inline bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)
{ return a.width == b.width && a.height == b.height; }
template<typename _Tp> static inline bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)
{ return a.width != b.width || a.height != b.height; }




template<typename _Tp> inline Rect_<_Tp>::Rect_() : x(0), y(0), width(0), height(0) {}
template<typename _Tp> inline Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) {}
template<typename _Tp> inline Rect_<_Tp>::Rect_(const Rect_<_Tp>& r) : x(r.x), y(r.y), width(r.width), height(r.height) {}
template<typename _Tp> inline Rect_<_Tp>::Rect_(const CvRect& r) : x((_Tp)r.x), y((_Tp)r.y), width((_Tp)r.width), height((_Tp)r.height) {}
template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz) :
    x(org.x), y(org.y), width(sz.width), height(sz.height) {}
template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
{
    x = std::min(pt1.x, pt2.x); y = std::min(pt1.y, pt2.y);
    width = std::max(pt1.x, pt2.x) - x; height = std::max(pt1.y, pt2.y) - y;
}
template<typename _Tp> inline Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )
{ x = r.x; y = r.y; width = r.width; height = r.height; return *this; }

template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::tl() const { return Point_<_Tp>(x,y); }
template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::br() const { return Point_<_Tp>(x+width, y+height); }

template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )
{ a.x += b.x; a.y += b.y; return a; }
template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )
{ a.x -= b.x; a.y -= b.y; return a; }

template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )
{ a.width += b.width; a.height += b.height; return a; }

template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )
{ a.width -= b.width; a.height -= b.height; return a; }

template<typename _Tp> static inline Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
{
    _Tp x1 = std::max(a.x, b.x), y1 = std::max(a.y, b.y);
    a.width = std::min(a.x + a.width, b.x + b.width) - x1;
    a.height = std::min(a.y + a.height, b.y + b.height) - y1;
    a.x = x1; a.y = y1;
    if( a.width <= 0 || a.height <= 0 )
        a = Rect();
    return a;
}

template<typename _Tp> static inline Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
{
    _Tp x1 = std::min(a.x, b.x), y1 = std::min(a.y, b.y);
    a.width = std::max(a.x + a.width, b.x + b.width) - x1;
    a.height = std::max(a.y + a.height, b.y + b.height) - y1;
    a.x = x1; a.y = y1;
    return a;
}

template<typename _Tp> inline Size_<_Tp> Rect_<_Tp>::size() const { return Size_<_Tp>(width, height); }
template<typename _Tp> inline _Tp Rect_<_Tp>::area() const { return width*height; }

template<typename _Tp> template<typename _Tp2> inline Rect_<_Tp>::operator Rect_<_Tp2>() const
{ return Rect_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y),
                     saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height)); }
template<typename _Tp> inline Rect_<_Tp>::operator CvRect() const
{ return cvRect(saturate_cast<int>(x), saturate_cast<int>(y),
                saturate_cast<int>(width), saturate_cast<int>(height)); }

template<typename _Tp> inline bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const
{ return x <= pt.x && pt.x < x + width && y <= pt.y && pt.y < y + height; }

template<typename _Tp> static inline bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
}

template<typename _Tp> static inline bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    return a.x != b.x || a.y != b.y || a.width != b.width || a.height != b.height;
}

template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)
{
    return Rect_<_Tp>( a.x + b.x, a.y + b.y, a.width, a.height );
}

template<typename _Tp> static inline Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)
{
    return Rect_<_Tp>( a.x - b.x, a.y - b.y, a.width, a.height );
}

template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)
{
    return Rect_<_Tp>( a.x, a.y, a.width + b.width, a.height + b.height );
}

template<typename _Tp> static inline Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    Rect_<_Tp> c = a;
    return c &= b;
}

template<typename _Tp> static inline Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    Rect_<_Tp> c = a;
    return c |= b;
}

template<typename _Tp> inline bool Point_<_Tp>::inside( const Rect_<_Tp>& r ) const
{
    return r.contains(*this);
}

inline RotatedRect::RotatedRect() { angle = 0; }
inline RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)
    : center(_center), size(_size), angle(_angle) {}
inline RotatedRect::RotatedRect(const CvBox2D& box)
    : center(box.center), size(box.size), angle(box.angle) {}
inline RotatedRect::operator CvBox2D() const
{
    CvBox2D box; box.center = center; box.size = size; box.angle = angle;
    return box;
}



template<typename _Tp> inline Scalar_<_Tp>::Scalar_()
{ this->val[0] = this->val[1] = this->val[2] = this->val[3] = 0; }

template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
{ this->val[0] = v0; this->val[1] = v1; this->val[2] = v2; this->val[3] = v3; }

template<typename _Tp> inline Scalar_<_Tp>::Scalar_(const CvScalar& s)
{
    this->val[0] = saturate_cast<_Tp>(s.val[0]);
    this->val[1] = saturate_cast<_Tp>(s.val[1]);
    this->val[2] = saturate_cast<_Tp>(s.val[2]);
    this->val[3] = saturate_cast<_Tp>(s.val[3]);
}

template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0)
{ this->val[0] = v0; this->val[1] = this->val[2] = this->val[3] = 0; }

template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)
{ return Scalar_<_Tp>(v0, v0, v0, v0); }
template<typename _Tp> inline Scalar_<_Tp>::operator CvScalar() const
{ return cvScalar(this->val[0], this->val[1], this->val[2], this->val[3]); }

template<typename _Tp> template<typename T2> inline Scalar_<_Tp>::operator Scalar_<T2>() const
{
    return Scalar_<T2>(saturate_cast<T2>(this->val[0]),
                  saturate_cast<T2>(this->val[1]),
                  saturate_cast<T2>(this->val[2]),
                  saturate_cast<T2>(this->val[3]));
}

template<typename _Tp> static inline Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a.val[0] = saturate_cast<_Tp>(a.val[0] + b.val[0]);
    a.val[1] = saturate_cast<_Tp>(a.val[1] + b.val[1]);
    a.val[2] = saturate_cast<_Tp>(a.val[2] + b.val[2]);
    a.val[3] = saturate_cast<_Tp>(a.val[3] + b.val[3]);
    return a;
}

template<typename _Tp> static inline Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a.val[0] = saturate_cast<_Tp>(a.val[0] - b.val[0]);
    a.val[1] = saturate_cast<_Tp>(a.val[1] - b.val[1]);
    a.val[2] = saturate_cast<_Tp>(a.val[2] - b.val[2]);
    a.val[3] = saturate_cast<_Tp>(a.val[3] - b.val[3]);
    return a;
}

template<typename _Tp> static inline Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )
{
    a.val[0] = saturate_cast<_Tp>(a.val[0] * v);
    a.val[1] = saturate_cast<_Tp>(a.val[1] * v);
    a.val[2] = saturate_cast<_Tp>(a.val[2] * v);
    a.val[3] = saturate_cast<_Tp>(a.val[3] * v);
    return a;
}

template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& t, double scale ) const
{
    return Scalar_<_Tp>( saturate_cast<_Tp>(this->val[0]*t.val[0]*scale),
                       saturate_cast<_Tp>(this->val[1]*t.val[1]*scale),
                       saturate_cast<_Tp>(this->val[2]*t.val[2]*scale),
                       saturate_cast<_Tp>(this->val[3]*t.val[3]*scale));
}

template<typename _Tp> static inline bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
{
    return a.val[0] == b.val[0] && a.val[1] == b.val[1] &&
        a.val[2] == b.val[2] && a.val[3] == b.val[3];
}

template<typename _Tp> static inline bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
{
    return a.val[0] != b.val[0] || a.val[1] != b.val[1] ||
        a.val[2] != b.val[2] || a.val[3] != b.val[3];
}

template<typename _Tp> static inline Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] + b.val[0]),
                      saturate_cast<_Tp>(a.val[1] + b.val[1]),
                      saturate_cast<_Tp>(a.val[2] + b.val[2]),
                      saturate_cast<_Tp>(a.val[3] + b.val[3]));
}

template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] - b.val[0]),
                      saturate_cast<_Tp>(a.val[1] - b.val[1]),
                      saturate_cast<_Tp>(a.val[2] - b.val[2]),
                      saturate_cast<_Tp>(a.val[3] - b.val[3]));
}

template<typename _Tp> static inline Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] * alpha),
                      saturate_cast<_Tp>(a.val[1] * alpha),
                      saturate_cast<_Tp>(a.val[2] * alpha),
                      saturate_cast<_Tp>(a.val[3] * alpha));
}

template<typename _Tp> static inline Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)
{
    return a*alpha;
}

template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(-a.val[0]), saturate_cast<_Tp>(-a.val[1]),
                      saturate_cast<_Tp>(-a.val[2]), saturate_cast<_Tp>(-a.val[3]));
}


template<typename _Tp> static inline Scalar_<_Tp>
operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3]),
                        saturate_cast<_Tp>(a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2]),
                        saturate_cast<_Tp>(a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1]),
                        saturate_cast<_Tp>(a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]));
}

template<typename _Tp> static inline Scalar_<_Tp>&
operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a = a*b;
    return a;
}

template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::conj() const
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(this->val[0]),
                        saturate_cast<_Tp>(-this->val[1]),
                        saturate_cast<_Tp>(-this->val[2]),
                        saturate_cast<_Tp>(-this->val[3]));
}

template<typename _Tp> inline bool Scalar_<_Tp>::isReal() const
{
    return this->val[1] == 0 && this->val[2] == 0 && this->val[3] == 0;
}

template<typename _Tp> static inline
Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, _Tp alpha)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] / alpha),
                        saturate_cast<_Tp>(a.val[1] / alpha),
                        saturate_cast<_Tp>(a.val[2] / alpha),
                        saturate_cast<_Tp>(a.val[3] / alpha));
}

template<typename _Tp> static inline
Scalar_<float> operator / (const Scalar_<float>& a, float alpha)
{
    float s = 1/alpha;
    return Scalar_<float>(a.val[0]*s, a.val[1]*s, a.val[2]*s, a.val[3]*s);
}

template<typename _Tp> static inline
Scalar_<double> operator / (const Scalar_<double>& a, double alpha)
{
    double s = 1/alpha;
    return Scalar_<double>(a.val[0]*s, a.val[1]*s, a.val[2]*s, a.val[3]*s);
}

template<typename _Tp> static inline
Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, _Tp alpha)
{
    a = a/alpha;
    return a;
}

template<typename _Tp> static inline
Scalar_<_Tp> operator / (_Tp a, const Scalar_<_Tp>& b)
{
    _Tp s = a/(b[0]*b[0] + b[1]*b[1] + b[2]*b[2] + b[3]*b[3]);
    return b.conj()*s;
}

template<typename _Tp> static inline
Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return a*((_Tp)1/b);
}

template<typename _Tp> static inline
Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a = a/b;
    return a;
}



inline Range::Range() : start(0), end(0) {}
inline Range::Range(int _start, int _end) : start(_start), end(_end) {}
inline Range::Range(const CvSlice& slice) : start(slice.start_index), end(slice.end_index)
{
    if( start == 0 && end == 0x3fffffff )
        *this = Range::all();
}

inline int Range::size() const { return end - start; }
inline bool Range::empty() const { return start == end; }
inline Range Range::all() { return Range((-2147483647 - 1), 2147483647); }

static inline bool operator == (const Range& r1, const Range& r2)
{ return r1.start == r2.start && r1.end == r2.end; }

static inline bool operator != (const Range& r1, const Range& r2)
{ return !(r1 == r2); }

static inline bool operator !(const Range& r)
{ return r.start == r.end; }

static inline Range operator & (const Range& r1, const Range& r2)
{
    Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end));
    r.end = std::max(r.end, r.start);
    return r;
}

static inline Range& operator &= (Range& r1, const Range& r2)
{
    r1 = r1 & r2;
    return r1;
}

static inline Range operator + (const Range& r1, int delta)
{
    return Range(r1.start + delta, r1.end + delta);
}

static inline Range operator + (int delta, const Range& r1)
{
    return Range(r1.start + delta, r1.end + delta);
}

static inline Range operator - (const Range& r1, int delta)
{
    return r1 + (-delta);
}

inline Range::operator CvSlice() const
{ return *this != Range::all() ? cvSlice(start, end) : cvSlice(0, 0x3fffffff); }
#2268 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp"
template <typename _Tp> class Vector
{
public:
    typedef _Tp value_type;
    typedef _Tp* iterator;
    typedef const _Tp* const_iterator;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;

    struct Hdr
    {
        Hdr() : data(0), datastart(0), refcount(0), size(0), capacity(0) {};
        _Tp* data;
        _Tp* datastart;
        int* refcount;
        size_t size;
        size_t capacity;
    };

    Vector() {}
    Vector(size_t _size) { resize(_size); }
    Vector(size_t _size, const _Tp& val)
    {
        resize(_size);
        for(size_t i = 0; i < _size; i++)
            hdr.data[i] = val;
    }
    Vector(_Tp* _data, size_t _size, bool _copyData=false)
    { set(_data, _size, _copyData); }

    template<int n> Vector(const Vec<_Tp, n>& vec)
    { set((_Tp*)&vec.val[0], n, true); }

    Vector(const std::vector<_Tp>& vec, bool _copyData=false)
    { set(!vec.empty() ? (_Tp*)&vec[0] : 0, vec.size(), _copyData); }

    Vector(const Vector& d) { *this = d; }

    Vector(const Vector& d, const Range& r_)
    {
        Range r = r_ == Range::all() ? Range(0, d.size()) : r_;


        if( r.size() > 0 && r.start >= 0 && r.end <= d.size() )
        {
            if( d.hdr.refcount )
                __sync_fetch_and_add(d.hdr.refcount, 1);
            hdr.refcount = d.hdr.refcount;
            hdr.datastart = d.hdr.datastart;
            hdr.data = d.hdr.data + r.start;
            hdr.capacity = hdr.size = r.size();
        }
    }

    Vector<_Tp>& operator = (const Vector& d)
    {
        if( this != &d )
        {
            if( d.hdr.refcount )
                __sync_fetch_and_add(d.hdr.refcount, 1);
            release();
            hdr = d.hdr;
        }
        return *this;
    }

    ~Vector() { release(); }

    Vector<_Tp> clone() const
    { return hdr.data ? Vector<_Tp>(hdr.data, hdr.size, true) : Vector<_Tp>(); }

    void copyTo(Vector<_Tp>& vec) const
    {
        size_t i, sz = size();
        vec.resize(sz);
        const _Tp* src = hdr.data;
        _Tp* dst = vec.hdr.data;
        for( i = 0; i < sz; i++ )
            dst[i] = src[i];
    }

    void copyTo(std::vector<_Tp>& vec) const
    {
        size_t i, sz = size();
        vec.resize(sz);
        const _Tp* src = hdr.data;
        _Tp* dst = sz ? &vec[0] : 0;
        for( i = 0; i < sz; i++ )
            dst[i] = src[i];
    }

    operator CvMat() const
    { return cvMat((int)size(), 1, type(), (void*)hdr.data); }

    _Tp& operator [] (size_t i) { ; return hdr.data[i]; }
    const _Tp& operator [] (size_t i) const { ; return hdr.data[i]; }
    Vector operator() (const Range& r) const { return Vector(*this, r); }
    _Tp& back() { ; return hdr.data[hdr.size-1]; }
    const _Tp& back() const { ; return hdr.data[hdr.size-1]; }
    _Tp& front() { ; return hdr.data[0]; }
    const _Tp& front() const { ; return hdr.data[0]; }

    _Tp* begin() { return hdr.data; }
    _Tp* end() { return hdr.data + hdr.size; }
    const _Tp* begin() const { return hdr.data; }
    const _Tp* end() const { return hdr.data + hdr.size; }

    void addref() { if( hdr.refcount ) __sync_fetch_and_add(hdr.refcount, 1); }
    void release()
    {
        if( hdr.refcount && __sync_fetch_and_add(hdr.refcount, -1) == 1 )
        {
            delete[] hdr.datastart;
            delete hdr.refcount;
        }
        hdr = Hdr();
    }

    void set(_Tp* _data, size_t _size, bool _copyData=false)
    {
        if( !_copyData )
        {
            release();
            hdr.data = hdr.datastart = _data;
            hdr.size = hdr.capacity = _size;
            hdr.refcount = 0;
        }
        else
        {
            reserve(_size);
            for( size_t i = 0; i < _size; i++ )
                hdr.data[i] = _data[i];
            hdr.size = _size;
        }
    }

    void reserve(size_t newCapacity)
    {
        _Tp* newData;
        int* newRefcount;
        size_t i, oldSize = hdr.size;
        if( (!hdr.refcount || *hdr.refcount == 1) && hdr.capacity >= newCapacity )
            return;
        newCapacity = std::max(newCapacity, oldSize);
        newData = new _Tp[newCapacity];
        newRefcount = new int(1);
        for( i = 0; i < oldSize; i++ )
            newData[i] = hdr.data[i];
        release();
        hdr.data = hdr.datastart = newData;
        hdr.capacity = newCapacity;
        hdr.size = oldSize;
        hdr.refcount = newRefcount;
    }

    void resize(size_t newSize)
    {
        size_t i;
        newSize = std::max(newSize, (size_t)0);
        if( (!hdr.refcount || *hdr.refcount == 1) && hdr.size == newSize )
            return;
        if( newSize > hdr.capacity )
            reserve(std::max(newSize, std::max((size_t)4, hdr.capacity*2)));
        for( i = hdr.size; i < newSize; i++ )
            hdr.data[i] = _Tp();
        hdr.size = newSize;
    }

    Vector<_Tp>& push_back(const _Tp& elem)
    {
        if( hdr.size == hdr.capacity )
            reserve( std::max((size_t)4, hdr.capacity*2) );
        hdr.data[hdr.size++] = elem;
        return *this;
    }

    Vector<_Tp>& pop_back()
    {
        if( hdr.size > 0 )
            --hdr.size;
        return *this;
    }

    size_t size() const { return hdr.size; }
    size_t capacity() const { return hdr.capacity; }
    bool empty() const { return hdr.size == 0; }
    void clear() { resize(0); }
    int type() const { return DataType<_Tp>::type; }

protected:
    Hdr hdr;
};


template<typename _Tp> inline typename DataType<_Tp>::work_type
dot(const Vector<_Tp>& v1, const Vector<_Tp>& v2)
{
    typedef typename DataType<_Tp>::work_type _Tw;
    size_t i = 0, n = v1.size();
    ((v1.size() == v2.size()) ? static_cast<void> (0) : __assert_fail ("v1.size() == v2.size()", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 2467, __PRETTY_FUNCTION__));

    _Tw s = 0;
    const _Tp *ptr1 = &v1[0], *ptr2 = &v2[0];
    for( ; i < n; i++ )
        s += (_Tw)ptr1[i]*ptr2[i];

    return s;
}


inline RNG::RNG() { state = 0xffffffff; }
inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }
inline unsigned RNG::next()
{
    state = (uint64)(unsigned)state*4164903690U + (unsigned)(state >> 32);
    return (unsigned)state;
}

inline RNG::operator uchar() { return (uchar)next(); }
inline RNG::operator schar() { return (schar)next(); }
inline RNG::operator ushort() { return (ushort)next(); }
inline RNG::operator short() { return (short)next(); }
inline RNG::operator unsigned() { return next(); }
inline unsigned RNG::operator ()(unsigned N) {return (unsigned)uniform(0,N);}
inline unsigned RNG::operator ()() {return next();}
inline RNG::operator int() { return (int)next(); }

inline RNG::operator float() { return next()*2.3283064365386962890625e-10f; }
inline RNG::operator double()
{
    unsigned t = next();
    return (((uint64)t << 32) | next())*5.4210108624275221700372640043497e-20;
}
inline int RNG::uniform(int a, int b) { return a == b ? a : (int)(next()%(b - a) + a); }
inline float RNG::uniform(float a, float b) { return ((float)*this)*(b - a) + a; }
inline double RNG::uniform(double a, double b) { return ((double)*this)*(b - a) + a; }

inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon(0) {}
inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)
    : type(_type), maxCount(_maxCount), epsilon(_epsilon) {}
inline TermCriteria::TermCriteria(const CvTermCriteria& criteria)
    : type(criteria.type), maxCount(criteria.max_iter), epsilon(criteria.epsilon) {}
inline TermCriteria::operator CvTermCriteria() const
{ return cvTermCriteria(type, maxCount, epsilon); }

inline uchar* LineIterator::operator *() { return ptr; }
inline LineIterator& LineIterator::operator ++()
{
    int mask = err < 0 ? -1 : 0;
    err += minusDelta + (plusDelta & mask);
    ptr += minusStep + (plusStep & mask);
    return *this;
}
inline LineIterator LineIterator::operator ++(int)
{
    LineIterator it = *this;
    ++(*this);
    return it;
}
inline Point LineIterator::pos() const
{
    Point p;
    p.y = (int)((ptr - ptr0)/step);
    p.x = (int)(((ptr - ptr0) - p.y*step)/elemSize);
    return p;
}



template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer()
{
    ptr = buf;
    size = fixed_size;
}

template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer(size_t _size)
{
    ptr = buf;
    size = fixed_size;
    allocate(_size);
}

template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::~AutoBuffer()
{ deallocate(); }

template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::allocate(size_t _size)
{
    if(_size <= size)
        return;
    deallocate();
    if(_size > fixed_size)
    {
        ptr = cv::allocate<_Tp>(_size);
        size = _size;
    }
}

template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::deallocate()
{
    if( ptr != buf )
    {
        cv::deallocate<_Tp>(ptr, size);
        ptr = buf;
        size = fixed_size;
    }
}

template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator _Tp* ()
{ return ptr; }

template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator const _Tp* () const
{ return ptr; }




template<typename _Tp> inline Ptr<_Tp>::Ptr() : obj(0), refcount(0) {}
template<typename _Tp> inline Ptr<_Tp>::Ptr(_Tp* _obj) : obj(_obj)
{
    if(obj)
    {
        refcount = (int*)fastMalloc(sizeof(*refcount));
        *refcount = 1;
    }
    else
        refcount = 0;
}

template<typename _Tp> inline void Ptr<_Tp>::addref()
{ if( refcount ) __sync_fetch_and_add(refcount, 1); }

template<typename _Tp> inline void Ptr<_Tp>::release()
{
    if( refcount && __sync_fetch_and_add(refcount, -1) == 1 )
    {
        delete_obj();
        fastFree(refcount);
    }
    refcount = 0;
    obj = 0;
}

template<typename _Tp> inline void Ptr<_Tp>::delete_obj()
{
    if( obj ) delete obj;
}

template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }

template<typename _Tp> inline Ptr<_Tp>::Ptr(const Ptr<_Tp>& _ptr)
{
    obj = _ptr.obj;
    refcount = _ptr.refcount;
    addref();
}

template<typename _Tp> inline Ptr<_Tp>& Ptr<_Tp>::operator = (const Ptr<_Tp>& _ptr)
{
    int* _refcount = _ptr.refcount;
    if( _refcount )
        __sync_fetch_and_add(_refcount, 1);
    release();
    obj = _ptr.obj;
    refcount = _refcount;
    return *this;
}

template<typename _Tp> inline _Tp* Ptr<_Tp>::operator -> () { return obj; }
template<typename _Tp> inline const _Tp* Ptr<_Tp>::operator -> () const { return obj; }

template<typename _Tp> inline Ptr<_Tp>::operator _Tp* () { return obj; }
template<typename _Tp> inline Ptr<_Tp>::operator const _Tp*() const { return obj; }

template<typename _Tp> inline bool Ptr<_Tp>::empty() const { return obj == 0; }

template<typename _Tp> template<typename _Tp2> Ptr<_Tp>::Ptr(const Ptr<_Tp2>& p)
    : obj(0), refcount(0)
{
    if (p.empty())
        return;

    _Tp* p_casted = dynamic_cast<_Tp*>(p.obj);
    if (!p_casted)
        return;

    obj = p_casted;
    refcount = p.refcount;
    addref();
}

template<typename _Tp> template<typename _Tp2> inline Ptr<_Tp2> Ptr<_Tp>::ptr()
{
    Ptr<_Tp2> p;
    if( !obj )
        return p;

    _Tp2* obj_casted = dynamic_cast<_Tp2*>(obj);
    if (!obj_casted)
        return p;

    if( refcount )
        __sync_fetch_and_add(refcount, 1);

    p.obj = obj_casted;
    p.refcount = refcount;
    return p;
}

template<typename _Tp> template<typename _Tp2> inline const Ptr<_Tp2> Ptr<_Tp>::ptr() const
{
    Ptr<_Tp2> p;
    if( !obj )
        return p;

    _Tp2* obj_casted = dynamic_cast<_Tp2*>(obj);
    if (!obj_casted)
        return p;

    if( refcount )
        __sync_fetch_and_add(refcount, 1);

    p.obj = obj_casted;
    p.refcount = refcount;
    return p;
}



template<> void Ptr<CvMat>::delete_obj();
template<> void Ptr<IplImage>::delete_obj();
template<> void Ptr<CvMatND>::delete_obj();
template<> void Ptr<CvSparseMat>::delete_obj();
template<> void Ptr<CvMemStorage>::delete_obj();
template<> void Ptr<CvFileStorage>::delete_obj();



 void write( FileStorage& fs, const string& name, int value );
 void write( FileStorage& fs, const string& name, float value );
 void write( FileStorage& fs, const string& name, double value );
 void write( FileStorage& fs, const string& name, const string& value );

template<typename _Tp> inline void write(FileStorage& fs, const _Tp& value)
{ write(fs, string(), value); }

 void writeScalar( FileStorage& fs, int value );
 void writeScalar( FileStorage& fs, float value );
 void writeScalar( FileStorage& fs, double value );
 void writeScalar( FileStorage& fs, const string& value );

template<> inline void write( FileStorage& fs, const int& value )
{
    writeScalar(fs, value);
}

template<> inline void write( FileStorage& fs, const float& value )
{
    writeScalar(fs, value);
}

template<> inline void write( FileStorage& fs, const double& value )
{
    writeScalar(fs, value);
}

template<> inline void write( FileStorage& fs, const string& value )
{
    writeScalar(fs, value);
}

template<typename _Tp> inline void write(FileStorage& fs, const Point_<_Tp>& pt )
{
    write(fs, pt.x);
    write(fs, pt.y);
}

template<typename _Tp> inline void write(FileStorage& fs, const Point3_<_Tp>& pt )
{
    write(fs, pt.x);
    write(fs, pt.y);
    write(fs, pt.z);
}

template<typename _Tp> inline void write(FileStorage& fs, const Size_<_Tp>& sz )
{
    write(fs, sz.width);
    write(fs, sz.height);
}

template<typename _Tp> inline void write(FileStorage& fs, const Complex<_Tp>& c )
{
    write(fs, c.re);
    write(fs, c.im);
}

template<typename _Tp> inline void write(FileStorage& fs, const Rect_<_Tp>& r )
{
    write(fs, r.x);
    write(fs, r.y);
    write(fs, r.width);
    write(fs, r.height);
}

template<typename _Tp, int cn> inline void write(FileStorage& fs, const Vec<_Tp, cn>& v )
{
    for(int i = 0; i < cn; i++)
        write(fs, v.val[i]);
}

template<typename _Tp> inline void write(FileStorage& fs, const Scalar_<_Tp>& s )
{
    write(fs, s.val[0]);
    write(fs, s.val[1]);
    write(fs, s.val[2]);
    write(fs, s.val[3]);
}

inline void write(FileStorage& fs, const Range& r )
{
    write(fs, r.start);
    write(fs, r.end);
}

class WriteStructContext
{
public:
    WriteStructContext(FileStorage& _fs, const string& name,
        int flags, const string& typeName=string());
    ~WriteStructContext();
    FileStorage* fs;
};

template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point_<_Tp>& pt )
{
    WriteStructContext ws(fs, name, 5 +8);
    write(fs, pt.x);
    write(fs, pt.y);
}

template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )
{
    WriteStructContext ws(fs, name, 5 +8);
    write(fs, pt.x);
    write(fs, pt.y);
    write(fs, pt.z);
}

template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Size_<_Tp>& sz )
{
    WriteStructContext ws(fs, name, 5 +8);
    write(fs, sz.width);
    write(fs, sz.height);
}

template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Complex<_Tp>& c )
{
    WriteStructContext ws(fs, name, 5 +8);
    write(fs, c.re);
    write(fs, c.im);
}

template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Rect_<_Tp>& r )
{
    WriteStructContext ws(fs, name, 5 +8);
    write(fs, r.x);
    write(fs, r.y);
    write(fs, r.width);
    write(fs, r.height);
}

template<typename _Tp, int cn> inline void write(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )
{
    WriteStructContext ws(fs, name, 5 +8);
    for(int i = 0; i < cn; i++)
        write(fs, v.val[i]);
}

template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )
{
    WriteStructContext ws(fs, name, 5 +8);
    write(fs, s.val[0]);
    write(fs, s.val[1]);
    write(fs, s.val[2]);
    write(fs, s.val[3]);
}

inline void write(FileStorage& fs, const string& name, const Range& r )
{
    WriteStructContext ws(fs, name, 5 +8);
    write(fs, r.start);
    write(fs, r.end);
}

template<typename _Tp, int numflag> class VecWriterProxy
{
public:
    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}
    void operator()(const vector<_Tp>& vec) const
    {
        size_t i, count = vec.size();
        for( i = 0; i < count; i++ )
            write( *fs, vec[i] );
    }
    FileStorage* fs;
};

template<typename _Tp> class VecWriterProxy<_Tp,1>
{
public:
    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}
    void operator()(const vector<_Tp>& vec) const
    {
        int _fmt = DataType<_Tp>::fmt;
        char fmt[] = { (char)((_fmt>>8)+'1'), (char)_fmt, '\0' };
        fs->writeRaw( string(fmt), !vec.empty() ? (uchar*)&vec[0] : 0, vec.size()*sizeof(_Tp) );
    }
    FileStorage* fs;
};

template<typename _Tp> static inline void write( FileStorage& fs, const vector<_Tp>& vec )
{
    VecWriterProxy<_Tp, DataType<_Tp>::fmt != 0> w(&fs);
    w(vec);
}

template<typename _Tp> static inline void write( FileStorage& fs, const string& name,
                                                const vector<_Tp>& vec )
{
    WriteStructContext ws(fs, name, 5 +(DataType<_Tp>::fmt != 0 ? 8 : 0));
    write(fs, vec);
}

 void write( FileStorage& fs, const string& name, const Mat& value );
 void write( FileStorage& fs, const string& name, const SparseMat& value );

template<typename _Tp> static inline FileStorage& operator << (FileStorage& fs, const _Tp& value)
{
    if( !fs.isOpened() )
        return fs;
    if( fs.state == FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP )
        cv::error( cv::Exception(CV_StsError, "No element name has been given", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 2908) );
    write( fs, fs.elname, value );
    if( fs.state & FileStorage::INSIDE_MAP )
        fs.state = FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP;
    return fs;
}

 FileStorage& operator << (FileStorage& fs, const string& str);

static inline FileStorage& operator << (FileStorage& fs, const char* str)
{ return (fs << string(str)); }

static inline FileStorage& operator << (FileStorage& fs, char* value)
{ return (fs << string(value)); }

inline FileNode::FileNode() : fs(0), node(0) {}
inline FileNode::FileNode(const CvFileStorage* _fs, const CvFileNode* _node)
    : fs(_fs), node(_node) {}

inline FileNode::FileNode(const FileNode& _node) : fs(_node.fs), node(_node.node) {}

inline int FileNode::type() const { return !node ? NONE : (node->tag & TYPE_MASK); }
inline bool FileNode::empty() const { return node == 0; }
inline bool FileNode::isNone() const { return type() == NONE; }
inline bool FileNode::isSeq() const { return type() == SEQ; }
inline bool FileNode::isMap() const { return type() == MAP; }
inline bool FileNode::isInt() const { return type() == INT; }
inline bool FileNode::isReal() const { return type() == REAL; }
inline bool FileNode::isString() const { return type() == STR; }
inline bool FileNode::isNamed() const { return !node ? false : (node->tag & NAMED) != 0; }
inline size_t FileNode::size() const
{
    int t = type();
    return t == MAP ? (size_t)((CvSet*)node->data.map)->active_count :
        t == SEQ ? (size_t)node->data.seq->total : (size_t)!isNone();
}

inline CvFileNode* FileNode::operator *() { return (CvFileNode*)node; }
inline const CvFileNode* FileNode::operator* () const { return node; }

static inline void read(const FileNode& node, int& value, int default_value)
{
    value = !node.node ? default_value :
    (((node.node->tag) & 7) == 1) ? node.node->data.i :
    (((node.node->tag) & 7) == 2) ? cvRound(node.node->data.f) : 0x7fffffff;
}

static inline void read(const FileNode& node, bool& value, bool default_value)
{
    int temp; read(node, temp, (int)default_value);
    value = temp != 0;
}

static inline void read(const FileNode& node, uchar& value, uchar default_value)
{
    int temp; read(node, temp, (int)default_value);
    value = saturate_cast<uchar>(temp);
}

static inline void read(const FileNode& node, schar& value, schar default_value)
{
    int temp; read(node, temp, (int)default_value);
    value = saturate_cast<schar>(temp);
}

static inline void read(const FileNode& node, ushort& value, ushort default_value)
{
    int temp; read(node, temp, (int)default_value);
    value = saturate_cast<ushort>(temp);
}

static inline void read(const FileNode& node, short& value, short default_value)
{
    int temp; read(node, temp, (int)default_value);
    value = saturate_cast<short>(temp);
}

static inline void read(const FileNode& node, float& value, float default_value)
{
    value = !node.node ? default_value :
        (((node.node->tag) & 7) == 1) ? (float)node.node->data.i :
        (((node.node->tag) & 7) == 2) ? (float)node.node->data.f : 1e30f;
}

static inline void read(const FileNode& node, double& value, double default_value)
{
    value = !node.node ? default_value :
        (((node.node->tag) & 7) == 1) ? (double)node.node->data.i :
        (((node.node->tag) & 7) == 2) ? node.node->data.f : 1e300;
}

static inline void read(const FileNode& node, string& value, const string& default_value)
{
    value = !node.node ? default_value : (((node.node->tag) & 7) == 3) ? string(node.node->data.str.ptr) : string("");
}

 void read(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() );
 void read(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() );

inline FileNode::operator int() const
{
    int value;
    read(*this, value, 0);
    return value;
}
inline FileNode::operator float() const
{
    float value;
    read(*this, value, 0.f);
    return value;
}
inline FileNode::operator double() const
{
    double value;
    read(*this, value, 0.);
    return value;
}
inline FileNode::operator string() const
{
    string value;
    read(*this, value, value);
    return value;
}

inline void FileNode::readRaw( const string& fmt, uchar* vec, size_t len ) const
{
    begin().readRaw( fmt, vec, len );
}

template<typename _Tp, int numflag> class VecReaderProxy
{
public:
    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}
    void operator()(vector<_Tp>& vec, size_t count) const
    {
        count = std::min(count, it->remaining);
        vec.resize(count);
        for( size_t i = 0; i < count; i++, ++(*it) )
            read(**it, vec[i], _Tp());
    }
    FileNodeIterator* it;
};

template<typename _Tp> class VecReaderProxy<_Tp,1>
{
public:
    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}
    void operator()(vector<_Tp>& vec, size_t count) const
    {
        size_t remaining = it->remaining, cn = DataType<_Tp>::channels;
        int _fmt = DataType<_Tp>::fmt;
        char fmt[] = { (char)((_fmt>>8)+'1'), (char)_fmt, '\0' };
        size_t remaining1 = remaining/cn;
        count = count < remaining1 ? count : remaining1;
        vec.resize(count);
        it->readRaw( string(fmt), !vec.empty() ? (uchar*)&vec[0] : 0, count*sizeof(_Tp) );
    }
    FileNodeIterator* it;
};

template<typename _Tp> static inline void
read( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)2147483647 )
{
    VecReaderProxy<_Tp, DataType<_Tp>::fmt != 0> r(&it);
    r(vec, maxCount);
}

template<typename _Tp> static inline void
read( const FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )
{
    if(!node.node)
        vec = default_value;
    else
    {
        FileNodeIterator it = node.begin();
        read( it, vec );
    }
}

inline FileNodeIterator FileNode::begin() const
{
    return FileNodeIterator(fs, node);
}

inline FileNodeIterator FileNode::end() const
{
    return FileNodeIterator(fs, node, size());
}

inline FileNode FileNodeIterator::operator *() const
{ return FileNode(fs, (const CvFileNode*)reader.ptr); }

inline FileNode FileNodeIterator::operator ->() const
{ return FileNode(fs, (const CvFileNode*)reader.ptr); }

template<typename _Tp> static inline FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)
{ read( *it, value, _Tp()); return ++it; }

template<typename _Tp> static inline
FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)
{
    VecReaderProxy<_Tp, DataType<_Tp>::fmt != 0> r(&it);
    r(vec, (size_t)2147483647);
    return it;
}

template<typename _Tp> static inline void operator >> (const FileNode& n, _Tp& value)
{ read( n, value, _Tp()); }

template<typename _Tp> static inline void operator >> (const FileNode& n, vector<_Tp>& vec)
{ FileNodeIterator it = n.begin(); it >> vec; }

static inline bool operator == (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return it1.fs == it2.fs && it1.container == it2.container &&
        it1.reader.ptr == it2.reader.ptr && it1.remaining == it2.remaining;
}

static inline bool operator != (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return !(it1 == it2);
}

static inline ptrdiff_t operator - (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return it2.remaining - it1.remaining;
}

static inline bool operator < (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return it1.remaining > it2.remaining;
}

inline FileNode FileStorage::getFirstTopLevelNode() const
{
    FileNode r = root();
    FileNodeIterator it = r.begin();
    return it != r.end() ? *it : FileNode();
}



template<typename _Tp> static inline _Tp gcd(_Tp a, _Tp b)
{
    if( a < b )
        std::swap(a, b);
    while( b > 0 )
    {
        _Tp r = a % b;
        a = b;
        b = r;
    }
    return a;
}
#3203 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp"
template<typename _Tp, class _LT> void sort( vector<_Tp>& vec, _LT LT=_LT() )
{
    int isort_thresh = 7;
    int sp = 0;

    struct
    {
        _Tp *lb;
        _Tp *ub;
    } stack[48];

    size_t total = vec.size();

    if( total <= 1 )
        return;

    _Tp* arr = &vec[0];
    stack[0].lb = arr;
    stack[0].ub = arr + (total - 1);

    while( sp >= 0 )
    {
        _Tp* left = stack[sp].lb;
        _Tp* right = stack[sp--].ub;

        for(;;)
        {
            int i, n = (int)(right - left) + 1, m;
            _Tp* ptr;
            _Tp* ptr2;

            if( n <= isort_thresh )
            {
            insert_sort:
                for( ptr = left + 1; ptr <= right; ptr++ )
                {
                    for( ptr2 = ptr; ptr2 > left && LT(ptr2[0],ptr2[-1]); ptr2--)
                        std::swap( ptr2[0], ptr2[-1] );
                }
                break;
            }
            else
            {
                _Tp* left0;
                _Tp* left1;
                _Tp* right0;
                _Tp* right1;
                _Tp* pivot;
                _Tp* a;
                _Tp* b;
                _Tp* c;
                int swap_cnt = 0;

                left0 = left;
                right0 = right;
                pivot = left + (n/2);

                if( n > 40 )
                {
                    int d = n / 8;
                    a = left, b = left + d, c = left + 2*d;
                    left = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                      : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));

                    a = pivot - d, b = pivot, c = pivot + d;
                    pivot = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                      : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));

                    a = right - 2*d, b = right - d, c = right;
                    right = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                      : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));
                }

                a = left, b = pivot, c = right;
                pivot = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                   : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));
                if( pivot != left0 )
                {
                    std::swap( *pivot, *left0 );
                    pivot = left0;
                }
                left = left1 = left0 + 1;
                right = right1 = right0;

                for(;;)
                {
                    while( left <= right && !LT(*pivot, *left) )
                    {
                        if( !LT(*left, *pivot) )
                        {
                            if( left > left1 )
                                std::swap( *left1, *left );
                            swap_cnt = 1;
                            left1++;
                        }
                        left++;
                    }

                    while( left <= right && !LT(*right, *pivot) )
                    {
                        if( !LT(*pivot, *right) )
                        {
                            if( right < right1 )
                                std::swap( *right1, *right );
                            swap_cnt = 1;
                            right1--;
                        }
                        right--;
                    }

                    if( left > right )
                        break;
                    std::swap( *left, *right );
                    swap_cnt = 1;
                    left++;
                    right--;
                }

                if( swap_cnt == 0 )
                {
                    left = left0, right = right0;
                    goto insert_sort;
                }

                n = std::min( (int)(left1 - left0), (int)(left - left1) );
                for( i = 0; i < n; i++ )
                    std::swap( left0[i], left[i-n] );

                n = std::min( (int)(right0 - right1), (int)(right1 - right) );
                for( i = 0; i < n; i++ )
                    std::swap( left[i], right0[i-n+1] );
                n = (int)(left - left1);
                m = (int)(right1 - right);
                if( n > 1 )
                {
                    if( m > 1 )
                    {
                        if( n > m )
                        {
                            stack[++sp].lb = left0;
                            stack[sp].ub = left0 + n - 1;
                            left = right0 - m + 1, right = right0;
                        }
                        else
                        {
                            stack[++sp].lb = right0 - m + 1;
                            stack[sp].ub = right0;
                            left = left0, right = left0 + n - 1;
                        }
                    }
                    else
                        left = left0, right = left0 + n - 1;
                }
                else if( m > 1 )
                    left = right0 - m + 1, right = right0;
                else
                    break;
            }
        }
    }
}

template<typename _Tp> class LessThan
{
public:
    bool operator()(const _Tp& a, const _Tp& b) const { return a < b; }
};

template<typename _Tp> class GreaterEq
{
public:
    bool operator()(const _Tp& a, const _Tp& b) const { return a >= b; }
};

template<typename _Tp> class LessThanIdx
{
public:
    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
    bool operator()(int a, int b) const { return arr[a] < arr[b]; }
    const _Tp* arr;
};

template<typename _Tp> class GreaterEqIdx
{
public:
    GreaterEqIdx( const _Tp* _arr ) : arr(_arr) {}
    bool operator()(int a, int b) const { return arr[a] >= arr[b]; }
    const _Tp* arr;
};
#3400 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp"
template<typename _Tp, class _EqPredicate> int
partition( const vector<_Tp>& _vec, vector<int>& labels,
           _EqPredicate predicate=_EqPredicate())
{
    int i, j, N = (int)_vec.size();
    const _Tp* vec = &_vec[0];

    const int PARENT=0;
    const int RANK=1;

    vector<int> _nodes(N*2);
    int (*nodes)[2] = (int(*)[2])&_nodes[0];


    for(i = 0; i < N; i++)
    {
        nodes[i][PARENT]=-1;
        nodes[i][RANK] = 0;
    }


    for( i = 0; i < N; i++ )
    {
        int root = i;


        while( nodes[root][PARENT] >= 0 )
            root = nodes[root][PARENT];

        for( j = 0; j < N; j++ )
        {
            if( i == j || !predicate(vec[i], vec[j]))
                continue;
            int root2 = j;

            while( nodes[root2][PARENT] >= 0 )
                root2 = nodes[root2][PARENT];

            if( root2 != root )
            {

                int rank = nodes[root][RANK], rank2 = nodes[root2][RANK];
                if( rank > rank2 )
                    nodes[root2][PARENT] = root;
                else
                {
                    nodes[root][PARENT] = root2;
                    nodes[root2][RANK] += rank == rank2;
                    root = root2;
                }
                ((nodes[root][PARENT] < 0) ? static_cast<void> (0) : __assert_fail ("nodes[root][PARENT] < 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 3450, __PRETTY_FUNCTION__));

                int k = j, parent;


                while( (parent = nodes[k][PARENT]) >= 0 )
                {
                    nodes[k][PARENT] = root;
                    k = parent;
                }


                k = i;
                while( (parent = nodes[k][PARENT]) >= 0 )
                {
                    nodes[k][PARENT] = root;
                    k = parent;
                }
            }
        }
    }


    labels.resize(N);
    int nclasses = 0;

    for( i = 0; i < N; i++ )
    {
        int root = i;
        while( nodes[root][PARENT] >= 0 )
            root = nodes[root][PARENT];

        if( nodes[root][RANK] >= 0 )
            nodes[root][RANK] = ~nclasses++;
        labels[i] = ~nodes[root][RANK];
    }

    return nclasses;
}





 schar* seqPush( CvSeq* seq, const void* element=0);
 schar* seqPushFront( CvSeq* seq, const void* element=0);
 void seqPop( CvSeq* seq, void* element=0);
 void seqPopFront( CvSeq* seq, void* element=0);
 void seqPopMulti( CvSeq* seq, void* elements,
                              int count, int in_front=0 );
 void seqRemove( CvSeq* seq, int index );
 void clearSeq( CvSeq* seq );
 schar* getSeqElem( const CvSeq* seq, int index );
 void seqRemoveSlice( CvSeq* seq, CvSlice slice );
 void seqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );

template<typename _Tp> inline Seq<_Tp>::Seq() : seq(0) {}
template<typename _Tp> inline Seq<_Tp>::Seq( const CvSeq* _seq ) : seq((CvSeq*)_seq)
{
    if(!!(!_seq || _seq->elem_size == sizeof(_Tp))) ; else cv::error( cv::Exception(CV_StsAssert, "!_seq || _seq->elem_size == sizeof(_Tp)", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 3509) );
}

template<typename _Tp> inline Seq<_Tp>::Seq( MemStorage& storage,
                                             int headerSize )
{
    if(!!(headerSize >= (int)sizeof(CvSeq))) ; else cv::error( cv::Exception(CV_StsAssert, "headerSize >= (int)sizeof(CvSeq)", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 3515) );
    seq = cvCreateSeq(DataType<_Tp>::type, headerSize, sizeof(_Tp), storage);
}

template<typename _Tp> inline _Tp& Seq<_Tp>::operator [](int idx)
{ return *(_Tp*)getSeqElem(seq, idx); }

template<typename _Tp> inline const _Tp& Seq<_Tp>::operator [](int idx) const
{ return *(_Tp*)getSeqElem(seq, idx); }

template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::begin() const
{ return SeqIterator<_Tp>(*this); }

template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::end() const
{ return SeqIterator<_Tp>(*this, true); }

template<typename _Tp> inline size_t Seq<_Tp>::size() const
{ return seq ? seq->total : 0; }

template<typename _Tp> inline int Seq<_Tp>::type() const
{ return seq ? ((seq->flags) & ((1 << 3)*512 - 1)) : 0; }

template<typename _Tp> inline int Seq<_Tp>::depth() const
{ return seq ? ((seq->flags) & ((1 << 3) - 1)) : 0; }

template<typename _Tp> inline int Seq<_Tp>::channels() const
{ return seq ? ((((seq->flags) & ((512 - 1) << 3)) >> 3) + 1) : 0; }

template<typename _Tp> inline size_t Seq<_Tp>::elemSize() const
{ return seq ? seq->elem_size : 0; }

template<typename _Tp> inline size_t Seq<_Tp>::index(const _Tp& elem) const
{ return cvSeqElemIdx(seq, &elem); }

template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp& elem)
{ cvSeqPush(seq, &elem); }

template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp& elem)
{ cvSeqPushFront(seq, &elem); }

template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp* elem, size_t count)
{ cvSeqPushMulti(seq, elem, (int)count, 0); }

template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp* elem, size_t count)
{ cvSeqPushMulti(seq, elem, (int)count, 1); }

template<typename _Tp> inline _Tp& Seq<_Tp>::back()
{ return *(_Tp*)getSeqElem(seq, -1); }

template<typename _Tp> inline const _Tp& Seq<_Tp>::back() const
{ return *(const _Tp*)getSeqElem(seq, -1); }

template<typename _Tp> inline _Tp& Seq<_Tp>::front()
{ return *(_Tp*)getSeqElem(seq, 0); }

template<typename _Tp> inline const _Tp& Seq<_Tp>::front() const
{ return *(const _Tp*)getSeqElem(seq, 0); }

template<typename _Tp> inline bool Seq<_Tp>::empty() const
{ return !seq || seq->total == 0; }

template<typename _Tp> inline void Seq<_Tp>::clear()
{ if(seq) clearSeq(seq); }

template<typename _Tp> inline void Seq<_Tp>::pop_back()
{ seqPop(seq); }

template<typename _Tp> inline void Seq<_Tp>::pop_front()
{ seqPopFront(seq); }

template<typename _Tp> inline void Seq<_Tp>::pop_back(_Tp* elem, size_t count)
{ seqPopMulti(seq, elem, (int)count, 0); }

template<typename _Tp> inline void Seq<_Tp>::pop_front(_Tp* elem, size_t count)
{ seqPopMulti(seq, elem, (int)count, 1); }

template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp& elem)
{ seqInsert(seq, idx, &elem); }

template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp* elems, size_t count)
{
    CvMat m = cvMat(1, count, DataType<_Tp>::type, elems);
    seqInsertSlice(seq, idx, &m);
}

template<typename _Tp> inline void Seq<_Tp>::remove(int idx)
{ seqRemove(seq, idx); }

template<typename _Tp> inline void Seq<_Tp>::remove(const Range& r)
{ seqRemoveSlice(seq, r); }

template<typename _Tp> inline void Seq<_Tp>::copyTo(vector<_Tp>& vec, const Range& range) const
{
    size_t len = !seq ? 0 : range == Range::all() ? seq->total : range.end - range.start;
    vec.resize(len);
    if( seq && len )
        cvCvtSeqToArray(seq, &vec[0], range);
}

template<typename _Tp> inline Seq<_Tp>::operator vector<_Tp>() const
{
    vector<_Tp> vec;
    copyTo(vec);
    return vec;
}

template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator()
{ memset(this, 0, sizeof(*this)); }

template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator(const Seq<_Tp>& _seq, bool seekEnd)
{
    cvStartReadSeq(_seq.seq, this);
    index = seekEnd ? _seq.seq->total : 0;
}

template<typename _Tp> inline void SeqIterator<_Tp>::seek(size_t pos)
{
    cvSetSeqReaderPos(this, (int)pos, false);
    index = pos;
}

template<typename _Tp> inline size_t SeqIterator<_Tp>::tell() const
{ return index; }

template<typename _Tp> inline _Tp& SeqIterator<_Tp>::operator *()
{ return *(_Tp*)ptr; }

template<typename _Tp> inline const _Tp& SeqIterator<_Tp>::operator *() const
{ return *(const _Tp*)ptr; }

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator ++()
{
    { if( ((*this).ptr += (sizeof(_Tp))) >= (*this).block_max ) { cvChangeSeqBlock( &(*this), 1 ); } };
    if( ++index >= seq->total*2 )
        index = 0;
    return *this;
}

template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator ++(int) const
{
    SeqIterator<_Tp> it = *this;
    ++*this;
    return it;
}

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator --()
{
    { if( ((*this).ptr -= (sizeof(_Tp))) < (*this).block_min ) { cvChangeSeqBlock( &(*this), -1 ); } };
    if( --index < 0 )
        index = seq->total*2-1;
    return *this;
}

template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator --(int) const
{
    SeqIterator<_Tp> it = *this;
    --*this;
    return it;
}

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator +=(int delta)
{
    cvSetSeqReaderPos(this, delta, 1);
    index += delta;
    int n = seq->total*2;
    if( index < 0 )
        index += n;
    if( index >= n )
        index -= n;
    return *this;
}

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator -=(int delta)
{
    return (*this += -delta);
}

template<typename _Tp> inline ptrdiff_t operator - (const SeqIterator<_Tp>& a,
                                                    const SeqIterator<_Tp>& b)
{
    ptrdiff_t delta = a.index - b.index, n = a.seq->total;
    if( std::abs(static_cast<long>(delta)) > n )
        delta += delta < 0 ? n : -n;
    return delta;
}

template<typename _Tp> inline bool operator == (const SeqIterator<_Tp>& a,
                                                const SeqIterator<_Tp>& b)
{
    return a.seq == b.seq && a.index == b.index;
}

template<typename _Tp> inline bool operator != (const SeqIterator<_Tp>& a,
                                                const SeqIterator<_Tp>& b)
{
    return !(a == b);
}


template<typename _ClsName> struct RTTIImpl
{
public:
    static int isInstance(const void* ptr)
    {
        static _ClsName dummy;
        static void* dummyp = &dummy;
        union
        {
            const void* p;
            const void** pp;
        } a, b;
        a.p = dummyp;
        b.p = ptr;
        return *a.pp == *b.pp;
    }
    static void release(void** dbptr)
    {
        if(dbptr && *dbptr)
        {
            delete (_ClsName*)*dbptr;
            *dbptr = 0;
        }
    }
    static void* read(CvFileStorage* fs, CvFileNode* n)
    {
        FileNode fn(fs, n);
        _ClsName* obj = new _ClsName;
        if(obj->read(fn))
            return obj;
        delete obj;
        return 0;
    }

    static void write(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)
    {
        if(ptr && _fs)
        {
            FileStorage fs(_fs);
            fs.fs.addref();
            ((const _ClsName*)ptr)->write(fs, string(name));
        }
    }

    static void* clone(const void* ptr)
    {
        if(!ptr)
            return 0;
        return new _ClsName(*(const _ClsName*)ptr);
    }
};


class Formatter
{
public:
    virtual ~Formatter() {}
    virtual void write(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const = 0;
    virtual void write(std::ostream& out, const void* data, int nelems, int type,
                       const int* params=0, int nparams=0) const = 0;
    static const Formatter* get(const char* fmt="");
    static const Formatter* setDefault(const Formatter* fmt);
};


struct Formatted
{
    Formatted(const Mat& m, const Formatter* fmt,
              const vector<int>& params);
    Formatted(const Mat& m, const Formatter* fmt,
              const int* params=0);
    Mat mtx;
    const Formatter* fmt;
    vector<int> params;
};

static inline Formatted format(const Mat& mtx, const char* fmt,
                               const vector<int>& params=vector<int>())
{
    return Formatted(mtx, Formatter::get(fmt), params);
}

template<typename _Tp> static inline Formatted format(const vector<Point_<_Tp> >& vec,
                                                      const char* fmt, const vector<int>& params=vector<int>())
{
    return Formatted(Mat(vec), Formatter::get(fmt), params);
}

template<typename _Tp> static inline Formatted format(const vector<Point3_<_Tp> >& vec,
                                                      const char* fmt, const vector<int>& params=vector<int>())
{
    return Formatted(Mat(vec), Formatter::get(fmt), params);
}
#3815 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp"
static inline std::ostream& operator << (std::ostream& out, const Mat& mtx)
{
    Formatter::get()->write(out, mtx);
    return out;
}
#3828 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp"
static inline std::ostream& operator << (std::ostream& out, const Formatted& fmtd)
{
    fmtd.fmt->write(out, fmtd.mtx);
    return out;
}


template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,
                                                                const vector<Point_<_Tp> >& vec)
{
    Formatter::get()->write(out, Mat(vec));
    return out;
}


template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,
                                                                const vector<Point3_<_Tp> >& vec)
{
    Formatter::get()->write(out, Mat(vec));
    return out;
}




template<typename _Tp, int m, int n> inline std::ostream& operator<<(std::ostream& out, const Matx<_Tp, m, n>& matx)
{
    out << cv::Mat(matx);
    return out;
}



template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point_<_Tp>& p)
{
    out << "[" << p.x << ", " << p.y << "]";
    return out;
}



template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point3_<_Tp>& p)
{
    out << "[" << p.x << ", " << p.y << ", " << p.z << "]";
    return out;
}



template<typename _Tp, int n> inline std::ostream& operator<<(std::ostream& out, const Vec<_Tp, n>& vec)
{
    out << "[";

    if(Vec<_Tp, n>::depth < 5)
    {
        for (int i = 0; i < n - 1; ++i) {
            out << (int)vec[i] << ", ";
        }
        out << (int)vec[n-1] << "]";
    }
    else
    {
        for (int i = 0; i < n - 1; ++i) {
            out << vec[i] << ", ";
        }
        out << vec[n-1] << "]";
    }

    return out;
}



template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Size_<_Tp>& size)
{
    out << "[" << size.width << " x " << size.height << "]";
    return out;
}



template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Rect_<_Tp>& rect)
{
    out << "[" << rect.width << " x " << rect.height << " from (" << rect.x << ", " << rect.y << ")]";
    return out;
}


template<typename _Tp> inline Ptr<_Tp> Algorithm::create(const string& name)
{
    return _create(name).ptr<_Tp>();
}

template<typename _Tp>
inline void Algorithm::set(const char* _name, const Ptr<_Tp>& value)
{
    Ptr<Algorithm> algo_ptr = value. template ptr<cv::Algorithm>();
    if (algo_ptr.empty()) {
        cv::error( cv::Exception(CV_StsUnsupportedFormat, "unknown/unsupported Ptr type of the second parameter of the method Algorithm::set", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 3926) );
    }
    info()->set(this, _name, ParamType<Algorithm>::type, &algo_ptr);
}

template<typename _Tp>
inline void Algorithm::set(const string& _name, const Ptr<_Tp>& value)
{
    this->set<_Tp>(_name.c_str(), value);
}

template<typename _Tp>
inline void Algorithm::setAlgorithm(const char* _name, const Ptr<_Tp>& value)
{
    Ptr<Algorithm> algo_ptr = value. template ptr<cv::Algorithm>();
    if (algo_ptr.empty()) {
        cv::error( cv::Exception(CV_StsUnsupportedFormat, "unknown/unsupported Ptr type of the second parameter of the method Algorithm::set", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/operations.hpp", 3942) );
    }
    info()->set(this, _name, ParamType<Algorithm>::type, &algo_ptr);
}

template<typename _Tp>
inline void Algorithm::setAlgorithm(const string& _name, const Ptr<_Tp>& value)
{
    this->set<_Tp>(_name.c_str(), value);
}

template<typename _Tp> inline typename ParamType<_Tp>::member_type Algorithm::get(const string& _name) const
{
    typename ParamType<_Tp>::member_type value;
    info()->get(this, _name.c_str(), ParamType<_Tp>::type, &value);
    return value;
}

template<typename _Tp> inline typename ParamType<_Tp>::member_type Algorithm::get(const char* _name) const
{
    typename ParamType<_Tp>::member_type value;
    info()->get(this, _name, ParamType<_Tp>::type, &value);
    return value;
}

template<typename _Tp, typename _Base> inline void AlgorithmInfo::addParam(Algorithm& algo, const char* parameter,
                  Ptr<_Tp>& value, bool readOnly, Ptr<_Tp> (Algorithm::*getter)(), void (Algorithm::*setter)(const Ptr<_Tp>&),
                  const string& help)
{

    addParam_(algo, parameter, ParamType<_Base>::type, &value, readOnly,
              (Algorithm::Getter)getter, (Algorithm::Setter)setter, help);
}

template<typename _Tp> inline void AlgorithmInfo::addParam(Algorithm& algo, const char* parameter,
                  Ptr<_Tp>& value, bool readOnly, Ptr<_Tp> (Algorithm::*getter)(), void (Algorithm::*setter)(const Ptr<_Tp>&),
                  const string& help)
{

    addParam_(algo, parameter, ParamType<Algorithm>::type, &value, readOnly,
              (Algorithm::Getter)getter, (Algorithm::Setter)setter, help);
}

}
#4787 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp" 1
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 1 3 4
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp" 2





namespace cv
{



inline void Mat::initEmpty()
{
    flags = MAGIC_VAL;
    dims = rows = cols = 0;
    data = datastart = dataend = datalimit = 0;
    refcount = 0;
    allocator = 0;
}

inline Mat::Mat() : size(&rows)
{
    initEmpty();
}

inline Mat::Mat(int _rows, int _cols, int _type) : size(&rows)
{
    initEmpty();
    create(_rows, _cols, _type);
}

inline Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s) : size(&rows)
{
    initEmpty();
    create(_rows, _cols, _type);
    *this = _s;
}

inline Mat::Mat(Size _sz, int _type) : size(&rows)
{
    initEmpty();
    create( _sz.height, _sz.width, _type );
}

inline Mat::Mat(Size _sz, int _type, const Scalar& _s) : size(&rows)
{
    initEmpty();
    create(_sz.height, _sz.width, _type);
    *this = _s;
}

inline Mat::Mat(int _dims, const int* _sz, int _type) : size(&rows)
{
    initEmpty();
    create(_dims, _sz, _type);
}

inline Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s) : size(&rows)
{
    initEmpty();
    create(_dims, _sz, _type);
    *this = _s;
}

inline Mat::Mat(const Mat& m)
    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
    refcount(m.refcount), datastart(m.datastart), dataend(m.dataend),
    datalimit(m.datalimit), allocator(m.allocator), size(&rows)
{
    if( refcount )
        __sync_fetch_and_add(refcount, 1);
    if( m.dims <= 2 )
    {
        step[0] = m.step[0]; step[1] = m.step[1];
    }
    else
    {
        dims = 0;
        copySize(m);
    }
}

inline Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)
    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_rows), cols(_cols),
    data((uchar*)_data), refcount(0), datastart((uchar*)_data), dataend(0),
    datalimit(0), allocator(0), size(&rows)
{
    size_t esz = (((((_type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((_type) & ((1 << 3) - 1))*2) & 3)), minstep = cols*esz;
    if( _step == AUTO_STEP )
    {
        _step = minstep;
        flags |= CONTINUOUS_FLAG;
    }
    else
    {
        if( rows == 1 ) _step = minstep;
        ;
        flags |= _step == minstep ? CONTINUOUS_FLAG : 0;
    }
    step[0] = _step; step[1] = esz;
    datalimit = datastart + _step*rows;
    dataend = datalimit - _step + minstep;
}

inline Mat::Mat(Size _sz, int _type, void* _data, size_t _step)
    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_sz.height), cols(_sz.width),
    data((uchar*)_data), refcount(0), datastart((uchar*)_data), dataend(0),
    datalimit(0), allocator(0), size(&rows)
{
    size_t esz = (((((_type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((_type) & ((1 << 3) - 1))*2) & 3)), minstep = cols*esz;
    if( _step == AUTO_STEP )
    {
        _step = minstep;
        flags |= CONTINUOUS_FLAG;
    }
    else
    {
        if( rows == 1 ) _step = minstep;
        ;
        flags |= _step == minstep ? CONTINUOUS_FLAG : 0;
    }
    step[0] = _step; step[1] = esz;
    datalimit = datastart + _step*rows;
    dataend = datalimit - _step + minstep;
}


template<typename _Tp> inline Mat::Mat(const vector<_Tp>& vec, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)),
    dims(2), rows((int)vec.size()), cols(1), data(0), refcount(0),
    datastart(0), dataend(0), allocator(0), size(&rows)
{
    if(vec.empty())
        return;
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        data = datastart = (uchar*)&vec[0];
        datalimit = dataend = datastart + rows*step[0];
    }
    else
        Mat((int)vec.size(), 1, DataType<_Tp>::type, (uchar*)&vec[0]).copyTo(*this);
}


template<typename _Tp, int n> inline Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)),
    dims(2), rows(n), cols(1), data(0), refcount(0),
    datastart(0), dataend(0), allocator(0), size(&rows)
{
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        data = datastart = (uchar*)vec.val;
        datalimit = dataend = datastart + rows*step[0];
    }
    else
        Mat(n, 1, DataType<_Tp>::type, (void*)vec.val).copyTo(*this);
}


template<typename _Tp, int m, int n> inline Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)),
    dims(2), rows(m), cols(n), data(0), refcount(0),
    datastart(0), dataend(0), allocator(0), size(&rows)
{
    if( !copyData )
    {
        step[0] = cols*sizeof(_Tp);
        step[1] = sizeof(_Tp);
        data = datastart = (uchar*)M.val;
        datalimit = dataend = datastart + rows*step[0];
    }
    else
        Mat(m, n, DataType<_Tp>::type, (uchar*)M.val).copyTo(*this);
}


template<typename _Tp> inline Mat::Mat(const Point_<_Tp>& pt, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)),
    dims(2), rows(2), cols(1), data(0), refcount(0),
    datastart(0), dataend(0), allocator(0), size(&rows)
{
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        data = datastart = (uchar*)&pt.x;
        datalimit = dataend = datastart + rows*step[0];
    }
    else
    {
        create(2, 1, DataType<_Tp>::type);
        ((_Tp*)data)[0] = pt.x;
        ((_Tp*)data)[1] = pt.y;
    }
}


template<typename _Tp> inline Mat::Mat(const Point3_<_Tp>& pt, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)),
    dims(2), rows(3), cols(1), data(0), refcount(0),
    datastart(0), dataend(0), allocator(0), size(&rows)
{
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        data = datastart = (uchar*)&pt.x;
        datalimit = dataend = datastart + rows*step[0];
    }
    else
    {
        create(3, 1, DataType<_Tp>::type);
        ((_Tp*)data)[0] = pt.x;
        ((_Tp*)data)[1] = pt.y;
        ((_Tp*)data)[2] = pt.z;
    }
}


template<typename _Tp> inline Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)),
    dims(0), rows(0), cols(0), data(0), refcount(0),
    datastart(0), dataend(0), allocator(0), size(&rows)
{
    *this = *commaInitializer;
}

inline Mat::~Mat()
{
    release();
    if( step.p != step.buf )
        fastFree(step.p);
}

inline Mat& Mat::operator = (const Mat& m)
{
    if( this != &m )
    {
        if( m.refcount )
            __sync_fetch_and_add(m.refcount, 1);
        release();
        flags = m.flags;
        if( dims <= 2 && m.dims <= 2 )
        {
            dims = m.dims;
            rows = m.rows;
            cols = m.cols;
            step[0] = m.step[0];
            step[1] = m.step[1];
        }
        else
            copySize(m);
        data = m.data;
        datastart = m.datastart;
        dataend = m.dataend;
        datalimit = m.datalimit;
        refcount = m.refcount;
        allocator = m.allocator;
    }
    return *this;
}

inline Mat Mat::row(int y) const { return Mat(*this, Range(y, y+1), Range::all()); }
inline Mat Mat::col(int x) const { return Mat(*this, Range::all(), Range(x, x+1)); }
inline Mat Mat::rowRange(int startrow, int endrow) const
    { return Mat(*this, Range(startrow, endrow), Range::all()); }
inline Mat Mat::rowRange(const Range& r) const
    { return Mat(*this, r, Range::all()); }
inline Mat Mat::colRange(int startcol, int endcol) const
    { return Mat(*this, Range::all(), Range(startcol, endcol)); }
inline Mat Mat::colRange(const Range& r) const
    { return Mat(*this, Range::all(), r); }

inline Mat Mat::diag(const Mat& d)
{
    if(!!(d.cols == 1 || d.rows == 1)) ; else cv::error( cv::Exception(CV_StsAssert, "d.cols == 1 || d.rows == 1", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 322) );
    int len = d.rows + d.cols - 1;
    Mat m(len, len, d.type(), Scalar(0)), md = m.diag();
    if( d.cols == 1 )
        d.copyTo(md);
    else
        transpose(d, md);
    return m;
}

inline Mat Mat::clone() const
{
    Mat m;
    copyTo(m);
    return m;
}

inline void Mat::assignTo( Mat& m, int _type ) const
{
    if( _type < 0 )
        m = *this;
    else
        convertTo(m, _type);
}

inline void Mat::create(int _rows, int _cols, int _type)
{
    _type &= TYPE_MASK;
    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )
        return;
    int sz[] = {_rows, _cols};
    create(2, sz, _type);
}

inline void Mat::create(Size _sz, int _type)
{
    create(_sz.height, _sz.width, _type);
}

inline void Mat::addref()
{ if( refcount ) __sync_fetch_and_add(refcount, 1); }

inline void Mat::release()
{
    if( refcount && __sync_fetch_and_add(refcount, -1) == 1 )
        deallocate();
    data = datastart = dataend = datalimit = 0;
    size.p[0] = 0;
    refcount = 0;
}

inline Mat Mat::operator()( Range _rowRange, Range _colRange ) const
{
    return Mat(*this, _rowRange, _colRange);
}

inline Mat Mat::operator()( const Rect& roi ) const
{ return Mat(*this, roi); }

inline Mat Mat::operator()(const Range* ranges) const
{
    return Mat(*this, ranges);
}

inline Mat::operator CvMat() const
{
    ;
    CvMat m = cvMat(rows, dims == 1 ? 1 : cols, type(), data);
    m.step = (int)step[0];
    m.type = (m.type & ~CONTINUOUS_FLAG) | (flags & CONTINUOUS_FLAG);
    return m;
}

inline bool Mat::isContinuous() const { return (flags & CONTINUOUS_FLAG) != 0; }
inline bool Mat::isSubmatrix() const { return (flags & SUBMATRIX_FLAG) != 0; }
inline size_t Mat::elemSize() const { return dims > 0 ? step.p[dims-1] : 0; }
inline size_t Mat::elemSize1() const { return ((((sizeof(size_t)<<28)|0x8442211) >> ((flags) & ((1 << 3) - 1))*4) & 15); }
inline int Mat::type() const { return ((flags) & ((1 << 3)*512 - 1)); }
inline int Mat::depth() const { return ((flags) & ((1 << 3) - 1)); }
inline int Mat::channels() const { return ((((flags) & ((512 - 1) << 3)) >> 3) + 1); }
inline size_t Mat::step1(int i) const { return step.p[i]/elemSize1(); }
inline bool Mat::empty() const { return data == 0 || total() == 0; }
inline size_t Mat::total() const
{
    if( dims <= 2 )
        return (size_t)rows*cols;
    size_t p = 1;
    for( int i = 0; i < dims; i++ )
        p *= size[i];
    return p;
}

inline uchar* Mat::ptr(int y)
{
    ;
    return data + step.p[0]*y;
}

inline const uchar* Mat::ptr(int y) const
{
    ;
    return data + step.p[0]*y;
}

template<typename _Tp> inline _Tp* Mat::ptr(int y)
{
    ;
    return (_Tp*)(data + step.p[0]*y);
}

template<typename _Tp> inline const _Tp* Mat::ptr(int y) const
{
    ;
    return (const _Tp*)(data + step.p[0]*y);
}


inline uchar* Mat::ptr(int i0, int i1)
{


                                                      ;
    return data + i0*step.p[0] + i1*step.p[1];
}

inline const uchar* Mat::ptr(int i0, int i1) const
{


                                                     ;
    return data + i0*step.p[0] + i1*step.p[1];
}

template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1)
{


                                                      ;
    return (_Tp*)(data + i0*step.p[0] + i1*step.p[1]);
}

template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1) const
{


                                                      ;
    return (const _Tp*)(data + i0*step.p[0] + i1*step.p[1]);
}

inline uchar* Mat::ptr(int i0, int i1, int i2)
{



                                                      ;
    return data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2];
}

inline const uchar* Mat::ptr(int i0, int i1, int i2) const
{



                                                      ;
    return data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2];
}

template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1, int i2)
{



                                                      ;
    return (_Tp*)(data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2]);
}

template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1, int i2) const
{



                                                      ;
    return (const _Tp*)(data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2]);
}

inline uchar* Mat::ptr(const int* idx)
{
    int i, d = dims;
    uchar* p = data;
    ;
    for( i = 0; i < d; i++ )
    {
        ;
        p += idx[i]*step.p[i];
    }
    return p;
}

inline const uchar* Mat::ptr(const int* idx) const
{
    int i, d = dims;
    uchar* p = data;
    ;
    for( i = 0; i < d; i++ )
    {
        ;
        p += idx[i]*step.p[i];
    }
    return p;
}

template<typename _Tp> inline _Tp& Mat::at(int i0, int i1)
{


                                                           ;
    return ((_Tp*)(data + step.p[0]*i0))[i1];
}

template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1) const
{


                                                           ;
    return ((const _Tp*)(data + step.p[0]*i0))[i1];
}

template<typename _Tp> inline _Tp& Mat::at(Point pt)
{


                                                           ;
    return ((_Tp*)(data + step.p[0]*pt.y))[pt.x];
}

template<typename _Tp> inline const _Tp& Mat::at(Point pt) const
{


                                                           ;
    return ((const _Tp*)(data + step.p[0]*pt.y))[pt.x];
}

template<typename _Tp> inline _Tp& Mat::at(int i0)
{


                                                                  ;
    if( isContinuous() || size.p[0] == 1 )
        return ((_Tp*)data)[i0];
    if( size.p[1] == 1 )
        return *(_Tp*)(data + step.p[0]*i0);
    int i = i0/cols, j = i0 - i*cols;
    return ((_Tp*)(data + step.p[0]*i))[j];
}

template<typename _Tp> inline const _Tp& Mat::at(int i0) const
{


                                                                  ;
    if( isContinuous() || size.p[0] == 1 )
        return ((const _Tp*)data)[i0];
    if( size.p[1] == 1 )
        return *(const _Tp*)(data + step.p[0]*i0);
    int i = i0/cols, j = i0 - i*cols;
    return ((const _Tp*)(data + step.p[0]*i))[j];
}

template<typename _Tp> inline _Tp& Mat::at(int i0, int i1, int i2)
{
    ;
    return *(_Tp*)ptr(i0, i1, i2);
}
template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1, int i2) const
{
    ;
    return *(const _Tp*)ptr(i0, i1, i2);
}
template<typename _Tp> inline _Tp& Mat::at(const int* idx)
{
    ;
    return *(_Tp*)ptr(idx);
}
template<typename _Tp> inline const _Tp& Mat::at(const int* idx) const
{
    ;
    return *(const _Tp*)ptr(idx);
}
template<typename _Tp, int n> _Tp& Mat::at(const Vec<int, n>& idx)
{
    ;
    return *(_Tp*)ptr(idx.val);
}
template<typename _Tp, int n> inline const _Tp& Mat::at(const Vec<int, n>& idx) const
{
    ;
    return *(const _Tp*)ptr(idx.val);
}


template<typename _Tp> inline MatConstIterator_<_Tp> Mat::begin() const
{
    ;
    return MatConstIterator_<_Tp>((const Mat_<_Tp>*)this);
}

template<typename _Tp> inline MatConstIterator_<_Tp> Mat::end() const
{
    ;
    MatConstIterator_<_Tp> it((const Mat_<_Tp>*)this);
    it += total();
    return it;
}

template<typename _Tp> inline MatIterator_<_Tp> Mat::begin()
{
    ;
    return MatIterator_<_Tp>((Mat_<_Tp>*)this);
}

template<typename _Tp> inline MatIterator_<_Tp> Mat::end()
{
    ;
    MatIterator_<_Tp> it((Mat_<_Tp>*)this);
    it += total();
    return it;
}

template<typename _Tp> inline Mat::operator vector<_Tp>() const
{
    vector<_Tp> v;
    copyTo(v);
    return v;
}

template<typename _Tp, int n> inline Mat::operator Vec<_Tp, n>() const
{
    if(!!(data && dims <= 2 && (rows == 1 || cols == 1) && rows + cols - 1 == n && channels() == 1)) ; else cv::error( cv::Exception(CV_StsAssert, "data && dims <= 2 && (rows == 1 || cols == 1) && rows + cols - 1 == n && channels() == 1", __func__,
 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp"
#660 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp"
    ,
 661
#660 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp"
    ) )
                                                        ;

    if( isContinuous() && type() == DataType<_Tp>::type )
        return Vec<_Tp, n>((_Tp*)data);
    Vec<_Tp, n> v; Mat tmp(rows, cols, DataType<_Tp>::type, v.val);
    convertTo(tmp, tmp.type());
    return v;
}

template<typename _Tp, int m, int n> inline Mat::operator Matx<_Tp, m, n>() const
{
    if(!!(data && dims <= 2 && rows == m && cols == n && channels() == 1)) ; else cv::error( cv::Exception(CV_StsAssert, "data && dims <= 2 && rows == m && cols == n && channels() == 1", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 672) );

    if( isContinuous() && type() == DataType<_Tp>::type )
        return Matx<_Tp, m, n>((_Tp*)data);
    Matx<_Tp, m, n> mtx; Mat tmp(rows, cols, DataType<_Tp>::type, mtx.val);
    convertTo(tmp, tmp.type());
    return mtx;
}


template<typename _Tp> inline void Mat::push_back(const _Tp& elem)
{
    if( !data )
    {
        *this = Mat(1, 1, DataType<_Tp>::type, (void*)&elem).clone();
        return;
    }
    if(!!(DataType<_Tp>::type == type() && cols == 1)) ; else cv::error( cv::Exception(CV_StsAssert, "DataType<_Tp>::type == type() && cols == 1", __func__,
 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp"
#689 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp"
    ,
 690
#689 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp"
    ) )
                                                               ;
    uchar* tmp = dataend + step[0];
    if( !isSubmatrix() && isContinuous() && tmp <= datalimit )
    {
        *(_Tp*)(data + (size.p[0]++)*step.p[0]) = elem;
        dataend = tmp;
    }
    else
        push_back_(&elem);
}

template<typename _Tp> inline void Mat::push_back(const Mat_<_Tp>& m)
{
    push_back((const Mat&)m);
}

inline Mat::MSize::MSize(int* _p) : p(_p) {}
inline Size Mat::MSize::operator()() const
{
    ;
    return Size(p[1], p[0]);
}
inline const int& Mat::MSize::operator[](int i) const { return p[i]; }
inline int& Mat::MSize::operator[](int i) { return p[i]; }
inline Mat::MSize::operator const int*() const { return p; }

inline bool Mat::MSize::operator == (const MSize& sz) const
{
    int d = p[-1], dsz = sz.p[-1];
    if( d != dsz )
        return false;
    if( d == 2 )
        return p[0] == sz.p[0] && p[1] == sz.p[1];

    for( int i = 0; i < d; i++ )
        if( p[i] != sz.p[i] )
            return false;
    return true;
}

inline bool Mat::MSize::operator != (const MSize& sz) const
{
    return !(*this == sz);
}

inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }
inline Mat::MStep::MStep(size_t s) { p = buf; p[0] = s; p[1] = 0; }
inline const size_t& Mat::MStep::operator[](int i) const { return p[i]; }
inline size_t& Mat::MStep::operator[](int i) { return p[i]; }
inline Mat::MStep::operator size_t() const
{
    ;
    return buf[0];
}
inline Mat::MStep& Mat::MStep::operator = (size_t s)
{
    ;
    buf[0] = s;
    return *this;
}

static inline Mat cvarrToMatND(const CvArr* arr, bool copyData=false, int coiMode=0)
{
    return cvarrToMat(arr, copyData, true, coiMode);
}



inline SVD::SVD() {}
inline SVD::SVD( InputArray m, int flags ) { operator ()(m, flags); }
inline void SVD::solveZ( InputArray m, OutputArray _dst )
{
    Mat mtx = m.getMat();
    SVD svd(mtx, (mtx.rows >= mtx.cols ? 0 : SVD::FULL_UV));
    _dst.create(svd.vt.cols, 1, svd.vt.type());
    Mat dst = _dst.getMat();
    svd.vt.row(svd.vt.rows-1).reshape(1,svd.vt.cols).copyTo(dst);
}

template<typename _Tp, int m, int n, int nm> inline void
    SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
{
    ((nm == ((m) > (n) ? (n) : (m))) ? static_cast<void> (0) : __assert_fail ("nm == MIN(m, n)", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 772, __PRETTY_FUNCTION__));
    Mat _a(a, false), _u(u, false), _w(w, false), _vt(vt, false);
    SVD::compute(_a, _w, _u, _vt);
    if(!!(_w.data == (uchar*)&w.val[0] && _u.data == (uchar*)&u.val[0] && _vt.data == (uchar*)&vt.val[0])) ; else cv::error( cv::Exception(CV_StsAssert, "_w.data == (uchar*)&w.val[0] && _u.data == (uchar*)&u.val[0] && _vt.data == (uchar*)&vt.val[0]", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 775) );
}

template<typename _Tp, int m, int n, int nm> inline void
SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
{
    ((nm == ((m) > (n) ? (n) : (m))) ? static_cast<void> (0) : __assert_fail ("nm == MIN(m, n)", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 781, __PRETTY_FUNCTION__));
    Mat _a(a, false), _w(w, false);
    SVD::compute(_a, _w);
    if(!!(_w.data == (uchar*)&w.val[0])) ; else cv::error( cv::Exception(CV_StsAssert, "_w.data == (uchar*)&w.val[0]", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 784) );
}

template<typename _Tp, int m, int n, int nm, int nb> inline void
SVD::backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u,
                const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs,
                Matx<_Tp, n, nb>& dst )
{
    ((nm == ((m) > (n) ? (n) : (m))) ? static_cast<void> (0) : __assert_fail ("nm == MIN(m, n)", "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 792, __PRETTY_FUNCTION__));
    Mat _u(u, false), _w(w, false), _vt(vt, false), _rhs(rhs, false), _dst(dst, false);
    SVD::backSubst(_w, _u, _vt, _rhs, _dst);
    if(!!(_dst.data == (uchar*)&dst.val[0])) ; else cv::error( cv::Exception(CV_StsAssert, "_dst.data == (uchar*)&dst.val[0]", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 795) );
}



template<typename _Tp> inline Mat_<_Tp>::Mat_()
    : Mat() { flags = (flags & ~((1 << 3)*512 - 1)) | DataType<_Tp>::type; }

template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols)
    : Mat(_rows, _cols, DataType<_Tp>::type) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)
    : Mat(_rows, _cols, DataType<_Tp>::type) { *this = value; }

template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz)
    : Mat(_sz.height, _sz.width, DataType<_Tp>::type) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)
    : Mat(_sz.height, _sz.width, DataType<_Tp>::type) { *this = value; }

template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz)
    : Mat(_dims, _sz, DataType<_Tp>::type) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)
    : Mat(_dims, _sz, DataType<_Tp>::type, Scalar(_s)) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)
    : Mat(m, ranges) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat& m)
    : Mat() { flags = (flags & ~((1 << 3)*512 - 1)) | DataType<_Tp>::type; *this = m; }

template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m)
    : Mat(m) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)
    : Mat(_rows, _cols, DataType<_Tp>::type, _data, steps) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Range& _rowRange, const Range& _colRange)
    : Mat(m, _rowRange, _colRange) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)
    : Mat(m, roi) {}

template<typename _Tp> template<int n> inline
    Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
    : Mat(n/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&vec)
{
    if(!!(n%DataType<_Tp>::channels == 0)) ; else cv::error( cv::Exception(CV_StsAssert, "n%DataType<_Tp>::channels == 0", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 843) );
    if( copyData )
        *this = clone();
}

template<typename _Tp> template<int m, int n> inline
    Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)
    : Mat(m, n/DataType<_Tp>::channels, DataType<_Tp>::type, (void*)&M)
{
    if(!!(n % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Exception(CV_StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 852) );
    if( copyData )
        *this = clone();
}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
    : Mat(2/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
{
    if(!!(2 % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Exception(CV_StsAssert, "2 % DataType<_Tp>::channels == 0", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 860) );
    if( copyData )
        *this = clone();
}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
    : Mat(3/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
{
    if(!!(3 % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Exception(CV_StsAssert, "3 % DataType<_Tp>::channels == 0", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 868) );
    if( copyData )
        *this = clone();
}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)
    : Mat(commaInitializer) {}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const vector<_Tp>& vec, bool copyData)
    : Mat(vec, copyData) {}

template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)
{
    if( DataType<_Tp>::type == m.type() )
    {
        Mat::operator = (m);
        return *this;
    }
    if( DataType<_Tp>::depth == m.depth() )
    {
        return (*this = m.reshape(DataType<_Tp>::channels, m.dims, 0));
    }
    ;
    m.convertTo(*this, type());
    return *this;
}

template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)
{
    Mat::operator=(m);
    return *this;
}

template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)
{
    typedef typename DataType<_Tp>::vec_type VT;
    Mat::operator=(Scalar((const VT&)s));
    return *this;
}

template<typename _Tp> inline void Mat_<_Tp>::create(int _rows, int _cols)
{
    Mat::create(_rows, _cols, DataType<_Tp>::type);
}

template<typename _Tp> inline void Mat_<_Tp>::create(Size _sz)
{
    Mat::create(_sz, DataType<_Tp>::type);
}

template<typename _Tp> inline void Mat_<_Tp>::create(int _dims, const int* _sz)
{
    Mat::create(_dims, _sz, DataType<_Tp>::type);
}


template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const
{ return Mat_<_Tp>(Mat::cross(m)); }

template<typename _Tp> template<typename T2> inline Mat_<_Tp>::operator Mat_<T2>() const
{ return Mat_<T2>(*this); }

template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::row(int y) const
{ return Mat_(*this, Range(y, y+1), Range::all()); }
template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::col(int x) const
{ return Mat_(*this, Range::all(), Range(x, x+1)); }
template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::diag(int d) const
{ return Mat_(Mat::diag(d)); }
template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::clone() const
{ return Mat_(Mat::clone()); }

template<typename _Tp> inline size_t Mat_<_Tp>::elemSize() const
{
    ;
    return sizeof(_Tp);
}

template<typename _Tp> inline size_t Mat_<_Tp>::elemSize1() const
{
    ;
    return sizeof(_Tp)/DataType<_Tp>::channels;
}
template<typename _Tp> inline int Mat_<_Tp>::type() const
{
    ;
    return DataType<_Tp>::type;
}
template<typename _Tp> inline int Mat_<_Tp>::depth() const
{
    ;
    return DataType<_Tp>::depth;
}
template<typename _Tp> inline int Mat_<_Tp>::channels() const
{
    ;
    return DataType<_Tp>::channels;
}
template<typename _Tp> inline size_t Mat_<_Tp>::stepT(int i) const { return step.p[i]/elemSize(); }
template<typename _Tp> inline size_t Mat_<_Tp>::step1(int i) const { return step.p[i]/elemSize1(); }

template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )
{ return (Mat_<_Tp>&)(Mat::adjustROI(dtop, dbottom, dleft, dright)); }

template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range& _rowRange, const Range& _colRange ) const
{ return Mat_<_Tp>(*this, _rowRange, _colRange); }

template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const
{ return Mat_<_Tp>(*this, roi); }

template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const
{ return Mat_<_Tp>(*this, ranges); }

template<typename _Tp> inline _Tp* Mat_<_Tp>::operator [](int y)
{ return (_Tp*)ptr(y); }
template<typename _Tp> inline const _Tp* Mat_<_Tp>::operator [](int y) const
{ return (const _Tp*)ptr(y); }

template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1)
{



                                                 ;
    return ((_Tp*)(data + step.p[0]*i0))[i1];
}

template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const
{



                                                 ;
    return ((const _Tp*)(data + step.p[0]*i0))[i1];
}

template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(Point pt)
{



                                                 ;
    return ((_Tp*)(data + step.p[0]*pt.y))[pt.x];
}

template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(Point pt) const
{



                                                ;
    return ((const _Tp*)(data + step.p[0]*pt.y))[pt.x];
}

template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(const int* idx)
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(const int* idx) const
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> template<int n> inline _Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx)
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> template<int n> inline const _Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx) const
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0)
{
    return this->at<_Tp>(i0);
}

template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0) const
{
    return this->at<_Tp>(i0);
}

template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)
{
    return this->at<_Tp>(i0, i1, i2);
}

template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const
{
    return this->at<_Tp>(i0, i1, i2);
}


template<typename _Tp> inline Mat_<_Tp>::operator vector<_Tp>() const
{
    vector<_Tp> v;
    copyTo(v);
    return v;
}

template<typename _Tp> template<int n> inline Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const
{
    if(!!(n % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Exception(CV_StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 1071) );
    return this->Mat::operator Vec<typename DataType<_Tp>::channel_type, n>();
}

template<typename _Tp> template<int m, int n> inline Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const
{
    if(!!(n % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Exception(CV_StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 1077) );
    return this->Mat::operator Matx<typename DataType<_Tp>::channel_type, m, n>();
}

template<typename T1, typename T2, typename Op> inline void
process( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )
{
    int y, x, rows = m1.rows, cols = m1.cols;

    ;

    for( y = 0; y < rows; y++ )
    {
        const T1* src = m1[y];
        T2* dst = m2[y];

        for( x = 0; x < cols; x++ )
            dst[x] = op(src[x]);
    }
}

template<typename T1, typename T2, typename T3, typename Op> inline void
process( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )
{
    int y, x, rows = m1.rows, cols = m1.cols;

    ;

    for( y = 0; y < rows; y++ )
    {
        const T1* src1 = m1[y];
        const T2* src2 = m2[y];
        T3* dst = m3[y];

        for( x = 0; x < cols; x++ )
            dst[x] = op( src1[x], src2[x] );
    }
}




template<typename _Tp> inline _InputArray::_InputArray(const vector<_Tp>& vec)
    : flags(FIXED_TYPE + STD_VECTOR + DataType<_Tp>::type), obj((void*)&vec) {}

template<typename _Tp> inline _InputArray::_InputArray(const vector<vector<_Tp> >& vec)
    : flags(FIXED_TYPE + STD_VECTOR_VECTOR + DataType<_Tp>::type), obj((void*)&vec) {}

template<typename _Tp> inline _InputArray::_InputArray(const vector<Mat_<_Tp> >& vec)
    : flags(FIXED_TYPE + STD_VECTOR_MAT + DataType<_Tp>::type), obj((void*)&vec) {}

template<typename _Tp, int m, int n> inline _InputArray::_InputArray(const Matx<_Tp, m, n>& mtx)
    : flags(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type), obj((void*)&mtx), sz(n, m) {}

template<typename _Tp> inline _InputArray::_InputArray(const _Tp* vec, int n)
    : flags(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type), obj((void*)vec), sz(n, 1) {}

inline _InputArray::_InputArray(const Scalar& s)
    : flags(FIXED_TYPE + FIXED_SIZE + MATX + 6), obj((void*)&s), sz(1, 4) {}

template<typename _Tp> inline _InputArray::_InputArray(const Mat_<_Tp>& m)
    : flags(FIXED_TYPE + MAT + DataType<_Tp>::type), obj((void*)&m) {}

template<typename _Tp> inline _OutputArray::_OutputArray(vector<_Tp>& vec)
    : _InputArray(vec) {}
template<typename _Tp> inline _OutputArray::_OutputArray(vector<vector<_Tp> >& vec)
    : _InputArray(vec) {}
template<typename _Tp> inline _OutputArray::_OutputArray(vector<Mat_<_Tp> >& vec)
    : _InputArray(vec) {}
template<typename _Tp> inline _OutputArray::_OutputArray(Mat_<_Tp>& m)
    : _InputArray(m) {}
template<typename _Tp, int m, int n> inline _OutputArray::_OutputArray(Matx<_Tp, m, n>& mtx)
    : _InputArray(mtx) {}
template<typename _Tp> inline _OutputArray::_OutputArray(_Tp* vec, int n)
    : _InputArray(vec, n) {}

template<typename _Tp> inline _OutputArray::_OutputArray(const vector<_Tp>& vec)
    : _InputArray(vec) {flags |= FIXED_SIZE;}
template<typename _Tp> inline _OutputArray::_OutputArray(const vector<vector<_Tp> >& vec)
    : _InputArray(vec) {flags |= FIXED_SIZE;}
template<typename _Tp> inline _OutputArray::_OutputArray(const vector<Mat_<_Tp> >& vec)
    : _InputArray(vec) {flags |= FIXED_SIZE;}

template<typename _Tp> inline _OutputArray::_OutputArray(const Mat_<_Tp>& m)
    : _InputArray(m) {flags |= FIXED_SIZE;}
template<typename _Tp, int m, int n> inline _OutputArray::_OutputArray(const Matx<_Tp, m, n>& mtx)
    : _InputArray(mtx) {}
template<typename _Tp> inline _OutputArray::_OutputArray(const _Tp* vec, int n)
    : _InputArray(vec, n) {}



class MatOp
{
public:
    MatOp() {};
    virtual ~MatOp() {};

    virtual bool elementWise(const MatExpr& expr) const;
    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;
    virtual void roi(const MatExpr& expr, const Range& rowRange,
                     const Range& colRange, MatExpr& res) const;
    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;
    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;
    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;
    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;
    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;
    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;
    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;
    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;

    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;

    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;

    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;

    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;

    virtual void abs(const MatExpr& expr, MatExpr& res) const;

    virtual void transpose(const MatExpr& expr, MatExpr& res) const;
    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;

    virtual Size size(const MatExpr& expr) const;
    virtual int type(const MatExpr& expr) const;
};


class MatExpr
{
public:
    MatExpr() : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s(Scalar()) {}
    MatExpr(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(),
            const Mat& _c=Mat(), double _alpha=1, double _beta=1, const Scalar& _s=Scalar())
        : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s) {}
    explicit MatExpr(const Mat& m);
    operator Mat() const
    {
        Mat m;
        op->assign(*this, m);
        return m;
    }

    template<typename _Tp> operator Mat_<_Tp>() const
    {
        Mat_<_Tp> m;
        op->assign(*this, m, DataType<_Tp>::type);
        return m;
    }

    MatExpr row(int y) const;
    MatExpr col(int x) const;
    MatExpr diag(int d=0) const;
    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;
    MatExpr operator()( const Rect& roi ) const;

    Mat cross(const Mat& m) const;
    double dot(const Mat& m) const;

    MatExpr t() const;
    MatExpr inv(int method = DECOMP_LU) const;
    MatExpr mul(const MatExpr& e, double scale=1) const;
    MatExpr mul(const Mat& m, double scale=1) const;

    Size size() const;
    int type() const;

    const MatOp* op;
    int flags;

    Mat a, b, c;
    double alpha, beta;
    Scalar s;
};


 MatExpr operator + (const Mat& a, const Mat& b);
 MatExpr operator + (const Mat& a, const Scalar& s);
 MatExpr operator + (const Scalar& s, const Mat& a);
 MatExpr operator + (const MatExpr& e, const Mat& m);
 MatExpr operator + (const Mat& m, const MatExpr& e);
 MatExpr operator + (const MatExpr& e, const Scalar& s);
 MatExpr operator + (const Scalar& s, const MatExpr& e);
 MatExpr operator + (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator - (const Mat& a, const Mat& b);
 MatExpr operator - (const Mat& a, const Scalar& s);
 MatExpr operator - (const Scalar& s, const Mat& a);
 MatExpr operator - (const MatExpr& e, const Mat& m);
 MatExpr operator - (const Mat& m, const MatExpr& e);
 MatExpr operator - (const MatExpr& e, const Scalar& s);
 MatExpr operator - (const Scalar& s, const MatExpr& e);
 MatExpr operator - (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator - (const Mat& m);
 MatExpr operator - (const MatExpr& e);

 MatExpr operator * (const Mat& a, const Mat& b);
 MatExpr operator * (const Mat& a, double s);
 MatExpr operator * (double s, const Mat& a);
 MatExpr operator * (const MatExpr& e, const Mat& m);
 MatExpr operator * (const Mat& m, const MatExpr& e);
 MatExpr operator * (const MatExpr& e, double s);
 MatExpr operator * (double s, const MatExpr& e);
 MatExpr operator * (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator / (const Mat& a, const Mat& b);
 MatExpr operator / (const Mat& a, double s);
 MatExpr operator / (double s, const Mat& a);
 MatExpr operator / (const MatExpr& e, const Mat& m);
 MatExpr operator / (const Mat& m, const MatExpr& e);
 MatExpr operator / (const MatExpr& e, double s);
 MatExpr operator / (double s, const MatExpr& e);
 MatExpr operator / (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator < (const Mat& a, const Mat& b);
 MatExpr operator < (const Mat& a, double s);
 MatExpr operator < (double s, const Mat& a);

 MatExpr operator <= (const Mat& a, const Mat& b);
 MatExpr operator <= (const Mat& a, double s);
 MatExpr operator <= (double s, const Mat& a);

 MatExpr operator == (const Mat& a, const Mat& b);
 MatExpr operator == (const Mat& a, double s);
 MatExpr operator == (double s, const Mat& a);

 MatExpr operator != (const Mat& a, const Mat& b);
 MatExpr operator != (const Mat& a, double s);
 MatExpr operator != (double s, const Mat& a);

 MatExpr operator >= (const Mat& a, const Mat& b);
 MatExpr operator >= (const Mat& a, double s);
 MatExpr operator >= (double s, const Mat& a);

 MatExpr operator > (const Mat& a, const Mat& b);
 MatExpr operator > (const Mat& a, double s);
 MatExpr operator > (double s, const Mat& a);

 MatExpr min(const Mat& a, const Mat& b);
 MatExpr min(const Mat& a, double s);
 MatExpr min(double s, const Mat& a);

 MatExpr max(const Mat& a, const Mat& b);
 MatExpr max(const Mat& a, double s);
 MatExpr max(double s, const Mat& a);

template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    return cv::min((const Mat&)a, (const Mat&)b);
}

template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, double s)
{
    return cv::min((const Mat&)a, s);
}

template<typename _Tp> static inline MatExpr min(double s, const Mat_<_Tp>& a)
{
    return cv::min((const Mat&)a, s);
}

template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    return cv::max((const Mat&)a, (const Mat&)b);
}

template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, double s)
{
    return cv::max((const Mat&)a, s);
}

template<typename _Tp> static inline MatExpr max(double s, const Mat_<_Tp>& a)
{
    return cv::max((const Mat&)a, s);
}

template<typename _Tp> static inline void min(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
{
    cv::min((const Mat&)a, (const Mat&)b, (Mat&)c);
}

template<typename _Tp> static inline void min(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
{
    cv::min((const Mat&)a, s, (Mat&)c);
}

template<typename _Tp> static inline void min(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
{
    cv::min((const Mat&)a, s, (Mat&)c);
}

template<typename _Tp> static inline void max(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
{
    cv::max((const Mat&)a, (const Mat&)b, (Mat&)c);
}

template<typename _Tp> static inline void max(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
{
    cv::max((const Mat&)a, s, (Mat&)c);
}

template<typename _Tp> static inline void max(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
{
    cv::max((const Mat&)a, s, (Mat&)c);
}


 MatExpr operator & (const Mat& a, const Mat& b);
 MatExpr operator & (const Mat& a, const Scalar& s);
 MatExpr operator & (const Scalar& s, const Mat& a);

 MatExpr operator | (const Mat& a, const Mat& b);
 MatExpr operator | (const Mat& a, const Scalar& s);
 MatExpr operator | (const Scalar& s, const Mat& a);

 MatExpr operator ^ (const Mat& a, const Mat& b);
 MatExpr operator ^ (const Mat& a, const Scalar& s);
 MatExpr operator ^ (const Scalar& s, const Mat& a);

 MatExpr operator ~(const Mat& m);

 MatExpr abs(const Mat& m);
 MatExpr abs(const MatExpr& e);

template<typename _Tp> static inline MatExpr abs(const Mat_<_Tp>& m)
{
    return cv::abs((const Mat&)m);
}



inline Mat& Mat::operator = (const MatExpr& e)
{
    e.op->assign(e, *this);
    return *this;
}

template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatExpr& e)
{
    e.op->assign(e, *this, DataType<_Tp>::type);
}

template<typename _Tp> Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)
{
    e.op->assign(e, *this, DataType<_Tp>::type);
    return *this;
}

static inline Mat& operator += (const Mat& a, const Mat& b)
{
    add(a, b, (Mat&)a);
    return (Mat&)a;
}

static inline Mat& operator += (const Mat& a, const Scalar& s)
{
    add(a, s, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    add(a, b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Scalar& s)
{
    add(a, s, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator += (const Mat& a, const MatExpr& b)
{
    b.op->augAssignAdd(b, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignAdd(b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator -= (const Mat& a, const Mat& b)
{
    subtract(a, b, (Mat&)a);
    return (Mat&)a;
}

static inline Mat& operator -= (const Mat& a, const Scalar& s)
{
    subtract(a, s, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    subtract(a, b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Scalar& s)
{
    subtract(a, s, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator -= (const Mat& a, const MatExpr& b)
{
    b.op->augAssignSubtract(b, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignSubtract(b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator *= (const Mat& a, const Mat& b)
{
    gemm(a, b, 1, Mat(), 0, (Mat&)a, 0);
    return (Mat&)a;
}

static inline Mat& operator *= (const Mat& a, double s)
{
    a.convertTo((Mat&)a, -1, s);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    gemm(a, b, 1, Mat(), 0, (Mat&)a, 0);
    return (Mat_<_Tp>&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, double s)
{
    a.convertTo((Mat&)a, -1, s);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator *= (const Mat& a, const MatExpr& b)
{
    b.op->augAssignMultiply(b, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignMultiply(b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator /= (const Mat& a, const Mat& b)
{
    divide(a, b, (Mat&)a);
    return (Mat&)a;
}

static inline Mat& operator /= (const Mat& a, double s)
{
    a.convertTo((Mat&)a, -1, 1./s);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    divide(a, b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, double s)
{
    a.convertTo((Mat&)a, -1, 1./s);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator /= (const Mat& a, const MatExpr& b)
{
    b.op->augAssignDivide(b, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignDivide(b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}



static inline Mat& operator &= (const Mat& a, const Mat& b)
{
    bitwise_and(a, b, (Mat&)a);
    return (Mat&)a;
}

static inline Mat& operator &= (const Mat& a, const Scalar& s)
{
    bitwise_and(a, s, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline Mat_<_Tp>&
operator &= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    bitwise_and(a, b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

template<typename _Tp> static inline Mat_<_Tp>&
operator &= (const Mat_<_Tp>& a, const Scalar& s)
{
    bitwise_and(a, s, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator |= (const Mat& a, const Mat& b)
{
    bitwise_or(a, b, (Mat&)a);
    return (Mat&)a;
}

static inline Mat& operator |= (const Mat& a, const Scalar& s)
{
    bitwise_or(a, s, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline Mat_<_Tp>&
operator |= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    bitwise_or(a, b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

template<typename _Tp> static inline Mat_<_Tp>&
operator |= (const Mat_<_Tp>& a, const Scalar& s)
{
    bitwise_or(a, s, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

static inline Mat& operator ^= (const Mat& a, const Mat& b)
{
    bitwise_xor(a, b, (Mat&)a);
    return (Mat&)a;
}

static inline Mat& operator ^= (const Mat& a, const Scalar& s)
{
    bitwise_xor(a, s, (Mat&)a);
    return (Mat&)a;
}

template<typename _Tp> static inline Mat_<_Tp>&
operator ^= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    bitwise_xor(a, b, (Mat&)a);
    return (Mat_<_Tp>&)a;
}

template<typename _Tp> static inline Mat_<_Tp>&
operator ^= (const Mat_<_Tp>& a, const Scalar& s)
{
    bitwise_xor(a, s, (Mat&)a);
    return (Mat_<_Tp>&)a;
}



template<typename _Tp> void split(const Mat& src, vector<Mat_<_Tp> >& mv)
{ split(src, (vector<Mat>&)mv ); }



template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(int rows, int cols)
{
    return Mat::zeros(rows, cols, DataType<_Tp>::type);
}

template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(Size sz)
{
    return Mat::zeros(sz, DataType<_Tp>::type);
}

template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(int rows, int cols)
{
    return Mat::ones(rows, cols, DataType<_Tp>::type);
}

template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(Size sz)
{
    return Mat::ones(sz, DataType<_Tp>::type);
}

template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(int rows, int cols)
{
    return Mat::eye(rows, cols, DataType<_Tp>::type);
}

template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(Size sz)
{
    return Mat::eye(sz, DataType<_Tp>::type);
}



inline MatConstIterator::MatConstIterator()
    : m(0), elemSize(0), ptr(0), sliceStart(0), sliceEnd(0) {}

inline MatConstIterator::MatConstIterator(const Mat* _m)
    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
{
    if( m && m->isContinuous() )
    {
        sliceStart = m->data;
        sliceEnd = sliceStart + m->total()*elemSize;
    }
    seek((const int*)0);
}

inline MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)
    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
{
    if(!!(m && m->dims <= 2)) ; else cv::error( cv::Exception(CV_StsAssert, "m && m->dims <= 2", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 1724) );
    if( m->isContinuous() )
    {
        sliceStart = m->data;
        sliceEnd = sliceStart + m->total()*elemSize;
    }
    int idx[]={_row, _col};
    seek(idx);
}

inline MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)
    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
{
    if(!!(m && m->dims <= 2)) ; else cv::error( cv::Exception(CV_StsAssert, "m && m->dims <= 2", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 1737) );
    if( m->isContinuous() )
    {
        sliceStart = m->data;
        sliceEnd = sliceStart + m->total()*elemSize;
    }
    int idx[]={_pt.y, _pt.x};
    seek(idx);
}

inline MatConstIterator::MatConstIterator(const MatConstIterator& it)
    : m(it.m), elemSize(it.elemSize), ptr(it.ptr), sliceStart(it.sliceStart), sliceEnd(it.sliceEnd)
{}

inline MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )
{
    m = it.m; elemSize = it.elemSize; ptr = it.ptr;
    sliceStart = it.sliceStart; sliceEnd = it.sliceEnd;
    return *this;
}

inline uchar* MatConstIterator::operator *() const { return ptr; }

inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)
{
    if( !m || ofs == 0 )
        return *this;
    ptrdiff_t ofsb = ofs*elemSize;
    ptr += ofsb;
    if( ptr < sliceStart || sliceEnd <= ptr )
    {
        ptr -= ofsb;
        seek(ofs, true);
    }
    return *this;
}

inline MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)
{ return (*this += -ofs); }

inline MatConstIterator& MatConstIterator::operator --()
{
    if( m && (ptr -= elemSize) < sliceStart )
    {
        ptr += elemSize;
        seek(-1, true);
    }
    return *this;
}

inline MatConstIterator MatConstIterator::operator --(int)
{
    MatConstIterator b = *this;
    *this += -1;
    return b;
}

inline MatConstIterator& MatConstIterator::operator ++()
{
    if( m && (ptr += elemSize) >= sliceEnd )
    {
        ptr -= elemSize;
        seek(1, true);
    }
    return *this;
}

inline MatConstIterator MatConstIterator::operator ++(int)
{
    MatConstIterator b = *this;
    *this += 1;
    return b;
}

template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_() {}

template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)
    : MatConstIterator(_m) {}

template<typename _Tp> inline MatConstIterator_<_Tp>::
    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)
    : MatConstIterator(_m, _row, _col) {}

template<typename _Tp> inline MatConstIterator_<_Tp>::
    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)
    : MatConstIterator(_m, _pt) {}

template<typename _Tp> inline MatConstIterator_<_Tp>::
    MatConstIterator_(const MatConstIterator_& it)
    : MatConstIterator(it) {}

template<typename _Tp> inline MatConstIterator_<_Tp>&
    MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )
{
    MatConstIterator::operator = (it);
    return *this;
}

template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }

template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)
{
    MatConstIterator::operator += (ofs);
    return *this;
}

template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)
{ return (*this += -ofs); }

template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()
{
    MatConstIterator::operator --();
    return *this;
}

template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)
{
    MatConstIterator_ b = *this;
    MatConstIterator::operator --();
    return b;
}

template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()
{
    MatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)
{
    MatConstIterator_ b = *this;
    MatConstIterator::operator ++();
    return b;
}

template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_() : MatConstIterator_<_Tp>() {}

template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)
    : MatConstIterator_<_Tp>(_m) {}

template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)
    : MatConstIterator_<_Tp>(_m, _row, _col) {}

template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, Point _pt)
    : MatConstIterator_<_Tp>(_m, _pt) {}

template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, const int* _idx)
    : MatConstIterator_<_Tp>(_m, _idx) {}

template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)
    : MatConstIterator_<_Tp>(it) {}

template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )
{
    MatConstIterator::operator = (it);
    return *this;
}

template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }

template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)
{
    MatConstIterator::operator += (ofs);
    return *this;
}

template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)
{
    MatConstIterator::operator += (-ofs);
    return *this;
}

template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()
{
    MatConstIterator::operator --();
    return *this;
}

template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)
{
    MatIterator_ b = *this;
    MatConstIterator::operator --();
    return b;
}

template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()
{
    MatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)
{
    MatIterator_ b = *this;
    MatConstIterator::operator ++();
    return b;
}

template<typename _Tp> inline Point MatConstIterator_<_Tp>::pos() const
{
    if( !m )
        return Point();
    ;
    if( m->isContinuous() )
    {
        ptrdiff_t ofs = (const _Tp*)ptr - (const _Tp*)m->data;
        int y = (int)(ofs / m->cols), x = (int)(ofs - (ptrdiff_t)y*m->cols);
        return Point(x, y);
    }
    else
    {
        ptrdiff_t ofs = (uchar*)ptr - m->data;
        int y = (int)(ofs / m->step), x = (int)((ofs - y*m->step)/sizeof(_Tp));
        return Point(x, y);
    }
}

static inline bool
operator == (const MatConstIterator& a, const MatConstIterator& b)
{ return a.m == b.m && a.ptr == b.ptr; }

template<typename _Tp> static inline bool
operator != (const MatConstIterator& a, const MatConstIterator& b)
{ return !(a == b); }

template<typename _Tp> static inline bool
operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
{ return a.m == b.m && a.ptr == b.ptr; }

template<typename _Tp> static inline bool
operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
{ return a.m != b.m || a.ptr != b.ptr; }

template<typename _Tp> static inline bool
operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
{ return a.m == b.m && a.ptr == b.ptr; }

template<typename _Tp> static inline bool
operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
{ return a.m != b.m || a.ptr != b.ptr; }

static inline bool
operator < (const MatConstIterator& a, const MatConstIterator& b)
{ return a.ptr < b.ptr; }

static inline bool
operator > (const MatConstIterator& a, const MatConstIterator& b)
{ return a.ptr > b.ptr; }

static inline bool
operator <= (const MatConstIterator& a, const MatConstIterator& b)
{ return a.ptr <= b.ptr; }

static inline bool
operator >= (const MatConstIterator& a, const MatConstIterator& b)
{ return a.ptr >= b.ptr; }

 ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a);

static inline MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)
{ MatConstIterator b = a; return b += ofs; }

static inline MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)
{ MatConstIterator b = a; return b += ofs; }

static inline MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)
{ MatConstIterator b = a; return b += -ofs; }

template<typename _Tp> static inline MatConstIterator_<_Tp>
operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
{ MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatConstIterator_<_Tp>&)t; }

template<typename _Tp> static inline MatConstIterator_<_Tp>
operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
{ MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatConstIterator_<_Tp>&)t; }

template<typename _Tp> static inline MatConstIterator_<_Tp>
operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
{ MatConstIterator t = (const MatConstIterator&)a - ofs; return (MatConstIterator_<_Tp>&)t; }

inline uchar* MatConstIterator::operator [](ptrdiff_t i) const
{ return *(*this + i); }

template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const
{ return *(_Tp*)MatConstIterator::operator [](i); }

template<typename _Tp> static inline MatIterator_<_Tp>
operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
{ MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatIterator_<_Tp>&)t; }

template<typename _Tp> static inline MatIterator_<_Tp>
operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)
{ MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatIterator_<_Tp>&)t; }

template<typename _Tp> static inline MatIterator_<_Tp>
operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
{ MatConstIterator t = (const MatConstIterator&)a - ofs; return (MatIterator_<_Tp>&)t; }

template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const
{ return *(*this + i); }

template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::begin() const
{ return Mat::begin<_Tp>(); }

template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::end() const
{ return Mat::end<_Tp>(); }

template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::begin()
{ return Mat::begin<_Tp>(); }

template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::end()
{ return Mat::end<_Tp>(); }

template<typename _Tp> inline MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m) : it(_m) {}

template<typename _Tp> template<typename T2> inline MatCommaInitializer_<_Tp>&
MatCommaInitializer_<_Tp>::operator , (T2 v)
{
    ;
    *this->it = _Tp(v); ++this->it;
    return *this;
}

template<typename _Tp> inline Mat_<_Tp> MatCommaInitializer_<_Tp>::operator *() const
{
    ;
    return Mat_<_Tp>(*this->it.m);
}

template<typename _Tp> inline MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const
{
    ;
    return Mat_<_Tp>(*this->it.m);
}

template<typename _Tp, typename T2> static inline MatCommaInitializer_<_Tp>
operator << (const Mat_<_Tp>& m, T2 val)
{
    MatCommaInitializer_<_Tp> commaInitializer((Mat_<_Tp>*)&m);
    return (commaInitializer, val);
}



inline SparseMat::SparseMat()
: flags(MAGIC_VAL), hdr(0)
{
}

inline SparseMat::SparseMat(int _dims, const int* _sizes, int _type)
: flags(MAGIC_VAL), hdr(0)
{
    create(_dims, _sizes, _type);
}

inline SparseMat::SparseMat(const SparseMat& m)
: flags(m.flags), hdr(m.hdr)
{
    addref();
}

inline SparseMat::~SparseMat()
{
    release();
}

inline SparseMat& SparseMat::operator = (const SparseMat& m)
{
    if( this != &m )
    {
        if( m.hdr )
            __sync_fetch_and_add(&m.hdr->refcount, 1);
        release();
        flags = m.flags;
        hdr = m.hdr;
    }
    return *this;
}

inline SparseMat& SparseMat::operator = (const Mat& m)
{ return (*this = SparseMat(m)); }

inline SparseMat SparseMat::clone() const
{
    SparseMat temp;
    this->copyTo(temp);
    return temp;
}


inline void SparseMat::assignTo( SparseMat& m, int _type ) const
{
    if( _type < 0 )
        m = *this;
    else
        convertTo(m, _type);
}

inline void SparseMat::addref()
{ if( hdr ) __sync_fetch_and_add(&hdr->refcount, 1); }

inline void SparseMat::release()
{
    if( hdr && __sync_fetch_and_add(&hdr->refcount, -1) == 1 )
        delete hdr;
    hdr = 0;
}

inline size_t SparseMat::elemSize() const
{ return (((((flags) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((flags) & ((1 << 3) - 1))*2) & 3)); }

inline size_t SparseMat::elemSize1() const
{ return ((((sizeof(size_t)<<28)|0x8442211) >> ((flags) & ((1 << 3) - 1))*4) & 15); }

inline int SparseMat::type() const
{ return ((flags) & ((1 << 3)*512 - 1)); }

inline int SparseMat::depth() const
{ return ((flags) & ((1 << 3) - 1)); }

inline int SparseMat::channels() const
{ return ((((flags) & ((512 - 1) << 3)) >> 3) + 1); }

inline const int* SparseMat::size() const
{
    return hdr ? hdr->size : 0;
}

inline int SparseMat::size(int i) const
{
    if( hdr )
    {
        ;
        return hdr->size[i];
    }
    return 0;
}

inline int SparseMat::dims() const
{
    return hdr ? hdr->dims : 0;
}

inline size_t SparseMat::nzcount() const
{
    return hdr ? hdr->nodeCount : 0;
}

inline size_t SparseMat::hash(int i0) const
{
    return (size_t)i0;
}

inline size_t SparseMat::hash(int i0, int i1) const
{
    return (size_t)(unsigned)i0*HASH_SCALE + (unsigned)i1;
}

inline size_t SparseMat::hash(int i0, int i1, int i2) const
{
    return ((size_t)(unsigned)i0*HASH_SCALE + (unsigned)i1)*HASH_SCALE + (unsigned)i2;
}

inline size_t SparseMat::hash(const int* idx) const
{
    size_t h = (unsigned)idx[0];
    if( !hdr )
        return 0;
    int i, d = hdr->dims;
    for( i = 1; i < d; i++ )
        h = h*HASH_SCALE + (unsigned)idx[i];
    return h;
}

template<typename _Tp> inline _Tp& SparseMat::ref(int i0, size_t* hashval)
{ return *(_Tp*)((SparseMat*)this)->ptr(i0, true, hashval); }

template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, size_t* hashval)
{ return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, true, hashval); }

template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)
{ return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, i2, true, hashval); }

template<typename _Tp> inline _Tp& SparseMat::ref(const int* idx, size_t* hashval)
{ return *(_Tp*)((SparseMat*)this)->ptr(idx, true, hashval); }

template<typename _Tp> inline _Tp SparseMat::value(int i0, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline _Tp SparseMat::value(const int* idx, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline const _Tp* SparseMat::find(int i0, size_t* hashval) const
{ return (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval); }

template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const
{ return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval); }

template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const
{ return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval); }

template<typename _Tp> inline const _Tp* SparseMat::find(const int* idx, size_t* hashval) const
{ return (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval); }

template<typename _Tp> inline _Tp& SparseMat::value(Node* n)
{ return *(_Tp*)((uchar*)n + hdr->valueOffset); }

template<typename _Tp> inline const _Tp& SparseMat::value(const Node* n) const
{ return *(const _Tp*)((const uchar*)n + hdr->valueOffset); }

inline SparseMat::Node* SparseMat::node(size_t nidx)
{ return (Node*)&hdr->pool[nidx]; }

inline const SparseMat::Node* SparseMat::node(size_t nidx) const
{ return (const Node*)&hdr->pool[nidx]; }

inline SparseMatIterator SparseMat::begin()
{ return SparseMatIterator(this); }

inline SparseMatConstIterator SparseMat::begin() const
{ return SparseMatConstIterator(this); }

inline SparseMatIterator SparseMat::end()
{ SparseMatIterator it(this); it.seekEnd(); return it; }

inline SparseMatConstIterator SparseMat::end() const
{ SparseMatConstIterator it(this); it.seekEnd(); return it; }

template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::begin()
{ return SparseMatIterator_<_Tp>(this); }

template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::begin() const
{ return SparseMatConstIterator_<_Tp>(this); }

template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::end()
{ SparseMatIterator_<_Tp> it(this); it.seekEnd(); return it; }

template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::end() const
{ SparseMatConstIterator_<_Tp> it(this); it.seekEnd(); return it; }


inline SparseMatConstIterator::SparseMatConstIterator()
: m(0), hashidx(0), ptr(0)
{
}

inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)
: m(it.m), hashidx(it.hashidx), ptr(it.ptr)
{
}

static inline bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
{ return it1.m == it2.m && it1.ptr == it2.ptr; }

static inline bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
{ return !(it1 == it2); }


inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)
{
    if( this != &it )
    {
        m = it.m;
        hashidx = it.hashidx;
        ptr = it.ptr;
    }
    return *this;
}

template<typename _Tp> inline const _Tp& SparseMatConstIterator::value() const
{ return *(_Tp*)ptr; }

inline const SparseMat::Node* SparseMatConstIterator::node() const
{
    return ptr && m && m->hdr ?
        (const SparseMat::Node*)(ptr - m->hdr->valueOffset) : 0;
}

inline SparseMatConstIterator SparseMatConstIterator::operator ++(int)
{
    SparseMatConstIterator it = *this;
    ++*this;
    return it;
}


inline void SparseMatConstIterator::seekEnd()
{
    if( m && m->hdr )
    {
        hashidx = m->hdr->hashtab.size();
        ptr = 0;
    }
}

inline SparseMatIterator::SparseMatIterator()
{}

inline SparseMatIterator::SparseMatIterator(SparseMat* _m)
: SparseMatConstIterator(_m)
{}

inline SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)
: SparseMatConstIterator(it)
{
}

inline SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)
{
    (SparseMatConstIterator&)*this = it;
    return *this;
}

template<typename _Tp> inline _Tp& SparseMatIterator::value() const
{ return *(_Tp*)ptr; }

inline SparseMat::Node* SparseMatIterator::node() const
{
    return (SparseMat::Node*)SparseMatConstIterator::node();
}

inline SparseMatIterator& SparseMatIterator::operator ++()
{
    SparseMatConstIterator::operator ++();
    return *this;
}

inline SparseMatIterator SparseMatIterator::operator ++(int)
{
    SparseMatIterator it = *this;
    ++*this;
    return it;
}


template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_()
{ flags = MAGIC_VAL | DataType<_Tp>::type; }

template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)
: SparseMat(_dims, _sizes, DataType<_Tp>::type)
{}

template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat& m)
{
    if( m.type() == DataType<_Tp>::type )
        *this = (const SparseMat_<_Tp>&)m;
    else
        m.convertTo(this, DataType<_Tp>::type);
}

template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)
{
    this->flags = m.flags;
    this->hdr = m.hdr;
    if( this->hdr )
        __sync_fetch_and_add(&this->hdr->refcount, 1);
}

template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const Mat& m)
{
    SparseMat sm(m);
    *this = sm;
}

template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const CvSparseMat* m)
{
    SparseMat sm(m);
    *this = sm;
}

template<typename _Tp> inline SparseMat_<_Tp>&
SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)
{
    if( this != &m )
    {
        if( m.hdr ) __sync_fetch_and_add(&m.hdr->refcount, 1);
        release();
        flags = m.flags;
        hdr = m.hdr;
    }
    return *this;
}

template<typename _Tp> inline SparseMat_<_Tp>&
SparseMat_<_Tp>::operator = (const SparseMat& m)
{
    if( m.type() == DataType<_Tp>::type )
        return (*this = (const SparseMat_<_Tp>&)m);
    m.convertTo(*this, DataType<_Tp>::type);
    return *this;
}

template<typename _Tp> inline SparseMat_<_Tp>&
SparseMat_<_Tp>::operator = (const Mat& m)
{ return (*this = SparseMat(m)); }

template<typename _Tp> inline SparseMat_<_Tp>
SparseMat_<_Tp>::clone() const
{
    SparseMat_<_Tp> m;
    this->copyTo(m);
    return m;
}

template<typename _Tp> inline void
SparseMat_<_Tp>::create(int _dims, const int* _sizes)
{
    SparseMat::create(_dims, _sizes, DataType<_Tp>::type);
}

template<typename _Tp> inline
SparseMat_<_Tp>::operator CvSparseMat*() const
{
    return SparseMat::operator CvSparseMat*();
}

template<typename _Tp> inline int SparseMat_<_Tp>::type() const
{ return DataType<_Tp>::type; }

template<typename _Tp> inline int SparseMat_<_Tp>::depth() const
{ return DataType<_Tp>::depth; }

template<typename _Tp> inline int SparseMat_<_Tp>::channels() const
{ return DataType<_Tp>::channels; }

template<typename _Tp> inline _Tp&
SparseMat_<_Tp>::ref(int i0, size_t* hashval)
{ return SparseMat::ref<_Tp>(i0, hashval); }

template<typename _Tp> inline _Tp
SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const
{ return SparseMat::value<_Tp>(i0, hashval); }

template<typename _Tp> inline _Tp&
SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)
{ return SparseMat::ref<_Tp>(i0, i1, hashval); }

template<typename _Tp> inline _Tp
SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const
{ return SparseMat::value<_Tp>(i0, i1, hashval); }

template<typename _Tp> inline _Tp&
SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)
{ return SparseMat::ref<_Tp>(i0, i1, i2, hashval); }

template<typename _Tp> inline _Tp
SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const
{ return SparseMat::value<_Tp>(i0, i1, i2, hashval); }

template<typename _Tp> inline _Tp&
SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)
{ return SparseMat::ref<_Tp>(idx, hashval); }

template<typename _Tp> inline _Tp
SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const
{ return SparseMat::value<_Tp>(idx, hashval); }

template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()
{ return SparseMatIterator_<_Tp>(this); }

template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const
{ return SparseMatConstIterator_<_Tp>(this); }

template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()
{ SparseMatIterator_<_Tp> it(this); it.seekEnd(); return it; }

template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const
{ SparseMatConstIterator_<_Tp> it(this); it.seekEnd(); return it; }

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()
{}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)
: SparseMatConstIterator(_m)
{}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat* _m)
: SparseMatConstIterator(_m)
{
    if(!!(_m->type() == DataType<_Tp>::type)) ; else cv::error( cv::Exception(CV_StsAssert, "_m->type() == DataType<_Tp>::type", __func__, "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/mat.hpp", 2537) );
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)
: SparseMatConstIterator(it)
{}

template<typename _Tp> inline SparseMatConstIterator_<_Tp>&
SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)
{ return reinterpret_cast<SparseMatConstIterator_<_Tp>&>
    (*reinterpret_cast<SparseMatConstIterator*>(this) =
     reinterpret_cast<const SparseMatConstIterator&>(it)); }

template<typename _Tp> inline const _Tp&
SparseMatConstIterator_<_Tp>::operator *() const
{ return *(const _Tp*)this->ptr; }

template<typename _Tp> inline SparseMatConstIterator_<_Tp>&
SparseMatConstIterator_<_Tp>::operator ++()
{
    SparseMatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline SparseMatConstIterator_<_Tp>
SparseMatConstIterator_<_Tp>::operator ++(int)
{
    SparseMatConstIterator it = *this;
    SparseMatConstIterator::operator ++();
    return it;
}

template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_()
{}

template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)
: SparseMatConstIterator_<_Tp>(_m)
{}

template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat* _m)
: SparseMatConstIterator_<_Tp>(_m)
{}

template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)
: SparseMatConstIterator_<_Tp>(it)
{}

template<typename _Tp> inline SparseMatIterator_<_Tp>&
SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)
{ return reinterpret_cast<SparseMatIterator_<_Tp>&>
    (*reinterpret_cast<SparseMatConstIterator*>(this) =
     reinterpret_cast<const SparseMatConstIterator&>(it)); }

template<typename _Tp> inline _Tp&
SparseMatIterator_<_Tp>::operator *() const
{ return *(_Tp*)this->ptr; }

template<typename _Tp> inline SparseMatIterator_<_Tp>&
SparseMatIterator_<_Tp>::operator ++()
{
    SparseMatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline SparseMatIterator_<_Tp>
SparseMatIterator_<_Tp>::operator ++(int)
{
    SparseMatIterator it = *this;
    SparseMatConstIterator::operator ++();
    return it;
}

}
#4788 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/core/core.hpp" 2
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/miniflann.hpp" 1
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/miniflann.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/defines.h" 1
#33 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/defines.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/config.h" 1
#34 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/defines.h" 2
#78 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/defines.h"
namespace cvflann {


enum flann_algorithm_t
{
    FLANN_INDEX_LINEAR = 0,
    FLANN_INDEX_KDTREE = 1,
    FLANN_INDEX_KMEANS = 2,
    FLANN_INDEX_COMPOSITE = 3,
    FLANN_INDEX_KDTREE_SINGLE = 4,
    FLANN_INDEX_HIERARCHICAL = 5,
    FLANN_INDEX_LSH = 6,
    FLANN_INDEX_SAVED = 254,
    FLANN_INDEX_AUTOTUNED = 255,


    LINEAR = 0,
    KDTREE = 1,
    KMEANS = 2,
    COMPOSITE = 3,
    KDTREE_SINGLE = 4,
    SAVED = 254,
    AUTOTUNED = 255
};



enum flann_centers_init_t
{
    FLANN_CENTERS_RANDOM = 0,
    FLANN_CENTERS_GONZALES = 1,
    FLANN_CENTERS_KMEANSPP = 2,


    CENTERS_RANDOM = 0,
    CENTERS_GONZALES = 1,
    CENTERS_KMEANSPP = 2
};

enum flann_log_level_t
{
    FLANN_LOG_NONE = 0,
    FLANN_LOG_FATAL = 1,
    FLANN_LOG_ERROR = 2,
    FLANN_LOG_WARN = 3,
    FLANN_LOG_INFO = 4
};

enum flann_distance_t
{
    FLANN_DIST_EUCLIDEAN = 1,
    FLANN_DIST_L2 = 1,
    FLANN_DIST_MANHATTAN = 2,
    FLANN_DIST_L1 = 2,
    FLANN_DIST_MINKOWSKI = 3,
    FLANN_DIST_MAX = 4,
    FLANN_DIST_HIST_INTERSECT = 5,
    FLANN_DIST_HELLINGER = 6,
    FLANN_DIST_CHI_SQUARE = 7,
    FLANN_DIST_CS = 7,
    FLANN_DIST_KULLBACK_LEIBLER = 8,
    FLANN_DIST_KL = 8,
    FLANN_DIST_HAMMING = 9,


    EUCLIDEAN = 1,
    MANHATTAN = 2,
    MINKOWSKI = 3,
    MAX_DIST = 4,
    HIST_INTERSECT = 5,
    HELLINGER = 6,
    CS = 7,
    KL = 8,
    KULLBACK_LEIBLER = 8
};

enum flann_datatype_t
{
    FLANN_INT8 = 0,
    FLANN_INT16 = 1,
    FLANN_INT32 = 2,
    FLANN_INT64 = 3,
    FLANN_UINT8 = 4,
    FLANN_UINT16 = 5,
    FLANN_UINT32 = 6,
    FLANN_UINT64 = 7,
    FLANN_FLOAT32 = 8,
    FLANN_FLOAT64 = 9
};

enum
{
    FLANN_CHECKS_UNLIMITED = -1,
    FLANN_CHECKS_AUTOTUNED = -2
};

}
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/flann/miniflann.hpp" 2

namespace cv
{

namespace flann
{

struct IndexParams
{
    IndexParams();
    ~IndexParams();

    std::string getString(const std::string& key, const std::string& defaultVal=std::string()) const;
    int getInt(const std::string& key, int defaultVal=-1) const;
    double getDouble(const std::string& key, double defaultVal=-1) const;

    void setString(const std::string& key, const std::string& value);
    void setInt(const std::string& key, int value);
    void setDouble(const std::string& key, double value);
    void setFloat(const std::string& key, float value);
    void setBool(const std::string& key, bool value);
    void setAlgorithm(int value);

    void getAll(std::vector<std::string>& names,
                std::vector<int>& types,
                std::vector<std::string>& strValues,
                std::vector<double>& numValues) const;

    void* params;
};

struct KDTreeIndexParams : public IndexParams
{
    KDTreeIndexParams(int trees=4);
};

struct LinearIndexParams : public IndexParams
{
    LinearIndexParams();
};

struct CompositeIndexParams : public IndexParams
{
    CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11,
                         cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = 0.2 );
};

struct AutotunedIndexParams : public IndexParams
{
    AutotunedIndexParams(float target_precision = 0.8, float build_weight = 0.01,
                         float memory_weight = 0, float sample_fraction = 0.1);
};

struct HierarchicalClusteringIndexParams : public IndexParams
{
    HierarchicalClusteringIndexParams(int branching = 32,
                      cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, int trees = 4, int leaf_size = 100 );
};

struct KMeansIndexParams : public IndexParams
{
    KMeansIndexParams(int branching = 32, int iterations = 11,
                      cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = 0.2 );
};

struct LshIndexParams : public IndexParams
{
    LshIndexParams(int table_number, int key_size, int multi_probe_level);
};

struct SavedIndexParams : public IndexParams
{
    SavedIndexParams(const std::string& filename);
};

struct SearchParams : public IndexParams
{
    SearchParams( int checks = 32, float eps = 0, bool sorted = true );
};

class Index
{
public:
    Index();
    Index(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2);
    virtual ~Index();

    virtual void build(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2);
    virtual void knnSearch(InputArray query, OutputArray indices,
                   OutputArray dists, int knn, const SearchParams& params=SearchParams());

    virtual int radiusSearch(InputArray query, OutputArray indices,
                             OutputArray dists, double radius, int maxResults,
                             const SearchParams& params=SearchParams());

    virtual void save(const std::string& filename) const;
    virtual bool load(InputArray features, const std::string& filename);
    virtual void release();
    cvflann::flann_distance_t getDistance() const;
    cvflann::flann_algorithm_t getAlgorithm() const;

protected:
    cvflann::flann_distance_t distType;
    cvflann::flann_algorithm_t algo;
    int featureType;
    void* index;
};

} }
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc_c.h" 1
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc_c.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/types_c.h" 1
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/types_c.h"
extern "C" {



typedef struct CvConnectedComp
{
    double area;
    CvScalar value;
    CvRect rect;
    CvSeq* contour;

}
CvConnectedComp;


enum
{
    CV_BLUR_NO_SCALE =0,
    CV_BLUR =1,
    CV_GAUSSIAN =2,
    CV_MEDIAN =3,
    CV_BILATERAL =4
};


enum
{
    CV_GAUSSIAN_5x5 = 7
};


enum
{
    CV_SCHARR =-1,
    CV_MAX_SOBEL_KSIZE =7
};


enum
{
    CV_BGR2BGRA =0,
    CV_RGB2RGBA =CV_BGR2BGRA,

    CV_BGRA2BGR =1,
    CV_RGBA2RGB =CV_BGRA2BGR,

    CV_BGR2RGBA =2,
    CV_RGB2BGRA =CV_BGR2RGBA,

    CV_RGBA2BGR =3,
    CV_BGRA2RGB =CV_RGBA2BGR,

    CV_BGR2RGB =4,
    CV_RGB2BGR =CV_BGR2RGB,

    CV_BGRA2RGBA =5,
    CV_RGBA2BGRA =CV_BGRA2RGBA,

    CV_BGR2GRAY =6,
    CV_RGB2GRAY =7,
    CV_GRAY2BGR =8,
    CV_GRAY2RGB =CV_GRAY2BGR,
    CV_GRAY2BGRA =9,
    CV_GRAY2RGBA =CV_GRAY2BGRA,
    CV_BGRA2GRAY =10,
    CV_RGBA2GRAY =11,

    CV_BGR2BGR565 =12,
    CV_RGB2BGR565 =13,
    CV_BGR5652BGR =14,
    CV_BGR5652RGB =15,
    CV_BGRA2BGR565 =16,
    CV_RGBA2BGR565 =17,
    CV_BGR5652BGRA =18,
    CV_BGR5652RGBA =19,

    CV_GRAY2BGR565 =20,
    CV_BGR5652GRAY =21,

    CV_BGR2BGR555 =22,
    CV_RGB2BGR555 =23,
    CV_BGR5552BGR =24,
    CV_BGR5552RGB =25,
    CV_BGRA2BGR555 =26,
    CV_RGBA2BGR555 =27,
    CV_BGR5552BGRA =28,
    CV_BGR5552RGBA =29,

    CV_GRAY2BGR555 =30,
    CV_BGR5552GRAY =31,

    CV_BGR2XYZ =32,
    CV_RGB2XYZ =33,
    CV_XYZ2BGR =34,
    CV_XYZ2RGB =35,

    CV_BGR2YCrCb =36,
    CV_RGB2YCrCb =37,
    CV_YCrCb2BGR =38,
    CV_YCrCb2RGB =39,

    CV_BGR2HSV =40,
    CV_RGB2HSV =41,

    CV_BGR2Lab =44,
    CV_RGB2Lab =45,

    CV_BayerBG2BGR =46,
    CV_BayerGB2BGR =47,
    CV_BayerRG2BGR =48,
    CV_BayerGR2BGR =49,

    CV_BayerBG2RGB =CV_BayerRG2BGR,
    CV_BayerGB2RGB =CV_BayerGR2BGR,
    CV_BayerRG2RGB =CV_BayerBG2BGR,
    CV_BayerGR2RGB =CV_BayerGB2BGR,

    CV_BGR2Luv =50,
    CV_RGB2Luv =51,
    CV_BGR2HLS =52,
    CV_RGB2HLS =53,

    CV_HSV2BGR =54,
    CV_HSV2RGB =55,

    CV_Lab2BGR =56,
    CV_Lab2RGB =57,
    CV_Luv2BGR =58,
    CV_Luv2RGB =59,
    CV_HLS2BGR =60,
    CV_HLS2RGB =61,

    CV_BayerBG2BGR_VNG =62,
    CV_BayerGB2BGR_VNG =63,
    CV_BayerRG2BGR_VNG =64,
    CV_BayerGR2BGR_VNG =65,

    CV_BayerBG2RGB_VNG =CV_BayerRG2BGR_VNG,
    CV_BayerGB2RGB_VNG =CV_BayerGR2BGR_VNG,
    CV_BayerRG2RGB_VNG =CV_BayerBG2BGR_VNG,
    CV_BayerGR2RGB_VNG =CV_BayerGB2BGR_VNG,

    CV_BGR2HSV_FULL = 66,
    CV_RGB2HSV_FULL = 67,
    CV_BGR2HLS_FULL = 68,
    CV_RGB2HLS_FULL = 69,

    CV_HSV2BGR_FULL = 70,
    CV_HSV2RGB_FULL = 71,
    CV_HLS2BGR_FULL = 72,
    CV_HLS2RGB_FULL = 73,

    CV_LBGR2Lab = 74,
    CV_LRGB2Lab = 75,
    CV_LBGR2Luv = 76,
    CV_LRGB2Luv = 77,

    CV_Lab2LBGR = 78,
    CV_Lab2LRGB = 79,
    CV_Luv2LBGR = 80,
    CV_Luv2LRGB = 81,

    CV_BGR2YUV = 82,
    CV_RGB2YUV = 83,
    CV_YUV2BGR = 84,
    CV_YUV2RGB = 85,

    CV_BayerBG2GRAY = 86,
    CV_BayerGB2GRAY = 87,
    CV_BayerRG2GRAY = 88,
    CV_BayerGR2GRAY = 89,


    CV_YUV2RGB_NV12 = 90,
    CV_YUV2BGR_NV12 = 91,
    CV_YUV2RGB_NV21 = 92,
    CV_YUV2BGR_NV21 = 93,
    CV_YUV420sp2RGB = CV_YUV2RGB_NV21,
    CV_YUV420sp2BGR = CV_YUV2BGR_NV21,

    CV_YUV2RGBA_NV12 = 94,
    CV_YUV2BGRA_NV12 = 95,
    CV_YUV2RGBA_NV21 = 96,
    CV_YUV2BGRA_NV21 = 97,
    CV_YUV420sp2RGBA = CV_YUV2RGBA_NV21,
    CV_YUV420sp2BGRA = CV_YUV2BGRA_NV21,

    CV_YUV2RGB_YV12 = 98,
    CV_YUV2BGR_YV12 = 99,
    CV_YUV2RGB_IYUV = 100,
    CV_YUV2BGR_IYUV = 101,
    CV_YUV2RGB_I420 = CV_YUV2RGB_IYUV,
    CV_YUV2BGR_I420 = CV_YUV2BGR_IYUV,
    CV_YUV420p2RGB = CV_YUV2RGB_YV12,
    CV_YUV420p2BGR = CV_YUV2BGR_YV12,

    CV_YUV2RGBA_YV12 = 102,
    CV_YUV2BGRA_YV12 = 103,
    CV_YUV2RGBA_IYUV = 104,
    CV_YUV2BGRA_IYUV = 105,
    CV_YUV2RGBA_I420 = CV_YUV2RGBA_IYUV,
    CV_YUV2BGRA_I420 = CV_YUV2BGRA_IYUV,
    CV_YUV420p2RGBA = CV_YUV2RGBA_YV12,
    CV_YUV420p2BGRA = CV_YUV2BGRA_YV12,

    CV_YUV2GRAY_420 = 106,
    CV_YUV2GRAY_NV21 = CV_YUV2GRAY_420,
    CV_YUV2GRAY_NV12 = CV_YUV2GRAY_420,
    CV_YUV2GRAY_YV12 = CV_YUV2GRAY_420,
    CV_YUV2GRAY_IYUV = CV_YUV2GRAY_420,
    CV_YUV2GRAY_I420 = CV_YUV2GRAY_420,
    CV_YUV420sp2GRAY = CV_YUV2GRAY_420,
    CV_YUV420p2GRAY = CV_YUV2GRAY_420,


    CV_YUV2RGB_UYVY = 107,
    CV_YUV2BGR_UYVY = 108,


    CV_YUV2RGB_Y422 = CV_YUV2RGB_UYVY,
    CV_YUV2BGR_Y422 = CV_YUV2BGR_UYVY,
    CV_YUV2RGB_UYNV = CV_YUV2RGB_UYVY,
    CV_YUV2BGR_UYNV = CV_YUV2BGR_UYVY,

    CV_YUV2RGBA_UYVY = 111,
    CV_YUV2BGRA_UYVY = 112,


    CV_YUV2RGBA_Y422 = CV_YUV2RGBA_UYVY,
    CV_YUV2BGRA_Y422 = CV_YUV2BGRA_UYVY,
    CV_YUV2RGBA_UYNV = CV_YUV2RGBA_UYVY,
    CV_YUV2BGRA_UYNV = CV_YUV2BGRA_UYVY,

    CV_YUV2RGB_YUY2 = 115,
    CV_YUV2BGR_YUY2 = 116,
    CV_YUV2RGB_YVYU = 117,
    CV_YUV2BGR_YVYU = 118,
    CV_YUV2RGB_YUYV = CV_YUV2RGB_YUY2,
    CV_YUV2BGR_YUYV = CV_YUV2BGR_YUY2,
    CV_YUV2RGB_YUNV = CV_YUV2RGB_YUY2,
    CV_YUV2BGR_YUNV = CV_YUV2BGR_YUY2,

    CV_YUV2RGBA_YUY2 = 119,
    CV_YUV2BGRA_YUY2 = 120,
    CV_YUV2RGBA_YVYU = 121,
    CV_YUV2BGRA_YVYU = 122,
    CV_YUV2RGBA_YUYV = CV_YUV2RGBA_YUY2,
    CV_YUV2BGRA_YUYV = CV_YUV2BGRA_YUY2,
    CV_YUV2RGBA_YUNV = CV_YUV2RGBA_YUY2,
    CV_YUV2BGRA_YUNV = CV_YUV2BGRA_YUY2,

    CV_YUV2GRAY_UYVY = 123,
    CV_YUV2GRAY_YUY2 = 124,

    CV_YUV2GRAY_Y422 = CV_YUV2GRAY_UYVY,
    CV_YUV2GRAY_UYNV = CV_YUV2GRAY_UYVY,
    CV_YUV2GRAY_YVYU = CV_YUV2GRAY_YUY2,
    CV_YUV2GRAY_YUYV = CV_YUV2GRAY_YUY2,
    CV_YUV2GRAY_YUNV = CV_YUV2GRAY_YUY2,


    CV_RGBA2mRGBA = 125,
    CV_mRGBA2RGBA = 126,

    CV_RGB2YUV_I420 = 127,
    CV_BGR2YUV_I420 = 128,
    CV_RGB2YUV_IYUV = CV_RGB2YUV_I420,
    CV_BGR2YUV_IYUV = CV_BGR2YUV_I420,

    CV_RGBA2YUV_I420 = 129,
    CV_BGRA2YUV_I420 = 130,
    CV_RGBA2YUV_IYUV = CV_RGBA2YUV_I420,
    CV_BGRA2YUV_IYUV = CV_BGRA2YUV_I420,
    CV_RGB2YUV_YV12 = 131,
    CV_BGR2YUV_YV12 = 132,
    CV_RGBA2YUV_YV12 = 133,
    CV_BGRA2YUV_YV12 = 134,

    CV_COLORCVT_MAX = 135
};



enum
{
    CV_INTER_NN =0,
    CV_INTER_LINEAR =1,
    CV_INTER_CUBIC =2,
    CV_INTER_AREA =3,
    CV_INTER_LANCZOS4 =4
};


enum
{
    CV_WARP_FILL_OUTLIERS =8,
    CV_WARP_INVERSE_MAP =16
};


enum
{
    CV_SHAPE_RECT =0,
    CV_SHAPE_CROSS =1,
    CV_SHAPE_ELLIPSE =2,
    CV_SHAPE_CUSTOM =100
};


enum
{
    CV_MOP_ERODE =0,
    CV_MOP_DILATE =1,
    CV_MOP_OPEN =2,
    CV_MOP_CLOSE =3,
    CV_MOP_GRADIENT =4,
    CV_MOP_TOPHAT =5,
    CV_MOP_BLACKHAT =6
};


typedef struct CvMoments
{
    double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;
    double mu20, mu11, mu02, mu30, mu21, mu12, mu03;
    double inv_sqrt_m00;
}
CvMoments;


typedef struct CvHuMoments
{
    double hu1, hu2, hu3, hu4, hu5, hu6, hu7;
}
CvHuMoments;


enum
{
    CV_TM_SQDIFF =0,
    CV_TM_SQDIFF_NORMED =1,
    CV_TM_CCORR =2,
    CV_TM_CCORR_NORMED =3,
    CV_TM_CCOEFF =4,
    CV_TM_CCOEFF_NORMED =5
};

typedef float ( * CvDistanceFunction)( const float* a, const float* b, void* user_param );


enum
{
    CV_RETR_EXTERNAL=0,
    CV_RETR_LIST=1,
    CV_RETR_CCOMP=2,
    CV_RETR_TREE=3,
    CV_RETR_FLOODFILL=4
};


enum
{
    CV_CHAIN_CODE=0,
    CV_CHAIN_APPROX_NONE=1,
    CV_CHAIN_APPROX_SIMPLE=2,
    CV_CHAIN_APPROX_TC89_L1=3,
    CV_CHAIN_APPROX_TC89_KCOS=4,
    CV_LINK_RUNS=5
};





typedef struct _CvContourScanner* CvContourScanner;


typedef struct CvChainPtReader
{
    int header_size; CvSeq* seq; CvSeqBlock* block; schar* ptr; schar* block_min; schar* block_max; int delta_index; schar* prev_elem;
    char code;
    CvPoint pt;
    schar deltas[8][2];
}
CvChainPtReader;
#447 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/types_c.h"
typedef size_t CvSubdiv2DEdge;
#462 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/types_c.h"
typedef struct CvQuadEdge2D
{
    int flags; struct CvSubdiv2DPoint* pt[4]; CvSubdiv2DEdge next[4];
}
CvQuadEdge2D;

typedef struct CvSubdiv2DPoint
{
    int flags; CvSubdiv2DEdge first; CvPoint2D32f pt; int id;
}
CvSubdiv2DPoint;
#482 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/types_c.h"
typedef struct CvSubdiv2D
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first; CvSetElem* free_elems; int active_count; CvSet* edges; int quad_edges; int is_geometry_valid; CvSubdiv2DEdge recent_edge; CvPoint2D32f topleft; CvPoint2D32f bottomright;
}
CvSubdiv2D;


typedef enum CvSubdiv2DPointLocation
{
    CV_PTLOC_ERROR = -2,
    CV_PTLOC_OUTSIDE_RECT = -1,
    CV_PTLOC_INSIDE = 0,
    CV_PTLOC_VERTEX = 1,
    CV_PTLOC_ON_EDGE = 2
}
CvSubdiv2DPointLocation;

typedef enum CvNextEdgeType
{
    CV_NEXT_AROUND_ORG = 0x00,
    CV_NEXT_AROUND_DST = 0x22,
    CV_PREV_AROUND_ORG = 0x11,
    CV_PREV_AROUND_DST = 0x33,
    CV_NEXT_AROUND_LEFT = 0x13,
    CV_NEXT_AROUND_RIGHT = 0x31,
    CV_PREV_AROUND_LEFT = 0x20,
    CV_PREV_AROUND_RIGHT = 0x02
}
CvNextEdgeType;






enum
{
    CV_POLY_APPROX_DP = 0
};


enum
{
    CV_CONTOURS_MATCH_I1 =1,
    CV_CONTOURS_MATCH_I2 =2,
    CV_CONTOURS_MATCH_I3 =3
};


enum
{
    CV_CLOCKWISE =1,
    CV_COUNTER_CLOCKWISE =2
};



typedef struct CvConvexityDefect
{
    CvPoint* start;
    CvPoint* end;
    CvPoint* depth_point;
    float depth;
} CvConvexityDefect;



enum
{
    CV_COMP_CORREL =0,
    CV_COMP_CHISQR =1,
    CV_COMP_INTERSECT =2,
    CV_COMP_BHATTACHARYYA =3,
    CV_COMP_HELLINGER =CV_COMP_BHATTACHARYYA
};


enum
{
    CV_DIST_MASK_3 =3,
    CV_DIST_MASK_5 =5,
    CV_DIST_MASK_PRECISE =0
};


enum
{
  CV_DIST_LABEL_CCOMP = 0,
  CV_DIST_LABEL_PIXEL = 1
};


enum
{
    CV_DIST_USER =-1,
    CV_DIST_L1 =1,
    CV_DIST_L2 =2,
    CV_DIST_C =3,
    CV_DIST_L12 =4,
    CV_DIST_FAIR =5,
    CV_DIST_WELSCH =6,
    CV_DIST_HUBER =7
};



enum
{
    CV_THRESH_BINARY =0,
    CV_THRESH_BINARY_INV =1,
    CV_THRESH_TRUNC =2,
    CV_THRESH_TOZERO =3,
    CV_THRESH_TOZERO_INV =4,
    CV_THRESH_MASK =7,
    CV_THRESH_OTSU =8

};


enum
{
    CV_ADAPTIVE_THRESH_MEAN_C =0,
    CV_ADAPTIVE_THRESH_GAUSSIAN_C =1
};


enum
{
    CV_FLOODFILL_FIXED_RANGE =(1 << 16),
    CV_FLOODFILL_MASK_ONLY =(1 << 17)
};



enum
{
    CV_CANNY_L2_GRADIENT =(1 << 31)
};


enum
{
    CV_HOUGH_STANDARD =0,
    CV_HOUGH_PROBABILISTIC =1,
    CV_HOUGH_MULTI_SCALE =2,
    CV_HOUGH_GRADIENT =3
};



struct CvFeatureTree;
struct CvLSH;
struct CvLSHOperations;


}
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc_c.h" 2


extern "C" {





extern "C" void cvAcc( const CvArr* image, CvArr* sum,
                   const CvArr* mask = __null );


extern "C" void cvSquareAcc( const CvArr* image, CvArr* sqsum,
                         const CvArr* mask = __null );


extern "C" void cvMultiplyAcc( const CvArr* image1, const CvArr* image2, CvArr* acc,
                           const CvArr* mask = __null );


extern "C" void cvRunningAvg( const CvArr* image, CvArr* acc, double alpha,
                          const CvArr* mask = __null );







extern "C" void cvCopyMakeBorder( const CvArr* src, CvArr* dst, CvPoint offset,
                              int bordertype, CvScalar value = cvScalarAll(0));


extern "C" void cvSmooth( const CvArr* src, CvArr* dst,
                      int smoothtype = CV_GAUSSIAN,
                      int size1 = 3,
                      int size2 = 0,
                      double sigma1 = 0,
                      double sigma2 = 0);


extern "C" void cvFilter2D( const CvArr* src, CvArr* dst, const CvMat* kernel,
                        CvPoint anchor = cvPoint(-1,-1));


extern "C" void cvIntegral( const CvArr* image, CvArr* sum,
                       CvArr* sqsum = __null,
                       CvArr* tilted_sum = __null);






extern "C" void cvPyrDown( const CvArr* src, CvArr* dst,
                        int filter = CV_GAUSSIAN_5x5 );






extern "C" void cvPyrUp( const CvArr* src, CvArr* dst,
                      int filter = CV_GAUSSIAN_5x5 );


extern "C" CvMat** cvCreatePyramid( const CvArr* img, int extra_layers, double rate,
                                const CvSize* layer_sizes = 0,
                                CvArr* bufarr = 0,
                                int calc = 1,
                                int filter = CV_GAUSSIAN_5x5 );


extern "C" void cvReleasePyramid( CvMat*** pyramid, int extra_layers );



extern "C" void cvPyrMeanShiftFiltering( const CvArr* src, CvArr* dst,
    double sp, double sr, int max_level = 1,
    CvTermCriteria termcrit = cvTermCriteria(1 +2,5,1));


extern "C" void cvWatershed( const CvArr* image, CvArr* markers );




extern "C" void cvSobel( const CvArr* src, CvArr* dst,
                    int xorder, int yorder,
                    int aperture_size = 3);


extern "C" void cvLaplace( const CvArr* src, CvArr* dst,
                      int aperture_size = 3 );


extern "C" void cvCvtColor( const CvArr* src, CvArr* dst, int code );



extern "C" void cvResize( const CvArr* src, CvArr* dst,
                       int interpolation = CV_INTER_LINEAR);


extern "C" void cvWarpAffine( const CvArr* src, CvArr* dst, const CvMat* map_matrix,
                           int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                           CvScalar fillval = cvScalarAll(0) );


extern "C" CvMat* cvGetAffineTransform( const CvPoint2D32f * src,
                                    const CvPoint2D32f * dst,
                                    CvMat * map_matrix );


extern "C" CvMat* cv2DRotationMatrix( CvPoint2D32f center, double angle,
                                   double scale, CvMat* map_matrix );


extern "C" void cvWarpPerspective( const CvArr* src, CvArr* dst, const CvMat* map_matrix,
                                int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                                CvScalar fillval = cvScalarAll(0) );


extern "C" CvMat* cvGetPerspectiveTransform( const CvPoint2D32f* src,
                                         const CvPoint2D32f* dst,
                                         CvMat* map_matrix );


extern "C" void cvRemap( const CvArr* src, CvArr* dst,
                      const CvArr* mapx, const CvArr* mapy,
                      int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                      CvScalar fillval = cvScalarAll(0) );


extern "C" void cvConvertMaps( const CvArr* mapx, const CvArr* mapy,
                            CvArr* mapxy, CvArr* mapalpha );


extern "C" void cvLogPolar( const CvArr* src, CvArr* dst,
                         CvPoint2D32f center, double M,
                         int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS);


extern "C" void cvLinearPolar( const CvArr* src, CvArr* dst,
                         CvPoint2D32f center, double maxRadius,
                         int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS);


extern "C" void cvUndistort2( const CvArr* src, CvArr* dst,
                          const CvMat* camera_matrix,
                          const CvMat* distortion_coeffs,
                          const CvMat* new_camera_matrix = 0 );



extern "C" void cvInitUndistortMap( const CvMat* camera_matrix,
                                const CvMat* distortion_coeffs,
                                CvArr* mapx, CvArr* mapy );


extern "C" void cvInitUndistortRectifyMap( const CvMat* camera_matrix,
                                       const CvMat* dist_coeffs,
                                       const CvMat *R, const CvMat* new_camera_matrix,
                                       CvArr* mapx, CvArr* mapy );



extern "C" void cvUndistortPoints( const CvMat* src, CvMat* dst,
                               const CvMat* camera_matrix,
                               const CvMat* dist_coeffs,
                               const CvMat* R = 0,
                               const CvMat* P = 0);


extern "C" IplConvKernel* cvCreateStructuringElementEx(
            int cols, int rows, int anchor_x, int anchor_y,
            int shape, int* values = __null );


extern "C" void cvReleaseStructuringElement( IplConvKernel** element );



extern "C" void cvErode( const CvArr* src, CvArr* dst,
                      IplConvKernel* element = __null,
                      int iterations = 1 );



extern "C" void cvDilate( const CvArr* src, CvArr* dst,
                       IplConvKernel* element = __null,
                       int iterations = 1 );


extern "C" void cvMorphologyEx( const CvArr* src, CvArr* dst,
                             CvArr* temp, IplConvKernel* element,
                             int operation, int iterations = 1 );


extern "C" void cvMoments( const CvArr* arr, CvMoments* moments, int binary = 0);


extern "C" double cvGetSpatialMoment( CvMoments* moments, int x_order, int y_order );
extern "C" double cvGetCentralMoment( CvMoments* moments, int x_order, int y_order );
extern "C" double cvGetNormalizedCentralMoment( CvMoments* moments,
                                             int x_order, int y_order );


extern "C" void cvGetHuMoments( CvMoments* moments, CvHuMoments* hu_moments );





extern "C" int cvSampleLine( const CvArr* image, CvPoint pt1, CvPoint pt2, void* buffer,
                          int connectivity = 8);




extern "C" void cvGetRectSubPix( const CvArr* src, CvArr* dst, CvPoint2D32f center );







extern "C" void cvGetQuadrangleSubPix( const CvArr* src, CvArr* dst,
                                    const CvMat* map_matrix );



extern "C" void cvMatchTemplate( const CvArr* image, const CvArr* templ,
                              CvArr* result, int method );



extern "C" float cvCalcEMD2( const CvArr* signature1,
                          const CvArr* signature2,
                          int distance_type,
                          CvDistanceFunction distance_func = __null,
                          const CvArr* cost_matrix = __null,
                          CvArr* flow = __null,
                          float* lower_bound = __null,
                          void* userdata = __null);







extern "C" int cvFindContours( CvArr* image, CvMemStorage* storage, CvSeq** first_contour,
                            int header_size = sizeof(CvContour),
                            int mode = CV_RETR_LIST,
                            int method = CV_CHAIN_APPROX_SIMPLE,
                            CvPoint offset = cvPoint(0,0));






extern "C" CvContourScanner cvStartFindContours( CvArr* image, CvMemStorage* storage,
                            int header_size = sizeof(CvContour),
                            int mode = CV_RETR_LIST,
                            int method = CV_CHAIN_APPROX_SIMPLE,
                            CvPoint offset = cvPoint(0,0));


extern "C" CvSeq* cvFindNextContour( CvContourScanner scanner );




extern "C" void cvSubstituteContour( CvContourScanner scanner, CvSeq* new_contour );



extern "C" CvSeq* cvEndFindContours( CvContourScanner* scanner );


extern "C" CvSeq* cvApproxChains( CvSeq* src_seq, CvMemStorage* storage,
                            int method = CV_CHAIN_APPROX_SIMPLE,
                            double parameter = 0,
                            int minimal_perimeter = 0,
                            int recursive = 0);




extern "C" void cvStartReadChainPoints( CvChain* chain, CvChainPtReader* reader );


extern "C" CvPoint cvReadChainPoint( CvChainPtReader* reader );
#352 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc_c.h"
extern "C" CvSeq* cvApproxPoly( const void* src_seq,
                             int header_size, CvMemStorage* storage,
                             int method, double eps,
                             int recursive = 0);


extern "C" double cvArcLength( const void* curve,
                            CvSlice slice = cvSlice(0, 0x3fffffff),
                            int is_closed = -1);

inline double cvContourPerimeter( const void* contour )
{
    return cvArcLength( contour, cvSlice(0, 0x3fffffff), 1 );
}




extern "C" CvRect cvBoundingRect( CvArr* points, int update = 0 );


extern "C" double cvContourArea( const CvArr* contour,
                              CvSlice slice = cvSlice(0, 0x3fffffff),
                              int oriented = 0);


extern "C" CvBox2D cvMinAreaRect2( const CvArr* points,
                                CvMemStorage* storage = __null);


extern "C" int cvMinEnclosingCircle( const CvArr* points,
                                  CvPoint2D32f* center, float* radius );


extern "C" double cvMatchShapes( const void* object1, const void* object2,
                              int method, double parameter = 0);


extern "C" CvSeq* cvConvexHull2( const CvArr* input,
                             void* hull_storage = __null,
                             int orientation = CV_CLOCKWISE,
                             int return_points = 0);


extern "C" int cvCheckContourConvexity( const CvArr* contour );



extern "C" CvSeq* cvConvexityDefects( const CvArr* contour, const CvArr* convexhull,
                                   CvMemStorage* storage = __null);


extern "C" CvBox2D cvFitEllipse2( const CvArr* points );


extern "C" CvRect cvMaxRect( const CvRect* rect1, const CvRect* rect2 );


extern "C" void cvBoxPoints( CvBox2D box, CvPoint2D32f pt[4] );



extern "C" CvSeq* cvPointSeqFromMat( int seq_kind, const CvArr* mat,
                                 CvContour* contour_header,
                                 CvSeqBlock* block );





extern "C" double cvPointPolygonTest( const CvArr* contour,
                                  CvPoint2D32f pt, int measure_dist );






extern "C" CvHistogram* cvCreateHist( int dims, int* sizes, int type,
                                   float** ranges = __null,
                                   int uniform = 1);


extern "C" void cvSetHistBinRanges( CvHistogram* hist, float** ranges,
                                int uniform = 1);


extern "C" CvHistogram* cvMakeHistHeaderForArray(
                            int dims, int* sizes, CvHistogram* hist,
                            float* data, float** ranges = __null,
                            int uniform = 1);


extern "C" void cvReleaseHist( CvHistogram** hist );


extern "C" void cvClearHist( CvHistogram* hist );


extern "C" void cvGetMinMaxHistValue( const CvHistogram* hist,
                                   float* min_value, float* max_value,
                                   int* min_idx = __null,
                                   int* max_idx = __null);




extern "C" void cvNormalizeHist( CvHistogram* hist, double factor );



extern "C" void cvThreshHist( CvHistogram* hist, double threshold );



extern "C" double cvCompareHist( const CvHistogram* hist1,
                              const CvHistogram* hist2,
                              int method);



extern "C" void cvCopyHist( const CvHistogram* src, CvHistogram** dst );




extern "C" void cvCalcBayesianProb( CvHistogram** src, int number,
                                CvHistogram** dst);


extern "C" void cvCalcArrHist( CvArr** arr, CvHistogram* hist,
                            int accumulate = 0,
                            const CvArr* mask = __null );

inline void cvCalcHist( IplImage** image, CvHistogram* hist,
                             int accumulate = 0,
                             const CvArr* mask = __null )
{
    cvCalcArrHist( (CvArr**)image, hist, accumulate, mask );
}


extern "C" void cvCalcArrBackProject( CvArr** image, CvArr* dst,
                                   const CvHistogram* hist );





extern "C" void cvCalcArrBackProjectPatch( CvArr** image, CvArr* dst, CvSize range,
                                        CvHistogram* hist, int method,
                                        double factor );





extern "C" void cvCalcProbDensity( const CvHistogram* hist1, const CvHistogram* hist2,
                                CvHistogram* dst_hist, double scale = 255 );


extern "C" void cvEqualizeHist( const CvArr* src, CvArr* dst );



extern "C" void cvDistTransform( const CvArr* src, CvArr* dst,
                              int distance_type = CV_DIST_L2,
                              int mask_size = 3,
                              const float* mask = __null,
                              CvArr* labels = __null,
                              int labelType = CV_DIST_LABEL_CCOMP);




extern "C" double cvThreshold( const CvArr* src, CvArr* dst,
                            double threshold, double max_value,
                            int threshold_type );






extern "C" void cvAdaptiveThreshold( const CvArr* src, CvArr* dst, double max_value,
                                  int adaptive_method = CV_ADAPTIVE_THRESH_MEAN_C,
                                  int threshold_type = CV_THRESH_BINARY,
                                  int block_size = 3,
                                  double param1 = 5);


extern "C" void cvFloodFill( CvArr* image, CvPoint seed_point,
                          CvScalar new_val, CvScalar lo_diff = cvScalarAll(0),
                          CvScalar up_diff = cvScalarAll(0),
                          CvConnectedComp* comp = __null,
                          int flags = 4,
                          CvArr* mask = __null);






extern "C" void cvCanny( const CvArr* image, CvArr* edges, double threshold1,
                      double threshold2, int aperture_size = 3 );




extern "C" void cvPreCornerDetect( const CvArr* image, CvArr* corners,
                               int aperture_size = 3 );



extern "C" void cvCornerEigenValsAndVecs( const CvArr* image, CvArr* eigenvv,
                                       int block_size, int aperture_size = 3 );



extern "C" void cvCornerMinEigenVal( const CvArr* image, CvArr* eigenval,
                                  int block_size, int aperture_size = 3 );



extern "C" void cvCornerHarris( const CvArr* image, CvArr* harris_responce,
                             int block_size, int aperture_size = 3,
                             double k = 0.04 );


extern "C" void cvFindCornerSubPix( const CvArr* image, CvPoint2D32f* corners,
                                 int count, CvSize win, CvSize zero_zone,
                                 CvTermCriteria criteria );



extern "C" void cvGoodFeaturesToTrack( const CvArr* image, CvArr* eig_image,
                                    CvArr* temp_image, CvPoint2D32f* corners,
                                    int* corner_count, double quality_level,
                                    double min_distance,
                                    const CvArr* mask = __null,
                                    int block_size = 3,
                                    int use_harris = 0,
                                    double k = 0.04 );
#603 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc_c.h"
extern "C" CvSeq* cvHoughLines2( CvArr* image, void* line_storage, int method,
                              double rho, double theta, int threshold,
                              double param1 = 0, double param2 = 0);


extern "C" CvSeq* cvHoughCircles( CvArr* image, void* circle_storage,
                              int method, double dp, double min_dist,
                              double param1 = 100,
                              double param2 = 100,
                              int min_radius = 0,
                              int max_radius = 0);


extern "C" void cvFitLine( const CvArr* points, int dist_type, double param,
                        double reps, double aeps, float* line );


}
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc.hpp" 1
#58 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc.hpp"
namespace cv
{


enum { BORDER_REPLICATE=1, BORDER_CONSTANT=0,
       BORDER_REFLECT=2, BORDER_WRAP=3,
       BORDER_REFLECT_101=4, BORDER_REFLECT101=BORDER_REFLECT_101,
       BORDER_TRANSPARENT=5,
       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };


 int borderInterpolate( int p, int len, int borderType );
#80 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc.hpp"
class BaseRowFilter
{
public:

    BaseRowFilter();

    virtual ~BaseRowFilter();

    virtual void operator()(const uchar* src, uchar* dst,
                            int width, int cn) = 0;
    int ksize, anchor;
};
#107 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc.hpp"
class BaseColumnFilter
{
public:

    BaseColumnFilter();

    virtual ~BaseColumnFilter();

    virtual void operator()(const uchar** src, uchar* dst, int dststep,
                            int dstcount, int width) = 0;

    virtual void reset();
    int ksize, anchor;
};
#133 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc.hpp"
class BaseFilter
{
public:

    BaseFilter();

    virtual ~BaseFilter();

    virtual void operator()(const uchar** src, uchar* dst, int dststep,
                            int dstcount, int width, int cn) = 0;

    virtual void reset();
    Size ksize;
    Point anchor;
};
#222 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc.hpp"
class FilterEngine
{
public:

    FilterEngine();

    FilterEngine(const Ptr<BaseFilter>& _filter2D,
                 const Ptr<BaseRowFilter>& _rowFilter,
                 const Ptr<BaseColumnFilter>& _columnFilter,
                 int srcType, int dstType, int bufType,
                 int _rowBorderType=BORDER_REPLICATE,
                 int _columnBorderType=-1,
                 const Scalar& _borderValue=Scalar());

    virtual ~FilterEngine();

    void init(const Ptr<BaseFilter>& _filter2D,
              const Ptr<BaseRowFilter>& _rowFilter,
              const Ptr<BaseColumnFilter>& _columnFilter,
              int srcType, int dstType, int bufType,
              int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1,
              const Scalar& _borderValue=Scalar());

    virtual int start(Size wholeSize, Rect roi, int maxBufRows=-1);

    virtual int start(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1),
                      bool isolated=false, int maxBufRows=-1);

    virtual int proceed(const uchar* src, int srcStep, int srcCount,
                        uchar* dst, int dstStep);

    virtual void apply( const Mat& src, Mat& dst,
                        const Rect& srcRoi=Rect(0,0,-1,-1),
                        Point dstOfs=Point(0,0),
                        bool isolated=false);

    bool isSeparable() const { return (const BaseFilter*)filter2D == 0; }

    int remainingInputRows() const;
    int remainingOutputRows() const;

    int srcType, dstType, bufType;
    Size ksize;
    Point anchor;
    int maxWidth;
    Size wholeSize;
    Rect roi;
    int dx1, dx2;
    int rowBorderType, columnBorderType;
    vector<int> borderTab;
    int borderElemSize;
    vector<uchar> ringBuf;
    vector<uchar> srcRow;
    vector<uchar> constBorderValue;
    vector<uchar> constBorderRow;
    int bufStep, startY, startY0, endY, rowCount, dstY;
    vector<uchar*> rows;

    Ptr<BaseFilter> filter2D;
    Ptr<BaseRowFilter> rowFilter;
    Ptr<BaseColumnFilter> columnFilter;
};


enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,
       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };


 int getKernelType(InputArray kernel, Point anchor);


 Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType,
                                            InputArray kernel, int anchor,
                                            int symmetryType);


 Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType,
                                            InputArray kernel, int anchor,
                                            int symmetryType, double delta=0,
                                            int bits=0);


 Ptr<BaseFilter> getLinearFilter(int srcType, int dstType,
                                           InputArray kernel,
                                           Point anchor=Point(-1,-1),
                                           double delta=0, int bits=0);


 Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType,
                          InputArray rowKernel, InputArray columnKernel,
                          Point anchor=Point(-1,-1), double delta=0,
                          int rowBorderType=BORDER_DEFAULT,
                          int columnBorderType=-1,
                          const Scalar& borderValue=Scalar());


 Ptr<FilterEngine> createLinearFilter(int srcType, int dstType,
                 InputArray kernel, Point _anchor=Point(-1,-1),
                 double delta=0, int rowBorderType=BORDER_DEFAULT,
                 int columnBorderType=-1, const Scalar& borderValue=Scalar());


 Mat getGaussianKernel( int ksize, double sigma, int ktype=6 );


 Ptr<FilterEngine> createGaussianFilter( int type, Size ksize,
                                    double sigma1, double sigma2=0,
                                    int borderType=BORDER_DEFAULT);

 void getDerivKernels( OutputArray kx, OutputArray ky,
                                   int dx, int dy, int ksize,
                                   bool normalize=false, int ktype=5 );

 Ptr<FilterEngine> createDerivFilter( int srcType, int dstType,
                                        int dx, int dy, int ksize,
                                        int borderType=BORDER_DEFAULT );

 Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType,
                                              int ksize, int anchor=-1);

 Ptr<BaseColumnFilter> getColumnSumFilter( int sumType, int dstType,
                                                     int ksize, int anchor=-1,
                                                     double scale=1);

 Ptr<FilterEngine> createBoxFilter( int srcType, int dstType, Size ksize,
                                              Point anchor=Point(-1,-1),
                                              bool normalize=true,
                                              int borderType=BORDER_DEFAULT);


 Mat getGaborKernel( Size ksize, double sigma, double theta, double lambd,
                                 double gamma, double psi=3.1415926535897932384626433832795*0.5, int ktype=6 );


enum { MORPH_ERODE=CV_MOP_ERODE, MORPH_DILATE=CV_MOP_DILATE,
       MORPH_OPEN=CV_MOP_OPEN, MORPH_CLOSE=CV_MOP_CLOSE,
       MORPH_GRADIENT=CV_MOP_GRADIENT, MORPH_TOPHAT=CV_MOP_TOPHAT,
       MORPH_BLACKHAT=CV_MOP_BLACKHAT };


 Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor=-1);

 Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor=-1);

 Ptr<BaseFilter> getMorphologyFilter(int op, int type, InputArray kernel,
                                               Point anchor=Point(-1,-1));


static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(double(1.79769313486231570815e+308L)); }


 Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel,
                    Point anchor=Point(-1,-1), int rowBorderType=BORDER_CONSTANT,
                    int columnBorderType=-1,
                    const Scalar& borderValue=morphologyDefaultBorderValue());


enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };

 Mat getStructuringElement(int shape, Size ksize, Point anchor=Point(-1,-1));

template<> void Ptr<IplConvKernel>::delete_obj();


 void copyMakeBorder( InputArray src, OutputArray dst,
                                int top, int bottom, int left, int right,
                                int borderType, const Scalar& value=Scalar() );


 void medianBlur( InputArray src, OutputArray dst, int ksize );

 void GaussianBlur( InputArray src,
                                               OutputArray dst, Size ksize,
                                               double sigmaX, double sigmaY=0,
                                               int borderType=BORDER_DEFAULT );

 void bilateralFilter( InputArray src, OutputArray dst, int d,
                                   double sigmaColor, double sigmaSpace,
                                   int borderType=BORDER_DEFAULT );

 void boxFilter( InputArray src, OutputArray dst, int ddepth,
                             Size ksize, Point anchor=Point(-1,-1),
                             bool normalize=true,
                             int borderType=BORDER_DEFAULT );

 void blur( InputArray src, OutputArray dst,
                        Size ksize, Point anchor=Point(-1,-1),
                        int borderType=BORDER_DEFAULT );


 void filter2D( InputArray src, OutputArray dst, int ddepth,
                            InputArray kernel, Point anchor=Point(-1,-1),
                            double delta=0, int borderType=BORDER_DEFAULT );


 void sepFilter2D( InputArray src, OutputArray dst, int ddepth,
                               InputArray kernelX, InputArray kernelY,
                               Point anchor=Point(-1,-1),
                               double delta=0, int borderType=BORDER_DEFAULT );


 void Sobel( InputArray src, OutputArray dst, int ddepth,
                         int dx, int dy, int ksize=3,
                         double scale=1, double delta=0,
                         int borderType=BORDER_DEFAULT );


 void Scharr( InputArray src, OutputArray dst, int ddepth,
                          int dx, int dy, double scale=1, double delta=0,
                          int borderType=BORDER_DEFAULT );


 void Laplacian( InputArray src, OutputArray dst, int ddepth,
                             int ksize=1, double scale=1, double delta=0,
                             int borderType=BORDER_DEFAULT );


 void Canny( InputArray image, OutputArray edges,
                         double threshold1, double threshold2,
                         int apertureSize=3, bool L2gradient=false );


 void cornerMinEigenVal( InputArray src, OutputArray dst,
                                   int blockSize, int ksize=3,
                                   int borderType=BORDER_DEFAULT );


 void cornerHarris( InputArray src, OutputArray dst, int blockSize,
                                int ksize, double k,
                                int borderType=BORDER_DEFAULT );


 void eigen2x2( const float* a, float* e, int n );


 void cornerEigenValsAndVecs( InputArray src, OutputArray dst,
                                          int blockSize, int ksize,
                                          int borderType=BORDER_DEFAULT );


 void preCornerDetect( InputArray src, OutputArray dst, int ksize,
                                   int borderType=BORDER_DEFAULT );


 void cornerSubPix( InputArray image, InputOutputArray corners,
                                Size winSize, Size zeroZone,
                                TermCriteria criteria );


 void goodFeaturesToTrack( InputArray image, OutputArray corners,
                                     int maxCorners, double qualityLevel, double minDistance,
                                     InputArray mask=noArray(), int blockSize=3,
                                     bool useHarrisDetector=false, double k=0.04 );


 void HoughLines( InputArray image, OutputArray lines,
                              double rho, double theta, int threshold,
                              double srn=0, double stn=0 );


 void HoughLinesP( InputArray image, OutputArray lines,
                               double rho, double theta, int threshold,
                               double minLineLength=0, double maxLineGap=0 );


 void HoughCircles( InputArray image, OutputArray circles,
                               int method, double dp, double minDist,
                               double param1=100, double param2=100,
                               int minRadius=0, int maxRadius=0 );

enum
{
    GHT_POSITION = 0,
    GHT_SCALE = 1,
    GHT_ROTATION = 2
};




class GeneralizedHough : public Algorithm
{
public:
    static Ptr<GeneralizedHough> create(int method);

    virtual ~GeneralizedHough();


    void setTemplate(InputArray templ, int cannyThreshold = 100, Point templCenter = Point(-1, -1));
    void setTemplate(InputArray edges, InputArray dx, InputArray dy, Point templCenter = Point(-1, -1));


    void detect(InputArray image, OutputArray positions, OutputArray votes = cv::noArray(), int cannyThreshold = 100);
    void detect(InputArray edges, InputArray dx, InputArray dy, OutputArray positions, OutputArray votes = cv::noArray());

    void release();

protected:
    virtual void setTemplateImpl(const Mat& edges, const Mat& dx, const Mat& dy, Point templCenter) = 0;
    virtual void detectImpl(const Mat& edges, const Mat& dx, const Mat& dy, OutputArray positions, OutputArray votes) = 0;
    virtual void releaseImpl() = 0;

private:
    Mat edges_, dx_, dy_;
};


 void erode( InputArray src, OutputArray dst, InputArray kernel,
                         Point anchor=Point(-1,-1), int iterations=1,
                         int borderType=BORDER_CONSTANT,
                         const Scalar& borderValue=morphologyDefaultBorderValue() );


 void dilate( InputArray src, OutputArray dst, InputArray kernel,
                          Point anchor=Point(-1,-1), int iterations=1,
                          int borderType=BORDER_CONSTANT,
                          const Scalar& borderValue=morphologyDefaultBorderValue() );


 void morphologyEx( InputArray src, OutputArray dst,
                                int op, InputArray kernel,
                                Point anchor=Point(-1,-1), int iterations=1,
                                int borderType=BORDER_CONSTANT,
                                const Scalar& borderValue=morphologyDefaultBorderValue() );


enum
{
    INTER_NEAREST=CV_INTER_NN,
    INTER_LINEAR=CV_INTER_LINEAR,
    INTER_CUBIC=CV_INTER_CUBIC,
    INTER_AREA=CV_INTER_AREA,
    INTER_LANCZOS4=CV_INTER_LANCZOS4,
    INTER_MAX=7,
    WARP_INVERSE_MAP=CV_WARP_INVERSE_MAP
};


 void resize( InputArray src, OutputArray dst,
                          Size dsize, double fx=0, double fy=0,
                          int interpolation=INTER_LINEAR );


 void warpAffine( InputArray src, OutputArray dst,
                              InputArray M, Size dsize,
                              int flags=INTER_LINEAR,
                              int borderMode=BORDER_CONSTANT,
                              const Scalar& borderValue=Scalar());


 void warpPerspective( InputArray src, OutputArray dst,
                                   InputArray M, Size dsize,
                                   int flags=INTER_LINEAR,
                                   int borderMode=BORDER_CONSTANT,
                                   const Scalar& borderValue=Scalar());

enum
{
    INTER_BITS=5, INTER_BITS2=INTER_BITS*2,
    INTER_TAB_SIZE=(1<<INTER_BITS),
    INTER_TAB_SIZE2=INTER_TAB_SIZE*INTER_TAB_SIZE
};


 void remap( InputArray src, OutputArray dst,
                         InputArray map1, InputArray map2,
                         int interpolation, int borderMode=BORDER_CONSTANT,
                         const Scalar& borderValue=Scalar());


 void convertMaps( InputArray map1, InputArray map2,
                               OutputArray dstmap1, OutputArray dstmap2,
                               int dstmap1type, bool nninterpolation=false );


 Mat getRotationMatrix2D( Point2f center, double angle, double scale );

 Mat getPerspectiveTransform( const Point2f src[], const Point2f dst[] );

 Mat getAffineTransform( const Point2f src[], const Point2f dst[] );

 void invertAffineTransform( InputArray M, OutputArray iM );

 Mat getPerspectiveTransform( InputArray src, InputArray dst );
 Mat getAffineTransform( InputArray src, InputArray dst );


 void getRectSubPix( InputArray image, Size patchSize,
                                 Point2f center, OutputArray patch, int patchType=-1 );


 void integral( InputArray src, OutputArray sum, int sdepth=-1 );


 void integral( InputArray src, OutputArray sum,
                                        OutputArray sqsum, int sdepth=-1 );

 void integral( InputArray src, OutputArray sum,
                                        OutputArray sqsum, OutputArray tilted,
                                        int sdepth=-1 );


 void accumulate( InputArray src, InputOutputArray dst,
                              InputArray mask=noArray() );

 void accumulateSquare( InputArray src, InputOutputArray dst,
                                    InputArray mask=noArray() );

 void accumulateProduct( InputArray src1, InputArray src2,
                                     InputOutputArray dst, InputArray mask=noArray() );

 void accumulateWeighted( InputArray src, InputOutputArray dst,
                                      double alpha, InputArray mask=noArray() );


 double PSNR(InputArray src1, InputArray src2);

 Point2d phaseCorrelate(InputArray src1, InputArray src2,
                                  InputArray window = noArray());
 Point2d phaseCorrelateRes(InputArray src1, InputArray src2,
                                    InputArray window, double* response = 0);
 void createHanningWindow(OutputArray dst, Size winSize, int type);


enum { THRESH_BINARY=CV_THRESH_BINARY, THRESH_BINARY_INV=CV_THRESH_BINARY_INV,
       THRESH_TRUNC=CV_THRESH_TRUNC, THRESH_TOZERO=CV_THRESH_TOZERO,
       THRESH_TOZERO_INV=CV_THRESH_TOZERO_INV, THRESH_MASK=CV_THRESH_MASK,
       THRESH_OTSU=CV_THRESH_OTSU };


 double threshold( InputArray src, OutputArray dst,
                               double thresh, double maxval, int type );


enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };


 void adaptiveThreshold( InputArray src, OutputArray dst,
                                     double maxValue, int adaptiveMethod,
                                     int thresholdType, int blockSize, double C );


 void pyrDown( InputArray src, OutputArray dst,
                           const Size& dstsize=Size(), int borderType=BORDER_DEFAULT );

 void pyrUp( InputArray src, OutputArray dst,
                         const Size& dstsize=Size(), int borderType=BORDER_DEFAULT );


 void buildPyramid( InputArray src, OutputArrayOfArrays dst,
                              int maxlevel, int borderType=BORDER_DEFAULT );


 void undistort( InputArray src, OutputArray dst,
                             InputArray cameraMatrix,
                             InputArray distCoeffs,
                             InputArray newCameraMatrix=noArray() );


 void initUndistortRectifyMap( InputArray cameraMatrix, InputArray distCoeffs,
                           InputArray R, InputArray newCameraMatrix,
                           Size size, int m1type, OutputArray map1, OutputArray map2 );

enum
{
    PROJ_SPHERICAL_ORTHO = 0,
    PROJ_SPHERICAL_EQRECT = 1
};


 float initWideAngleProjMap( InputArray cameraMatrix, InputArray distCoeffs,
                                         Size imageSize, int destImageWidth,
                                         int m1type, OutputArray map1, OutputArray map2,
                                         int projType=PROJ_SPHERICAL_EQRECT, double alpha=0);


 Mat getDefaultNewCameraMatrix( InputArray cameraMatrix, Size imgsize=Size(),
                                            bool centerPrincipalPoint=false );


 void undistortPoints( InputArray src, OutputArray dst,
                                   InputArray cameraMatrix, InputArray distCoeffs,
                                   InputArray R=noArray(), InputArray P=noArray());

template<> void Ptr<CvHistogram>::delete_obj();


 void calcHist( const Mat* images, int nimages,
                          const int* channels, InputArray mask,
                          OutputArray hist, int dims, const int* histSize,
                          const float** ranges, bool uniform=true, bool accumulate=false );


 void calcHist( const Mat* images, int nimages,
                          const int* channels, InputArray mask,
                          SparseMat& hist, int dims,
                          const int* histSize, const float** ranges,
                          bool uniform=true, bool accumulate=false );

 void calcHist( InputArrayOfArrays images,
                            const vector<int>& channels,
                            InputArray mask, OutputArray hist,
                            const vector<int>& histSize,
                            const vector<float>& ranges,
                            bool accumulate=false );


 void calcBackProject( const Mat* images, int nimages,
                                 const int* channels, InputArray hist,
                                 OutputArray backProject, const float** ranges,
                                 double scale=1, bool uniform=true );


 void calcBackProject( const Mat* images, int nimages,
                                 const int* channels, const SparseMat& hist,
                                 OutputArray backProject, const float** ranges,
                                 double scale=1, bool uniform=true );

 void calcBackProject( InputArrayOfArrays images, const vector<int>& channels,
                                   InputArray hist, OutputArray dst,
                                   const vector<float>& ranges,
                                   double scale );
#754 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/imgproc/imgproc.hpp"
 double compareHist( InputArray H1, InputArray H2, int method );


 double compareHist( const SparseMat& H1, const SparseMat& H2, int method );


 void equalizeHist( InputArray src, OutputArray dst );

class CLAHE : public Algorithm
{
public:
    virtual void apply(InputArray src, OutputArray dst) = 0;

    virtual void setClipLimit(double clipLimit) = 0;
    virtual double getClipLimit() const = 0;

    virtual void setTilesGridSize(Size tileGridSize) = 0;
    virtual Size getTilesGridSize() const = 0;

    virtual void collectGarbage() = 0;
};
 Ptr<CLAHE> createCLAHE(double clipLimit = 40.0, Size tileGridSize = Size(8, 8));

 float EMD( InputArray signature1, InputArray signature2,
                      int distType, InputArray cost=noArray(),
                      float* lowerBound=0, OutputArray flow=noArray() );


 void watershed( InputArray image, InputOutputArray markers );


 void pyrMeanShiftFiltering( InputArray src, OutputArray dst,
                                         double sp, double sr, int maxLevel=1,
                                         TermCriteria termcrit=TermCriteria(
                                            TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) );


enum
{
    GC_BGD = 0,
    GC_FGD = 1,
    GC_PR_BGD = 2,
    GC_PR_FGD = 3
};


enum
{
    GC_INIT_WITH_RECT = 0,
    GC_INIT_WITH_MASK = 1,
    GC_EVAL = 2
};


 void grabCut( InputArray img, InputOutputArray mask, Rect rect,
                           InputOutputArray bgdModel, InputOutputArray fgdModel,
                           int iterCount, int mode = GC_EVAL );

enum
{
    DIST_LABEL_CCOMP = 0,
    DIST_LABEL_PIXEL = 1
};


 void distanceTransform( InputArray src, OutputArray dst,
                                     OutputArray labels, int distanceType, int maskSize,
                                     int labelType=DIST_LABEL_CCOMP );


 void distanceTransform( InputArray src, OutputArray dst,
                                     int distanceType, int maskSize );

enum { FLOODFILL_FIXED_RANGE = 1 << 16, FLOODFILL_MASK_ONLY = 1 << 17 };


 int floodFill( InputOutputArray image,
                          Point seedPoint, Scalar newVal, Rect* rect=0,
                          Scalar loDiff=Scalar(), Scalar upDiff=Scalar(),
                          int flags=4 );


 int floodFill( InputOutputArray image, InputOutputArray mask,
                            Point seedPoint, Scalar newVal, Rect* rect=0,
                            Scalar loDiff=Scalar(), Scalar upDiff=Scalar(),
                            int flags=4 );


enum
{
    COLOR_BGR2BGRA =0,
    COLOR_RGB2RGBA =COLOR_BGR2BGRA,

    COLOR_BGRA2BGR =1,
    COLOR_RGBA2RGB =COLOR_BGRA2BGR,

    COLOR_BGR2RGBA =2,
    COLOR_RGB2BGRA =COLOR_BGR2RGBA,

    COLOR_RGBA2BGR =3,
    COLOR_BGRA2RGB =COLOR_RGBA2BGR,

    COLOR_BGR2RGB =4,
    COLOR_RGB2BGR =COLOR_BGR2RGB,

    COLOR_BGRA2RGBA =5,
    COLOR_RGBA2BGRA =COLOR_BGRA2RGBA,

    COLOR_BGR2GRAY =6,
    COLOR_RGB2GRAY =7,
    COLOR_GRAY2BGR =8,
    COLOR_GRAY2RGB =COLOR_GRAY2BGR,
    COLOR_GRAY2BGRA =9,
    COLOR_GRAY2RGBA =COLOR_GRAY2BGRA,
    COLOR_BGRA2GRAY =10,
    COLOR_RGBA2GRAY =11,

    COLOR_BGR2BGR565 =12,
    COLOR_RGB2BGR565 =13,
    COLOR_BGR5652BGR =14,
    COLOR_BGR5652RGB =15,
    COLOR_BGRA2BGR565 =16,
    COLOR_RGBA2BGR565 =17,
    COLOR_BGR5652BGRA =18,
    COLOR_BGR5652RGBA =19,

    COLOR_GRAY2BGR565 =20,
    COLOR_BGR5652GRAY =21,

    COLOR_BGR2BGR555 =22,
    COLOR_RGB2BGR555 =23,
    COLOR_BGR5552BGR =24,
    COLOR_BGR5552RGB =25,
    COLOR_BGRA2BGR555 =26,
    COLOR_RGBA2BGR555 =27,
    COLOR_BGR5552BGRA =28,
    COLOR_BGR5552RGBA =29,

    COLOR_GRAY2BGR555 =30,
    COLOR_BGR5552GRAY =31,

    COLOR_BGR2XYZ =32,
    COLOR_RGB2XYZ =33,
    COLOR_XYZ2BGR =34,
    COLOR_XYZ2RGB =35,

    COLOR_BGR2YCrCb =36,
    COLOR_RGB2YCrCb =37,
    COLOR_YCrCb2BGR =38,
    COLOR_YCrCb2RGB =39,

    COLOR_BGR2HSV =40,
    COLOR_RGB2HSV =41,

    COLOR_BGR2Lab =44,
    COLOR_RGB2Lab =45,

    COLOR_BayerBG2BGR =46,
    COLOR_BayerGB2BGR =47,
    COLOR_BayerRG2BGR =48,
    COLOR_BayerGR2BGR =49,

    COLOR_BayerBG2RGB =COLOR_BayerRG2BGR,
    COLOR_BayerGB2RGB =COLOR_BayerGR2BGR,
    COLOR_BayerRG2RGB =COLOR_BayerBG2BGR,
    COLOR_BayerGR2RGB =COLOR_BayerGB2BGR,

    COLOR_BGR2Luv =50,
    COLOR_RGB2Luv =51,
    COLOR_BGR2HLS =52,
    COLOR_RGB2HLS =53,

    COLOR_HSV2BGR =54,
    COLOR_HSV2RGB =55,

    COLOR_Lab2BGR =56,
    COLOR_Lab2RGB =57,
    COLOR_Luv2BGR =58,
    COLOR_Luv2RGB =59,
    COLOR_HLS2BGR =60,
    COLOR_HLS2RGB =61,

    COLOR_BayerBG2BGR_VNG =62,
    COLOR_BayerGB2BGR_VNG =63,
    COLOR_BayerRG2BGR_VNG =64,
    COLOR_BayerGR2BGR_VNG =65,

    COLOR_BayerBG2RGB_VNG =COLOR_BayerRG2BGR_VNG,
    COLOR_BayerGB2RGB_VNG =COLOR_BayerGR2BGR_VNG,
    COLOR_BayerRG2RGB_VNG =COLOR_BayerBG2BGR_VNG,
    COLOR_BayerGR2RGB_VNG =COLOR_BayerGB2BGR_VNG,

    COLOR_BGR2HSV_FULL = 66,
    COLOR_RGB2HSV_FULL = 67,
    COLOR_BGR2HLS_FULL = 68,
    COLOR_RGB2HLS_FULL = 69,

    COLOR_HSV2BGR_FULL = 70,
    COLOR_HSV2RGB_FULL = 71,
    COLOR_HLS2BGR_FULL = 72,
    COLOR_HLS2RGB_FULL = 73,

    COLOR_LBGR2Lab = 74,
    COLOR_LRGB2Lab = 75,
    COLOR_LBGR2Luv = 76,
    COLOR_LRGB2Luv = 77,

    COLOR_Lab2LBGR = 78,
    COLOR_Lab2LRGB = 79,
    COLOR_Luv2LBGR = 80,
    COLOR_Luv2LRGB = 81,

    COLOR_BGR2YUV = 82,
    COLOR_RGB2YUV = 83,
    COLOR_YUV2BGR = 84,
    COLOR_YUV2RGB = 85,

    COLOR_BayerBG2GRAY = 86,
    COLOR_BayerGB2GRAY = 87,
    COLOR_BayerRG2GRAY = 88,
    COLOR_BayerGR2GRAY = 89,


    COLOR_YUV2RGB_NV12 = 90,
    COLOR_YUV2BGR_NV12 = 91,
    COLOR_YUV2RGB_NV21 = 92,
    COLOR_YUV2BGR_NV21 = 93,
    COLOR_YUV420sp2RGB = COLOR_YUV2RGB_NV21,
    COLOR_YUV420sp2BGR = COLOR_YUV2BGR_NV21,

    COLOR_YUV2RGBA_NV12 = 94,
    COLOR_YUV2BGRA_NV12 = 95,
    COLOR_YUV2RGBA_NV21 = 96,
    COLOR_YUV2BGRA_NV21 = 97,
    COLOR_YUV420sp2RGBA = COLOR_YUV2RGBA_NV21,
    COLOR_YUV420sp2BGRA = COLOR_YUV2BGRA_NV21,

    COLOR_YUV2RGB_YV12 = 98,
    COLOR_YUV2BGR_YV12 = 99,
    COLOR_YUV2RGB_IYUV = 100,
    COLOR_YUV2BGR_IYUV = 101,
    COLOR_YUV2RGB_I420 = COLOR_YUV2RGB_IYUV,
    COLOR_YUV2BGR_I420 = COLOR_YUV2BGR_IYUV,
    COLOR_YUV420p2RGB = COLOR_YUV2RGB_YV12,
    COLOR_YUV420p2BGR = COLOR_YUV2BGR_YV12,

    COLOR_YUV2RGBA_YV12 = 102,
    COLOR_YUV2BGRA_YV12 = 103,
    COLOR_YUV2RGBA_IYUV = 104,
    COLOR_YUV2BGRA_IYUV = 105,
    COLOR_YUV2RGBA_I420 = COLOR_YUV2RGBA_IYUV,
    COLOR_YUV2BGRA_I420 = COLOR_YUV2BGRA_IYUV,
    COLOR_YUV420p2RGBA = COLOR_YUV2RGBA_YV12,
    COLOR_YUV420p2BGRA = COLOR_YUV2BGRA_YV12,

    COLOR_YUV2GRAY_420 = 106,
    COLOR_YUV2GRAY_NV21 = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_NV12 = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_YV12 = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_IYUV = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_I420 = COLOR_YUV2GRAY_420,
    COLOR_YUV420sp2GRAY = COLOR_YUV2GRAY_420,
    COLOR_YUV420p2GRAY = COLOR_YUV2GRAY_420,


    COLOR_YUV2RGB_UYVY = 107,
    COLOR_YUV2BGR_UYVY = 108,


    COLOR_YUV2RGB_Y422 = COLOR_YUV2RGB_UYVY,
    COLOR_YUV2BGR_Y422 = COLOR_YUV2BGR_UYVY,
    COLOR_YUV2RGB_UYNV = COLOR_YUV2RGB_UYVY,
    COLOR_YUV2BGR_UYNV = COLOR_YUV2BGR_UYVY,

    COLOR_YUV2RGBA_UYVY = 111,
    COLOR_YUV2BGRA_UYVY = 112,


    COLOR_YUV2RGBA_Y422 = COLOR_YUV2RGBA_UYVY,
    COLOR_YUV2BGRA_Y422 = COLOR_YUV2BGRA_UYVY,
    COLOR_YUV2RGBA_UYNV = COLOR_YUV2RGBA_UYVY,
    COLOR_YUV2BGRA_UYNV = COLOR_YUV2BGRA_UYVY,

    COLOR_YUV2RGB_YUY2 = 115,
    COLOR_YUV2BGR_YUY2 = 116,
    COLOR_YUV2RGB_YVYU = 117,
    COLOR_YUV2BGR_YVYU = 118,
    COLOR_YUV2RGB_YUYV = COLOR_YUV2RGB_YUY2,
    COLOR_YUV2BGR_YUYV = COLOR_YUV2BGR_YUY2,
    COLOR_YUV2RGB_YUNV = COLOR_YUV2RGB_YUY2,
    COLOR_YUV2BGR_YUNV = COLOR_YUV2BGR_YUY2,

    COLOR_YUV2RGBA_YUY2 = 119,
    COLOR_YUV2BGRA_YUY2 = 120,
    COLOR_YUV2RGBA_YVYU = 121,
    COLOR_YUV2BGRA_YVYU = 122,
    COLOR_YUV2RGBA_YUYV = COLOR_YUV2RGBA_YUY2,
    COLOR_YUV2BGRA_YUYV = COLOR_YUV2BGRA_YUY2,
    COLOR_YUV2RGBA_YUNV = COLOR_YUV2RGBA_YUY2,
    COLOR_YUV2BGRA_YUNV = COLOR_YUV2BGRA_YUY2,

    COLOR_YUV2GRAY_UYVY = 123,
    COLOR_YUV2GRAY_YUY2 = 124,

    COLOR_YUV2GRAY_Y422 = COLOR_YUV2GRAY_UYVY,
    COLOR_YUV2GRAY_UYNV = COLOR_YUV2GRAY_UYVY,
    COLOR_YUV2GRAY_YVYU = COLOR_YUV2GRAY_YUY2,
    COLOR_YUV2GRAY_YUYV = COLOR_YUV2GRAY_YUY2,
    COLOR_YUV2GRAY_YUNV = COLOR_YUV2GRAY_YUY2,


    COLOR_RGBA2mRGBA = 125,
    COLOR_mRGBA2RGBA = 126,

    COLOR_RGB2YUV_I420 = 127,
    COLOR_BGR2YUV_I420 = 128,
    COLOR_RGB2YUV_IYUV = COLOR_RGB2YUV_I420,
    COLOR_BGR2YUV_IYUV = COLOR_BGR2YUV_I420,

    COLOR_RGBA2YUV_I420 = 129,
    COLOR_BGRA2YUV_I420 = 130,
    COLOR_RGBA2YUV_IYUV = COLOR_RGBA2YUV_I420,
    COLOR_BGRA2YUV_IYUV = COLOR_BGRA2YUV_I420,
    COLOR_RGB2YUV_YV12 = 131,
    COLOR_BGR2YUV_YV12 = 132,
    COLOR_RGBA2YUV_YV12 = 133,
    COLOR_BGRA2YUV_YV12 = 134,

    COLOR_COLORCVT_MAX = 135
};



 void cvtColor( InputArray src, OutputArray dst, int code, int dstCn=0 );


class Moments
{
public:

    Moments();

    Moments(double m00, double m10, double m01, double m20, double m11,
            double m02, double m30, double m21, double m12, double m03 );

    Moments( const CvMoments& moments );

    operator CvMoments() const;


    double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;

    double mu20, mu11, mu02, mu30, mu21, mu12, mu03;

    double nu20, nu11, nu02, nu30, nu21, nu12, nu03;
};


 Moments moments( InputArray array, bool binaryImage=false );


 void HuMoments( const Moments& moments, double hu[7] );
 void HuMoments( const Moments& m, OutputArray hu );


enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };


 void matchTemplate( InputArray image, InputArray templ,
                                 OutputArray result, int method );


enum
{
    RETR_EXTERNAL=CV_RETR_EXTERNAL,
    RETR_LIST=CV_RETR_LIST,
    RETR_CCOMP=CV_RETR_CCOMP,
    RETR_TREE=CV_RETR_TREE,
    RETR_FLOODFILL=CV_RETR_FLOODFILL
};


enum
{
    CHAIN_APPROX_NONE=CV_CHAIN_APPROX_NONE,
    CHAIN_APPROX_SIMPLE=CV_CHAIN_APPROX_SIMPLE,
    CHAIN_APPROX_TC89_L1=CV_CHAIN_APPROX_TC89_L1,
    CHAIN_APPROX_TC89_KCOS=CV_CHAIN_APPROX_TC89_KCOS
};


 void findContours( InputOutputArray image, OutputArrayOfArrays contours,
                              OutputArray hierarchy, int mode,
                              int method, Point offset=Point());


 void findContours( InputOutputArray image, OutputArrayOfArrays contours,
                              int mode, int method, Point offset=Point());


 void drawContours( InputOutputArray image, InputArrayOfArrays contours,
                              int contourIdx, const Scalar& color,
                              int thickness=1, int lineType=8,
                              InputArray hierarchy=noArray(),
                              int maxLevel=2147483647, Point offset=Point() );


 void approxPolyDP( InputArray curve,
                                OutputArray approxCurve,
                                double epsilon, bool closed );


 double arcLength( InputArray curve, bool closed );

 Rect boundingRect( InputArray points );

 double contourArea( InputArray contour, bool oriented=false );

 RotatedRect minAreaRect( InputArray points );

 void minEnclosingCircle( InputArray points,
                                      Point2f& center, float& radius );

 double matchShapes( InputArray contour1, InputArray contour2,
                                 int method, double parameter );

 void convexHull( InputArray points, OutputArray hull,
                              bool clockwise=false, bool returnPoints=true );

 void convexityDefects( InputArray contour, InputArray convexhull, OutputArray convexityDefects );


 bool isContourConvex( InputArray contour );


 float intersectConvexConvex( InputArray _p1, InputArray _p2,
                                          OutputArray _p12, bool handleNested=true );


 RotatedRect fitEllipse( InputArray points );


 void fitLine( InputArray points, OutputArray line, int distType,
                           double param, double reps, double aeps );

 double pointPolygonTest( InputArray contour, Point2f pt, bool measureDist );


class Subdiv2D
{
public:
    enum
    {
        PTLOC_ERROR = -2,
        PTLOC_OUTSIDE_RECT = -1,
        PTLOC_INSIDE = 0,
        PTLOC_VERTEX = 1,
        PTLOC_ON_EDGE = 2
    };

    enum
    {
        NEXT_AROUND_ORG = 0x00,
        NEXT_AROUND_DST = 0x22,
        PREV_AROUND_ORG = 0x11,
        PREV_AROUND_DST = 0x33,
        NEXT_AROUND_LEFT = 0x13,
        NEXT_AROUND_RIGHT = 0x31,
        PREV_AROUND_LEFT = 0x20,
        PREV_AROUND_RIGHT = 0x02
    };

    Subdiv2D();
    Subdiv2D(Rect rect);
    void initDelaunay(Rect rect);

    int insert(Point2f pt);
    void insert(const vector<Point2f>& ptvec);
    int locate(Point2f pt, int& edge, int& vertex);

    int findNearest(Point2f pt, Point2f* nearestPt=0);
    void getEdgeList( vector<Vec4f>& edgeList) const;
    void getTriangleList( vector<Vec6f>& triangleList) const;
    void getVoronoiFacetList(const vector<int>& idx, vector<vector<Point2f> >& facetList,
                                     vector<Point2f>& facetCenters);

    Point2f getVertex(int vertex, int* firstEdge=0) const;

    int getEdge( int edge, int nextEdgeType ) const;
    int nextEdge(int edge) const;
    int rotateEdge(int edge, int rotate) const;
    int symEdge(int edge) const;
    int edgeOrg(int edge, Point2f* orgpt=0) const;
    int edgeDst(int edge, Point2f* dstpt=0) const;

protected:
    int newEdge();
    void deleteEdge(int edge);
    int newPoint(Point2f pt, bool isvirtual, int firstEdge=0);
    void deletePoint(int vtx);
    void setEdgePoints( int edge, int orgPt, int dstPt );
    void splice( int edgeA, int edgeB );
    int connectEdges( int edgeA, int edgeB );
    void swapEdges( int edge );
    int isRightOf(Point2f pt, int edge) const;
    void calcVoronoi();
    void clearVoronoi();
    void checkSubdiv() const;

    struct Vertex
    {
        Vertex();
        Vertex(Point2f pt, bool _isvirtual, int _firstEdge=0);
        bool isvirtual() const;
        bool isfree() const;
        int firstEdge;
        int type;
        Point2f pt;
    };
    struct QuadEdge
    {
        QuadEdge();
        QuadEdge(int edgeidx);
        bool isfree() const;
        int next[4];
        int pt[4];
    };

    vector<Vertex> vtx;
    vector<QuadEdge> qedges;
    int freeQEdge;
    int freePoint;
    bool validGeometry;

    int recentEdge;
    Point2f topLeft;
    Point2f bottomRight;
};

}
#51 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/photo/photo.hpp" 1
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/photo/photo.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/photo/photo_c.h" 1
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/photo/photo_c.h"
extern "C" {



enum
{
    CV_INPAINT_NS =0,
    CV_INPAINT_TELEA =1
};



extern "C" void cvInpaint( const CvArr* src, const CvArr* inpaint_mask,
                       CvArr* dst, double inpaintRange, int flags );



}
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/photo/photo.hpp" 2






namespace cv
{


enum
{
    INPAINT_NS=CV_INPAINT_NS,
    INPAINT_TELEA=CV_INPAINT_TELEA
};


 void inpaint( InputArray src, InputArray inpaintMask,
                           OutputArray dst, double inpaintRadius, int flags );


 void fastNlMeansDenoising( InputArray src, OutputArray dst, float h = 3,
                                        int templateWindowSize = 7, int searchWindowSize = 21);

 void fastNlMeansDenoisingColored( InputArray src, OutputArray dst,
                                               float h = 3, float hColor = 3,
                                               int templateWindowSize = 7, int searchWindowSize = 21);

 void fastNlMeansDenoisingMulti( InputArrayOfArrays srcImgs, OutputArray dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             float h = 3, int templateWindowSize = 7, int searchWindowSize = 21);

 void fastNlMeansDenoisingColoredMulti( InputArrayOfArrays srcImgs, OutputArray dst,
                                                    int imgToDenoiseIndex, int temporalWindowSize,
                                                    float h = 3, float hColor = 3,
                                                    int templateWindowSize = 7, int searchWindowSize = 21);

}
#52 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/video.hpp" 1
#46 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/video.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/tracking.hpp" 1
#54 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/tracking.hpp"
extern "C" {
#73 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/tracking.hpp"
extern "C" void cvCalcOpticalFlowPyrLK( const CvArr* prev, const CvArr* curr,
                                     CvArr* prev_pyr, CvArr* curr_pyr,
                                     const CvPoint2D32f* prev_features,
                                     CvPoint2D32f* curr_features,
                                     int count,
                                     CvSize win_size,
                                     int level,
                                     char* status,
                                     float* track_error,
                                     CvTermCriteria criteria,
                                     int flags );




extern "C" void cvCalcAffineFlowPyrLK( const CvArr* prev, const CvArr* curr,
                                    CvArr* prev_pyr, CvArr* curr_pyr,
                                    const CvPoint2D32f* prev_features,
                                    CvPoint2D32f* curr_features,
                                    float* matrices, int count,
                                    CvSize win_size, int level,
                                    char* status, float* track_error,
                                    CvTermCriteria criteria, int flags );


extern "C" int cvEstimateRigidTransform( const CvArr* A, const CvArr* B,
                                      CvMat* M, int full_affine );


extern "C" void cvCalcOpticalFlowFarneback( const CvArr* prev, const CvArr* next,
                                        CvArr* flow, double pyr_scale, int levels,
                                        int winsize, int iterations, int poly_n,
                                        double poly_sigma, int flags );
#120 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/tracking.hpp"
extern "C" void cvUpdateMotionHistory( const CvArr* silhouette, CvArr* mhi,
                                      double timestamp, double duration );



extern "C" void cvCalcMotionGradient( const CvArr* mhi, CvArr* mask, CvArr* orientation,
                                     double delta1, double delta2,
                                     int aperture_size = 3);




extern "C" double cvCalcGlobalOrientation( const CvArr* orientation, const CvArr* mask,
                                        const CvArr* mhi, double timestamp,
                                        double duration );



extern "C" CvSeq* cvSegmentMotion( const CvArr* mhi, CvArr* seg_mask,
                                CvMemStorage* storage,
                                double timestamp, double seg_thresh );







extern "C" int cvCamShift( const CvArr* prob_image, CvRect window,
                        CvTermCriteria criteria, CvConnectedComp* comp,
                        CvBox2D* box = __null );



extern "C" int cvMeanShift( const CvArr* prob_image, CvRect window,
                         CvTermCriteria criteria, CvConnectedComp* comp );







typedef struct CvKalman
{
    int MP;
    int DP;
    int CP;



    float* PosterState;
    float* PriorState;
    float* DynamMatr;
    float* MeasurementMatr;
    float* MNCovariance;
    float* PNCovariance;
    float* KalmGainMatr;
    float* PriorErrorCovariance;
    float* PosterErrorCovariance;
    float* Temp1;
    float* Temp2;


    CvMat* state_pre;

    CvMat* state_post;

    CvMat* transition_matrix;
    CvMat* control_matrix;

    CvMat* measurement_matrix;
    CvMat* process_noise_cov;
    CvMat* measurement_noise_cov;
    CvMat* error_cov_pre;

    CvMat* gain;

    CvMat* error_cov_post;

    CvMat* temp1;
    CvMat* temp2;
    CvMat* temp3;
    CvMat* temp4;
    CvMat* temp5;
} CvKalman;


extern "C" CvKalman* cvCreateKalman( int dynam_params, int measure_params,
                                 int control_params = 0);


extern "C" void cvReleaseKalman( CvKalman** kalman);


extern "C" const CvMat* cvKalmanPredict( CvKalman* kalman,
                                      const CvMat* control = __null);



extern "C" const CvMat* cvKalmanCorrect( CvKalman* kalman, const CvMat* measurement );





}

namespace cv
{


 void updateMotionHistory( InputArray silhouette, InputOutputArray mhi,
                                       double timestamp, double duration );


 void calcMotionGradient( InputArray mhi, OutputArray mask,
                                      OutputArray orientation,
                                      double delta1, double delta2,
                                      int apertureSize=3 );


 double calcGlobalOrientation( InputArray orientation, InputArray mask,
                                           InputArray mhi, double timestamp,
                                           double duration );

 void segmentMotion(InputArray mhi, OutputArray segmask,
                                vector<Rect>& boundingRects,
                                double timestamp, double segThresh);


 RotatedRect CamShift( InputArray probImage, Rect& window,
                                   TermCriteria criteria );


 int meanShift( InputArray probImage, Rect& window,
                            TermCriteria criteria );
#265 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/tracking.hpp"
class KalmanFilter
{
public:

    KalmanFilter();

    KalmanFilter(int dynamParams, int measureParams, int controlParams=0, int type=5);

    void init(int dynamParams, int measureParams, int controlParams=0, int type=5);


    const Mat& predict(const Mat& control=Mat());

    const Mat& correct(const Mat& measurement);

    Mat statePre;
    Mat statePost;
    Mat transitionMatrix;
    Mat controlMatrix;
    Mat measurementMatrix;
    Mat processNoiseCov;
    Mat measurementNoiseCov;
    Mat errorCovPre;
    Mat gain;
    Mat errorCovPost;


    Mat temp1;
    Mat temp2;
    Mat temp3;
    Mat temp4;
    Mat temp5;
};

enum
{
    OPTFLOW_USE_INITIAL_FLOW = 4,
    OPTFLOW_LK_GET_MIN_EIGENVALS = 8,
    OPTFLOW_FARNEBACK_GAUSSIAN = 256
};


 int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid,
                                         Size winSize, int maxLevel, bool withDerivatives = true,
                                         int pyrBorder = BORDER_REFLECT_101, int derivBorder = BORDER_CONSTANT,
                                         bool tryReuseInputImage = true);


 void calcOpticalFlowPyrLK( InputArray prevImg, InputArray nextImg,
                           InputArray prevPts, InputOutputArray nextPts,
                           OutputArray status, OutputArray err,
                           Size winSize=Size(21,21), int maxLevel=3,
                           TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01),
                           int flags=0, double minEigThreshold=1e-4);


 void calcOpticalFlowFarneback( InputArray prev, InputArray next,
                           InputOutputArray flow, double pyr_scale, int levels, int winsize,
                           int iterations, int poly_n, double poly_sigma, int flags );



 Mat estimateRigidTransform( InputArray src, InputArray dst,
                                         bool fullAffine);


 void calcOpticalFlowSF(Mat& from,
                                    Mat& to,
                                    Mat& flow,
                                    int layers,
                                    int averaging_block_size,
                                    int max_flow);

 void calcOpticalFlowSF(Mat& from,
                                    Mat& to,
                                    Mat& flow,
                                    int layers,
                                    int averaging_block_size,
                                    int max_flow,
                                    double sigma_dist,
                                    double sigma_color,
                                    int postprocess_window,
                                    double sigma_dist_fix,
                                    double sigma_color_fix,
                                    double occ_thr,
                                    int upscale_averaging_radius,
                                    double upscale_sigma_dist,
                                    double upscale_sigma_color,
                                    double speed_up_thr);

class DenseOpticalFlow : public Algorithm
{
public:
    virtual void calc(InputArray I0, InputArray I1, InputOutputArray flow) = 0;
    virtual void collectGarbage() = 0;
};






 Ptr<DenseOpticalFlow> createOptFlow_DualTVL1();

}
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/video.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp" 1
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/list" 1 3
#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/list" 3

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/list" 3




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 1 3
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {

#76 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) throw ();

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) throw ();

      void
      _M_reverse() throw ();

      void
      _M_hook(_List_node_base* const __position) throw ();

      void
      _M_unhook() throw ();
    };


  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      _Tp _M_data;







    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
#304 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 __detail::_List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }
#371 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
#428 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;







      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct
       (std::__addressof(__p->_M_data), __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }
#506 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
    public:





      list()
      : _Base() { }





      explicit
      list(const allocator_type& __a)
      : _Base(__a) { }
#557 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
#571 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
#610 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
#635 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
#681 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
#697 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
#720 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
#839 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }
#889 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());







      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
#945 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
#972 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
#986 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
#1012 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
#1045 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
#1094 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
#1114 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
#1138 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
#1159 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
#1176 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
#1213 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x)

      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
#1243 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x, iterator __i)

      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
#1279 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void




      splice(iterator __position, list& __x, iterator __first,
      iterator __last)

      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
#1314 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
#1328 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
#1342 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      unique();
#1357 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
#1378 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      merge(list& __x);
#1404 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);







      void
      reverse()
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }
#1488 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }



      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->_M_hook(__position._M_node);
      }
#1529 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
      void
      _M_erase(iterator __position)
      {
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);



 _M_get_Tp_allocator().destroy(std::__addressof(__n->_M_data));

        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
#1562 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
#1591 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/list" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/list.tcc" 1 3
#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);



   _M_get_Tp_allocator().destroy(std::__addressof(__tmp->_M_data));

   _M_put_node(__tmp);
 }
    }
#97 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }
#167 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }


  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::



    merge(list& __x)

    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::



      merge(list& __x, _StrictWeakOrdering __comp)

      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }


}
#66 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/list" 2 3
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp" 2
namespace cv
{







class BackgroundSubtractor : public Algorithm
{
public:

    virtual ~BackgroundSubtractor();

    virtual void operator()(InputArray image, OutputArray fgmask,
                                              double learningRate=0);


    virtual void getBackgroundImage(OutputArray backgroundImage) const;
};
#81 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp"
class BackgroundSubtractorMOG : public BackgroundSubtractor
{
public:

    BackgroundSubtractorMOG();

    BackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma=0);

    virtual ~BackgroundSubtractorMOG();

    virtual void operator()(InputArray image, OutputArray fgmask, double learningRate=0);


    virtual void initialize(Size frameSize, int frameType);

    virtual AlgorithmInfo* info() const;

protected:
    Size frameSize;
    int frameType;
    Mat bgmodel;
    int nframes;
    int history;
    int nmixtures;
    double varThreshold;
    double backgroundRatio;
    double noiseSigma;
};
#118 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp"
class BackgroundSubtractorMOG2 : public BackgroundSubtractor
{
public:

    BackgroundSubtractorMOG2();

    BackgroundSubtractorMOG2(int history, float varThreshold, bool bShadowDetection=true);

    virtual ~BackgroundSubtractorMOG2();

    virtual void operator()(InputArray image, OutputArray fgmask, double learningRate=-1);


    virtual void getBackgroundImage(OutputArray backgroundImage) const;


    virtual void initialize(Size frameSize, int frameType);

    virtual AlgorithmInfo* info() const;

protected:
    Size frameSize;
    int frameType;
    Mat bgmodel;
    Mat bgmodelUsedModes;
    int nframes;
    int history;
    int nmixtures;


    double varThreshold;
#157 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp"
    float backgroundRatio;






    float varThresholdGen;





    float fVarInit;
    float fVarMin;
    float fVarMax;





    float fCT;





    bool bShadowDetection;
    unsigned char nShadowDetection;
    float fTau;




};
#200 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp"
class BackgroundSubtractorGMG: public cv::BackgroundSubtractor
{
public:
    BackgroundSubtractorGMG();
    virtual ~BackgroundSubtractorGMG();
    virtual AlgorithmInfo* info() const;
#214 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/background_segm.hpp"
    void initialize(cv::Size frameSize, double min, double max);







    virtual void operator()(InputArray image, OutputArray fgmask, double learningRate=-1.0);




    void release();


    int maxFeatures;

    double learningRate;

    int numInitializationFrames;

    int quantizationLevels;

    double backgroundPrior;

    double decisionThreshold;

    int smoothingRadius;

    bool updateBackgroundModel;

private:
    double maxVal_;
    double minVal_;

    cv::Size frameSize_;
    int frameNum_;

    cv::Mat_<int> nfeatures_;
    cv::Mat_<unsigned int> colors_;
    cv::Mat_<float> weights_;

    cv::Mat buf_;
};

}
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/video/video.hpp" 2


namespace cv
{

 bool initModule_video(void);

}
#53 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp" 1
#52 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
namespace cv
{

 bool initModule_features2d();
#69 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class KeyPoint
{
public:

    KeyPoint() : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}

    KeyPoint(Point2f _pt, float _size, float _angle=-1,
            float _response=0, int _octave=0, int _class_id=-1)
            : pt(_pt), size(_size), angle(_angle),
            response(_response), octave(_octave), class_id(_class_id) {}

    KeyPoint(float x, float y, float _size, float _angle=-1,
            float _response=0, int _octave=0, int _class_id=-1)
            : pt(x, y), size(_size), angle(_angle),
            response(_response), octave(_octave), class_id(_class_id) {}

    size_t hash() const;


    static void convert(const vector<KeyPoint>& keypoints,
                        vector<Point2f>& points2f,
                        const vector<int>& keypointIndexes=vector<int>());

    static void convert(const vector<Point2f>& points2f,
                        vector<KeyPoint>& keypoints,
                        float size=1, float response=1, int octave=0, int class_id=-1);




    static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);

    Point2f pt;
    float size;
    float angle;


    float response;
    int octave;
    int class_id;
};


 void write(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints);

 void read(const FileNode& node, vector<KeyPoint>& keypoints);






class KeyPointsFilter
{
public:
    KeyPointsFilter(){}




    static void runByImageBorder( vector<KeyPoint>& keypoints, Size imageSize, int borderSize );



    static void runByKeypointSize( vector<KeyPoint>& keypoints, float minSize,
                                   float maxSize=3.40282346638528859812e+38F );



    static void runByPixelsMask( vector<KeyPoint>& keypoints, const Mat& mask );



    static void removeDuplicated( vector<KeyPoint>& keypoints );




    static void retainBest( vector<KeyPoint>& keypoints, int npoints );
};







class FeatureDetector : public virtual Algorithm
{
public:
    virtual ~FeatureDetector();
#168 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    void detect( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;







    void detect( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const;


    virtual bool empty() const;


    static Ptr<FeatureDetector> create( const string& detectorType );

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const = 0;






    static void removeInvalidPoints( const Mat& mask, vector<KeyPoint>& keypoints );
};
#205 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class DescriptorExtractor : public virtual Algorithm
{
public:
    virtual ~DescriptorExtractor();







    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;
#225 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    void compute( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const;

    virtual int descriptorSize() const = 0;
    virtual int descriptorType() const = 0;

    virtual bool empty() const;

    static Ptr<DescriptorExtractor> create( const string& descriptorExtractorType );

protected:
    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const = 0;




    static void removeBorderKeypoints( vector<KeyPoint>& keypoints,
                                      Size imageSize, int borderSize );
};






class Feature2D : public FeatureDetector, public DescriptorExtractor
{
public:
#261 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    virtual void operator()( InputArray image, InputArray mask,
                                     vector<KeyPoint>& keypoints,
                                     OutputArray descriptors,
                                     bool useProvidedKeypoints=false ) const = 0;


    static Ptr<Feature2D> create( const string& name );
};




class BRISK : public Feature2D
{
public:
    explicit BRISK(int thresh=30, int octaves=3, float patternScale=1.0f);

    virtual ~BRISK();


    int descriptorSize() const;

    int descriptorType() const;


    void operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints) const;


    void operator()( InputArray image, InputArray mask, vector<KeyPoint>& keypoints,
                      OutputArray descriptors, bool useProvidedKeypoints=false ) const;

    AlgorithmInfo* info() const;


    explicit BRISK(std::vector<float> &radiusList, std::vector<int> &numberList,
        float dMax=5.85f, float dMin=8.2f, std::vector<int> indexChange=std::vector<int>());




    void generateKernel(std::vector<float> &radiusList,
        std::vector<int> &numberList, float dMax=5.85f, float dMin=8.2f,
        std::vector<int> indexChange=std::vector<int>());

protected:

    void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;
    void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    void computeKeypointsNoOrientation(InputArray image, InputArray mask, vector<KeyPoint>& keypoints) const;
    void computeDescriptorsAndOrOrientation(InputArray image, InputArray mask, vector<KeyPoint>& keypoints,
                                       OutputArray descriptors, bool doDescriptors, bool doOrientation,
                                       bool useProvidedKeypoints) const;


    int threshold;
    int octaves;


    struct BriskPatternPoint{
        float x;
        float y;
        float sigma;
    };
    struct BriskShortPair{
        unsigned int i;
        unsigned int j;
    };
    struct BriskLongPair{
        unsigned int i;
        unsigned int j;
        int weighted_dx;
        int weighted_dy;
    };
    inline int smoothedIntensity(const cv::Mat& image,
                const cv::Mat& integral,const float key_x,
                const float key_y, const unsigned int scale,
                const unsigned int rot, const unsigned int point) const;

    BriskPatternPoint* patternPoints_;
    unsigned int points_;
    float* scaleList_;
    unsigned int* sizeList_;
    static const unsigned int scales_;
    static const float scalerange_;
    static const unsigned int n_rot_;


    int strings_;
    float dMax_;
    float dMin_;
    BriskShortPair* shortPairs_;
    BriskLongPair* longPairs_;
    unsigned int noShortPairs_;
    unsigned int noLongPairs_;


    static const float basicSize_;
};





class ORB : public Feature2D
{
public:

    enum { kBytes = 32, HARRIS_SCORE=0, FAST_SCORE=1 };

    explicit ORB(int nfeatures = 500, float scaleFactor = 1.2f, int nlevels = 8, int edgeThreshold = 31,
        int firstLevel = 0, int WTA_K=2, int scoreType=ORB::HARRIS_SCORE, int patchSize=31 );


    int descriptorSize() const;

    int descriptorType() const;


    void operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints) const;


    void operator()( InputArray image, InputArray mask, vector<KeyPoint>& keypoints,
                     OutputArray descriptors, bool useProvidedKeypoints=false ) const;

    AlgorithmInfo* info() const;

protected:

    void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;
    void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    int nfeatures;
    double scaleFactor;
    int nlevels;
    int edgeThreshold;
    int firstLevel;
    int WTA_K;
    int scoreType;
    int patchSize;
};

typedef ORB OrbFeatureDetector;
typedef ORB OrbDescriptorExtractor;




class FREAK : public DescriptorExtractor
{
public:







    explicit FREAK( bool orientationNormalized = true,
           bool scaleNormalized = true,
           float patternScale = 22.0f,
           int nOctaves = 4,
           const vector<int>& selectedPairs = vector<int>());
    FREAK( const FREAK& rhs );
    FREAK& operator=( const FREAK& );

    virtual ~FREAK();


    virtual int descriptorSize() const;


    virtual int descriptorType() const;
#442 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    vector<int> selectPairs( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints,
                      const double corrThresh = 0.7, bool verbose = true );

    AlgorithmInfo* info() const;

    enum
    {
        NB_SCALES = 64, NB_PAIRS = 512, NB_ORIENPAIRS = 45
    };

protected:
    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;
    void buildPattern();
    uchar meanIntensity( const Mat& image, const Mat& integral, const float kp_x, const float kp_y,
                         const unsigned int scale, const unsigned int rot, const unsigned int point ) const;

    bool orientationNormalized;
    bool scaleNormalized;
    double patternScale;
    int nOctaves;
    bool extAll;

    double patternScale0;
    int nOctaves0;
    vector<int> selectedPairs0;

    struct PatternPoint
    {
        float x;
        float y;
        float sigma;
    };

    struct DescriptionPair
    {
        uchar i;
        uchar j;
    };

    struct OrientationPair
    {
        uchar i;
        uchar j;
        int weight_dx;
        int weight_dy;
    };

    vector<PatternPoint> patternLookup;
    int patternSizes[NB_SCALES];
    DescriptionPair descriptionPairs[NB_PAIRS];
    OrientationPair orientationPairs[NB_ORIENPAIRS];
};
#505 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class MSER : public FeatureDetector
{
public:

    explicit MSER( int _delta=5, int _min_area=60, int _max_area=14400,
          double _max_variation=0.25, double _min_diversity=.2,
          int _max_evolution=200, double _area_threshold=1.01,
          double _min_margin=0.003, int _edge_blur_size=5 );


    void operator()( const Mat& image, vector<vector<Point> >& msers,
                                        const Mat& mask=Mat() ) const;
    AlgorithmInfo* info() const;

protected:
    void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    int delta;
    int minArea;
    int maxArea;
    double maxVariation;
    double minDiversity;
    int maxEvolution;
    double areaThreshold;
    double minMargin;
    int edgeBlurSize;
};

typedef MSER MserFeatureDetector;






class StarDetector : public FeatureDetector
{
public:

    StarDetector(int _maxSize=45, int _responseThreshold=30,
                 int _lineThresholdProjected=10,
                 int _lineThresholdBinarized=8,
                 int _suppressNonmaxSize=5);


    void operator()(const Mat& image,
                vector<KeyPoint>& keypoints) const;

    AlgorithmInfo* info() const;

protected:
    void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    int maxSize;
    int responseThreshold;
    int lineThresholdProjected;
    int lineThresholdBinarized;
    int suppressNonmaxSize;
};


 void FAST( InputArray image, vector<KeyPoint>& keypoints,
                      int threshold, bool nonmaxSupression=true );

 void FASTX( InputArray image, vector<KeyPoint>& keypoints,
                      int threshold, bool nonmaxSupression, int type );

class FastFeatureDetector : public FeatureDetector
{
public:

    enum
    {
      TYPE_5_8 = 0, TYPE_7_12 = 1, TYPE_9_16 = 2
    };

    FastFeatureDetector( int threshold=10, bool nonmaxSuppression=true );
    AlgorithmInfo* info() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    int threshold;
    bool nonmaxSuppression;
};


class GFTTDetector : public FeatureDetector
{
public:
    GFTTDetector( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1,
                  int blockSize=3, bool useHarrisDetector=false, double k=0.04 );
    AlgorithmInfo* info() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    int nfeatures;
    double qualityLevel;
    double minDistance;
    int blockSize;
    bool useHarrisDetector;
    double k;
};

typedef GFTTDetector GoodFeaturesToTrackDetector;
typedef StarDetector StarFeatureDetector;

class SimpleBlobDetector : public FeatureDetector
{
public:
  struct Params
  {
      Params();
      float thresholdStep;
      float minThreshold;
      float maxThreshold;
      size_t minRepeatability;
      float minDistBetweenBlobs;

      bool filterByColor;
      uchar blobColor;

      bool filterByArea;
      float minArea, maxArea;

      bool filterByCircularity;
      float minCircularity, maxCircularity;

      bool filterByInertia;
      float minInertiaRatio, maxInertiaRatio;

      bool filterByConvexity;
      float minConvexity, maxConvexity;

      void read( const FileNode& fn );
      void write( FileStorage& fs ) const;
  };

  SimpleBlobDetector(const SimpleBlobDetector::Params &parameters = SimpleBlobDetector::Params());

  virtual void read( const FileNode& fn );
  virtual void write( FileStorage& fs ) const;

protected:
  struct Center
  {
      Point2d location;
      double radius;
      double confidence;
  };

  virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;
  virtual void findBlobs(const Mat &image, const Mat &binaryImage, vector<Center> &centers) const;

  Params params;
  AlgorithmInfo* info() const;
};


class DenseFeatureDetector : public FeatureDetector
{
public:
    explicit DenseFeatureDetector( float initFeatureScale=1.f, int featureScaleLevels=1,
                                   float featureScaleMul=0.1f,
                                   int initXyStep=6, int initImgBound=0,
                                   bool varyXyStepWithScale=true,
                                   bool varyImgBoundWithScale=false );
    AlgorithmInfo* info() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    double initFeatureScale;
    int featureScaleLevels;
    double featureScaleMul;

    int initXyStep;
    int initImgBound;

    bool varyXyStepWithScale;
    bool varyImgBoundWithScale;
};





class GridAdaptedFeatureDetector : public FeatureDetector
{
public:







    GridAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector=0,
                                        int maxTotalKeypoints=1000,
                                        int gridRows=4, int gridCols=4 );


    virtual bool empty() const;

    AlgorithmInfo* info() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    Ptr<FeatureDetector> detector;
    int maxTotalKeypoints;
    int gridRows;
    int gridCols;
};





class PyramidAdaptedFeatureDetector : public FeatureDetector
{
public:

    PyramidAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int maxLevel=2 );


    virtual bool empty() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    Ptr<FeatureDetector> detector;
    int maxLevel;
};




class AdjusterAdapter: public FeatureDetector
{
public:


    virtual ~AdjusterAdapter() {}




    virtual void tooFew(int min, int n_detected) = 0;




    virtual void tooMany(int max, int n_detected) = 0;



    virtual bool good() const = 0;

    virtual Ptr<AdjusterAdapter> clone() const = 0;

    static Ptr<AdjusterAdapter> create( const string& detectorType );
};
#781 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class DynamicAdaptedFeatureDetector: public FeatureDetector
{
public:







    DynamicAdaptedFeatureDetector( const Ptr<AdjusterAdapter>& adjuster, int min_features=400, int max_features=500, int max_iters=5 );

    virtual bool empty() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

private:
    DynamicAdaptedFeatureDetector& operator=(const DynamicAdaptedFeatureDetector&);
    DynamicAdaptedFeatureDetector(const DynamicAdaptedFeatureDetector&);

    int escape_iters_;
    int min_features_, max_features_;
    const Ptr<AdjusterAdapter> adjuster_;
};




class FastAdjuster: public AdjusterAdapter
{
public:



    FastAdjuster(int init_thresh=20, bool nonmax=true, int min_thresh=1, int max_thresh=200);

    virtual void tooFew(int minv, int n_detected);
    virtual void tooMany(int maxv, int n_detected);
    virtual bool good() const;

    virtual Ptr<AdjusterAdapter> clone() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    int thresh_;
    bool nonmax_;
    int init_thresh_, min_thresh_, max_thresh_;
};





class StarAdjuster: public AdjusterAdapter
{
public:
    StarAdjuster(double initial_thresh=30.0, double min_thresh=2., double max_thresh=200.);

    virtual void tooFew(int minv, int n_detected);
    virtual void tooMany(int maxv, int n_detected);
    virtual bool good() const;

    virtual Ptr<AdjusterAdapter> clone() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    double thresh_, init_thresh_, min_thresh_, max_thresh_;
};

class SurfAdjuster: public AdjusterAdapter
{
public:
    SurfAdjuster( double initial_thresh=400.f, double min_thresh=2, double max_thresh=1000 );

    virtual void tooFew(int minv, int n_detected);
    virtual void tooMany(int maxv, int n_detected);
    virtual bool good() const;

    virtual Ptr<AdjusterAdapter> clone() const;

protected:
    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;

    double thresh_, init_thresh_, min_thresh_, max_thresh_;
};

 Mat windowedMatchingMask( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2,
                                     float maxDeltaX, float maxDeltaY );
#884 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class OpponentColorDescriptorExtractor : public DescriptorExtractor
{
public:
    OpponentColorDescriptorExtractor( const Ptr<DescriptorExtractor>& descriptorExtractor );

    virtual void read( const FileNode& );
    virtual void write( FileStorage& ) const;

    virtual int descriptorSize() const;
    virtual int descriptorType() const;

    virtual bool empty() const;

protected:
    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;

    Ptr<DescriptorExtractor> descriptorExtractor;
};




class BriefDescriptorExtractor : public DescriptorExtractor
{
public:
    static const int PATCH_SIZE = 48;
    static const int KERNEL_SIZE = 9;


    BriefDescriptorExtractor( int bytes = 32 );

    virtual void read( const FileNode& );
    virtual void write( FileStorage& ) const;

    virtual int descriptorSize() const;
    virtual int descriptorType() const;



    AlgorithmInfo* info() const;

protected:
    virtual void computeImpl(const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors) const;

    typedef void(*PixelTestFn)(const Mat&, const vector<KeyPoint>&, Mat&);

    int bytes_;
    PixelTestFn test_fn_;
};






template<typename T>
struct Accumulator
{
    typedef T Type;
};

template<> struct Accumulator<unsigned char> { typedef float Type; };
template<> struct Accumulator<unsigned short> { typedef float Type; };
template<> struct Accumulator<char> { typedef float Type; };
template<> struct Accumulator<short> { typedef float Type; };




template<class T>
struct SL2
{
    enum { normType = NORM_L2SQR };
    typedef T ValueType;
    typedef typename Accumulator<T>::Type ResultType;

    ResultType operator()( const T* a, const T* b, int size ) const
    {
        return normL2Sqr<ValueType, ResultType>(a, b, size);
    }
};




template<class T>
struct L2
{
    enum { normType = NORM_L2 };
    typedef T ValueType;
    typedef typename Accumulator<T>::Type ResultType;

    ResultType operator()( const T* a, const T* b, int size ) const
    {
        return (ResultType)sqrt((double)normL2Sqr<ValueType, ResultType>(a, b, size));
    }
};




template<class T>
struct L1
{
    enum { normType = NORM_L1 };
    typedef T ValueType;
    typedef typename Accumulator<T>::Type ResultType;

    ResultType operator()( const T* a, const T* b, int size ) const
    {
        return normL1<ValueType, ResultType>(a, b, size);
    }
};





struct Hamming
{
    enum { normType = NORM_HAMMING };
    typedef unsigned char ValueType;
    typedef int ResultType;



    ResultType operator()( const unsigned char* a, const unsigned char* b, int size ) const
    {
        return normHamming(a, b, size);
    }
};

typedef Hamming HammingLUT;

template<int cellsize> struct HammingMultilevel
{
    enum { normType = NORM_HAMMING + (cellsize>1) };
    typedef unsigned char ValueType;
    typedef int ResultType;

    ResultType operator()( const unsigned char* a, const unsigned char* b, int size ) const
    {
        return normHamming(a, b, size, cellsize);
    }
};







struct DMatch
{
    DMatch() : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(3.40282346638528859812e+38F) {}
    DMatch( int _queryIdx, int _trainIdx, float _distance ) :
            queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(-1), distance(_distance) {}
    DMatch( int _queryIdx, int _trainIdx, int _imgIdx, float _distance ) :
            queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) {}

    int queryIdx;
    int trainIdx;
    int imgIdx;

    float distance;


    bool operator<( const DMatch &m ) const
    {
        return distance < m.distance;
    }
};







class DescriptorMatcher : public Algorithm
{
public:
    virtual ~DescriptorMatcher();





    virtual void add( const vector<Mat>& descriptors );



    const vector<Mat>& getTrainDescriptors() const;



    virtual void clear();




    virtual bool empty() const;



    virtual bool isMaskSupported() const = 0;
#1102 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    virtual void train();





    void match( const Mat& queryDescriptors, const Mat& trainDescriptors,
                vector<DMatch>& matches, const Mat& mask=Mat() ) const;




    void knnMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,
                   vector<vector<DMatch> >& matches, int k,
                   const Mat& mask=Mat(), bool compactResult=false ) const;


    void radiusMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,
                      vector<vector<DMatch> >& matches, float maxDistance,
                      const Mat& mask=Mat(), bool compactResult=false ) const;




    void match( const Mat& queryDescriptors, vector<DMatch>& matches,
                const vector<Mat>& masks=vector<Mat>() );
    void knnMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,
           const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );
    void radiusMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,
                   const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );


    virtual void read( const FileNode& );

    virtual void write( FileStorage& ) const;




    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;

    static Ptr<DescriptorMatcher> create( const string& descriptorMatcherType );
protected:




    class DescriptorCollection
    {
    public:
        DescriptorCollection();
        DescriptorCollection( const DescriptorCollection& collection );
        virtual ~DescriptorCollection();


        void set( const vector<Mat>& descriptors );
        virtual void clear();

        const Mat& getDescriptors() const;
        const Mat getDescriptor( int imgIdx, int localDescIdx ) const;
        const Mat getDescriptor( int globalDescIdx ) const;
        void getLocalIdx( int globalDescIdx, int& imgIdx, int& localDescIdx ) const;

        int size() const;

    protected:
        Mat mergedDescriptors;
        vector<int> startIdxs;
    };




    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,
           const vector<Mat>& masks=vector<Mat>(), bool compactResult=false ) = 0;
    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,
           const vector<Mat>& masks=vector<Mat>(), bool compactResult=false ) = 0;

    static bool isPossibleMatch( const Mat& mask, int queryIdx, int trainIdx );
    static bool isMaskedOut( const vector<Mat>& masks, int queryIdx );

    static Mat clone_op( Mat m ) { return m.clone(); }
    void checkMasks( const vector<Mat>& masks, int queryDescriptorsCount ) const;


    vector<Mat> trainDescCollection;
};
#1199 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class BFMatcher : public DescriptorMatcher
{
public:
    BFMatcher( int normType=NORM_L2, bool crossCheck=false );
    virtual ~BFMatcher() {}

    virtual bool isMaskSupported() const { return true; }

    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;

    AlgorithmInfo* info() const;
protected:
    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,
           const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );
    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,
           const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );

    int normType;
    bool crossCheck;
};





class FlannBasedMatcher : public DescriptorMatcher
{
public:
    FlannBasedMatcher( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(),
                       const Ptr<flann::SearchParams>& searchParams=new flann::SearchParams() );

    virtual void add( const vector<Mat>& descriptors );
    virtual void clear();


    virtual void read( const FileNode& );

    virtual void write( FileStorage& ) const;

    virtual void train();
    virtual bool isMaskSupported() const;

    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;

    AlgorithmInfo* info() const;
protected:
    static void convertToDMatches( const DescriptorCollection& descriptors,
                                   const Mat& indices, const Mat& distances,
                                   vector<vector<DMatch> >& matches );

    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,
                   const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );
    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,
                   const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );

    Ptr<flann::IndexParams> indexParams;
    Ptr<flann::SearchParams> searchParams;
    Ptr<flann::Index> flannIndex;

    DescriptorCollection mergedDescriptors;
    int addedDescCount;
};







class GenericDescriptorMatcher;
typedef GenericDescriptorMatcher GenericDescriptorMatch;

class GenericDescriptorMatcher
{
public:
    GenericDescriptorMatcher();
    virtual ~GenericDescriptorMatcher();
#1287 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    virtual void add( const vector<Mat>& images,
                      vector<vector<KeyPoint> >& keypoints );

    const vector<Mat>& getTrainImages() const;
    const vector<vector<KeyPoint> >& getTrainKeypoints() const;




    virtual void clear();



    virtual bool isMaskSupported() = 0;





    virtual void train();
#1316 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                           const Mat& trainImage, vector<KeyPoint>& trainKeypoints ) const;

    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints );







    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                const Mat& trainImage, vector<KeyPoint>& trainKeypoints,
                vector<DMatch>& matches, const Mat& mask=Mat() ) const;




    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                   const Mat& trainImage, vector<KeyPoint>& trainKeypoints,
                   vector<vector<DMatch> >& matches, int k,
                   const Mat& mask=Mat(), bool compactResult=false ) const;

    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                      const Mat& trainImage, vector<KeyPoint>& trainKeypoints,
                      vector<vector<DMatch> >& matches, float maxDistance,
                      const Mat& mask=Mat(), bool compactResult=false ) const;




    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() );
    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                   vector<vector<DMatch> >& matches, int k,
                   const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );
    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                      vector<vector<DMatch> >& matches, float maxDistance,
                      const vector<Mat>& masks=vector<Mat>(), bool compactResult=false );


    virtual void read( const FileNode& fn );

    virtual void write( FileStorage& fs ) const;


    virtual bool empty() const;




    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;

    static Ptr<GenericDescriptorMatcher> create( const string& genericDescritptorMatcherType,
                                                 const string &paramsFilename=string() );

protected:



    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                               vector<vector<DMatch> >& matches, int k,
                               const vector<Mat>& masks, bool compactResult ) = 0;
    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                                  vector<vector<DMatch> >& matches, float maxDistance,
                                  const vector<Mat>& masks, bool compactResult ) = 0;



    class KeyPointCollection
    {
    public:
        KeyPointCollection();
        KeyPointCollection( const KeyPointCollection& collection );
        void add( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints );
        void clear();


        size_t keypointCount() const;
        size_t imageCount() const;

        const vector<vector<KeyPoint> >& getKeypoints() const;
        const vector<KeyPoint>& getKeypoints( int imgIdx ) const;
        const KeyPoint& getKeyPoint( int imgIdx, int localPointIdx ) const;
        const KeyPoint& getKeyPoint( int globalPointIdx ) const;
        void getLocalIdx( int globalPointIdx, int& imgIdx, int& localPointIdx ) const;

        const vector<Mat>& getImages() const;
        const Mat& getImage( int imgIdx ) const;

    protected:
        int pointCount;

        vector<Mat> images;
        vector<vector<KeyPoint> > keypoints;

        vector<int> startIndices;

    private:
        static Mat clone_op( Mat m ) { return m.clone(); }
    };

    KeyPointCollection trainPointCollection;
};
#1429 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class VectorDescriptorMatcher;
typedef VectorDescriptorMatcher VectorDescriptorMatch;

class VectorDescriptorMatcher : public GenericDescriptorMatcher
{
public:
    VectorDescriptorMatcher( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher );
    virtual ~VectorDescriptorMatcher();

    virtual void add( const vector<Mat>& imgCollection,
                      vector<vector<KeyPoint> >& pointCollection );

    virtual void clear();

    virtual void train();

    virtual bool isMaskSupported();

    virtual void read( const FileNode& fn );
    virtual void write( FileStorage& fs ) const;
    virtual bool empty() const;

    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;

protected:
    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                               vector<vector<DMatch> >& matches, int k,
                               const vector<Mat>& masks, bool compactResult );
    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,
                                  vector<vector<DMatch> >& matches, float maxDistance,
                                  const vector<Mat>& masks, bool compactResult );

    Ptr<DescriptorExtractor> extractor;
    Ptr<DescriptorMatcher> matcher;
};




struct DrawMatchesFlags
{
    enum{ DEFAULT = 0,




          DRAW_OVER_OUTIMG = 1,

          NOT_DRAW_SINGLE_POINTS = 2,
          DRAW_RICH_KEYPOINTS = 4

        };
};


 void drawKeypoints( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImage,
                               const Scalar& color=Scalar::all(-1), int flags=DrawMatchesFlags::DEFAULT );


 void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,
                             const Mat& img2, const vector<KeyPoint>& keypoints2,
                             const vector<DMatch>& matches1to2, Mat& outImg,
                             const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1),
                             const vector<char>& matchesMask=vector<char>(), int flags=DrawMatchesFlags::DEFAULT );

 void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,
                             const Mat& img2, const vector<KeyPoint>& keypoints2,
                             const vector<vector<DMatch> >& matches1to2, Mat& outImg,
                             const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1),
                             const vector<vector<char> >& matchesMask=vector<vector<char> >(), int flags=DrawMatchesFlags::DEFAULT );





 void evaluateFeatureDetector( const Mat& img1, const Mat& img2, const Mat& H1to2,
                                         vector<KeyPoint>* keypoints1, vector<KeyPoint>* keypoints2,
                                         float& repeatability, int& correspCount,
                                         const Ptr<FeatureDetector>& fdetector=Ptr<FeatureDetector>() );

 void computeRecallPrecisionCurve( const vector<vector<DMatch> >& matches1to2,
                                             const vector<vector<uchar> >& correctMatches1to2Mask,
                                             vector<Point2f>& recallPrecisionCurve );

 float getRecall( const vector<Point2f>& recallPrecisionCurve, float l_precision );
 int getNearestPoint( const vector<Point2f>& recallPrecisionCurve, float l_precision );

 void evaluateGenericDescriptorMatcher( const Mat& img1, const Mat& img2, const Mat& H1to2,
                                                  vector<KeyPoint>& keypoints1, vector<KeyPoint>& keypoints2,
                                                  vector<vector<DMatch> >* matches1to2, vector<vector<uchar> >* correctMatches1to2Mask,
                                                  vector<Point2f>& recallPrecisionCurve,
                                                  const Ptr<GenericDescriptorMatcher>& dmatch=Ptr<GenericDescriptorMatcher>() );
#1529 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
class BOWTrainer
{
public:
    BOWTrainer();
    virtual ~BOWTrainer();

    void add( const Mat& descriptors );
    const vector<Mat>& getDescriptors() const;
    int descripotorsCount() const;

    virtual void clear();
#1548 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/features2d/features2d.hpp"
    virtual Mat cluster() const = 0;
    virtual Mat cluster( const Mat& descriptors ) const = 0;

protected:
    vector<Mat> descriptors;
    int size;
};




class BOWKMeansTrainer : public BOWTrainer
{
public:
    BOWKMeansTrainer( int clusterCount, const TermCriteria& termcrit=TermCriteria(),
                      int attempts=3, int flags=KMEANS_PP_CENTERS );
    virtual ~BOWKMeansTrainer();


    virtual Mat cluster() const;
    virtual Mat cluster( const Mat& descriptors ) const;

protected:

    int clusterCount;
    TermCriteria termcrit;
    int attempts;
    int flags;
};




class BOWImgDescriptorExtractor
{
public:
    BOWImgDescriptorExtractor( const Ptr<DescriptorExtractor>& dextractor,
                               const Ptr<DescriptorMatcher>& dmatcher );
    virtual ~BOWImgDescriptorExtractor();

    void setVocabulary( const Mat& vocabulary );
    const Mat& getVocabulary() const;
    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor,
                  vector<vector<int> >* pointIdxsOfClusters=0, Mat* descriptors=0 );


    int descriptorSize() const;
    int descriptorType() const;

protected:
    Mat vocabulary;
    Ptr<DescriptorExtractor> dextractor;
    Ptr<DescriptorMatcher> dmatcher;
};

}
#54 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp" 1
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/deque" 1 3
#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/deque" 3

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/deque" 3





#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 1 3
#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#87 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
#104 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator()
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
#437 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
#481 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
#571 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
#718 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:





      deque()
      : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
#816 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
#830 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
#882 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
#907 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
#957 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
#973 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
#999 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
#1113 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
#1176 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size > __len)
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
#1199 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
#1215 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
#1230 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
#1255 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
#1273 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
#1330 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
#1361 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
#1392 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
#1413 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
#1450 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
#1490 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
#1504 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
#1527 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
#1546 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
#1558 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
#1620 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
#1642 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);
#1658 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }




      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);
#1729 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void _M_pop_back_aux();

      void _M_pop_front_aux();
#1741 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);







      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }
#1847 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
#1883 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
#1915 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
#1933 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }




}
#66 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/deque" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 1 3
#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#92 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }
#148 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }
#193 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }
#332 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)

      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {




     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);

     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(const value_type& __t)

      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;




     this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);

   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>
#572 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 3
    typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, const value_type& __x)
      {
 value_type __x_copy = __x;

 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front((front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::copy(__front2, __pos1, __front1);
   }
 else
   {
     push_back((back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::copy_backward(__pos, __back2, __back1);
   }
 *__pos = (__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }
#1045 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/deque.tcc" 3

}
#68 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/deque" 2 3
#51 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp" 2

extern "C" {
#68 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
typedef struct CvHaarFeature
{
    int tilted;
    struct
    {
        CvRect r;
        float weight;
    } rect[3];
} CvHaarFeature;

typedef struct CvHaarClassifier
{
    int count;
    CvHaarFeature* haar_feature;
    float* threshold;
    int* left;
    int* right;
    float* alpha;
} CvHaarClassifier;

typedef struct CvHaarStageClassifier
{
    int count;
    float threshold;
    CvHaarClassifier* classifier;

    int next;
    int child;
    int parent;
} CvHaarStageClassifier;

typedef struct CvHidHaarClassifierCascade CvHidHaarClassifierCascade;

typedef struct CvHaarClassifierCascade
{
    int flags;
    int count;
    CvSize orig_window_size;
    CvSize real_window_size;
    double scale;
    CvHaarStageClassifier* stage_classifier;
    CvHidHaarClassifierCascade* hid_cascade;
} CvHaarClassifierCascade;

typedef struct CvAvgComp
{
    CvRect rect;
    int neighbors;
} CvAvgComp;



extern "C" CvHaarClassifierCascade* cvLoadHaarClassifierCascade(
                    const char* directory, CvSize orig_window_size);

extern "C" void cvReleaseHaarClassifierCascade( CvHaarClassifierCascade** cascade );
#139 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
extern "C" CvSeq* cvHaarDetectObjects( const CvArr* image,
                     CvHaarClassifierCascade* cascade, CvMemStorage* storage,
                     double scale_factor = 1.1,
                     int min_neighbors = 3, int flags = 0,
                     CvSize min_size = cvSize(0,0), CvSize max_size = cvSize(0,0));


extern "C" void cvSetImagesForHaarClassifierCascade( CvHaarClassifierCascade* cascade,
                                                const CvArr* sum, const CvArr* sqsum,
                                                const CvArr* tilted_sum, double scale );


extern "C" int cvRunHaarClassifierCascade( const CvHaarClassifierCascade* cascade,
                                       CvPoint pt, int start_stage = 0);
#163 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
typedef struct CvLSVMFilterPosition
{
    int x;
    int y;
    int l;
} CvLSVMFilterPosition;
#184 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
typedef struct CvLSVMFilterObject{
    CvLSVMFilterPosition V;
    float fineFunction[4];
    int sizeX;
    int sizeY;
    int numFeatures;
    float *H;
} CvLSVMFilterObject;
#201 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
typedef struct CvLatentSvmDetector
{
    int num_filters;
    int num_components;
    int* num_part_filters;
    CvLSVMFilterObject** filters;
    float* b;
    float score_threshold;
}
CvLatentSvmDetector;





typedef struct CvObjectDetection
{
    CvRect rect;
    float score;
} CvObjectDetection;
#236 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
extern "C" CvLatentSvmDetector* cvLoadLatentSvmDetector(const char* filename);
#247 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
extern "C" void cvReleaseLatentSvmDetector(CvLatentSvmDetector** detector);
#269 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
extern "C" CvSeq* cvLatentSvmDetectObjects(IplImage* image,
                                CvLatentSvmDetector* detector,
                                CvMemStorage* storage,
                                float overlap_threshold = 0.5f,
                                int numThreads = -1);


}

 CvSeq* cvHaarDetectObjectsForROC( const CvArr* image,
                     CvHaarClassifierCascade* cascade, CvMemStorage* storage,
                     std::vector<int>& rejectLevels, std::vector<double>& levelWeightds,
                     double scale_factor = 1.1,
                     int min_neighbors = 3, int flags = 0,
                     CvSize min_size = cvSize(0,0), CvSize max_size = cvSize(0,0),
                     bool outputRejectLevels = false );

namespace cv
{
#297 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
class LatentSvmDetector
{
public:
    struct ObjectDetection
    {
        ObjectDetection();
        ObjectDetection( const Rect& rect, float score, int classID=-1 );
        Rect rect;
        float score;
        int classID;
    };

    LatentSvmDetector();
    LatentSvmDetector( const vector<string>& filenames, const vector<string>& classNames=vector<string>() );
    virtual ~LatentSvmDetector();

    virtual void clear();
    virtual bool empty() const;
    bool load( const vector<string>& filenames, const vector<string>& classNames=vector<string>() );

    virtual void detect( const Mat& image,
                         vector<ObjectDetection>& objectDetections,
                         float overlapThreshold=0.5f,
                         int numThreads=-1 );

    const vector<string>& getClassNames() const;
    size_t getClassCount() const;

private:
    vector<CvLatentSvmDetector*> detectors;
    vector<string> classNames;
};

 void groupRectangles( vector<Rect>& rectList, int groupThreshold, double eps=0.2);
 void groupRectangles( vector<Rect>& rectList, vector<int>& weights, int groupThreshold, double eps=0.2);
 void groupRectangles( vector<Rect>& rectList, int groupThreshold, double eps, vector<int>* weights, vector<double>* levelWeights );
 void groupRectangles(vector<Rect>& rectList, vector<int>& rejectLevels,
                                vector<double>& levelWeights, int groupThreshold, double eps=0.2);
 void groupRectangles_meanshift(vector<Rect>& rectList, vector<double>& foundWeights, vector<double>& foundScales,
                                          double detectThreshold = 0.0, Size winDetSize = Size(64, 128));


class FeatureEvaluator
{
public:
    enum { HAAR = 0, LBP = 1, HOG = 2 };
    virtual ~FeatureEvaluator();

    virtual bool read(const FileNode& node);
    virtual Ptr<FeatureEvaluator> clone() const;
    virtual int getFeatureType() const;

    virtual bool setImage(const Mat& img, Size origWinSize);
    virtual bool setWindow(Point p);

    virtual double calcOrd(int featureIdx) const;
    virtual int calcCat(int featureIdx) const;

    static Ptr<FeatureEvaluator> create(int type);
};

template<> void Ptr<CvHaarClassifierCascade>::delete_obj();

enum
{
    CASCADE_DO_CANNY_PRUNING=1,
    CASCADE_SCALE_IMAGE=2,
    CASCADE_FIND_BIGGEST_OBJECT=4,
    CASCADE_DO_ROUGH_SEARCH=8
};

class CascadeClassifier
{
public:
    CascadeClassifier();
    CascadeClassifier( const string& filename );
    virtual ~CascadeClassifier();

    virtual bool empty() const;
    bool load( const string& filename );
    virtual bool read( const FileNode& node );
    virtual void detectMultiScale( const Mat& image,
                                   vector<Rect>& objects,
                                   double scaleFactor=1.1,
                                   int minNeighbors=3, int flags=0,
                                   Size minSize=Size(),
                                   Size maxSize=Size() );

    virtual void detectMultiScale( const Mat& image,
                                   vector<Rect>& objects,
                                   vector<int>& rejectLevels,
                                   vector<double>& levelWeights,
                                   double scaleFactor=1.1,
                                   int minNeighbors=3, int flags=0,
                                   Size minSize=Size(),
                                   Size maxSize=Size(),
                                   bool outputRejectLevels=false );


    bool isOldFormatCascade() const;
    virtual Size getOriginalWindowSize() const;
    int getFeatureType() const;
    bool setImage( const Mat& );

protected:



    virtual bool detectSingleScale( const Mat& image, int stripCount, Size processingRectSize,
                                    int stripSize, int yStep, double factor, vector<Rect>& candidates,
                                    vector<int>& rejectLevels, vector<double>& levelWeights, bool outputRejectLevels=false);

protected:
    enum { BOOST = 0 };
    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,
           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };

    friend class CascadeClassifierInvoker;

    template<class FEval>
    friend int predictOrdered( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);

    template<class FEval>
    friend int predictCategorical( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);

    template<class FEval>
    friend int predictOrderedStump( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);

    template<class FEval>
    friend int predictCategoricalStump( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);

    bool setImage( Ptr<FeatureEvaluator>& feval, const Mat& image);
    virtual int runAt( Ptr<FeatureEvaluator>& feval, Point pt, double& weight );

    class Data
    {
    public:
        struct DTreeNode
        {
            int featureIdx;
            float threshold;
            int left;
            int right;
        };

        struct DTree
        {
            int nodeCount;
        };

        struct Stage
        {
            int first;
            int ntrees;
            float threshold;
        };

        bool read(const FileNode &node);

        bool isStumpBased;

        int stageType;
        int featureType;
        int ncategories;
        Size origWinSize;

        vector<Stage> stages;
        vector<DTree> classifiers;
        vector<DTreeNode> nodes;
        vector<float> leaves;
        vector<int> subsets;
    };

    Data data;
    Ptr<FeatureEvaluator> featureEvaluator;
    Ptr<CvHaarClassifierCascade> oldCascade;

public:
    class MaskGenerator
    {
    public:
        virtual ~MaskGenerator() {}
        virtual cv::Mat generateMask(const cv::Mat& src)=0;
        virtual void initializeMask(const cv::Mat& ) {};
    };
    void setMaskGenerator(Ptr<MaskGenerator> maskGenerator);
    Ptr<MaskGenerator> getMaskGenerator();

    void setFaceDetectionMaskGenerator();

protected:
    Ptr<MaskGenerator> maskGenerator;
};





struct DetectionROI
{

   double scale;

   vector<cv::Point> locations;

   vector<double> confidences;
};

struct HOGDescriptor
{
public:
    enum { L2Hys=0 };
    enum { DEFAULT_NLEVELS=64 };

    HOGDescriptor() : winSize(64,128), blockSize(16,16), blockStride(8,8),
        cellSize(8,8), nbins(9), derivAperture(1), winSigma(-1),
        histogramNormType(HOGDescriptor::L2Hys), L2HysThreshold(0.2), gammaCorrection(true),
        nlevels(HOGDescriptor::DEFAULT_NLEVELS)
    {}

    HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride,
                  Size _cellSize, int _nbins, int _derivAperture=1, double _winSigma=-1,
                  int _histogramNormType=HOGDescriptor::L2Hys,
                  double _L2HysThreshold=0.2, bool _gammaCorrection=false,
                  int _nlevels=HOGDescriptor::DEFAULT_NLEVELS)
    : winSize(_winSize), blockSize(_blockSize), blockStride(_blockStride), cellSize(_cellSize),
    nbins(_nbins), derivAperture(_derivAperture), winSigma(_winSigma),
    histogramNormType(_histogramNormType), L2HysThreshold(_L2HysThreshold),
    gammaCorrection(_gammaCorrection), nlevels(_nlevels)
    {}

    HOGDescriptor(const String& filename)
    {
        load(filename);
    }

    HOGDescriptor(const HOGDescriptor& d)
    {
        d.copyTo(*this);
    }

    virtual ~HOGDescriptor() {}

    size_t getDescriptorSize() const;
    bool checkDetectorSize() const;
    double getWinSigma() const;

    virtual void setSVMDetector(InputArray _svmdetector);

    virtual bool read(FileNode& fn);
    virtual void write(FileStorage& fs, const String& objname) const;

    virtual bool load(const String& filename, const String& objname=String());
    virtual void save(const String& filename, const String& objname=String()) const;
    virtual void copyTo(HOGDescriptor& c) const;

    virtual void compute(const Mat& img,
                         vector<float>& descriptors,
                         Size winStride=Size(), Size padding=Size(),
                         const vector<Point>& locations=vector<Point>()) const;

    virtual void detect(const Mat& img, vector<Point>& foundLocations,
                        vector<double>& weights,
                        double hitThreshold=0, Size winStride=Size(),
                        Size padding=Size(),
                        const vector<Point>& searchLocations=vector<Point>()) const;

    virtual void detect(const Mat& img, vector<Point>& foundLocations,
                        double hitThreshold=0, Size winStride=Size(),
                        Size padding=Size(),
                        const vector<Point>& searchLocations=vector<Point>()) const;

    virtual void detectMultiScale(const Mat& img, vector<Rect>& foundLocations,
                                  vector<double>& foundWeights, double hitThreshold=0,
                                  Size winStride=Size(), Size padding=Size(), double scale=1.05,
                                  double finalThreshold=2.0,bool useMeanshiftGrouping = false) const;

    virtual void detectMultiScale(const Mat& img, vector<Rect>& foundLocations,
                                  double hitThreshold=0, Size winStride=Size(),
                                  Size padding=Size(), double scale=1.05,
                                  double finalThreshold=2.0, bool useMeanshiftGrouping = false) const;

    virtual void computeGradient(const Mat& img, Mat& grad, Mat& angleOfs,
                                 Size paddingTL=Size(), Size paddingBR=Size()) const;

    static vector<float> getDefaultPeopleDetector();
    static vector<float> getDaimlerPeopleDetector();

    Size winSize;
    Size blockSize;
    Size blockStride;
    Size cellSize;
    int nbins;
    int derivAperture;
    double winSigma;
    int histogramNormType;
    double L2HysThreshold;
    bool gammaCorrection;
    vector<float> svmDetector;
    int nlevels;



   void detectROI(const cv::Mat& img, const vector<cv::Point> &locations,
                                   std::vector<cv::Point>& foundLocations, std::vector<double>& confidences,
                                   double hitThreshold = 0, cv::Size winStride = Size(),
                                   cv::Size padding = Size()) const;


   void detectMultiScaleROI(const cv::Mat& img,
                                                       std::vector<cv::Rect>& foundLocations,
                                                       std::vector<DetectionROI>& locations,
                                                       double hitThreshold = 0,
                                                       int groupThreshold = 0) const;


   void readALTModel(std::string modelfile);
};


 void findDataMatrix(InputArray image,
                                 vector<string>& codes,
                                 OutputArray corners=noArray(),
                                 OutputArrayOfArrays dmtx=noArray());
 void drawDataMatrixCodes(InputOutputArray image,
                                      const vector<string>& codes,
                                      InputArray corners);
}





struct CvDataMatrixCode {
  char msg[4];
  CvMat *original;
  CvMat *corners;
};

 std::deque<CvDataMatrixCode> cvFindDataMatrix(CvMat *im);





namespace cv {
namespace linemod {

using cv::FileNode;
using cv::FileStorage;
using cv::Mat;
using cv::noArray;
using cv::OutputArrayOfArrays;
using cv::Point;
using cv::Ptr;
using cv::Rect;
using cv::Size;






struct Feature
{
  int x;
  int y;
  int label;

  Feature() : x(0), y(0), label(0) {}
  Feature(int x, int y, int label);

  void read(const FileNode& fn);
  void write(FileStorage& fs) const;
};

inline Feature::Feature(int _x, int _y, int _label) : x(_x), y(_y), label(_label) {}

struct Template
{
  int width;
  int height;
  int pyramid_level;
  std::vector<Feature> features;

  void read(const FileNode& fn);
  void write(FileStorage& fs) const;
};




class QuantizedPyramid
{
public:

  virtual ~QuantizedPyramid() {}







  virtual void quantize(Mat& dst) const =0;






  virtual bool extractTemplate(Template& templ) const =0;






  virtual void pyrDown() =0;

protected:

  struct Candidate
  {
    Candidate(int x, int y, int label, float score);


    bool operator<(const Candidate& rhs) const
    {
      return score > rhs.score;
    }

    Feature f;
    float score;
  };
#741 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  static void selectScatteredFeatures(const std::vector<Candidate>& candidates,
                                      std::vector<Feature>& features,
                                      size_t num_features, float distance);
};

inline QuantizedPyramid::Candidate::Candidate(int x, int y, int label, float _score) : f(x, y, label), score(_score) {}






class Modality
{
public:

  virtual ~Modality() {}
#766 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  Ptr<QuantizedPyramid> process(const Mat& src,
                    const Mat& mask = Mat()) const
  {
    return processImpl(src, mask);
  }

  virtual std::string name() const =0;

  virtual void read(const FileNode& fn) =0;
  virtual void write(FileStorage& fs) const =0;
#784 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  static Ptr<Modality> create(const std::string& modality_type);




  static Ptr<Modality> create(const FileNode& fn);

protected:

  virtual Ptr<QuantizedPyramid> processImpl(const Mat& src,
                        const Mat& mask) const =0;
};




class ColorGradient : public Modality
{
public:



  ColorGradient();
#816 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  ColorGradient(float weak_threshold, size_t num_features, float strong_threshold);

  virtual std::string name() const;

  virtual void read(const FileNode& fn);
  virtual void write(FileStorage& fs) const;

  float weak_threshold;
  size_t num_features;
  float strong_threshold;

protected:
  virtual Ptr<QuantizedPyramid> processImpl(const Mat& src,
                        const Mat& mask) const;
};




class DepthNormal : public Modality
{
public:



  DepthNormal();
#853 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  DepthNormal(int distance_threshold, int difference_threshold, size_t num_features,
              int extract_threshold);

  virtual std::string name() const;

  virtual void read(const FileNode& fn);
  virtual void write(FileStorage& fs) const;

  int distance_threshold;
  int difference_threshold;
  size_t num_features;
  int extract_threshold;

protected:
  virtual Ptr<QuantizedPyramid> processImpl(const Mat& src,
                        const Mat& mask) const;
};




void colormap(const Mat& quantized, Mat& dst);




struct Match
{
  Match()
  {
  }

  Match(int x, int y, float similarity, const std::string& class_id, int template_id);


  bool operator<(const Match& rhs) const
  {

    if (similarity != rhs.similarity)
      return similarity > rhs.similarity;
    else
      return template_id < rhs.template_id;
  }

  bool operator==(const Match& rhs) const
  {
    return x == rhs.x && y == rhs.y && similarity == rhs.similarity && class_id == rhs.class_id;
  }

  int x;
  int y;
  float similarity;
  std::string class_id;
  int template_id;
};

inline Match::Match(int _x, int _y, float _similarity, const std::string& _class_id, int _template_id)
    : x(_x), y(_y), similarity(_similarity), class_id(_class_id), template_id(_template_id)
  {
  }





class Detector
{
public:



  Detector();
#933 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  Detector(const std::vector< Ptr<Modality> >& modalities, const std::vector<int>& T_pyramid);
#950 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  void match(const std::vector<Mat>& sources, float threshold, std::vector<Match>& matches,
             const std::vector<std::string>& class_ids = std::vector<std::string>(),
             OutputArrayOfArrays quantized_images = noArray(),
             const std::vector<Mat>& masks = std::vector<Mat>()) const;
#965 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/objdetect/objdetect.hpp"
  int addTemplate(const std::vector<Mat>& sources, const std::string& class_id,
          const Mat& object_mask, Rect* bounding_box = __null);




  int addSyntheticTemplate(const std::vector<Template>& templates, const std::string& class_id);







  const std::vector< Ptr<Modality> >& getModalities() const { return modalities; }




  int getT(int pyramid_level) const { return T_at_level[pyramid_level]; }




  int pyramidLevels() const { return pyramid_levels; }







  const std::vector<Template>& getTemplates(const std::string& class_id, int template_id) const;

  int numTemplates() const;
  int numTemplates(const std::string& class_id) const;
  int numClasses() const { return static_cast<int>(class_templates.size()); }

  std::vector<std::string> classIds() const;

  void read(const FileNode& fn);
  void write(FileStorage& fs) const;

  std::string readClass(const FileNode& fn, const std::string &class_id_override = "");
  void writeClass(const std::string& class_id, FileStorage& fs) const;

  void readClasses(const std::vector<std::string>& class_ids,
                   const std::string& format = "templates_%s.yml.gz");
  void writeClasses(const std::string& format = "templates_%s.yml.gz") const;

protected:
  std::vector< Ptr<Modality> > modalities;
  int pyramid_levels;
  std::vector<int> T_at_level;

  typedef std::vector<Template> TemplatePyramid;
  typedef std::map<std::string, std::vector<TemplatePyramid> > TemplatesMap;
  TemplatesMap class_templates;

  typedef std::vector<Mat> LinearMemories;

  typedef std::vector< std::vector<LinearMemories> > LinearMemoryPyramid;

  void matchClass(const LinearMemoryPyramid& lm_pyramid,
                  const std::vector<Size>& sizes,
                  float threshold, std::vector<Match>& matches,
                  const std::string& class_id,
                  const std::vector<TemplatePyramid>& template_pyramids) const;
};






 Ptr<Detector> getDefaultLINE();







 Ptr<Detector> getDefaultLINEMOD();

}
}
#55 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/calib3d/calib3d.hpp" 1
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/calib3d/calib3d.hpp"
extern "C" {






typedef struct CvPOSITObject CvPOSITObject;


extern "C" CvPOSITObject* cvCreatePOSITObject( CvPoint3D32f* points, int point_count );




extern "C" void cvPOSIT( CvPOSITObject* posit_object, CvPoint2D32f* image_points,
                       double focal_length, CvTermCriteria criteria,
                       float* rotation_matrix, float* translation_vector);


extern "C" void cvReleasePOSITObject( CvPOSITObject** posit_object );


extern "C" int cvRANSACUpdateNumIters( double p, double err_prob,
                                   int model_points, int max_iters );

extern "C" void cvConvertPointsHomogeneous( const CvMat* src, CvMat* dst );
#90 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/calib3d/calib3d.hpp"
enum
{
    CV_ITERATIVE = 0,
    CV_EPNP = 1,
    CV_P3P = 2
};

extern "C" int cvFindFundamentalMat( const CvMat* points1, const CvMat* points2,
                                 CvMat* fundamental_matrix,
                                 int method = 8,
                                 double param1 = 3., double param2 = 0.99,
                                 CvMat* status = __null );




extern "C" void cvComputeCorrespondEpilines( const CvMat* points,
                                         int which_image,
                                         const CvMat* fundamental_matrix,
                                         CvMat* correspondent_lines );



extern "C" void cvTriangulatePoints(CvMat* projMatr1, CvMat* projMatr2,
                                CvMat* projPoints1, CvMat* projPoints2,
                                CvMat* points4D);

extern "C" void cvCorrectMatches(CvMat* F, CvMat* points1, CvMat* points2,
                             CvMat* new_points1, CvMat* new_points2);






extern "C" void cvGetOptimalNewCameraMatrix( const CvMat* camera_matrix,
                                         const CvMat* dist_coeffs,
                                         CvSize image_size, double alpha,
                                         CvMat* new_camera_matrix,
                                         CvSize new_imag_size = cvSize(0,0),
                                         CvRect* valid_pixel_ROI = 0,
                                         int center_principal_point = 0);


extern "C" int cvRodrigues2( const CvMat* src, CvMat* dst,
                         CvMat* jacobian = 0 );


extern "C" int cvFindHomography( const CvMat* src_points,
                             const CvMat* dst_points,
                             CvMat* homography,
                             int method = 0,
                             double ransacReprojThreshold = 3,
                             CvMat* mask = 0);


extern "C" void cvRQDecomp3x3( const CvMat *matrixM, CvMat *matrixR, CvMat *matrixQ,
                           CvMat *matrixQx = __null,
                           CvMat *matrixQy = __null,
                           CvMat *matrixQz = __null,
                           CvPoint3D64f *eulerAngles = __null);


extern "C" void cvDecomposeProjectionMatrix( const CvMat *projMatr, CvMat *calibMatr,
                                         CvMat *rotMatr, CvMat *posVect,
                                         CvMat *rotMatrX = __null,
                                         CvMat *rotMatrY = __null,
                                         CvMat *rotMatrZ = __null,
                                         CvPoint3D64f *eulerAngles = __null);


extern "C" void cvCalcMatMulDeriv( const CvMat* A, const CvMat* B, CvMat* dABdA, CvMat* dABdB );



extern "C" void cvComposeRT( const CvMat* _rvec1, const CvMat* _tvec1,
                         const CvMat* _rvec2, const CvMat* _tvec2,
                         CvMat* _rvec3, CvMat* _tvec3,
                         CvMat* dr3dr1 = 0, CvMat* dr3dt1 = 0,
                         CvMat* dr3dr2 = 0, CvMat* dr3dt2 = 0,
                         CvMat* dt3dr1 = 0, CvMat* dt3dt1 = 0,
                         CvMat* dt3dr2 = 0, CvMat* dt3dt2 = 0 );



extern "C" void cvProjectPoints2( const CvMat* object_points, const CvMat* rotation_vector,
                              const CvMat* translation_vector, const CvMat* camera_matrix,
                              const CvMat* distortion_coeffs, CvMat* image_points,
                              CvMat* dpdrot = __null, CvMat* dpdt = __null,
                              CvMat* dpdf = __null, CvMat* dpdc = __null,
                              CvMat* dpddist = __null,
                              double aspect_ratio = 0);



extern "C" void cvFindExtrinsicCameraParams2( const CvMat* object_points,
                                          const CvMat* image_points,
                                          const CvMat* camera_matrix,
                                          const CvMat* distortion_coeffs,
                                          CvMat* rotation_vector,
                                          CvMat* translation_vector,
                                          int use_extrinsic_guess = 0 );



extern "C" void cvInitIntrinsicParams2D( const CvMat* object_points,
                                     const CvMat* image_points,
                                     const CvMat* npoints, CvSize image_size,
                                     CvMat* camera_matrix,
                                     double aspect_ratio = 1. );
#212 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/calib3d/calib3d.hpp"
extern "C" int cvCheckChessboard(IplImage* src, CvSize size);


extern "C" int cvFindChessboardCorners( const void* image, CvSize pattern_size,
                                    CvPoint2D32f* corners,
                                    int* corner_count = __null,
                                    int flags = 1 +2 );


extern "C" void cvDrawChessboardCorners( CvArr* image, CvSize pattern_size,
                                     CvPoint2D32f* corners,
                                     int count, int pattern_was_found );
#240 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/calib3d/calib3d.hpp"
extern "C" double cvCalibrateCamera2( const CvMat* object_points,
                                const CvMat* image_points,
                                const CvMat* point_counts,
                                CvSize image_size,
                                CvMat* camera_matrix,
                                CvMat* distortion_coeffs,
                                CvMat* rotation_vectors = __null,
                                CvMat* translation_vectors = __null,
                                int flags = 0,
                                CvTermCriteria term_crit = cvTermCriteria( 1 +2,30,double(2.22044604925031308085e-16L))
                                                                                      );



extern "C" void cvCalibrationMatrixValues( const CvMat *camera_matrix,
                                CvSize image_size,
                                double aperture_width = 0,
                                double aperture_height = 0,
                                double *fovx = __null,
                                double *fovy = __null,
                                double *focal_length = __null,
                                CvPoint2D64f *principal_point = __null,
                                double *pixel_aspect_ratio = __null);







extern "C" double cvStereoCalibrate( const CvMat* object_points, const CvMat* image_points1,
                               const CvMat* image_points2, const CvMat* npoints,
                               CvMat* camera_matrix1, CvMat* dist_coeffs1,
                               CvMat* camera_matrix2, CvMat* dist_coeffs2,
                               CvSize image_size, CvMat* R, CvMat* T,
                               CvMat* E = 0, CvMat* F = 0,
                               CvTermCriteria term_crit = cvTermCriteria( 1 +2,30,1e-6)
                                                                             ,
                               int flags = 256);





extern "C" void cvStereoRectify( const CvMat* camera_matrix1, const CvMat* camera_matrix2,
                             const CvMat* dist_coeffs1, const CvMat* dist_coeffs2,
                             CvSize image_size, const CvMat* R, const CvMat* T,
                             CvMat* R1, CvMat* R2, CvMat* P1, CvMat* P2,
                             CvMat* Q = 0,
                             int flags = 1024,
                             double alpha = -1,
                             CvSize new_image_size = cvSize(0,0),
                             CvRect* valid_pix_ROI1 = 0,
                             CvRect* valid_pix_ROI2 = 0);



extern "C" int cvStereoRectifyUncalibrated( const CvMat* points1, const CvMat* points2,
                                        const CvMat* F, CvSize img_size,
                                        CvMat* H1, CvMat* H2,
                                        double threshold = 5);
#310 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/calib3d/calib3d.hpp"
typedef struct CvStereoBMState
{

    int preFilterType;
    int preFilterSize;
    int preFilterCap;


    int SADWindowSize;
    int minDisparity;
    int numberOfDisparities;


    int textureThreshold;

    int uniquenessRatio;


    int speckleWindowSize;
    int speckleRange;

    int trySmallerWindows;

    CvRect roi1, roi2;
    int disp12MaxDiff;


    CvMat* preFilteredImg0;
    CvMat* preFilteredImg1;
    CvMat* slidingSumBuf;
    CvMat* cost;
    CvMat* disp;
} CvStereoBMState;





extern "C" CvStereoBMState* cvCreateStereoBMState(int preset = 0,
                                              int numberOfDisparities = 0);

extern "C" void cvReleaseStereoBMState( CvStereoBMState** state );

extern "C" void cvFindStereoCorrespondenceBM( const CvArr* left, const CvArr* right,
                                          CvArr* disparity, CvStereoBMState* state );

extern "C" CvRect cvGetValidDisparityROI( CvRect roi1, CvRect roi2, int minDisparity,
                                      int numberOfDisparities, int SADWindowSize );

extern "C" void cvValidateDisparity( CvArr* disparity, const CvArr* cost,
                                 int minDisparity, int numberOfDisparities,
                                 int disp12MaxDiff = 1 );


extern "C" void cvReprojectImageTo3D( const CvArr* disparityImage,
                                   CvArr* _3dImage, const CvMat* Q,
                                   int handleMissingValues = 0 );



}


class CvLevMarq
{
public:
    CvLevMarq();
    CvLevMarq( int nparams, int nerrs, CvTermCriteria criteria=
              cvTermCriteria(2 +1,30,double(2.22044604925031308085e-16L)),
              bool completeSymmFlag=false );
    ~CvLevMarq();
    void init( int nparams, int nerrs, CvTermCriteria criteria=
              cvTermCriteria(2 +1,30,double(2.22044604925031308085e-16L)),
              bool completeSymmFlag=false );
    bool update( const CvMat*& param, CvMat*& J, CvMat*& err );
    bool updateAlt( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm );

    void clear();
    void step();
    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };

    cv::Ptr<CvMat> mask;
    cv::Ptr<CvMat> prevParam;
    cv::Ptr<CvMat> param;
    cv::Ptr<CvMat> J;
    cv::Ptr<CvMat> err;
    cv::Ptr<CvMat> JtJ;
    cv::Ptr<CvMat> JtJN;
    cv::Ptr<CvMat> JtErr;
    cv::Ptr<CvMat> JtJV;
    cv::Ptr<CvMat> JtJW;
    double prevErrNorm, errNorm;
    int lambdaLg10;
    CvTermCriteria criteria;
    int state;
    int iters;
    bool completeSymmFlag;
};

namespace cv
{

 void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian=noArray());


enum
{
    LMEDS=4,
    RANSAC=8
};


 Mat findHomography( InputArray srcPoints, InputArray dstPoints,
                                 int method=0, double ransacReprojThreshold=3,
                                 OutputArray mask=noArray());


 Mat findHomography( InputArray srcPoints, InputArray dstPoints,
                               OutputArray mask, int method=0, double ransacReprojThreshold=3);


 Vec3d RQDecomp3x3( InputArray src, OutputArray mtxR, OutputArray mtxQ,
                                OutputArray Qx=noArray(),
                                OutputArray Qy=noArray(),
                                OutputArray Qz=noArray());


 void decomposeProjectionMatrix( InputArray projMatrix, OutputArray cameraMatrix,
                                             OutputArray rotMatrix, OutputArray transVect,
                                             OutputArray rotMatrixX=noArray(),
                                             OutputArray rotMatrixY=noArray(),
                                             OutputArray rotMatrixZ=noArray(),
                                             OutputArray eulerAngles=noArray() );


 void matMulDeriv( InputArray A, InputArray B,
                               OutputArray dABdA,
                               OutputArray dABdB );


 void composeRT( InputArray rvec1, InputArray tvec1,
                             InputArray rvec2, InputArray tvec2,
                             OutputArray rvec3, OutputArray tvec3,
                             OutputArray dr3dr1=noArray(), OutputArray dr3dt1=noArray(),
                             OutputArray dr3dr2=noArray(), OutputArray dr3dt2=noArray(),
                             OutputArray dt3dr1=noArray(), OutputArray dt3dt1=noArray(),
                             OutputArray dt3dr2=noArray(), OutputArray dt3dt2=noArray() );


 void projectPoints( InputArray objectPoints,
                                 InputArray rvec, InputArray tvec,
                                 InputArray cameraMatrix, InputArray distCoeffs,
                                 OutputArray imagePoints,
                                 OutputArray jacobian=noArray(),
                                 double aspectRatio=0 );


enum
{
    ITERATIVE=CV_ITERATIVE,
    EPNP=CV_EPNP,
    P3P=CV_P3P
};
 bool solvePnP( InputArray objectPoints, InputArray imagePoints,
                            InputArray cameraMatrix, InputArray distCoeffs,
                            OutputArray rvec, OutputArray tvec,
                            bool useExtrinsicGuess=false, int flags=ITERATIVE);


 void solvePnPRansac( InputArray objectPoints,
                                  InputArray imagePoints,
                                  InputArray cameraMatrix,
                                  InputArray distCoeffs,
                                  OutputArray rvec,
                                  OutputArray tvec,
                                  bool useExtrinsicGuess = false,
                                  int iterationsCount = 100,
                                  float reprojectionError = 8.0,
                                  int minInliersCount = 100,
                                  OutputArray inliers = noArray(),
                                  int flags = ITERATIVE);


 Mat initCameraMatrix2D( InputArrayOfArrays objectPoints,
                                     InputArrayOfArrays imagePoints,
                                     Size imageSize, double aspectRatio=1. );

enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,
       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };


 bool findChessboardCorners( InputArray image, Size patternSize,
                                         OutputArray corners,
                                         int flags=CALIB_CB_ADAPTIVE_THRESH+CALIB_CB_NORMALIZE_IMAGE );


 bool find4QuadCornerSubpix(InputArray img, InputOutputArray corners, Size region_size);


 void drawChessboardCorners( InputOutputArray image, Size patternSize,
                                         InputArray corners, bool patternWasFound );

enum { CALIB_CB_SYMMETRIC_GRID = 1, CALIB_CB_ASYMMETRIC_GRID = 2,
       CALIB_CB_CLUSTERING = 4 };


 bool findCirclesGrid( InputArray image, Size patternSize,
                                 OutputArray centers, int flags=CALIB_CB_SYMMETRIC_GRID,
                                 const Ptr<FeatureDetector> &blobDetector = new SimpleBlobDetector());


 bool findCirclesGridDefault( InputArray image, Size patternSize,
                                          OutputArray centers, int flags=CALIB_CB_SYMMETRIC_GRID );
enum
{
    CALIB_USE_INTRINSIC_GUESS = 1,
    CALIB_FIX_ASPECT_RATIO = 2,
    CALIB_FIX_PRINCIPAL_POINT = 4,
    CALIB_ZERO_TANGENT_DIST = 8,
    CALIB_FIX_FOCAL_LENGTH = 16,
    CALIB_FIX_K1 = 32,
    CALIB_FIX_K2 = 64,
    CALIB_FIX_K3 = 128,
    CALIB_FIX_K4 = 2048,
    CALIB_FIX_K5 = 4096,
    CALIB_FIX_K6 = 8192,
    CALIB_RATIONAL_MODEL = 16384,

    CALIB_FIX_INTRINSIC = 256,
    CALIB_SAME_FOCAL_LENGTH = 512,

    CALIB_ZERO_DISPARITY = 1024
};


 double calibrateCamera( InputArrayOfArrays objectPoints,
                                     InputArrayOfArrays imagePoints,
                                     Size imageSize,
                                     InputOutputArray cameraMatrix,
                                     InputOutputArray distCoeffs,
                                     OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs,
                                     int flags=0, TermCriteria criteria = TermCriteria(
                                         TermCriteria::COUNT+TermCriteria::EPS, 30, double(2.22044604925031308085e-16L)) );


 void calibrationMatrixValues( InputArray cameraMatrix,
                                Size imageSize,
                                double apertureWidth,
                                double apertureHeight,
                                double& fovx,
                                double& fovy,
                                double& focalLength,
                                Point2d& principalPoint,
                                double& aspectRatio );


 double stereoCalibrate( InputArrayOfArrays objectPoints,
                                     InputArrayOfArrays imagePoints1,
                                     InputArrayOfArrays imagePoints2,
                                     InputOutputArray cameraMatrix1,
                                     InputOutputArray distCoeffs1,
                                     InputOutputArray cameraMatrix2,
                                     InputOutputArray distCoeffs2,
                                     Size imageSize, OutputArray R,
                                     OutputArray T, OutputArray E, OutputArray F,
                                     TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6),
                                     int flags=CALIB_FIX_INTRINSIC );



 void stereoRectify( InputArray cameraMatrix1, InputArray distCoeffs1,
                               InputArray cameraMatrix2, InputArray distCoeffs2,
                               Size imageSize, InputArray R, InputArray T,
                               OutputArray R1, OutputArray R2,
                               OutputArray P1, OutputArray P2,
                               OutputArray Q, int flags=CALIB_ZERO_DISPARITY,
                               double alpha=-1, Size newImageSize=Size(),
                               Rect* validPixROI1=0, Rect* validPixROI2=0 );


 bool stereoRectifyUncalibrated( InputArray points1, InputArray points2,
                                             InputArray F, Size imgSize,
                                             OutputArray H1, OutputArray H2,
                                             double threshold=5 );


 float rectify3Collinear( InputArray cameraMatrix1, InputArray distCoeffs1,
                                      InputArray cameraMatrix2, InputArray distCoeffs2,
                                      InputArray cameraMatrix3, InputArray distCoeffs3,
                                      InputArrayOfArrays imgpt1, InputArrayOfArrays imgpt3,
                                      Size imageSize, InputArray R12, InputArray T12,
                                      InputArray R13, InputArray T13,
                                      OutputArray R1, OutputArray R2, OutputArray R3,
                                      OutputArray P1, OutputArray P2, OutputArray P3,
                                      OutputArray Q, double alpha, Size newImgSize,
                                      Rect* roi1, Rect* roi2, int flags );


 Mat getOptimalNewCameraMatrix( InputArray cameraMatrix, InputArray distCoeffs,
                                            Size imageSize, double alpha, Size newImgSize=Size(),
                                            Rect* validPixROI=0, bool centerPrincipalPoint=false);


 void convertPointsToHomogeneous( InputArray src, OutputArray dst );


 void convertPointsFromHomogeneous( InputArray src, OutputArray dst );


 void convertPointsHomogeneous( InputArray src, OutputArray dst );


enum
{
    FM_7POINT = 1,
    FM_8POINT = 2,
    FM_LMEDS = 4,
    FM_RANSAC = 8
};


 Mat findFundamentalMat( InputArray points1, InputArray points2,
                                     int method=FM_RANSAC,
                                     double param1=3., double param2=0.99,
                                     OutputArray mask=noArray());


 Mat findFundamentalMat( InputArray points1, InputArray points2,
                                   OutputArray mask, int method=FM_RANSAC,
                                   double param1=3., double param2=0.99);


 void computeCorrespondEpilines( InputArray points,
                                           int whichImage, InputArray F,
                                           OutputArray lines );

 void triangulatePoints( InputArray projMatr1, InputArray projMatr2,
                                     InputArray projPoints1, InputArray projPoints2,
                                     OutputArray points4D );

 void correctMatches( InputArray F, InputArray points1, InputArray points2,
                                  OutputArray newPoints1, OutputArray newPoints2 );

template<> void Ptr<CvStereoBMState>::delete_obj();






class StereoBM
{
public:
    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,
        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };


    StereoBM();

    StereoBM(int preset, int ndisparities=0, int SADWindowSize=21);

    void init(int preset, int ndisparities=0, int SADWindowSize=21);

    void operator()( InputArray left, InputArray right,
                                         OutputArray disparity, int disptype=3 );


    Ptr<CvStereoBMState> state;
};







class StereoSGBM
{
public:
    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };


    StereoSGBM();


    StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize,
               int P1=0, int P2=0, int disp12MaxDiff=0,
               int preFilterCap=0, int uniquenessRatio=0,
               int speckleWindowSize=0, int speckleRange=0,
               bool fullDP=false);

    virtual ~StereoSGBM();


    virtual void operator()(InputArray left, InputArray right,
                                                OutputArray disp);

    int minDisparity;
    int numberOfDisparities;
    int SADWindowSize;
    int preFilterCap;
    int uniquenessRatio;
    int P1;
    int P2;
    int speckleWindowSize;
    int speckleRange;
    int disp12MaxDiff;
    bool fullDP;

protected:
    Mat buffer;
};


 void filterSpeckles( InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff,
                                  InputOutputArray buf=noArray() );


 Rect getValidDisparityROI( Rect roi1, Rect roi2,
                                        int minDisparity, int numberOfDisparities,
                                        int SADWindowSize );


 void validateDisparity( InputOutputArray disparity, InputArray cost,
                                     int minDisparity, int numberOfDisparities,
                                     int disp12MaxDisp=1 );


 void reprojectImageTo3D( InputArray disparity,
                                      OutputArray _3dImage, InputArray Q,
                                      bool handleMissingValues=false,
                                      int ddepth=-1 );

 int estimateAffine3D(InputArray src, InputArray dst,
                                   OutputArray out, OutputArray inliers,
                                   double ransacThreshold=3, double confidence=0.99);

}
#56 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp" 1
#45 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 1 3 4
#46 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp" 2





#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 3

#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

#61 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
#52 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp" 2
#72 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
struct CvVectors
{
    int type;
    int dims, count;
    CvVectors* next;
    union
    {
        uchar** ptr;
        float** fl;
        double** db;
    } data;
};
#134 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
class CvStatModel
{
public:
    CvStatModel();
    virtual ~CvStatModel();

    virtual void clear();

    virtual void save( const char* filename, const char* name=0 ) const;
    virtual void load( const char* filename, const char* name=0 );

    virtual void write( CvFileStorage* storage, const char* name ) const;
    virtual void read( CvFileStorage* storage, CvFileNode* node );

protected:
    const char* default_model_name;
};
#161 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
class CvMLData;

struct CvParamGrid
{

    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };

    CvParamGrid()
    {
        min_val = max_val = step = 0;
    }

    CvParamGrid( double min_val, double max_val, double log_step );

    bool check() const;

    double min_val;
    double max_val;
    double step;
};

inline CvParamGrid::CvParamGrid( double _min_val, double _max_val, double _log_step )
{
    min_val = _min_val;
    max_val = _max_val;
    step = _log_step;
}

class CvNormalBayesClassifier : public CvStatModel
{
public:
    CvNormalBayesClassifier();
    virtual ~CvNormalBayesClassifier();

    CvNormalBayesClassifier( const CvMat* trainData, const CvMat* responses,
        const CvMat* varIdx=0, const CvMat* sampleIdx=0 );

    virtual bool train( const CvMat* trainData, const CvMat* responses,
        const CvMat* varIdx = 0, const CvMat* sampleIdx=0, bool update=false );

    virtual float predict( const CvMat* samples, CvMat* results=0 ) const;
    virtual void clear();

    CvNormalBayesClassifier( const cv::Mat& trainData, const cv::Mat& responses,
                            const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat() );
    virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,
                       const cv::Mat& varIdx = cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(),
                       bool update=false );
    virtual float predict( const cv::Mat& samples, cv::Mat* results=0 ) const;

    virtual void write( CvFileStorage* storage, const char* name ) const;
    virtual void read( CvFileStorage* storage, CvFileNode* node );

protected:
    int var_count, var_all;
    CvMat* var_idx;
    CvMat* cls_labels;
    CvMat** count;
    CvMat** sum;
    CvMat** productsum;
    CvMat** avg;
    CvMat** inv_eigen_values;
    CvMat** cov_rotate_mats;
    CvMat* c;
};







class CvKNearest : public CvStatModel
{
public:

    CvKNearest();
    virtual ~CvKNearest();

    CvKNearest( const CvMat* trainData, const CvMat* responses,
                const CvMat* sampleIdx=0, bool isRegression=false, int max_k=32 );

    virtual bool train( const CvMat* trainData, const CvMat* responses,
                        const CvMat* sampleIdx=0, bool is_regression=false,
                        int maxK=32, bool updateBase=false );

    virtual float find_nearest( const CvMat* samples, int k, CvMat* results=0,
        const float** neighbors=0, CvMat* neighborResponses=0, CvMat* dist=0 ) const;

    CvKNearest( const cv::Mat& trainData, const cv::Mat& responses,
               const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int max_k=32 );

    virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,
                       const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false,
                       int maxK=32, bool updateBase=false );

    virtual float find_nearest( const cv::Mat& samples, int k, cv::Mat* results=0,
                                const float** neighbors=0, cv::Mat* neighborResponses=0,
                                cv::Mat* dist=0 ) const;
    virtual float find_nearest( const cv::Mat& samples, int k, cv::Mat& results,
                                        cv::Mat& neighborResponses, cv::Mat& dists) const;

    virtual void clear();
    int get_max_k() const;
    int get_var_count() const;
    int get_sample_count() const;
    bool is_regression() const;

    virtual float write_results( int k, int k1, int start, int end,
        const float* neighbor_responses, const float* dist, CvMat* _results,
        CvMat* _neighbor_responses, CvMat* _dist, Cv32suf* sort_buf ) const;

    virtual void find_neighbors_direct( const CvMat* _samples, int k, int start, int end,
        float* neighbor_responses, const float** neighbors, float* dist ) const;

protected:

    int max_k, var_count;
    int total;
    bool regression;
    CvVectors* samples;
};






struct CvSVMParams
{
    CvSVMParams();
    CvSVMParams( int svm_type, int kernel_type,
                 double degree, double gamma, double coef0,
                 double Cvalue, double nu, double p,
                 CvMat* class_weights, CvTermCriteria term_crit );

    int svm_type;
    int kernel_type;
    double degree;
    double gamma;
    double coef0;

    double C;
    double nu;
    double p;
    CvMat* class_weights;
    CvTermCriteria term_crit;
};


struct CvSVMKernel
{
    typedef void (CvSVMKernel::*Calc)( int vec_count, int vec_size, const float** vecs,
                                       const float* another, float* results );
    CvSVMKernel();
    CvSVMKernel( const CvSVMParams* params, Calc _calc_func );
    virtual bool create( const CvSVMParams* params, Calc _calc_func );
    virtual ~CvSVMKernel();

    virtual void clear();
    virtual void calc( int vcount, int n, const float** vecs, const float* another, float* results );

    const CvSVMParams* params;
    Calc calc_func;

    virtual void calc_non_rbf_base( int vec_count, int vec_size, const float** vecs,
                                    const float* another, float* results,
                                    double alpha, double beta );

    virtual void calc_linear( int vec_count, int vec_size, const float** vecs,
                              const float* another, float* results );
    virtual void calc_rbf( int vec_count, int vec_size, const float** vecs,
                           const float* another, float* results );
    virtual void calc_poly( int vec_count, int vec_size, const float** vecs,
                            const float* another, float* results );
    virtual void calc_sigmoid( int vec_count, int vec_size, const float** vecs,
                               const float* another, float* results );
};


struct CvSVMKernelRow
{
    CvSVMKernelRow* prev;
    CvSVMKernelRow* next;
    float* data;
};


struct CvSVMSolutionInfo
{
    double obj;
    double rho;
    double upper_bound_p;
    double upper_bound_n;
    double r;
};

class CvSVMSolver
{
public:
    typedef bool (CvSVMSolver::*SelectWorkingSet)( int& i, int& j );
    typedef float* (CvSVMSolver::*GetRow)( int i, float* row, float* dst, bool existed );
    typedef void (CvSVMSolver::*CalcRho)( double& rho, double& r );

    CvSVMSolver();

    CvSVMSolver( int count, int var_count, const float** samples, schar* y,
                 int alpha_count, double* alpha, double Cp, double Cn,
                 CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row,
                 SelectWorkingSet select_working_set, CalcRho calc_rho );
    virtual bool create( int count, int var_count, const float** samples, schar* y,
                 int alpha_count, double* alpha, double Cp, double Cn,
                 CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row,
                 SelectWorkingSet select_working_set, CalcRho calc_rho );
    virtual ~CvSVMSolver();

    virtual void clear();
    virtual bool solve_generic( CvSVMSolutionInfo& si );

    virtual bool solve_c_svc( int count, int var_count, const float** samples, schar* y,
                              double Cp, double Cn, CvMemStorage* storage,
                              CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si );
    virtual bool solve_nu_svc( int count, int var_count, const float** samples, schar* y,
                               CvMemStorage* storage, CvSVMKernel* kernel,
                               double* alpha, CvSVMSolutionInfo& si );
    virtual bool solve_one_class( int count, int var_count, const float** samples,
                                  CvMemStorage* storage, CvSVMKernel* kernel,
                                  double* alpha, CvSVMSolutionInfo& si );

    virtual bool solve_eps_svr( int count, int var_count, const float** samples, const float* y,
                                CvMemStorage* storage, CvSVMKernel* kernel,
                                double* alpha, CvSVMSolutionInfo& si );

    virtual bool solve_nu_svr( int count, int var_count, const float** samples, const float* y,
                               CvMemStorage* storage, CvSVMKernel* kernel,
                               double* alpha, CvSVMSolutionInfo& si );

    virtual float* get_row_base( int i, bool* _existed );
    virtual float* get_row( int i, float* dst );

    int sample_count;
    int var_count;
    int cache_size;
    int cache_line_size;
    const float** samples;
    const CvSVMParams* params;
    CvMemStorage* storage;
    CvSVMKernelRow lru_list;
    CvSVMKernelRow* rows;

    int alpha_count;

    double* G;
    double* alpha;


    schar* alpha_status;

    schar* y;
    double* b;
    float* buf[2];
    double eps;
    int max_iter;
    double C[2];
    CvSVMKernel* kernel;

    SelectWorkingSet select_working_set_func;
    CalcRho calc_rho_func;
    GetRow get_row_func;

    virtual bool select_working_set( int& i, int& j );
    virtual bool select_working_set_nu_svm( int& i, int& j );
    virtual void calc_rho( double& rho, double& r );
    virtual void calc_rho_nu_svm( double& rho, double& r );

    virtual float* get_row_svc( int i, float* row, float* dst, bool existed );
    virtual float* get_row_one_class( int i, float* row, float* dst, bool existed );
    virtual float* get_row_svr( int i, float* row, float* dst, bool existed );
};


struct CvSVMDecisionFunc
{
    double rho;
    int sv_count;
    double* alpha;
    int* sv_index;
};



class CvSVM : public CvStatModel
{
public:

    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };


    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };


    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };

    CvSVM();
    virtual ~CvSVM();

    CvSVM( const CvMat* trainData, const CvMat* responses,
           const CvMat* varIdx=0, const CvMat* sampleIdx=0,
           CvSVMParams params=CvSVMParams() );

    virtual bool train( const CvMat* trainData, const CvMat* responses,
                        const CvMat* varIdx=0, const CvMat* sampleIdx=0,
                        CvSVMParams params=CvSVMParams() );

    virtual bool train_auto( const CvMat* trainData, const CvMat* responses,
        const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params,
        int kfold = 10,
        CvParamGrid Cgrid = get_default_grid(CvSVM::C),
        CvParamGrid gammaGrid = get_default_grid(CvSVM::GAMMA),
        CvParamGrid pGrid = get_default_grid(CvSVM::P),
        CvParamGrid nuGrid = get_default_grid(CvSVM::NU),
        CvParamGrid coeffGrid = get_default_grid(CvSVM::COEF),
        CvParamGrid degreeGrid = get_default_grid(CvSVM::DEGREE),
        bool balanced=false );

    virtual float predict( const CvMat* sample, bool returnDFVal=false ) const;
    virtual float predict( const CvMat* samples, CvMat* results ) const;

    CvSVM( const cv::Mat& trainData, const cv::Mat& responses,
          const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(),
          CvSVMParams params=CvSVMParams() );

    virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,
                       const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(),
                       CvSVMParams params=CvSVMParams() );

    virtual bool train_auto( const cv::Mat& trainData, const cv::Mat& responses,
                            const cv::Mat& varIdx, const cv::Mat& sampleIdx, CvSVMParams params,
                            int k_fold = 10,
                            CvParamGrid Cgrid = CvSVM::get_default_grid(CvSVM::C),
                            CvParamGrid gammaGrid = CvSVM::get_default_grid(CvSVM::GAMMA),
                            CvParamGrid pGrid = CvSVM::get_default_grid(CvSVM::P),
                            CvParamGrid nuGrid = CvSVM::get_default_grid(CvSVM::NU),
                            CvParamGrid coeffGrid = CvSVM::get_default_grid(CvSVM::COEF),
                            CvParamGrid degreeGrid = CvSVM::get_default_grid(CvSVM::DEGREE),
                            bool balanced=false);
    virtual float predict( const cv::Mat& sample, bool returnDFVal=false ) const;
    void predict( cv::InputArray samples, cv::OutputArray results ) const;

    virtual int get_support_vector_count() const;
    virtual const float* get_support_vector(int i) const;
    virtual CvSVMParams get_params() const { return params; };
    virtual void clear();

    static CvParamGrid get_default_grid( int param_id );

    virtual void write( CvFileStorage* storage, const char* name ) const;
    virtual void read( CvFileStorage* storage, CvFileNode* node );
    int get_var_count() const { return var_idx ? var_idx->cols : var_all; }

protected:

    virtual bool set_params( const CvSVMParams& params );
    virtual bool train1( int sample_count, int var_count, const float** samples,
                    const void* responses, double Cp, double Cn,
                    CvMemStorage* _storage, double* alpha, double& rho );
    virtual bool do_train( int svm_type, int sample_count, int var_count, const float** samples,
                    const CvMat* responses, CvMemStorage* _storage, double* alpha );
    virtual void create_kernel();
    virtual void create_solver();

    virtual float predict( const float* row_sample, int row_len, bool returnDFVal=false ) const;

    virtual void write_params( CvFileStorage* fs ) const;
    virtual void read_params( CvFileStorage* fs, CvFileNode* node );

    void optimize_linear_svm();

    CvSVMParams params;
    CvMat* class_labels;
    int var_all;
    float** sv;
    int sv_total;
    CvMat* var_idx;
    CvMat* class_weights;
    CvSVMDecisionFunc* decision_func;
    CvMemStorage* storage;

    CvSVMSolver* solver;
    CvSVMKernel* kernel;
};




namespace cv
{
class EM : public Algorithm
{
public:

    enum {COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2, COV_MAT_DEFAULT=COV_MAT_DIAGONAL};


    enum {DEFAULT_NCLUSTERS=5, DEFAULT_MAX_ITERS=100};


    enum {START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0};

    EM(int nclusters=EM::DEFAULT_NCLUSTERS, int covMatType=EM::COV_MAT_DIAGONAL,
       const TermCriteria& termCrit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS,
                                                 EM::DEFAULT_MAX_ITERS, 1.19209289550781250000e-7F));

    virtual ~EM();
    virtual void clear();

    virtual bool train(InputArray samples,
                       OutputArray logLikelihoods=noArray(),
                       OutputArray labels=noArray(),
                       OutputArray probs=noArray());

    virtual bool trainE(InputArray samples,
                        InputArray means0,
                        InputArray covs0=noArray(),
                        InputArray weights0=noArray(),
                        OutputArray logLikelihoods=noArray(),
                        OutputArray labels=noArray(),
                        OutputArray probs=noArray());

    virtual bool trainM(InputArray samples,
                        InputArray probs0,
                        OutputArray logLikelihoods=noArray(),
                        OutputArray labels=noArray(),
                        OutputArray probs=noArray());

    Vec2d predict(InputArray sample,
                OutputArray probs=noArray()) const;

    bool isTrained() const;

    AlgorithmInfo* info() const;
    virtual void read(const FileNode& fn);

protected:

    virtual void setTrainData(int startStep, const Mat& samples,
                              const Mat* probs0,
                              const Mat* means0,
                              const vector<Mat>* covs0,
                              const Mat* weights0);

    bool doTrain(int startStep,
                 OutputArray logLikelihoods,
                 OutputArray labels,
                 OutputArray probs);
    virtual void eStep();
    virtual void mStep();

    void clusterTrainSamples();
    void decomposeCovs();
    void computeLogWeightDivDet();

    Vec2d computeProbabilities(const Mat& sample, Mat* probs) const;


    int nclusters;
    int covMatType;
    int maxIters;
    double epsilon;

    Mat trainSamples;
    Mat trainProbs;
    Mat trainLogLikelihoods;
    Mat trainLabels;

    Mat weights;
    Mat means;
    vector<Mat> covs;

    vector<Mat> covsEigenValues;
    vector<Mat> covsRotateMats;
    vector<Mat> invCovsEigenValues;
    Mat logWeightDivDet;
};
}




 struct CvPair16u32s
{
    unsigned short* u;
    int* i;
};





struct CvDTreeSplit
{
    int var_idx;
    int condensed_idx;
    int inversed;
    float quality;
    CvDTreeSplit* next;
    union
    {
        int subset[2];
        struct
        {
            float c;
            int split_point;
        }
        ord;
    };
};

struct CvDTreeNode
{
    int class_idx;
    int Tn;
    double value;

    CvDTreeNode* parent;
    CvDTreeNode* left;
    CvDTreeNode* right;

    CvDTreeSplit* split;

    int sample_count;
    int depth;
    int* num_valid;
    int offset;
    int buf_idx;
    double maxlr;


    int complexity;
    double alpha;
    double node_risk, tree_risk, tree_error;


    int* cv_Tn;
    double* cv_node_risk;
    double* cv_node_error;

    int get_num_valid(int vi) { return num_valid ? num_valid[vi] : sample_count; }
    void set_num_valid(int vi, int n) { if( num_valid ) num_valid[vi] = n; }
};


struct CvDTreeParams
{
    int max_categories;
    int max_depth;
    int min_sample_count;
    int cv_folds;
    bool use_surrogates;
    bool use_1se_rule;
    bool truncate_pruned_tree;
    float regression_accuracy;
    const float* priors;

    CvDTreeParams();
    CvDTreeParams( int max_depth, int min_sample_count,
                   float regression_accuracy, bool use_surrogates,
                   int max_categories, int cv_folds,
                   bool use_1se_rule, bool truncate_pruned_tree,
                   const float* priors );
};


struct CvDTreeTrainData
{
    CvDTreeTrainData();
    CvDTreeTrainData( const CvMat* trainData, int tflag,
                      const CvMat* responses, const CvMat* varIdx=0,
                      const CvMat* sampleIdx=0, const CvMat* varType=0,
                      const CvMat* missingDataMask=0,
                      const CvDTreeParams& params=CvDTreeParams(),
                      bool _shared=false, bool _add_labels=false );
    virtual ~CvDTreeTrainData();

    virtual void set_data( const CvMat* trainData, int tflag,
                          const CvMat* responses, const CvMat* varIdx=0,
                          const CvMat* sampleIdx=0, const CvMat* varType=0,
                          const CvMat* missingDataMask=0,
                          const CvDTreeParams& params=CvDTreeParams(),
                          bool _shared=false, bool _add_labels=false,
                          bool _update_data=false );
    virtual void do_responses_copy();

    virtual void get_vectors( const CvMat* _subsample_idx,
         float* values, uchar* missing, float* responses, bool get_class_idx=false );

    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );

    virtual void write_params( CvFileStorage* fs ) const;
    virtual void read_params( CvFileStorage* fs, CvFileNode* node );


    virtual void clear();

    int get_num_classes() const;
    int get_var_type(int vi) const;
    int get_work_var_count() const {return work_var_count;}

    virtual const float* get_ord_responses( CvDTreeNode* n, float* values_buf, int* sample_indices_buf );
    virtual const int* get_class_labels( CvDTreeNode* n, int* labels_buf );
    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );
    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );
    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );
    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf,
                                   const float** ord_values, const int** sorted_indices, int* sample_indices_buf );
    virtual int get_child_buf_idx( CvDTreeNode* n );



    virtual bool set_params( const CvDTreeParams& params );
    virtual CvDTreeNode* new_node( CvDTreeNode* parent, int count,
                                   int storage_idx, int offset );

    virtual CvDTreeSplit* new_split_ord( int vi, float cmp_val,
                int split_point, int inversed, float quality );
    virtual CvDTreeSplit* new_split_cat( int vi, float quality );
    virtual void free_node_data( CvDTreeNode* node );
    virtual void free_train_data();
    virtual void free_node( CvDTreeNode* node );

    int sample_count, var_all, var_count, max_c_count;
    int ord_var_count, cat_var_count, work_var_count;
    bool have_labels, have_priors;
    bool is_classifier;
    int tflag;

    const CvMat* train_data;
    const CvMat* responses;
    CvMat* responses_copy;

    int buf_count, buf_size;
    bool shared;
    int is_buf_16u;

    CvMat* cat_count;
    CvMat* cat_ofs;
    CvMat* cat_map;

    CvMat* counts;
    CvMat* buf;
    inline size_t get_length_subbuf() const
    {
        size_t res = (size_t)(work_var_count + 1) * (size_t)sample_count;
        return res;
    }

    CvMat* direction;
    CvMat* split_buf;

    CvMat* var_idx;
    CvMat* var_type;


    CvMat* priors;
    CvMat* priors_mult;

    CvDTreeParams params;

    CvMemStorage* tree_storage;
    CvMemStorage* temp_storage;

    CvDTreeNode* data_root;

    CvSet* node_heap;
    CvSet* split_heap;
    CvSet* cv_heap;
    CvSet* nv_heap;

    cv::RNG* rng;
};

class CvDTree;
class CvForestTree;

namespace cv
{
    struct DTreeBestSplitFinder;
    struct ForestTreeBestSplitFinder;
}

class CvDTree : public CvStatModel
{
public:
    CvDTree();
    virtual ~CvDTree();

    virtual bool train( const CvMat* trainData, int tflag,
                        const CvMat* responses, const CvMat* varIdx=0,
                        const CvMat* sampleIdx=0, const CvMat* varType=0,
                        const CvMat* missingDataMask=0,
                        CvDTreeParams params=CvDTreeParams() );

    virtual bool train( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() );


    virtual float calc_error( CvMLData* trainData, int type, std::vector<float> *resp = 0 );

    virtual bool train( CvDTreeTrainData* trainData, const CvMat* subsampleIdx );

    virtual CvDTreeNode* predict( const CvMat* sample, const CvMat* missingDataMask=0,
                                  bool preprocessedInput=false ) const;

    virtual bool train( const cv::Mat& trainData, int tflag,
                       const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(),
                       const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(),
                       const cv::Mat& missingDataMask=cv::Mat(),
                       CvDTreeParams params=CvDTreeParams() );

    virtual CvDTreeNode* predict( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(),
                                  bool preprocessedInput=false ) const;
    virtual cv::Mat getVarImportance();

    virtual const CvMat* get_var_importance();
    virtual void clear();

    virtual void read( CvFileStorage* fs, CvFileNode* node );
    virtual void write( CvFileStorage* fs, const char* name ) const;


    virtual void read( CvFileStorage* fs, CvFileNode* node,
                       CvDTreeTrainData* data );
    virtual void write( CvFileStorage* fs ) const;

    const CvDTreeNode* get_root() const;
    int get_pruned_tree_idx() const;
    CvDTreeTrainData* get_data();

protected:
    friend struct cv::DTreeBestSplitFinder;

    virtual bool do_train( const CvMat* _subsample_idx );

    virtual void try_split_node( CvDTreeNode* n );
    virtual void split_node_data( CvDTreeNode* n );
    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );
    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi,
                            float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,
                            float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi,
                            float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi,
                            float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );
    virtual double calc_node_dir( CvDTreeNode* node );
    virtual void complete_node_dir( CvDTreeNode* node );
    virtual void cluster_categories( const int* vectors, int vector_count,
        int var_count, int* sums, int k, int* cluster_labels );

    virtual void calc_node_value( CvDTreeNode* node );

    virtual void prune_cv();
    virtual double update_tree_rnc( int T, int fold );
    virtual int cut_tree( int T, int fold, double min_alpha );
    virtual void free_prune_data(bool cut_tree);
    virtual void free_tree();

    virtual void write_node( CvFileStorage* fs, CvDTreeNode* node ) const;
    virtual void write_split( CvFileStorage* fs, CvDTreeSplit* split ) const;
    virtual CvDTreeNode* read_node( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent );
    virtual CvDTreeSplit* read_split( CvFileStorage* fs, CvFileNode* node );
    virtual void write_tree_nodes( CvFileStorage* fs ) const;
    virtual void read_tree_nodes( CvFileStorage* fs, CvFileNode* node );

    CvDTreeNode* root;
    CvMat* var_importance;
    CvDTreeTrainData* data;

public:
    int pruned_tree_idx;
};






class CvRTrees;

class CvForestTree: public CvDTree
{
public:
    CvForestTree();
    virtual ~CvForestTree();

    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest );

    virtual int get_var_count() const {return data ? data->var_count : 0;}
    virtual void read( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data );


    virtual bool train( const CvMat* trainData, int tflag,
                        const CvMat* responses, const CvMat* varIdx=0,
                        const CvMat* sampleIdx=0, const CvMat* varType=0,
                        const CvMat* missingDataMask=0,
                        CvDTreeParams params=CvDTreeParams() );

    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );
    virtual void read( CvFileStorage* fs, CvFileNode* node );
    virtual void read( CvFileStorage* fs, CvFileNode* node,
                       CvDTreeTrainData* data );


protected:
    friend struct cv::ForestTreeBestSplitFinder;

    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );
    CvRTrees* forest;
};


struct CvRTParams : public CvDTreeParams
{

    bool calc_var_importance;
    int nactive_vars;
    CvTermCriteria term_crit;

    CvRTParams();
    CvRTParams( int max_depth, int min_sample_count,
                float regression_accuracy, bool use_surrogates,
                int max_categories, const float* priors, bool calc_var_importance,
                int nactive_vars, int max_num_of_trees_in_the_forest,
                float forest_accuracy, int termcrit_type );
};


class CvRTrees : public CvStatModel
{
public:
    CvRTrees();
    virtual ~CvRTrees();
    virtual bool train( const CvMat* trainData, int tflag,
                        const CvMat* responses, const CvMat* varIdx=0,
                        const CvMat* sampleIdx=0, const CvMat* varType=0,
                        const CvMat* missingDataMask=0,
                        CvRTParams params=CvRTParams() );

    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );
    virtual float predict( const CvMat* sample, const CvMat* missing = 0 ) const;
    virtual float predict_prob( const CvMat* sample, const CvMat* missing = 0 ) const;

    virtual bool train( const cv::Mat& trainData, int tflag,
                       const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(),
                       const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(),
                       const cv::Mat& missingDataMask=cv::Mat(),
                       CvRTParams params=CvRTParams() );
    virtual float predict( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;
    virtual float predict_prob( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;
    virtual cv::Mat getVarImportance();

    virtual void clear();

    virtual const CvMat* get_var_importance();
    virtual float get_proximity( const CvMat* sample1, const CvMat* sample2,
        const CvMat* missing1 = 0, const CvMat* missing2 = 0 ) const;

    virtual float calc_error( CvMLData* data, int type , std::vector<float>* resp = 0 );

    virtual float get_train_error();

    virtual void read( CvFileStorage* fs, CvFileNode* node );
    virtual void write( CvFileStorage* fs, const char* name ) const;

    CvMat* get_active_var_mask();
    CvRNG* get_rng();

    int get_tree_count() const;
    CvForestTree* get_tree(int i) const;

protected:
    virtual std::string getName() const;

    virtual bool grow_forest( const CvTermCriteria term_crit );


    CvForestTree** trees;
    CvDTreeTrainData* data;
    int ntrees;
    int nclasses;
    double oob_error;
    CvMat* var_importance;
    int nsamples;

    cv::RNG* rng;
    CvMat* active_var_mask;
};




struct CvERTreeTrainData : public CvDTreeTrainData
{
    virtual void set_data( const CvMat* trainData, int tflag,
                          const CvMat* responses, const CvMat* varIdx=0,
                          const CvMat* sampleIdx=0, const CvMat* varType=0,
                          const CvMat* missingDataMask=0,
                          const CvDTreeParams& params=CvDTreeParams(),
                          bool _shared=false, bool _add_labels=false,
                          bool _update_data=false );
    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf,
                                   const float** ord_values, const int** missing, int* sample_buf = 0 );
    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );
    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );
    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );
    virtual void get_vectors( const CvMat* _subsample_idx, float* values, uchar* missing,
                              float* responses, bool get_class_idx=false );
    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );
    const CvMat* missing_mask;
};

class CvForestERTree : public CvForestTree
{
protected:
    virtual double calc_node_dir( CvDTreeNode* node );
    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual void split_node_data( CvDTreeNode* n );
};

class CvERTrees : public CvRTrees
{
public:
    CvERTrees();
    virtual ~CvERTrees();
    virtual bool train( const CvMat* trainData, int tflag,
                        const CvMat* responses, const CvMat* varIdx=0,
                        const CvMat* sampleIdx=0, const CvMat* varType=0,
                        const CvMat* missingDataMask=0,
                        CvRTParams params=CvRTParams());
    virtual bool train( const cv::Mat& trainData, int tflag,
                       const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(),
                       const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(),
                       const cv::Mat& missingDataMask=cv::Mat(),
                       CvRTParams params=CvRTParams());
    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );
protected:
    virtual std::string getName() const;
    virtual bool grow_forest( const CvTermCriteria term_crit );
};






struct CvBoostParams : public CvDTreeParams
{
    int boost_type;
    int weak_count;
    int split_criteria;
    double weight_trim_rate;

    CvBoostParams();
    CvBoostParams( int boost_type, int weak_count, double weight_trim_rate,
                   int max_depth, bool use_surrogates, const float* priors );
};


class CvBoost;

class CvBoostTree: public CvDTree
{
public:
    CvBoostTree();
    virtual ~CvBoostTree();

    virtual bool train( CvDTreeTrainData* trainData,
                        const CvMat* subsample_idx, CvBoost* ensemble );

    virtual void scale( double s );
    virtual void read( CvFileStorage* fs, CvFileNode* node,
                       CvBoost* ensemble, CvDTreeTrainData* _data );
    virtual void clear();


    virtual bool train( const CvMat* trainData, int tflag,
                        const CvMat* responses, const CvMat* varIdx=0,
                        const CvMat* sampleIdx=0, const CvMat* varType=0,
                        const CvMat* missingDataMask=0,
                        CvDTreeParams params=CvDTreeParams() );
    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );

    virtual void read( CvFileStorage* fs, CvFileNode* node );
    virtual void read( CvFileStorage* fs, CvFileNode* node,
                       CvDTreeTrainData* data );


protected:

    virtual void try_split_node( CvDTreeNode* n );
    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi,
        float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 );
    virtual void calc_node_value( CvDTreeNode* n );
    virtual double calc_node_dir( CvDTreeNode* n );

    CvBoost* ensemble;
};


class CvBoost : public CvStatModel
{
public:

    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };


    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };

    CvBoost();
    virtual ~CvBoost();

    CvBoost( const CvMat* trainData, int tflag,
             const CvMat* responses, const CvMat* varIdx=0,
             const CvMat* sampleIdx=0, const CvMat* varType=0,
             const CvMat* missingDataMask=0,
             CvBoostParams params=CvBoostParams() );

    virtual bool train( const CvMat* trainData, int tflag,
             const CvMat* responses, const CvMat* varIdx=0,
             const CvMat* sampleIdx=0, const CvMat* varType=0,
             const CvMat* missingDataMask=0,
             CvBoostParams params=CvBoostParams(),
             bool update=false );

    virtual bool train( CvMLData* data,
             CvBoostParams params=CvBoostParams(),
             bool update=false );

    virtual float predict( const CvMat* sample, const CvMat* missing=0,
                           CvMat* weak_responses=0, CvSlice slice=cvSlice(0, 0x3fffffff),
                           bool raw_mode=false, bool return_sum=false ) const;

    CvBoost( const cv::Mat& trainData, int tflag,
            const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(),
            const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(),
            const cv::Mat& missingDataMask=cv::Mat(),
            CvBoostParams params=CvBoostParams() );

    virtual bool train( const cv::Mat& trainData, int tflag,
                       const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(),
                       const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(),
                       const cv::Mat& missingDataMask=cv::Mat(),
                       CvBoostParams params=CvBoostParams(),
                       bool update=false );

    virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),
                                   const cv::Range& slice=cv::Range::all(), bool rawMode=false,
                                   bool returnSum=false ) const;

    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 );

    virtual void prune( CvSlice slice );

    virtual void clear();

    virtual void write( CvFileStorage* storage, const char* name ) const;
    virtual void read( CvFileStorage* storage, CvFileNode* node );
    virtual const CvMat* get_active_vars(bool absolute_idx=true);

    CvSeq* get_weak_predictors();

    CvMat* get_weights();
    CvMat* get_subtree_weights();
    CvMat* get_weak_response();
    const CvBoostParams& get_params() const;
    const CvDTreeTrainData* get_data() const;

protected:

    virtual bool set_params( const CvBoostParams& params );
    virtual void update_weights( CvBoostTree* tree );
    virtual void trim_weights();
    virtual void write_params( CvFileStorage* fs ) const;
    virtual void read_params( CvFileStorage* fs, CvFileNode* node );

    CvDTreeTrainData* data;
    CvBoostParams params;
    CvSeq* weak;

    CvMat* active_vars;
    CvMat* active_vars_abs;
    bool have_active_cat_vars;

    CvMat* orig_response;
    CvMat* sum_response;
    CvMat* weak_eval;
    CvMat* subsample_mask;
    CvMat* weights;
    CvMat* subtree_weights;
    bool have_subsample;
};
#1301 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
struct CvGBTreesParams : public CvDTreeParams
{
    int weak_count;
    int loss_function_type;
    float subsample_portion;
    float shrinkage;

    CvGBTreesParams();
    CvGBTreesParams( int loss_function_type, int weak_count, float shrinkage,
        float subsample_portion, int max_depth, bool use_surrogates );
};
#1361 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
class CvGBTrees : public CvStatModel
{
public:
#1388 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};
#1402 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    CvGBTrees();
#1442 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    CvGBTrees( const CvMat* trainData, int tflag,
             const CvMat* responses, const CvMat* varIdx=0,
             const CvMat* sampleIdx=0, const CvMat* varType=0,
             const CvMat* missingDataMask=0,
             CvGBTreesParams params=CvGBTreesParams() );





    virtual ~CvGBTrees();
#1494 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual bool train( const CvMat* trainData, int tflag,
             const CvMat* responses, const CvMat* varIdx=0,
             const CvMat* sampleIdx=0, const CvMat* varType=0,
             const CvMat* missingDataMask=0,
             CvGBTreesParams params=CvGBTreesParams(),
             bool update=false );
#1518 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual bool train( CvMLData* data,
             CvGBTreesParams params=CvGBTreesParams(),
             bool update=false );
#1550 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual float predict_serial( const CvMat* sample, const CvMat* missing=0,
            CvMat* weakResponses=0, CvSlice slice = cvSlice(0, 0x3fffffff),
            int k=-1 ) const;
#1582 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual float predict( const CvMat* sample, const CvMat* missing=0,
            CvMat* weakResponses=0, CvSlice slice = cvSlice(0, 0x3fffffff),
            int k=-1 ) const;
#1600 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void clear();
#1618 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual float calc_error( CvMLData* _data, int type,
            std::vector<float> *resp = 0 );
#1634 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void write( CvFileStorage* fs, const char* name ) const;
#1650 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void read( CvFileStorage* fs, CvFileNode* node );



    CvGBTrees( const cv::Mat& trainData, int tflag,
              const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(),
              const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(),
              const cv::Mat& missingDataMask=cv::Mat(),
              CvGBTreesParams params=CvGBTreesParams() );

    virtual bool train( const cv::Mat& trainData, int tflag,
                       const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(),
                       const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(),
                       const cv::Mat& missingDataMask=cv::Mat(),
                       CvGBTreesParams params=CvGBTreesParams(),
                       bool update=false );

    virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),
                           const cv::Range& slice = cv::Range::all(),
                           int k=-1 ) const;

protected:
#1688 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void find_gradient( const int k = 0);
#1707 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void change_values(CvDTree* tree, const int k = 0);
#1726 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual float find_optimal_value( const CvMat* _Idx );
#1743 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void do_subsample();
#1760 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    void leaves_get( CvDTreeNode** leaves, int& count, CvDTreeNode* node );
#1777 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    CvDTreeNode** GetLeaves( const CvDTree* dtree, int& len );
#1793 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual bool problem_type() const;
#1808 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void write_params( CvFileStorage* fs ) const;
#1828 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
    virtual void read_params( CvFileStorage* fs, CvFileNode* fnode );
    int get_len(const CvMat* mat) const;


    CvDTreeTrainData* data;
    CvGBTreesParams params;

    CvSeq** weak;
    CvMat* orig_response;
    CvMat* sum_response;
    CvMat* sum_response_tmp;
    CvMat* sample_idx;
    CvMat* subsample_train;
    CvMat* subsample_test;
    CvMat* missing;
    CvMat* class_labels;

    cv::RNG* rng;

    int class_count;
    float delta;
    float base_value;

};
#1861 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
struct CvANN_MLP_TrainParams
{
    CvANN_MLP_TrainParams();
    CvANN_MLP_TrainParams( CvTermCriteria term_crit, int train_method,
                           double param1, double param2=0 );
    ~CvANN_MLP_TrainParams();

    enum { BACKPROP=0, RPROP=1 };

    CvTermCriteria term_crit;
    int train_method;


    double bp_dw_scale, bp_moment_scale;


    double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;
};


class CvANN_MLP : public CvStatModel
{
public:
    CvANN_MLP();
    CvANN_MLP( const CvMat* layerSizes,
               int activateFunc=CvANN_MLP::SIGMOID_SYM,
               double fparam1=0, double fparam2=0 );

    virtual ~CvANN_MLP();

    virtual void create( const CvMat* layerSizes,
                         int activateFunc=CvANN_MLP::SIGMOID_SYM,
                         double fparam1=0, double fparam2=0 );

    virtual int train( const CvMat* inputs, const CvMat* outputs,
                       const CvMat* sampleWeights, const CvMat* sampleIdx=0,
                       CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(),
                       int flags=0 );
    virtual float predict( const CvMat* inputs, CvMat* outputs ) const;

    CvANN_MLP( const cv::Mat& layerSizes,
              int activateFunc=CvANN_MLP::SIGMOID_SYM,
              double fparam1=0, double fparam2=0 );

    virtual void create( const cv::Mat& layerSizes,
                        int activateFunc=CvANN_MLP::SIGMOID_SYM,
                        double fparam1=0, double fparam2=0 );

    virtual int train( const cv::Mat& inputs, const cv::Mat& outputs,
                      const cv::Mat& sampleWeights, const cv::Mat& sampleIdx=cv::Mat(),
                      CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(),
                      int flags=0 );

    virtual float predict( const cv::Mat& inputs, cv::Mat& outputs ) const;

    virtual void clear();


    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };


    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };

    virtual void read( CvFileStorage* fs, CvFileNode* node );
    virtual void write( CvFileStorage* storage, const char* name ) const;

    int get_layer_count() { return layer_sizes ? layer_sizes->cols : 0; }
    const CvMat* get_layer_sizes() { return layer_sizes; }
    double* get_weights(int layer)
    {
        return layer_sizes && weights &&
            (unsigned)layer <= (unsigned)layer_sizes->cols ? weights[layer] : 0;
    }

    virtual void calc_activ_func_deriv( CvMat* xf, CvMat* deriv, const double* bias ) const;

protected:

    virtual bool prepare_to_train( const CvMat* _inputs, const CvMat* _outputs,
            const CvMat* _sample_weights, const CvMat* sampleIdx,
            CvVectors* _ivecs, CvVectors* _ovecs, double** _sw, int _flags );


    virtual int train_backprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );


    virtual int train_rprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );

    virtual void calc_activ_func( CvMat* xf, const double* bias ) const;
    virtual void set_activ_func( int _activ_func=SIGMOID_SYM,
                                 double _f_param1=0, double _f_param2=0 );
    virtual void init_weights();
    virtual void scale_input( const CvMat* _src, CvMat* _dst ) const;
    virtual void scale_output( const CvMat* _src, CvMat* _dst ) const;
    virtual void calc_input_scale( const CvVectors* vecs, int flags );
    virtual void calc_output_scale( const CvVectors* vecs, int flags );

    virtual void write_params( CvFileStorage* fs ) const;
    virtual void read_params( CvFileStorage* fs, CvFileNode* node );

    CvMat* layer_sizes;
    CvMat* wbuf;
    CvMat* sample_weights;
    double** weights;
    double f_param1, f_param2;
    double min_val, max_val, min_val1, max_val1;
    int activ_func;
    int max_count, max_buf_sz;
    CvANN_MLP_TrainParams params;
    cv::RNG* rng;
};







extern "C" void cvRandMVNormal( CvMat* mean, CvMat* cov, CvMat* sample,
                           CvRNG* rng = 0 );


extern "C" void cvRandGaussMixture( CvMat* means[],
                               CvMat* covs[],
                               float weights[],
                               int clsnum,
                               CvMat* sample,
                               CvMat* sampClasses = 0 );




extern "C" void cvCreateTestSet( int type, CvMat** samples,
                 int num_samples,
                 int num_features,
                 CvMat** responses,
                 int num_classes, ... );
#2006 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/ml/ml.hpp"
struct CvTrainTestSplit
{
    CvTrainTestSplit();
    CvTrainTestSplit( int train_sample_count, bool mix = true);
    CvTrainTestSplit( float train_sample_portion, bool mix = true);

    union
    {
        int count;
        float portion;
    } train_sample_part;
    int train_sample_part_mode;

    bool mix;
};

class CvMLData
{
public:
    CvMLData();
    virtual ~CvMLData();




    int read_csv( const char* filename );

    const CvMat* get_values() const;
    const CvMat* get_responses();
    const CvMat* get_missing() const;

    void set_response_idx( int idx );

    int get_response_idx() const;

    void set_train_test_split( const CvTrainTestSplit * spl );
    const CvMat* get_train_sample_idx() const;
    const CvMat* get_test_sample_idx() const;
    void mix_train_and_test_idx();

    const CvMat* get_var_idx();
    void chahge_var_idx( int vi, bool state );

    void change_var_idx( int vi, bool state );

    const CvMat* get_var_types();
    int get_var_type( int var_idx ) const;



    void set_var_types( const char* str );


    void change_var_type( int var_idx, int type);

    void set_delimiter( char ch );
    char get_delimiter() const;

    void set_miss_ch( char ch );
    char get_miss_ch() const;

    const std::map<std::string, int>& get_class_labels_map() const;

protected:
    virtual void clear();

    void str_to_flt_elem( const char* token, float& flt_elem, int& type);
    void free_train_test_idx();

    char delimiter;
    char miss_ch;


    CvMat* values;
    CvMat* missing;
    CvMat* var_types;
    CvMat* var_idx_mask;

    CvMat* response_out;
    CvMat* var_idx_out;
    CvMat* var_types_out;

    int response_idx;

    int train_sample_count;
    bool mix;

    int total_class_count;
    std::map<std::string, int> class_map;

    CvMat* train_sample_idx;
    CvMat* test_sample_idx;
    int* sample_idx;

    cv::RNG* rng;
};


namespace cv
{

typedef CvStatModel StatModel;
typedef CvParamGrid ParamGrid;
typedef CvNormalBayesClassifier NormalBayesClassifier;
typedef CvKNearest KNearest;
typedef CvSVMParams SVMParams;
typedef CvSVMKernel SVMKernel;
typedef CvSVMSolver SVMSolver;
typedef CvSVM SVM;
typedef CvDTreeParams DTreeParams;
typedef CvMLData TrainData;
typedef CvDTree DecisionTree;
typedef CvForestTree ForestTree;
typedef CvRTParams RandomTreeParams;
typedef CvRTrees RandomTrees;
typedef CvERTreeTrainData ERTreeTRainData;
typedef CvForestERTree ERTree;
typedef CvERTrees ERTrees;
typedef CvBoostParams BoostParams;
typedef CvBoostTree BoostTree;
typedef CvBoost Boost;
typedef CvANN_MLP_TrainParams ANN_MLP_TrainParams;
typedef CvANN_MLP NeuralNet_MLP;
typedef CvGBTreesParams GradientBoostingTreeParams;
typedef CvGBTrees GradientBoostingTrees;

template<> void Ptr<CvDTreeSplit>::delete_obj();

 bool initModule_ml(void);

}
#57 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/highgui/highgui_c.h" 1
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/highgui/highgui_c.h"
extern "C" {
#57 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/highgui/highgui_c.h"
enum { CV_FONT_LIGHT = 25,
        CV_FONT_NORMAL = 50,
        CV_FONT_DEMIBOLD = 63,
        CV_FONT_BOLD = 75,
        CV_FONT_BLACK = 87
};

enum { CV_STYLE_NORMAL = 0,
        CV_STYLE_ITALIC = 1,
        CV_STYLE_OBLIQUE = 2
};




extern "C" CvFont cvFontQt(const char* nameFont, int pointSize = -1, CvScalar color = cvScalarAll(0), int weight = CV_FONT_NORMAL, int style = CV_STYLE_NORMAL, int spacing = 0);

extern "C" void cvAddText(const CvArr* img, const char* text, CvPoint org, CvFont *arg2);

extern "C" void cvDisplayOverlay(const char* name, const char* text, int delayms = 0);
extern "C" void cvDisplayStatusBar(const char* name, const char* text, int delayms = 0);

extern "C" void cvSaveWindowParameters(const char* name);
extern "C" void cvLoadWindowParameters(const char* name);
extern "C" int cvStartLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);
extern "C" void cvStopLoop( void );

typedef void ( *CvButtonCallback)(int state, void* userdata);
enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};
extern "C" int cvCreateButton( const char* button_name = __null,CvButtonCallback on_change = __null, void* userdata = __null , int button_type = CV_PUSH_BUTTON, int initial_button_state = 0);




extern "C" int cvInitSystem( int argc, char** argv );

extern "C" int cvStartWindowThread( void );


enum
{

    CV_WND_PROP_FULLSCREEN = 0,
    CV_WND_PROP_AUTOSIZE = 1,
    CV_WND_PROP_ASPECTRATIO= 2,
    CV_WND_PROP_OPENGL = 3,


    CV_WINDOW_NORMAL = 0x00000000,
    CV_WINDOW_AUTOSIZE = 0x00000001,
    CV_WINDOW_OPENGL = 0x00001000,


    CV_GUI_EXPANDED = 0x00000000,
    CV_GUI_NORMAL = 0x00000010,


    CV_WINDOW_FULLSCREEN = 1,
    CV_WINDOW_FREERATIO = 0x00000100,
    CV_WINDOW_KEEPRATIO = 0x00000000
};


extern "C" int cvNamedWindow( const char* name, int flags = CV_WINDOW_AUTOSIZE );


extern "C" void cvSetWindowProperty(const char* name, int prop_id, double prop_value);
extern "C" double cvGetWindowProperty(const char* name, int prop_id);


extern "C" void cvShowImage( const char* name, const CvArr* image );


extern "C" void cvResizeWindow( const char* name, int width, int height );
extern "C" void cvMoveWindow( const char* name, int x, int y );



extern "C" void cvDestroyWindow( const char* name );

extern "C" void cvDestroyAllWindows(void);


extern "C" void* cvGetWindowHandle( const char* name );


extern "C" const char* cvGetWindowName( void* window_handle );


typedef void ( *CvTrackbarCallback)(int pos);


extern "C" int cvCreateTrackbar( const char* trackbar_name, const char* window_name,
                             int* value, int count, CvTrackbarCallback on_change = __null);

typedef void ( *CvTrackbarCallback2)(int pos, void* userdata);

extern "C" int cvCreateTrackbar2( const char* trackbar_name, const char* window_name,
                              int* value, int count, CvTrackbarCallback2 on_change,
                              void* userdata = 0);


extern "C" int cvGetTrackbarPos( const char* trackbar_name, const char* window_name );
extern "C" void cvSetTrackbarPos( const char* trackbar_name, const char* window_name, int pos );

enum
{
    CV_EVENT_MOUSEMOVE =0,
    CV_EVENT_LBUTTONDOWN =1,
    CV_EVENT_RBUTTONDOWN =2,
    CV_EVENT_MBUTTONDOWN =3,
    CV_EVENT_LBUTTONUP =4,
    CV_EVENT_RBUTTONUP =5,
    CV_EVENT_MBUTTONUP =6,
    CV_EVENT_LBUTTONDBLCLK =7,
    CV_EVENT_RBUTTONDBLCLK =8,
    CV_EVENT_MBUTTONDBLCLK =9
};

enum
{
    CV_EVENT_FLAG_LBUTTON =1,
    CV_EVENT_FLAG_RBUTTON =2,
    CV_EVENT_FLAG_MBUTTON =4,
    CV_EVENT_FLAG_CTRLKEY =8,
    CV_EVENT_FLAG_SHIFTKEY =16,
    CV_EVENT_FLAG_ALTKEY =32
};

typedef void ( *CvMouseCallback )(int event, int x, int y, int flags, void* param);


extern "C" void cvSetMouseCallback( const char* window_name, CvMouseCallback on_mouse,
                                void* param = __null);

enum
{

    CV_LOAD_IMAGE_UNCHANGED =-1,

    CV_LOAD_IMAGE_GRAYSCALE =0,

    CV_LOAD_IMAGE_COLOR =1,

    CV_LOAD_IMAGE_ANYDEPTH =2,

    CV_LOAD_IMAGE_ANYCOLOR =4
};







extern "C" IplImage* cvLoadImage( const char* filename, int iscolor = CV_LOAD_IMAGE_COLOR);
extern "C" CvMat* cvLoadImageM( const char* filename, int iscolor = CV_LOAD_IMAGE_COLOR);

enum
{
    CV_IMWRITE_JPEG_QUALITY =1,
    CV_IMWRITE_PNG_COMPRESSION =16,
    CV_IMWRITE_PNG_STRATEGY =17,
    CV_IMWRITE_PNG_BILEVEL =18,
    CV_IMWRITE_PNG_STRATEGY_DEFAULT =0,
    CV_IMWRITE_PNG_STRATEGY_FILTERED =1,
    CV_IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY =2,
    CV_IMWRITE_PNG_STRATEGY_RLE =3,
    CV_IMWRITE_PNG_STRATEGY_FIXED =4,
    CV_IMWRITE_PXM_BINARY =32
};


extern "C" int cvSaveImage( const char* filename, const CvArr* image,
                        const int* params = 0 );


extern "C" IplImage* cvDecodeImage( const CvMat* buf, int iscolor = CV_LOAD_IMAGE_COLOR);
extern "C" CvMat* cvDecodeImageM( const CvMat* buf, int iscolor = CV_LOAD_IMAGE_COLOR);


extern "C" CvMat* cvEncodeImage( const char* ext, const CvArr* image,
                             const int* params = 0 );

enum
{
    CV_CVTIMG_FLIP =1,
    CV_CVTIMG_SWAP_RB =2
};


extern "C" void cvConvertImage( const CvArr* src, CvArr* dst, int flags = 0);


extern "C" int cvWaitKey(int delay = 0);



typedef void ( *CvOpenGlDrawCallback)(void* userdata);
extern "C" void cvSetOpenGlDrawCallback(const char* window_name, CvOpenGlDrawCallback callback, void* userdata = __null);

extern "C" void cvSetOpenGlContext(const char* window_name);
extern "C" void cvUpdateWindow(const char* window_name);







typedef struct CvCapture CvCapture;


extern "C" CvCapture* cvCreateFileCapture( const char* filename );

enum
{
    CV_CAP_ANY =0,

    CV_CAP_MIL =100,

    CV_CAP_VFW =200,
    CV_CAP_V4L =200,
    CV_CAP_V4L2 =200,

    CV_CAP_FIREWARE =300,
    CV_CAP_FIREWIRE =300,
    CV_CAP_IEEE1394 =300,
    CV_CAP_DC1394 =300,
    CV_CAP_CMU1394 =300,

    CV_CAP_STEREO =400,
    CV_CAP_TYZX =400,
    CV_TYZX_LEFT =400,
    CV_TYZX_RIGHT =401,
    CV_TYZX_COLOR =402,
    CV_TYZX_Z =403,

    CV_CAP_QT =500,

    CV_CAP_UNICAP =600,

    CV_CAP_DSHOW =700,
    CV_CAP_MSMF =1400,

    CV_CAP_PVAPI =800,

    CV_CAP_OPENNI =900,
    CV_CAP_OPENNI_ASUS =910,

    CV_CAP_ANDROID =1000,

    CV_CAP_XIAPI =1100,

    CV_CAP_AVFOUNDATION = 1200,

    CV_CAP_GIGANETIX = 1300
};


extern "C" CvCapture* cvCreateCameraCapture( int index );



extern "C" int cvGrabFrame( CvCapture* capture );





extern "C" IplImage* cvRetrieveFrame( CvCapture* capture, int streamIdx = 0 );



extern "C" IplImage* cvQueryFrame( CvCapture* capture );


extern "C" void cvReleaseCapture( CvCapture** capture );

enum
{


    CV_CAP_PROP_DC1394_OFF = -4,
    CV_CAP_PROP_DC1394_MODE_MANUAL = -3,
    CV_CAP_PROP_DC1394_MODE_AUTO = -2,
    CV_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO = -1,
    CV_CAP_PROP_POS_MSEC =0,
    CV_CAP_PROP_POS_FRAMES =1,
    CV_CAP_PROP_POS_AVI_RATIO =2,
    CV_CAP_PROP_FRAME_WIDTH =3,
    CV_CAP_PROP_FRAME_HEIGHT =4,
    CV_CAP_PROP_FPS =5,
    CV_CAP_PROP_FOURCC =6,
    CV_CAP_PROP_FRAME_COUNT =7,
    CV_CAP_PROP_FORMAT =8,
    CV_CAP_PROP_MODE =9,
    CV_CAP_PROP_BRIGHTNESS =10,
    CV_CAP_PROP_CONTRAST =11,
    CV_CAP_PROP_SATURATION =12,
    CV_CAP_PROP_HUE =13,
    CV_CAP_PROP_GAIN =14,
    CV_CAP_PROP_EXPOSURE =15,
    CV_CAP_PROP_CONVERT_RGB =16,
    CV_CAP_PROP_WHITE_BALANCE_BLUE_U =17,
    CV_CAP_PROP_RECTIFICATION =18,
    CV_CAP_PROP_MONOCROME =19,
    CV_CAP_PROP_SHARPNESS =20,
    CV_CAP_PROP_AUTO_EXPOSURE =21,


    CV_CAP_PROP_GAMMA =22,
    CV_CAP_PROP_TEMPERATURE =23,
    CV_CAP_PROP_TRIGGER =24,
    CV_CAP_PROP_TRIGGER_DELAY =25,
    CV_CAP_PROP_WHITE_BALANCE_RED_V =26,
    CV_CAP_PROP_ZOOM =27,
    CV_CAP_PROP_FOCUS =28,
    CV_CAP_PROP_GUID =29,
    CV_CAP_PROP_ISO_SPEED =30,
    CV_CAP_PROP_MAX_DC1394 =31,
    CV_CAP_PROP_BACKLIGHT =32,
    CV_CAP_PROP_PAN =33,
    CV_CAP_PROP_TILT =34,
    CV_CAP_PROP_ROLL =35,
    CV_CAP_PROP_IRIS =36,
    CV_CAP_PROP_SETTINGS =37,

    CV_CAP_PROP_AUTOGRAB =1024,
    CV_CAP_PROP_SUPPORTED_PREVIEW_SIZES_STRING=1025,
    CV_CAP_PROP_PREVIEW_FORMAT=1026,


    CV_CAP_OPENNI_DEPTH_GENERATOR = 1 << 31,
    CV_CAP_OPENNI_IMAGE_GENERATOR = 1 << 30,
    CV_CAP_OPENNI_GENERATORS_MASK = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_OPENNI_IMAGE_GENERATOR,


    CV_CAP_PROP_OPENNI_OUTPUT_MODE = 100,
    CV_CAP_PROP_OPENNI_FRAME_MAX_DEPTH = 101,
    CV_CAP_PROP_OPENNI_BASELINE = 102,
    CV_CAP_PROP_OPENNI_FOCAL_LENGTH = 103,
    CV_CAP_PROP_OPENNI_REGISTRATION = 104,
    CV_CAP_PROP_OPENNI_REGISTRATION_ON = CV_CAP_PROP_OPENNI_REGISTRATION,


    CV_CAP_PROP_OPENNI_APPROX_FRAME_SYNC = 105,
    CV_CAP_PROP_OPENNI_MAX_BUFFER_SIZE = 106,
    CV_CAP_PROP_OPENNI_CIRCLE_BUFFER = 107,
    CV_CAP_PROP_OPENNI_MAX_TIME_DURATION = 108,

    CV_CAP_PROP_OPENNI_GENERATOR_PRESENT = 109,

    CV_CAP_OPENNI_IMAGE_GENERATOR_PRESENT = CV_CAP_OPENNI_IMAGE_GENERATOR + CV_CAP_PROP_OPENNI_GENERATOR_PRESENT,
    CV_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE = CV_CAP_OPENNI_IMAGE_GENERATOR + CV_CAP_PROP_OPENNI_OUTPUT_MODE,
    CV_CAP_OPENNI_DEPTH_GENERATOR_BASELINE = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_BASELINE,
    CV_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_FOCAL_LENGTH,
    CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_REGISTRATION,
    CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON = CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION,


    CV_CAP_GSTREAMER_QUEUE_LENGTH = 200,
    CV_CAP_PROP_PVAPI_MULTICASTIP = 300,


    CV_CAP_PROP_XI_DOWNSAMPLING = 400,
    CV_CAP_PROP_XI_DATA_FORMAT = 401,
    CV_CAP_PROP_XI_OFFSET_X = 402,
    CV_CAP_PROP_XI_OFFSET_Y = 403,
    CV_CAP_PROP_XI_TRG_SOURCE = 404,
    CV_CAP_PROP_XI_TRG_SOFTWARE = 405,
    CV_CAP_PROP_XI_GPI_SELECTOR = 406,
    CV_CAP_PROP_XI_GPI_MODE = 407,
    CV_CAP_PROP_XI_GPI_LEVEL = 408,
    CV_CAP_PROP_XI_GPO_SELECTOR = 409,
    CV_CAP_PROP_XI_GPO_MODE = 410,
    CV_CAP_PROP_XI_LED_SELECTOR = 411,
    CV_CAP_PROP_XI_LED_MODE = 412,
    CV_CAP_PROP_XI_MANUAL_WB = 413,
    CV_CAP_PROP_XI_AUTO_WB = 414,
    CV_CAP_PROP_XI_AEAG = 415,
    CV_CAP_PROP_XI_EXP_PRIORITY = 416,
    CV_CAP_PROP_XI_AE_MAX_LIMIT = 417,
    CV_CAP_PROP_XI_AG_MAX_LIMIT = 418,
    CV_CAP_PROP_XI_AEAG_LEVEL = 419,
    CV_CAP_PROP_XI_TIMEOUT = 420,


    CV_CAP_PROP_ANDROID_FLASH_MODE = 8001,
    CV_CAP_PROP_ANDROID_FOCUS_MODE = 8002,
    CV_CAP_PROP_ANDROID_WHITE_BALANCE = 8003,
    CV_CAP_PROP_ANDROID_ANTIBANDING = 8004,
    CV_CAP_PROP_ANDROID_FOCAL_LENGTH = 8005,
    CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_NEAR = 8006,
    CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_OPTIMAL = 8007,
    CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_FAR = 8008,


    CV_CAP_PROP_IOS_DEVICE_FOCUS = 9001,
    CV_CAP_PROP_IOS_DEVICE_EXPOSURE = 9002,
    CV_CAP_PROP_IOS_DEVICE_FLASH = 9003,
    CV_CAP_PROP_IOS_DEVICE_WHITEBALANCE = 9004,
    CV_CAP_PROP_IOS_DEVICE_TORCH = 9005



    ,CV_CAP_PROP_GIGA_FRAME_OFFSET_X = 10001,
    CV_CAP_PROP_GIGA_FRAME_OFFSET_Y = 10002,
    CV_CAP_PROP_GIGA_FRAME_WIDTH_MAX = 10003,
    CV_CAP_PROP_GIGA_FRAME_HEIGH_MAX = 10004,
    CV_CAP_PROP_GIGA_FRAME_SENS_WIDTH = 10005,
    CV_CAP_PROP_GIGA_FRAME_SENS_HEIGH = 10006
};

enum
{

    CV_CAP_OPENNI_DEPTH_MAP = 0,
    CV_CAP_OPENNI_POINT_CLOUD_MAP = 1,
    CV_CAP_OPENNI_DISPARITY_MAP = 2,
    CV_CAP_OPENNI_DISPARITY_MAP_32F = 3,
    CV_CAP_OPENNI_VALID_DEPTH_MASK = 4,


    CV_CAP_OPENNI_BGR_IMAGE = 5,
    CV_CAP_OPENNI_GRAY_IMAGE = 6
};


enum
{
    CV_CAP_OPENNI_VGA_30HZ = 0,
    CV_CAP_OPENNI_SXGA_15HZ = 1,
    CV_CAP_OPENNI_SXGA_30HZ = 2,
    CV_CAP_OPENNI_QVGA_30HZ = 3,
    CV_CAP_OPENNI_QVGA_60HZ = 4
};


enum
{
    CV_CAP_ANDROID_COLOR_FRAME_BGR = 0,
    CV_CAP_ANDROID_COLOR_FRAME = CV_CAP_ANDROID_COLOR_FRAME_BGR,
    CV_CAP_ANDROID_GREY_FRAME = 1,
    CV_CAP_ANDROID_COLOR_FRAME_RGB = 2,
    CV_CAP_ANDROID_COLOR_FRAME_BGRA = 3,
    CV_CAP_ANDROID_COLOR_FRAME_RGBA = 4
};


enum
{
    CV_CAP_ANDROID_FLASH_MODE_AUTO = 0,
    CV_CAP_ANDROID_FLASH_MODE_OFF,
    CV_CAP_ANDROID_FLASH_MODE_ON,
    CV_CAP_ANDROID_FLASH_MODE_RED_EYE,
    CV_CAP_ANDROID_FLASH_MODE_TORCH
};


enum
{
    CV_CAP_ANDROID_FOCUS_MODE_AUTO = 0,
    CV_CAP_ANDROID_FOCUS_MODE_CONTINUOUS_VIDEO,
    CV_CAP_ANDROID_FOCUS_MODE_EDOF,
    CV_CAP_ANDROID_FOCUS_MODE_FIXED,
    CV_CAP_ANDROID_FOCUS_MODE_INFINITY,
    CV_CAP_ANDROID_FOCUS_MODE_MACRO
};


enum
{
    CV_CAP_ANDROID_WHITE_BALANCE_AUTO = 0,
    CV_CAP_ANDROID_WHITE_BALANCE_CLOUDY_DAYLIGHT,
    CV_CAP_ANDROID_WHITE_BALANCE_DAYLIGHT,
    CV_CAP_ANDROID_WHITE_BALANCE_FLUORESCENT,
    CV_CAP_ANDROID_WHITE_BALANCE_INCANDESCENT,
    CV_CAP_ANDROID_WHITE_BALANCE_SHADE,
    CV_CAP_ANDROID_WHITE_BALANCE_TWILIGHT,
    CV_CAP_ANDROID_WHITE_BALANCE_WARM_FLUORESCENT
};


enum
{
    CV_CAP_ANDROID_ANTIBANDING_50HZ = 0,
    CV_CAP_ANDROID_ANTIBANDING_60HZ,
    CV_CAP_ANDROID_ANTIBANDING_AUTO,
    CV_CAP_ANDROID_ANTIBANDING_OFF
};


extern "C" double cvGetCaptureProperty( CvCapture* capture, int property_id );
extern "C" int cvSetCaptureProperty( CvCapture* capture, int property_id, double value );


extern "C" int cvGetCaptureDomain( CvCapture* capture);


typedef struct CvVideoWriter CvVideoWriter;

inline int CV_FOURCC(char c1, char c2, char c3, char c4)
{
    return (c1 & 255) + ((c2 & 255) << 8) + ((c3 & 255) << 16) + ((c4 & 255) << 24);
}





extern "C" CvVideoWriter* cvCreateVideoWriter( const char* filename, int fourcc,
                                           double fps, CvSize frame_size,
                                           int is_color = 1);





extern "C" int cvWriteFrame( CvVideoWriter* writer, const IplImage* image );


extern "C" void cvReleaseVideoWriter( CvVideoWriter** writer );
#617 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/highgui/highgui_c.h"
}
#58 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/highgui/highgui.hpp" 1
#51 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/highgui/highgui.hpp"
struct CvCapture;
struct CvVideoWriter;

namespace cv
{

enum {

    WINDOW_NORMAL = CV_WINDOW_NORMAL,
    WINDOW_AUTOSIZE = CV_WINDOW_AUTOSIZE,
    WINDOW_OPENGL = CV_WINDOW_OPENGL,


    WND_PROP_FULLSCREEN = CV_WND_PROP_FULLSCREEN,
    WND_PROP_AUTOSIZE = CV_WND_PROP_AUTOSIZE,
    WND_PROP_ASPECT_RATIO = CV_WND_PROP_ASPECTRATIO,
    WND_PROP_OPENGL = CV_WND_PROP_OPENGL
};

 void namedWindow(const string& winname, int flags = WINDOW_AUTOSIZE);
 void destroyWindow(const string& winname);
 void destroyAllWindows();

 int startWindowThread();

 int waitKey(int delay = 0);

 void imshow(const string& winname, InputArray mat);

 void resizeWindow(const string& winname, int width, int height);
 void moveWindow(const string& winname, int x, int y);

 void setWindowProperty(const string& winname, int prop_id, double prop_value);
 double getWindowProperty(const string& winname, int prop_id);

enum
{
    EVENT_MOUSEMOVE =0,
    EVENT_LBUTTONDOWN =1,
    EVENT_RBUTTONDOWN =2,
    EVENT_MBUTTONDOWN =3,
    EVENT_LBUTTONUP =4,
    EVENT_RBUTTONUP =5,
    EVENT_MBUTTONUP =6,
    EVENT_LBUTTONDBLCLK =7,
    EVENT_RBUTTONDBLCLK =8,
    EVENT_MBUTTONDBLCLK =9
};

enum
{
    EVENT_FLAG_LBUTTON =1,
    EVENT_FLAG_RBUTTON =2,
    EVENT_FLAG_MBUTTON =4,
    EVENT_FLAG_CTRLKEY =8,
    EVENT_FLAG_SHIFTKEY =16,
    EVENT_FLAG_ALTKEY =32
};

typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);


 void setMouseCallback(const string& winname, MouseCallback onMouse, void* userdata = 0);


typedef void ( *TrackbarCallback)(int pos, void* userdata);

 int createTrackbar(const string& trackbarname, const string& winname,
                              int* value, int count,
                              TrackbarCallback onChange = 0,
                              void* userdata = 0);

 int getTrackbarPos(const string& trackbarname, const string& winname);
 void setTrackbarPos(const string& trackbarname, const string& winname, int pos);



typedef void (*OpenGlDrawCallback)(void* userdata);
 void setOpenGlDrawCallback(const string& winname, OpenGlDrawCallback onOpenGlDraw, void* userdata = 0);

 void setOpenGlContext(const string& winname);

 void updateWindow(const string& winname);


 void pointCloudShow(const string& winname, const GlCamera& camera, const GlArrays& arr);
 void pointCloudShow(const string& winname, const GlCamera& camera, InputArray points, InputArray colors = noArray());




 CvFont fontQt(const string& nameFont, int pointSize=-1,
                         Scalar color=Scalar::all(0), int weight=CV_FONT_NORMAL,
                         int style=CV_STYLE_NORMAL, int spacing=0);
 void addText( const Mat& img, const string& text, Point org, CvFont font);

 void displayOverlay(const string& winname, const string& text, int delayms = 0);
 void displayStatusBar(const string& winname, const string& text, int delayms = 0);

 void saveWindowParameters(const string& windowName);
 void loadWindowParameters(const string& windowName);
 int startLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);
 void stopLoop();

typedef void ( *ButtonCallback)(int state, void* userdata);
 int createButton( const string& bar_name, ButtonCallback on_change,
                             void* userdata=__null, int type=CV_PUSH_BUTTON,
                             bool initial_button_state=0);



enum
{

    IMREAD_UNCHANGED =-1,

    IMREAD_GRAYSCALE =0,

    IMREAD_COLOR =1,

    IMREAD_ANYDEPTH =2,

    IMREAD_ANYCOLOR =4
};

enum
{
    IMWRITE_JPEG_QUALITY =1,
    IMWRITE_PNG_COMPRESSION =16,
    IMWRITE_PNG_STRATEGY =17,
    IMWRITE_PNG_BILEVEL =18,
    IMWRITE_PNG_STRATEGY_DEFAULT =0,
    IMWRITE_PNG_STRATEGY_FILTERED =1,
    IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY =2,
    IMWRITE_PNG_STRATEGY_RLE =3,
    IMWRITE_PNG_STRATEGY_FIXED =4,
    IMWRITE_PXM_BINARY =32
};

 Mat imread( const string& filename, int flags=1 );
 bool imwrite( const string& filename, InputArray img,
              const vector<int>& params=vector<int>());
 Mat imdecode( InputArray buf, int flags );
 Mat imdecode( InputArray buf, int flags, Mat* dst );
 bool imencode( const string& ext, InputArray img,
                            vector<uchar>& buf,
                            const vector<int>& params=vector<int>());



template<> void Ptr<CvCapture>::delete_obj();
template<> void Ptr<CvVideoWriter>::delete_obj();

class VideoCapture
{
public:
    VideoCapture();
    VideoCapture(const string& filename);
    VideoCapture(int device);

    virtual ~VideoCapture();
    virtual bool open(const string& filename);
    virtual bool open(int device);
    virtual bool isOpened() const;
    virtual void release();

    virtual bool grab();
    virtual bool retrieve( Mat& image, int channel=0);
    virtual VideoCapture& operator >> ( Mat& image);
    virtual bool read( Mat& image);

    virtual bool set(int propId, double value);
    virtual double get(int propId);

protected:
    Ptr<CvCapture> cap;
};


class VideoWriter
{
public:
    VideoWriter();
    VideoWriter(const string& filename, int fourcc, double fps,
                Size frameSize, bool isColor=true);

    virtual ~VideoWriter();
    virtual bool open(const string& filename, int fourcc, double fps,
                      Size frameSize, bool isColor=true);
    virtual bool isOpened() const;
    virtual void release();
    virtual VideoWriter& operator << (const Mat& image);
    virtual void write(const Mat& image);

protected:
    Ptr<CvVideoWriter> writer;
};



}
#59 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp" 1
#57 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
class CvAdaptiveSkinDetector
{
private:
    enum {
        GSD_HUE_LT = 3,
        GSD_HUE_UT = 33,
        GSD_INTENSITY_LT = 15,
        GSD_INTENSITY_UT = 250
    };

    class Histogram
    {
    private:
        enum {
            HistogramSize = (GSD_HUE_UT - GSD_HUE_LT + 1)
        };

    protected:
        int findCoverageIndex(double surfaceToCover, int defaultValue = 0);

    public:
        CvHistogram *fHistogram;
        Histogram();
        virtual ~Histogram();

        void findCurveThresholds(int &x1, int &x2, double percent = 0.05);
        void mergeWith(Histogram *source, double weight);
    };

    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;
    double fHistogramMergeFactor, fHuePercentCovered;
    Histogram histogramHueMotion, skinHueHistogram;
    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;
    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;

protected:
    void initData(IplImage *src, int widthDivider, int heightDivider);
    void adaptiveFilter();

public:

    enum {
        MORPHING_METHOD_NONE = 0,
        MORPHING_METHOD_ERODE = 1,
        MORPHING_METHOD_ERODE_ERODE = 2,
        MORPHING_METHOD_ERODE_DILATE = 3
    };

    CvAdaptiveSkinDetector(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE);
    virtual ~CvAdaptiveSkinDetector();

    virtual void process(IplImage *inputBGRImage, IplImage *outputHueMask);
};






class CvFuzzyPoint {
public:
    double x, y, value;

    CvFuzzyPoint(double _x, double _y);
};

class CvFuzzyCurve {
private:
    std::vector<CvFuzzyPoint> points;
    double value, centre;

    bool between(double x, double x1, double x2);

public:
    CvFuzzyCurve();
    ~CvFuzzyCurve();

    void setCentre(double _centre);
    double getCentre();
    void clear();
    void addPoint(double x, double y);
    double calcValue(double param);
    double getValue();
    void setValue(double _value);
};

class CvFuzzyFunction {
public:
    std::vector<CvFuzzyCurve> curves;

    CvFuzzyFunction();
    ~CvFuzzyFunction();
    void addCurve(CvFuzzyCurve *curve, double value = 0);
    void resetValues();
    double calcValue();
    CvFuzzyCurve *newCurve();
};

class CvFuzzyRule {
private:
    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;
    CvFuzzyCurve *fuzzyOutput;
public:
    CvFuzzyRule();
    ~CvFuzzyRule();
    void setRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);
    double calcValue(double param1, double param2);
    CvFuzzyCurve *getOutputCurve();
};

class CvFuzzyController {
private:
    std::vector<CvFuzzyRule*> rules;
public:
    CvFuzzyController();
    ~CvFuzzyController();
    void addRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);
    double calcOutput(double param1, double param2);
};

class CvFuzzyMeanShiftTracker
{
private:
    class FuzzyResizer
    {
    private:
        CvFuzzyFunction iInput, iOutput;
        CvFuzzyController fuzzyController;
    public:
        FuzzyResizer();
        int calcOutput(double edgeDensity, double density);
    };

    class SearchWindow
    {
    public:
        FuzzyResizer *fuzzyResizer;
        int x, y;
        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;
        int ldx, ldy, ldw, ldh, numShifts, numIters;
        int xGc, yGc;
        long m00, m01, m10, m11, m02, m20;
        double ellipseAngle;
        double density;
        unsigned int depthLow, depthHigh;
        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;

        SearchWindow();
        ~SearchWindow();
        void setSize(int _x, int _y, int _width, int _height);
        void initDepthValues(IplImage *maskImage, IplImage *depthMap);
        bool shift();
        void extractInfo(IplImage *maskImage, IplImage *depthMap, bool initDepth);
        void getResizeAttribsEdgeDensityLinear(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);
        void getResizeAttribsInnerDensity(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);
        void getResizeAttribsEdgeDensityFuzzy(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);
        bool meanShift(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth);
    };

public:
    enum TrackingState
    {
        tsNone = 0,
        tsSearching = 1,
        tsTracking = 2,
        tsSetWindow = 3,
        tsDisabled = 10
    };

    enum ResizeMethod {
        rmEdgeDensityLinear = 0,
        rmEdgeDensityFuzzy = 1,
        rmInnerDensity = 2
    };

    enum {
        MinKernelMass = 1000
    };

    SearchWindow kernel;
    int searchMode;

private:
    enum
    {
        MaxMeanShiftIteration = 5,
        MaxSetSizeIteration = 5
    };

    void findOptimumSearchWindow(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth);

public:
    CvFuzzyMeanShiftTracker();
    ~CvFuzzyMeanShiftTracker();

    void track(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass);
};


namespace cv
{

    class Octree
    {
    public:
        struct Node
        {
            Node() {}
            int begin, end;
            float x_min, x_max, y_min, y_max, z_min, z_max;
            int maxLevels;
            bool isLeaf;
            int children[8];
        };

        Octree();
        Octree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );
        virtual ~Octree();

        virtual void buildTree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );
        virtual void getPointsWithinSphere( const Point3f& center, float radius,
                                           vector<Point3f>& points ) const;
        const vector<Node>& getNodes() const { return nodes; }
    private:
        int minPoints;
        vector<Point3f> points;
        vector<Node> nodes;

        virtual void buildNext(size_t node_ind);
    };


    class Mesh3D
    {
    public:
        struct EmptyMeshException {};

        Mesh3D();
        Mesh3D(const vector<Point3f>& vtx);
        ~Mesh3D();

        void buildOctree();
        void clearOctree();
        float estimateResolution(float tryRatio = 0.1f);
        void computeNormals(float normalRadius, int minNeighbors = 20);
        void computeNormals(const vector<int>& subset, float normalRadius, int minNeighbors = 20);

        void writeAsVrml(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const;

        vector<Point3f> vtx;
        vector<Point3f> normals;
        float resolution;
        Octree octree;

        const static Point3f allzero;
    };

    class SpinImageModel
    {
    public:


        float normalRadius;
        int minNeighbors;

        float binSize;
        int imageWidth;

        float lambda;
        float gamma;

        float T_GeometriccConsistency;
        float T_GroupingCorespondances;


        SpinImageModel();
        explicit SpinImageModel(const Mesh3D& mesh);
        ~SpinImageModel();

        void setLogger(std::ostream* log);
        void selectRandomSubset(float ratio);
        void setSubset(const vector<int>& subset);
        void compute();

        void match(const SpinImageModel& scene, vector< vector<Vec2i> >& result);

        Mat packRandomScaledSpins(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const;

        size_t getSpinCount() const { return spinImages.rows; }
        Mat getSpinImage(size_t index) const { return spinImages.row((int)index); }
        const Point3f& getSpinVertex(size_t index) const { return mesh.vtx[subset[index]]; }
        const Point3f& getSpinNormal(size_t index) const { return mesh.normals[subset[index]]; }

        const Mesh3D& getMesh() const { return mesh; }
        Mesh3D& getMesh() { return mesh; }


        static bool spinCorrelation(const Mat& spin1, const Mat& spin2, float lambda, float& result);

        static Point2f calcSpinMapCoo(const Point3f& point, const Point3f& vertex, const Point3f& normal);

        static float geometricConsistency(const Point3f& pointScene1, const Point3f& normalScene1,
                                          const Point3f& pointModel1, const Point3f& normalModel1,
                                          const Point3f& pointScene2, const Point3f& normalScene2,
                                          const Point3f& pointModel2, const Point3f& normalModel2);

        static float groupingCreteria(const Point3f& pointScene1, const Point3f& normalScene1,
                                      const Point3f& pointModel1, const Point3f& normalModel1,
                                      const Point3f& pointScene2, const Point3f& normalScene2,
                                      const Point3f& pointModel2, const Point3f& normalModel2,
                                      float gamma);
    protected:
        void defaultParams();

        void matchSpinToModel(const Mat& spin, vector<int>& indeces,
                              vector<float>& corrCoeffs, bool useExtremeOutliers = true) const;

        void repackSpinImages(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const;

        vector<int> subset;
        Mesh3D mesh;
        Mat spinImages;
        std::ostream* out;
    };

    class TickMeter
    {
    public:
        TickMeter();
        void start();
        void stop();

        int64 getTimeTicks() const;
        double getTimeMicro() const;
        double getTimeMilli() const;
        double getTimeSec() const;
        int64 getCounter() const;

        void reset();
    private:
        int64 counter;
        int64 sumTime;
        int64 startTime;
    };

    std::ostream& operator<<(std::ostream& out, const TickMeter& tm);

    class SelfSimDescriptor
    {
    public:
        SelfSimDescriptor();
        SelfSimDescriptor(int _ssize, int _lsize,
                          int _startDistanceBucket=DEFAULT_START_DISTANCE_BUCKET,
                          int _numberOfDistanceBuckets=DEFAULT_NUM_DISTANCE_BUCKETS,
                          int _nangles=DEFAULT_NUM_ANGLES);
        SelfSimDescriptor(const SelfSimDescriptor& ss);
        virtual ~SelfSimDescriptor();
        SelfSimDescriptor& operator = (const SelfSimDescriptor& ss);

        size_t getDescriptorSize() const;
        Size getGridSize( Size imgsize, Size winStride ) const;

        virtual void compute(const Mat& img, vector<float>& descriptors, Size winStride=Size(),
                             const vector<Point>& locations=vector<Point>()) const;
        virtual void computeLogPolarMapping(Mat& mappingMask) const;
        virtual void SSD(const Mat& img, Point pt, Mat& ssd) const;

        int smallSize;
        int largeSize;
        int startDistanceBucket;
        int numberOfDistanceBuckets;
        int numberOfAngles;

        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,
            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,
            DEFAULT_NUM_DISTANCE_BUCKETS = 7 };
    };


    typedef bool (*BundleAdjustCallback)(int iteration, double norm_error, void* user_data);

    class LevMarqSparse {
    public:
        LevMarqSparse();
        LevMarqSparse(int npoints,
                      int ncameras,
                      int nPointParams,
                      int nCameraParams,
                      int nErrParams,

                      Mat& visibility,

                      Mat& P0,
                      Mat& X,
                      TermCriteria criteria,


                      void ( * fjac)(int i, int j, Mat& point_params,
                                             Mat& cam_params, Mat& A, Mat& B, void* data),

                      void ( * func)(int i, int j, Mat& point_params,
                                             Mat& cam_params, Mat& estim, void* data),
                      void* data,
                      BundleAdjustCallback cb, void* user_data
                      );

        virtual ~LevMarqSparse();

        virtual void run( int npoints,
                         int ncameras,
                         int nPointParams,
                         int nCameraParams,
                         int nErrParams,

                         Mat& visibility,

                         Mat& P0,
                         Mat& X,
                         TermCriteria criteria,


                         void ( * fjac)(int i, int j, Mat& point_params,
                                                Mat& cam_params, Mat& A, Mat& B, void* data),

                         void ( * func)(int i, int j, Mat& point_params,
                                                Mat& cam_params, Mat& estim, void* data),
                         void* data
                         );

        virtual void clear();


        static void bundleAdjust(vector<Point3d>& points,
                                 const vector<vector<Point2d> >& imagePoints,
                                 const vector<vector<int> >& visibility,
                                 vector<Mat>& cameraMatrix,
                                 vector<Mat>& R,
                                 vector<Mat>& T,
                                 vector<Mat>& distCoeffs,
                                 const TermCriteria& criteria=
                                 TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, double(2.22044604925031308085e-16L)),
                                 BundleAdjustCallback cb = 0, void* user_data = 0);

    public:
        virtual void optimize(CvMat &_vis);


        void ask_for_proj(CvMat &_vis,bool once=false);

        void ask_for_projac(CvMat &_vis);

        CvMat* err;
        double prevErrNorm, errNorm;
        double lambda;
        CvTermCriteria criteria;
        int iters;

        CvMat** U;
        CvMat** V;
        CvMat** inv_V_star;

        CvMat** A;
        CvMat** B;
        CvMat** W;

        CvMat* X;
        CvMat* hX;

        CvMat* prevP;
        CvMat* P;


        CvMat* deltaP;

        CvMat** ea;

        CvMat** eb;


        CvMat** Yj;

        CvMat* S;

        CvMat* JtJ_diag;

        CvMat* Vis_index;

        int num_cams;
        int num_points;
        int num_err_param;
        int num_cam_param;
        int num_point_param;


        void (*fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data);
        void (*func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data);

        void* data;

        BundleAdjustCallback cb;
        void* user_data;
    };

    int chamerMatching( Mat& img, Mat& templ,
                                  vector<vector<Point> >& results, vector<float>& cost,
                                  double templScale=1, int maxMatches = 20,
                                  double minMatchDistance = 1.0, int padX = 3,
                                  int padY = 3, int scales = 5, double minScale = 0.6, double maxScale = 1.6,
                                  double orientationWeight = 0.5, double truncate = 20);


    class StereoVar
    {
    public:

        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};
        enum {CYCLE_O, CYCLE_V};
        enum {PENALIZATION_TICHONOV, PENALIZATION_CHARBONNIER, PENALIZATION_PERONA_MALIK};


        StereoVar();


        StereoVar(int levels, double pyrScale, int nIt, int minDisp, int maxDisp, int poly_n, double poly_sigma, float fi, float lambda, int penalization, int cycle, int flags);


        virtual ~StereoVar();


        virtual void operator()(const Mat& left, const Mat& right, Mat& disp);

        int levels;
        double pyrScale;
        int nIt;
        int minDisp;
        int maxDisp;
        int poly_n;
        double poly_sigma;
        float fi;
        float lambda;
        int penalization;
        int cycle;
        int flags;

    private:
        void autoParams();
        void FMG(Mat &I1, Mat &I2, Mat &I2x, Mat &u, int level);
        void VCycle_MyFAS(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level);
        void VariationalSolver(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level);
    };

    void polyfit(const Mat& srcx, const Mat& srcy, Mat& dst, int order);

    class Directory
    {
        public:
            static std::vector<std::string> GetListFiles ( const std::string& path, const std::string & exten = "*", bool addPath = true );
            static std::vector<std::string> GetListFilesR ( const std::string& path, const std::string & exten = "*", bool addPath = true );
            static std::vector<std::string> GetListFolders( const std::string& path, const std::string & exten = "*", bool addPath = true );
    };
#626 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
    void generateColors( std::vector<Scalar>& colors, size_t count, size_t factor=100 );






    enum { ROTATION = 1,
           TRANSLATION = 2,
           RIGID_BODY_MOTION = 4
         };
    bool RGBDOdometry( Mat& Rt, const Mat& initRt,
                                  const Mat& image0, const Mat& depth0, const Mat& mask0,
                                  const Mat& image1, const Mat& depth1, const Mat& mask1,
                                  const Mat& cameraMatrix, float minDepth=0.f, float maxDepth=4.f, float maxDepthDiff=0.07f,
                                  const std::vector<int>& iterCounts=std::vector<int>(),
                                  const std::vector<float>& minGradientMagnitudes=std::vector<float>(),
                                  int transformType=RIGID_BODY_MOTION );
#654 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
    class LogPolar_Interp
    {
    public:

        LogPolar_Interp() {}
#674 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
        LogPolar_Interp(int w, int h, Point2i center, int R=70, double ro0=3.0,
                        int interp=INTER_LINEAR, int full=1, int S=117, int sp=1);





        const Mat to_cortical(const Mat &source);





        const Mat to_cartesian(const Mat &source);



        ~LogPolar_Interp();

    protected:

        Mat Rsri;
        Mat Csri;

        int S, R, M, N;
        int top, bottom,left,right;
        double ro0, romax, a, q;
        int interp;

        Mat ETAyx;
        Mat CSIyx;

        void create_map(int M, int N, int R, int S, double ro0);
    };
#718 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
    class LogPolar_Overlapping
    {
    public:
        LogPolar_Overlapping() {}
#737 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
        LogPolar_Overlapping(int w, int h, Point2i center, int R=70,
                             double ro0=3.0, int full=1, int S=117, int sp=1);





        const Mat to_cortical(const Mat &source);





        const Mat to_cartesian(const Mat &source);



        ~LogPolar_Overlapping();

    protected:

        Mat Rsri;
        Mat Csri;
        vector<int> Rsr;
        vector<int> Csr;
        vector<double> Wsr;

        int S, R, M, N, ind1;
        int top, bottom,left,right;
        double ro0, romax, a, q;

        struct kernel
        {
            kernel() { w = 0; }
            vector<double> weights;
            int w;
        };

        Mat ETAyx;
        Mat CSIyx;
        vector<kernel> w_ker_2D;

        void create_map(int M, int N, int R, int S, double ro0);
    };
#792 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
    class LogPolar_Adjacent
    {
    public:
        LogPolar_Adjacent() {}
#812 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp"
        LogPolar_Adjacent(int w, int h, Point2i center, int R=70, double ro0=3.0, double smin=0.25, int full=1, int S=117, int sp=1);





        const Mat to_cortical(const Mat &source);





        const Mat to_cartesian(const Mat &source);



        ~LogPolar_Adjacent();

    protected:
        struct pixel
        {
            pixel() { u = v = 0; a = 0.; }
            int u;
            int v;
            double a;
        };
        int S, R, M, N;
        int top, bottom,left,right;
        double ro0, romax, a, q;
        vector<vector<pixel> > L;
        vector<double> A;

        void subdivide_recursively(double x, double y, int i, int j, double length, double smin);
        bool get_uv(double x, double y, int&u, int&v);
        void create_map(int M, int N, int R, int S, double ro0, double smin);
    };

    Mat subspaceProject(InputArray W, InputArray mean, InputArray src);
    Mat subspaceReconstruct(InputArray W, InputArray mean, InputArray src);

    class LDA
    {
    public:


        LDA(int num_components = 0) :
            _num_components(num_components) {};





        LDA(const Mat& src, vector<int> labels,
                int num_components = 0) :
                    _num_components(num_components)
        {
            this->compute(src, labels);
        }





        LDA(InputArrayOfArrays src, InputArray labels,
                int num_components = 0) :
                    _num_components(num_components)
        {
            this->compute(src, labels);
        }


        void save(const string& filename) const;


        void load(const string& filename);


        void save(FileStorage& fs) const;


        void load(const FileStorage& node);


        ~LDA() {}


        void compute(InputArrayOfArrays src, InputArray labels);


        Mat project(InputArray src);


        Mat reconstruct(InputArray src);


        Mat eigenvectors() const { return _eigenvectors; };


        Mat eigenvalues() const { return _eigenvalues; }

    protected:
        bool _dataAsRow;
        int _num_components;
        Mat _eigenvectors;
        Mat _eigenvalues;

        void lda(InputArrayOfArrays src, InputArray labels);
    };

    class FaceRecognizer : public Algorithm
    {
    public:

        virtual ~FaceRecognizer() {}


        virtual void train(InputArrayOfArrays src, InputArray labels) = 0;


        void update(InputArrayOfArrays src, InputArray labels);


        virtual int predict(InputArray src) const = 0;


        virtual void predict(InputArray src, int &label, double &confidence) const = 0;


        virtual void save(const string& filename) const;


        virtual void load(const string& filename);


        virtual void save(FileStorage& fs) const = 0;


        virtual void load(const FileStorage& fs) = 0;

    };

    Ptr<FaceRecognizer> createEigenFaceRecognizer(int num_components = 0, double threshold = double(1.79769313486231570815e+308L));
    Ptr<FaceRecognizer> createFisherFaceRecognizer(int num_components = 0, double threshold = double(1.79769313486231570815e+308L));
    Ptr<FaceRecognizer> createLBPHFaceRecognizer(int radius=1, int neighbors=8,
                                                            int grid_x=8, int grid_y=8, double threshold = double(1.79769313486231570815e+308L));

    enum
    {
        COLORMAP_AUTUMN = 0,
        COLORMAP_BONE = 1,
        COLORMAP_JET = 2,
        COLORMAP_WINTER = 3,
        COLORMAP_RAINBOW = 4,
        COLORMAP_OCEAN = 5,
        COLORMAP_SUMMER = 6,
        COLORMAP_SPRING = 7,
        COLORMAP_COOL = 8,
        COLORMAP_HSV = 9,
        COLORMAP_PINK = 10,
        COLORMAP_HOT = 11
    };

    void applyColorMap(InputArray src, OutputArray dst, int colormap);

    bool initModule_contrib();
}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp" 1
#76 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
#40 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<class _Clos, typename _Tp>
    class _Expr;

  template<typename _Tp1, typename _Tp2>
    class _ValArray;

  template<class _Oper, template<class, class> class _Meta, class _Dom>
    struct _UnClos;

  template<class _Oper,
        template<class, class> class _Meta1,
        template<class, class> class _Meta2,
        class _Dom1, class _Dom2>
    class _BinClos;

  template<template<class, class> class _Meta, class _Dom>
    class _SClos;

  template<template<class, class> class _Meta, class _Dom>
    class _GClos;

  template<template<class, class> class _Meta, class _Dom>
    class _IClos;

  template<template<class, class> class _Meta, class _Dom>
    class _ValFunClos;

  template<template<class, class> class _Meta, class _Dom>
    class _RefFunClos;

  template<class _Tp> class valarray;
  class slice;
  template<class _Tp> class slice_array;
  class gslice;
  template<class _Tp> class gslice_array;
  template<class _Tp> class mask_array;
  template<class _Tp> class indirect_array;


}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.h" 1 3
#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.h" 3

#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.h" 3



#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{







  inline void*
  __valarray_get_memory(size_t __n)
  { return operator new(__n); }

  template<typename _Tp>
    inline _Tp*__restrict__
    __valarray_get_storage(size_t __n)
    {
      return static_cast<_Tp*__restrict__>
 (std::__valarray_get_memory(__n * sizeof(_Tp)));
    }


  inline void
  __valarray_release_memory(void* __p)
  { operator delete(__p); }



  template<typename _Tp, bool>
    struct _Array_default_ctor
    {


      inline static void
      _S_do_it(_Tp* __b, _Tp* __e)
      {
 while (__b != __e)
   new(__b++) _Tp();
      }
    };

  template<typename _Tp>
    struct _Array_default_ctor<_Tp, true>
    {

      inline static void
      _S_do_it(_Tp* __b, _Tp* __e)
      { __builtin_memset(__b, 0, (__e - __b) * sizeof(_Tp)); }
    };

  template<typename _Tp>
    inline void
    __valarray_default_construct(_Tp* __b, _Tp* __e)
    {
      _Array_default_ctor<_Tp, __is_scalar<_Tp>::__value>::_S_do_it(__b, __e);
    }




  template<typename _Tp, bool>
    struct _Array_init_ctor
    {


      inline static void
      _S_do_it(_Tp* __b, _Tp* __e, const _Tp __t)
      {
 while (__b != __e)
   new(__b++) _Tp(__t);
      }
    };

  template<typename _Tp>
    struct _Array_init_ctor<_Tp, true>
    {
      inline static void
      _S_do_it(_Tp* __b, _Tp* __e, const _Tp __t)
      {
 while (__b != __e)
   *__b++ = __t;
      }
    };

  template<typename _Tp>
    inline void
    __valarray_fill_construct(_Tp* __b, _Tp* __e, const _Tp __t)
    {
      _Array_init_ctor<_Tp, __is_trivial(_Tp)>::_S_do_it(__b, __e, __t);
    }





  template<typename _Tp, bool>
    struct _Array_copy_ctor
    {


      inline static void
      _S_do_it(const _Tp* __b, const _Tp* __e, _Tp* __restrict__ __o)
      {
 while (__b != __e)
   new(__o++) _Tp(*__b++);
      }
    };

  template<typename _Tp>
    struct _Array_copy_ctor<_Tp, true>
    {
      inline static void
      _S_do_it(const _Tp* __b, const _Tp* __e, _Tp* __restrict__ __o)
      { __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp)); }
    };

  template<typename _Tp>
    inline void
    __valarray_copy_construct(const _Tp* __b, const _Tp* __e,
         _Tp* __restrict__ __o)
    {
      _Array_copy_ctor<_Tp, __is_trivial(_Tp)>::_S_do_it(__b, __e, __o);
    }


  template<typename _Tp>
    inline void
    __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,
          size_t __s, _Tp* __restrict__ __o)
    {
      if (__is_trivial(_Tp))
 while (__n--)
   {
     *__o++ = *__a;
     __a += __s;
   }
      else
 while (__n--)
   {
     new(__o++) _Tp(*__a);
     __a += __s;
   }
    }


  template<typename _Tp>
    inline void
    __valarray_copy_construct (const _Tp* __restrict__ __a,
          const size_t* __restrict__ __i,
          _Tp* __restrict__ __o, size_t __n)
    {
      if (__is_trivial(_Tp))
 while (__n--)
   *__o++ = __a[*__i++];
      else
 while (__n--)
   new (__o++) _Tp(__a[*__i++]);
    }


  template<typename _Tp>
    inline void
    __valarray_destroy_elements(_Tp* __b, _Tp* __e)
    {
      if (!__is_trivial(_Tp))
 while (__b != __e)
   {
     __b->~_Tp();
     ++__b;
   }
    }


  template<typename _Tp>
    inline void
    __valarray_fill(_Tp* __restrict__ __a, size_t __n, const _Tp& __t)
    {
      while (__n--)
 *__a++ = __t;
    }


  template<typename _Tp>
    inline void
    __valarray_fill(_Tp* __restrict__ __a, size_t __n,
      size_t __s, const _Tp& __t)
    {
      for (size_t __i = 0; __i < __n; ++__i, __a += __s)
 *__a = __t;
    }


  template<typename _Tp>
    inline void
    __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,
      size_t __n, const _Tp& __t)
    {
      for (size_t __j = 0; __j < __n; ++__j, ++__i)
 __a[*__i] = __t;
    }



  template<typename _Tp, bool>
    struct _Array_copier
    {
      inline static void
      _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)
      {
 while(__n--)
   *__b++ = *__a++;
      }
    };

  template<typename _Tp>
    struct _Array_copier<_Tp, true>
    {
      inline static void
      _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)
      { __builtin_memcpy(__b, __a, __n * sizeof (_Tp)); }
    };


  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, size_t __n,
      _Tp* __restrict__ __b)
    {
      _Array_copier<_Tp, __is_trivial(_Tp)>::_S_do_it(__a, __n, __b);
    }


  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, size_t __n, size_t __s,
      _Tp* __restrict__ __b)
    {
      for (size_t __i = 0; __i < __n; ++__i, ++__b, __a += __s)
 *__b = *__a;
    }


  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, _Tp* __restrict__ __b,
      size_t __n, size_t __s)
    {
      for (size_t __i = 0; __i < __n; ++__i, ++__a, __b += __s)
 *__b = *__a;
    }



  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __src, size_t __n, size_t __s1,
      _Tp* __restrict__ __dst, size_t __s2)
    {
      for (size_t __i = 0; __i < __n; ++__i)
 __dst[__i * __s2] = __src[__i * __s1];
    }


  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a,
      const size_t* __restrict__ __i,
      _Tp* __restrict__ __b, size_t __n)
    {
      for (size_t __j = 0; __j < __n; ++__j, ++__b, ++__i)
 *__b = __a[*__i];
    }


  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __a, size_t __n,
      _Tp* __restrict__ __b, const size_t* __restrict__ __i)
    {
      for (size_t __j = 0; __j < __n; ++__j, ++__a, ++__i)
 __b[*__i] = *__a;
    }



  template<typename _Tp>
    inline void
    __valarray_copy(const _Tp* __restrict__ __src, size_t __n,
      const size_t* __restrict__ __i,
      _Tp* __restrict__ __dst, const size_t* __restrict__ __j)
    {
      for (size_t __k = 0; __k < __n; ++__k)
 __dst[*__j++] = __src[*__i++];
    }
#346 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.h" 3
  template<typename _Tp>
    inline _Tp
    __valarray_sum(const _Tp* __f, const _Tp* __l)
    {
      _Tp __r = _Tp();
      while (__f != __l)
 __r += *__f++;
      return __r;
    }


  template<typename _Tp>
    inline _Tp
    __valarray_product(const _Tp* __f, const _Tp* __l)
    {
      _Tp __r = _Tp(1);
      while (__f != __l)
 __r = __r * *__f++;
      return __r;
    }


  template<typename _Ta>
    inline typename _Ta::value_type
    __valarray_min(const _Ta& __a)
    {
      size_t __s = __a.size();
      typedef typename _Ta::value_type _Value_type;
      _Value_type __r = __s == 0 ? _Value_type() : __a[0];
      for (size_t __i = 1; __i < __s; ++__i)
 {
   _Value_type __t = __a[__i];
   if (__t < __r)
     __r = __t;
 }
      return __r;
    }

  template<typename _Ta>
    inline typename _Ta::value_type
    __valarray_max(const _Ta& __a)
    {
      size_t __s = __a.size();
      typedef typename _Ta::value_type _Value_type;
      _Value_type __r = __s == 0 ? _Value_type() : __a[0];
      for (size_t __i = 1; __i < __s; ++__i)
 {
   _Value_type __t = __a[__i];
   if (__t > __r)
     __r = __t;
 }
      return __r;
    }







  template<typename _Tp>
    struct _Array
    {
      explicit _Array(size_t);
      explicit _Array(_Tp* const __restrict__);
      explicit _Array(const valarray<_Tp>&);
      _Array(const _Tp* __restrict__, size_t);

      _Tp* begin() const;

      _Tp* const __restrict__ _M_data;
    };



  template<typename _Tp>
    inline void
    __valarray_copy_construct(_Array<_Tp> __a, _Array<size_t> __i,
         _Array<_Tp> __b, size_t __n)
    { std::__valarray_copy_construct(__a._M_data, __i._M_data,
         __b._M_data, __n); }


  template<typename _Tp>
    inline void
    __valarray_copy_construct(_Array<_Tp> __a, size_t __n, size_t __s,
         _Array<_Tp> __b)
    { std::__valarray_copy_construct(__a._M_data, __n, __s, __b._M_data); }

  template<typename _Tp>
    inline void
    __valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)
    { std::__valarray_fill(__a._M_data, __n, __t); }

  template<typename _Tp>
    inline void
    __valarray_fill(_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)
    { std::__valarray_fill(__a._M_data, __n, __s, __t); }

  template<typename _Tp>
    inline void
    __valarray_fill(_Array<_Tp> __a, _Array<size_t> __i,
      size_t __n, const _Tp& __t)
    { std::__valarray_fill(__a._M_data, __i._M_data, __n, __t); }


  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)
    { std::__valarray_copy(__a._M_data, __n, __b._M_data); }


  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b)
    { std::__valarray_copy(__a._M_data, __n, __s, __b._M_data); }


  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s)
    { __valarray_copy(__a._M_data, __b._M_data, __n, __s); }



  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s1,
                    _Array<_Tp> __b, size_t __s2)
    { std::__valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2); }


  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, _Array<size_t> __i,
      _Array<_Tp> __b, size_t __n)
    { std::__valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n); }


  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,
      _Array<size_t> __i)
    { std::__valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data); }



  template<typename _Tp>
    inline void
    __valarray_copy(_Array<_Tp> __src, size_t __n, _Array<size_t> __i,
                    _Array<_Tp> __dst, _Array<size_t> __j)
    {
      std::__valarray_copy(__src._M_data, __n, __i._M_data,
      __dst._M_data, __j._M_data);
    }

  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(size_t __n)
    : _M_data(__valarray_get_storage<_Tp>(__n))
    { std::__valarray_default_construct(_M_data, _M_data + __n); }

  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(_Tp* const __restrict__ __p)
    : _M_data (__p) {}

  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(const valarray<_Tp>& __v)
    : _M_data (__v._M_data) {}

  template<typename _Tp>
    inline
    _Array<_Tp>::_Array(const _Tp* __restrict__ __b, size_t __s)
    : _M_data(__valarray_get_storage<_Tp>(__s))
    { std::__valarray_copy_construct(__b, __s, _M_data); }

  template<typename _Tp>
    inline _Tp*
    _Array<_Tp>::begin () const
    { return _M_data; }
#677 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.h" 3
   template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p += __t; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p += *__q; } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p += __e[__i]; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p += *__q; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p += *__q; } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p += __e[__i]; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] += *__q; } template<typename _Tp> inline void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p += __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] += __e[__k]; } template<typename _Tp> void _Array_augmented___plus(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p += *__q; } } template<typename _Tp> void _Array_augmented___plus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p += *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___plus(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p += __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p -= __t; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p -= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p -= __e[__i]; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p -= *__q; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p -= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p -= __e[__i]; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] -= *__q; } template<typename _Tp> inline void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p -= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] -= __e[__k]; } template<typename _Tp> void _Array_augmented___minus(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p -= *__q; } } template<typename _Tp> void _Array_augmented___minus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p -= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___minus(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p -= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p *= __t; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p *= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p *= __e[__i]; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p *= *__q; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p *= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p *= __e[__i]; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] *= *__q; } template<typename _Tp> inline void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p *= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] *= __e[__k]; } template<typename _Tp> void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p *= *__q; } } template<typename _Tp> void _Array_augmented___multiplies(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p *= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___multiplies(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p *= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p /= __t; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p /= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p /= __e[__i]; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p /= *__q; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p /= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p /= __e[__i]; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] /= *__q; } template<typename _Tp> inline void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p /= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] /= __e[__k]; } template<typename _Tp> void _Array_augmented___divides(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p /= *__q; } } template<typename _Tp> void _Array_augmented___divides(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p /= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___divides(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p /= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p %= __t; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p %= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p %= __e[__i]; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p %= *__q; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p %= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p %= __e[__i]; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] %= *__q; } template<typename _Tp> inline void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p %= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] %= __e[__k]; } template<typename _Tp> void _Array_augmented___modulus(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p %= *__q; } } template<typename _Tp> void _Array_augmented___modulus(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p %= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___modulus(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p %= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p ^= __t; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p ^= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p ^= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p ^= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p ^= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p ^= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] ^= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p ^= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] ^= __e[__k]; } template<typename _Tp> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p ^= *__q; } } template<typename _Tp> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p ^= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_xor(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p ^= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p |= __t; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p |= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p |= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p |= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p |= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p |= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] |= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p |= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] |= __e[__k]; } template<typename _Tp> void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p |= *__q; } } template<typename _Tp> void _Array_augmented___bitwise_or(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p |= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_or(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p |= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p &= __t; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p &= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p &= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p &= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p &= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p &= __e[__i]; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] &= *__q; } template<typename _Tp> inline void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p &= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] &= __e[__k]; } template<typename _Tp> void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p &= *__q; } } template<typename _Tp> void _Array_augmented___bitwise_and(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p &= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___bitwise_and(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p &= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p <<= __t; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p <<= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p <<= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p <<= *__q; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p <<= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p <<= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] <<= *__q; } template<typename _Tp> inline void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p <<= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] <<= __e[__k]; } template<typename _Tp> void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p <<= *__q; } } template<typename _Tp> void _Array_augmented___shift_left(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p <<= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___shift_left(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p <<= __e[__i]; } }
   template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, const _Tp& __t) { for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p) *__p >>= __t; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) { _Tp* __p = __a._M_data; for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) *__p >>= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__p) *__p >>= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n; __p += __s, ++__q) *__p >>= *__q; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s) { _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, __q += __s) *__p >>= *__q; } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __s, const _Expr<_Dom, _Tp>& __e, size_t __n) { _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, __p += __s) *__p >>= __e[__i]; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<size_t> __i, _Array<_Tp> __b, size_t __n) { _Tp* __q(__b._M_data); for (size_t* __j = __i._M_data; __j < __i._M_data + __n; ++__j, ++__q) __a._M_data[*__j] >>= *__q; } template<typename _Tp> inline void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<size_t> __i) { _Tp* __p(__a._M_data); for (size_t* __j = __i._M_data; __j<__i._M_data + __n; ++__j, ++__p) *__p >>= __b._M_data[*__j]; } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<size_t> __i, const _Expr<_Dom, _Tp>& __e, size_t __n) { size_t* __j(__i._M_data); for (size_t __k = 0; __k<__n; ++__k, ++__j) __a._M_data[*__j] >>= __e[__k]; } template<typename _Tp> void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__q, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p >>= *__q; } } template<typename _Tp> void _Array_augmented___shift_right(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m) { bool* __ok(__m._M_data); _Tp* __q(__b._M_data); for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p, ++__ok, ++__q) { while (! *__ok) { ++__ok; ++__q; } *__p >>= *__q; } } template<typename _Tp, class _Dom> void _Array_augmented___shift_right(_Array<_Tp> __a, _Array<bool> __m, const _Expr<_Dom, _Tp>& __e, size_t __n) { bool* __ok(__m._M_data); _Tp* __p(__a._M_data); for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p) { while (! *__ok) { ++__ok; ++__p; } *__p >>= __e[__i]; } }




}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.tcc" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp>
    void
    __valarray_fill(_Array<_Tp> __a, size_t __n, _Array<bool> __m,
      const _Tp& __t)
    {
      _Tp* __p = __a._M_data;
      bool* __ok (__m._M_data);
      for (size_t __i=0; __i < __n; ++__i, ++__ok, ++__p)
 {
   while (!*__ok)
   {
     ++__ok;
     ++__p;
   }
   *__p = __t;
 }
    }







  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b,
      size_t __n)
    {
      _Tp* __p (__a._M_data);
      bool* __ok (__m._M_data);
      for (_Tp* __q = __b._M_data; __q < __b._M_data + __n;
    ++__q, ++__ok, ++__p)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__p;
     }
   *__q = *__p;
 }
    }







  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,
      _Array<bool> __m)
    {
      _Tp* __q (__b._M_data);
      bool* __ok (__m._M_data);
      for (_Tp* __p = __a._M_data; __p < __a._M_data+__n;
    ++__p, ++__ok, ++__q)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__q;
     }
   *__q = *__p;
 }
    }






  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __a, _Array<bool> __m, size_t __n,
      _Array<_Tp> __b, _Array<bool> __k)
    {
      _Tp* __p (__a._M_data);
      _Tp* __q (__b._M_data);
      bool* __srcok (__m._M_data);
      bool* __dstok (__k._M_data);
      for (size_t __i = 0; __i < __n;
    ++__srcok, ++__p, ++__dstok, ++__q, ++__i)
 {
   while (! *__srcok)
     {
       ++__srcok;
       ++__p;
     }
   while (! *__dstok)
     {
       ++__dstok;
       ++__q;
     }
   *__q = *__p;
 }
    }



  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n, _Array<_Tp> __a)
    {
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, ++__p)
 *__p = __e[__i];
    }



  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n,
       _Array<_Tp> __a, size_t __s)
    {
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, __p += __s)
 *__p = __e[__i];
    }



  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n,
      _Array<_Tp> __a, _Array<size_t> __i)
    {
      size_t* __j (__i._M_data);
      for (size_t __k = 0; __k < __n; ++__k, ++__j)
 __a._M_data[*__j] = __e[__k];
    }



  template<typename _Tp>
    void
    __valarray_copy(_Array<_Tp> __e, _Array<size_t> __f,
      size_t __n,
      _Array<_Tp> __a, _Array<size_t> __i)
    {
      size_t* __g (__f._M_data);
      size_t* __j (__i._M_data);
      for (size_t __k = 0; __k < __n; ++__k, ++__j, ++__g)
 __a._M_data[*__j] = __e._M_data[*__g];
    }







  template<typename _Tp, class _Dom>
    void
    __valarray_copy(const _Expr<_Dom, _Tp>& __e, size_t __n,
      _Array<_Tp> __a, _Array<bool> __m)
    {
      bool* __ok (__m._M_data);
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__p;
     }
   *__p = __e[__i];
 }
    }


  template<typename _Tp, class _Dom>
    void
    __valarray_copy_construct(const _Expr<_Dom, _Tp>& __e, size_t __n,
         _Array<_Tp> __a)
    {
      _Tp* __p (__a._M_data);
      for (size_t __i = 0; __i < __n; ++__i, ++__p)
 new (__p) _Tp(__e[__i]);
    }


  template<typename _Tp>
    void
    __valarray_copy_construct(_Array<_Tp> __a, _Array<bool> __m,
         _Array<_Tp> __b, size_t __n)
    {
      _Tp* __p (__a._M_data);
      bool* __ok (__m._M_data);
      for (_Tp* __q = __b._M_data; __q < __b._M_data+__n; ++__q, ++__ok, ++__p)
 {
   while (! *__ok)
     {
       ++__ok;
       ++__p;
     }
   new (__q) _Tp(*__p);
 }
    }


}
#694 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_array.h" 2 3
#90 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_before.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_before.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_before.h" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/slice_array.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/slice_array.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/slice_array.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/slice_array.h" 3
  class slice
  {
  public:

    slice();
#73 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/slice_array.h" 3
    slice(size_t, size_t, size_t);


    size_t start() const;

    size_t size() const;

    size_t stride() const;

  private:
    size_t _M_off;
    size_t _M_sz;
    size_t _M_st;
  };



  inline
  slice::slice()
  : _M_off(0), _M_sz(0), _M_st(0) {}

  inline
  slice::slice(size_t __o, size_t __d, size_t __s)
  : _M_off(__o), _M_sz(__d), _M_st(__s) {}

  inline size_t
  slice::start() const
  { return _M_off; }

  inline size_t
  slice::size() const
  { return _M_sz; }

  inline size_t
  slice::stride() const
  { return _M_st; }
#123 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/slice_array.h" 3
  template<typename _Tp>
    class slice_array
    {
    public:
      typedef _Tp value_type;





      slice_array(const slice_array&);



      slice_array& operator=(const slice_array&);


      void operator=(const valarray<_Tp>&) const;

      void operator*=(const valarray<_Tp>&) const;

      void operator/=(const valarray<_Tp>&) const;

      void operator%=(const valarray<_Tp>&) const;

      void operator+=(const valarray<_Tp>&) const;

      void operator-=(const valarray<_Tp>&) const;

      void operator^=(const valarray<_Tp>&) const;

      void operator&=(const valarray<_Tp>&) const;

      void operator|=(const valarray<_Tp>&) const;

      void operator<<=(const valarray<_Tp>&) const;

      void operator>>=(const valarray<_Tp>&) const;

      void operator=(const _Tp &) const;


      template<class _Dom>
        void operator=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator*=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator/=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator%=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator+=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator-=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator^=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator&=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator|=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator<<=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
 void operator>>=(const _Expr<_Dom, _Tp>&) const;

    private:
      friend class valarray<_Tp>;
      slice_array(_Array<_Tp>, const slice&);

      const size_t _M_sz;
      const size_t _M_stride;
      const _Array<_Tp> _M_array;


      slice_array();
    };

  template<typename _Tp>
    inline
    slice_array<_Tp>::slice_array(_Array<_Tp> __a, const slice& __s)
    : _M_sz(__s.size()), _M_stride(__s.stride()),
      _M_array(__a.begin() + __s.start()) {}

  template<typename _Tp>
    inline
    slice_array<_Tp>::slice_array(const slice_array<_Tp>& a)
    : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array) {}




  template<typename _Tp>
    inline slice_array<_Tp>&
    slice_array<_Tp>::operator=(const slice_array<_Tp>& __a)
    {
      std::__valarray_copy(__a._M_array, __a._M_sz, __a._M_stride,
      _M_array, _M_stride);
      return *this;
    }

  template<typename _Tp>
    inline void
    slice_array<_Tp>::operator=(const _Tp& __t) const
    { std::__valarray_fill(_M_array, _M_sz, _M_stride, __t); }

  template<typename _Tp>
    inline void
    slice_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    { std::__valarray_copy(_Array<_Tp>(__v), _M_array, _M_sz, _M_stride); }

  template<typename _Tp>
  template<class _Dom>
    inline void
    slice_array<_Tp>::operator=(const _Expr<_Dom,_Tp>& __e) const
    { std::__valarray_copy(__e, _M_sz, _M_array, _M_stride); }
#257 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/slice_array.h" 3
template<typename _Tp> inline void slice_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator *=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___multiplies(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator /=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___divides(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator %=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___modulus(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator +=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___plus(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator -=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___minus(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator ^=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator &=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator |=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator <<=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_left(_M_array, _M_stride, __e, _M_sz); }
template<typename _Tp> inline void slice_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _M_sz, _M_stride, _Array<_Tp>(__v)); } template<typename _Tp> template<class _Dom> inline void slice_array<_Tp>::operator >>=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_right(_M_array, _M_stride, __e, _M_sz); }






}
#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_before.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#54 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_before.h" 3
  template<typename _Tp1, typename _Tp2> class _Constant;
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_before.h" 3
  struct _Abs
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return abs(__t); }
  };

  struct _Cos
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return cos(__t); }
  };

  struct _Acos
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return acos(__t); }
  };

  struct _Cosh
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return cosh(__t); }
  };

  struct _Sin
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return sin(__t); }
  };

  struct _Asin
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return asin(__t); }
  };

  struct _Sinh
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return sinh(__t); }
  };

  struct _Tan
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return tan(__t); }
  };

  struct _Atan
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return atan(__t); }
  };

  struct _Tanh
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return tanh(__t); }
  };

  struct _Exp
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return exp(__t); }
  };

  struct _Log
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return log(__t); }
  };

  struct _Log10
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return log10(__t); }
  };

  struct _Sqrt
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return sqrt(__t); }
  };





  struct __unary_plus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return +__t; }
  };

  struct __negate
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return -__t; }
  };

  struct __bitwise_not
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __t) const
      { return ~__t; }
  };

  struct __plus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
  };

  struct __minus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
  };

  struct __multiplies
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
  };

  struct __divides
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
  };

  struct __modulus
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
  };

  struct __bitwise_xor
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
  };

  struct __bitwise_and
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
  };

  struct __bitwise_or
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
  };

  struct __shift_left
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x << __y; }
  };

  struct __shift_right
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >> __y; }
  };

  struct __logical_and
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
  };

  struct __logical_or
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
  };

  struct __logical_not
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x) const
      { return !__x; }
  };

  struct __equal_to
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
  };

  struct __not_equal_to
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
  };

  struct __less
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
  };

  struct __greater
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
  };

  struct __less_equal
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
  };

  struct __greater_equal
  {
    template<typename _Tp>
      bool operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
  };


  struct _Atan2
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return atan2(__x, __y); }
  };

  struct _Pow
  {
    template<typename _Tp>
      _Tp operator()(const _Tp& __x, const _Tp& __y) const
      { return pow(__x, __y); }
  };





  template<typename, typename _Tp>
    struct __fun
    {
      typedef _Tp result_type;
    };


  template<typename _Tp>
    struct __fun<__logical_not, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__logical_and, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__logical_or, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__less, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__greater, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__less_equal, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__greater_equal, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__equal_to, _Tp>
    {
      typedef bool result_type;
    };

  template<typename _Tp>
    struct __fun<__not_equal_to, _Tp>
    {
      typedef bool result_type;
    };





  template<typename _Dom, typename _Arg>
    class _FunBase
    {
    public:
      typedef typename _Dom::value_type value_type;

      _FunBase(const _Dom& __e, value_type __f(_Arg))
      : _M_expr(__e), _M_func(__f) {}

      value_type operator[](size_t __i) const
      { return _M_func (_M_expr[__i]); }

      size_t size() const { return _M_expr.size ();}

    private:
      const _Dom& _M_expr;
      value_type (*_M_func)(_Arg);
    };

  template<class _Dom>
    struct _ValFunClos<_Expr,_Dom> : _FunBase<_Dom, typename _Dom::value_type>
    {
      typedef _FunBase<_Dom, typename _Dom::value_type> _Base;
      typedef typename _Base::value_type value_type;
      typedef value_type _Tp;

      _ValFunClos(const _Dom& __e, _Tp __f(_Tp)) : _Base(__e, __f) {}
    };

  template<typename _Tp>
    struct _ValFunClos<_ValArray,_Tp> : _FunBase<valarray<_Tp>, _Tp>
    {
      typedef _FunBase<valarray<_Tp>, _Tp> _Base;
      typedef _Tp value_type;

      _ValFunClos(const valarray<_Tp>& __v, _Tp __f(_Tp)) : _Base(__v, __f) {}
    };

  template<class _Dom>
    struct _RefFunClos<_Expr, _Dom>
    : _FunBase<_Dom, const typename _Dom::value_type&>
    {
      typedef _FunBase<_Dom, const typename _Dom::value_type&> _Base;
      typedef typename _Base::value_type value_type;
      typedef value_type _Tp;

      _RefFunClos(const _Dom& __e, _Tp __f(const _Tp&))
      : _Base(__e, __f) {}
    };

  template<typename _Tp>
    struct _RefFunClos<_ValArray, _Tp>
    : _FunBase<valarray<_Tp>, const _Tp&>
    {
      typedef _FunBase<valarray<_Tp>, const _Tp&> _Base;
      typedef _Tp value_type;

      _RefFunClos(const valarray<_Tp>& __v, _Tp __f(const _Tp&))
      : _Base(__v, __f) {}
    };





  template<class _Oper, class _Arg>
    class _UnBase
    {
    public:
      typedef typename _Arg::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;

      _UnBase(const _Arg& __e) : _M_expr(__e) {}

      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr[__i]); }

      size_t size() const { return _M_expr.size(); }

    private:
      const _Arg& _M_expr;
    };

  template<class _Oper, class _Dom>
    struct _UnClos<_Oper, _Expr, _Dom>
    : _UnBase<_Oper, _Dom>
    {
      typedef _Dom _Arg;
      typedef _UnBase<_Oper, _Dom> _Base;
      typedef typename _Base::value_type value_type;

      _UnClos(const _Arg& __e) : _Base(__e) {}
    };

  template<class _Oper, typename _Tp>
    struct _UnClos<_Oper, _ValArray, _Tp>
    : _UnBase<_Oper, valarray<_Tp> >
    {
      typedef valarray<_Tp> _Arg;
      typedef _UnBase<_Oper, valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;

      _UnClos(const _Arg& __e) : _Base(__e) {}
    };






  template<class _Oper, class _FirstArg, class _SecondArg>
    class _BinBase
    {
    public:
      typedef typename _FirstArg::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;

      _BinBase(const _FirstArg& __e1, const _SecondArg& __e2)
      : _M_expr1(__e1), _M_expr2(__e2) {}

      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr1[__i], _M_expr2[__i]); }

      size_t size() const { return _M_expr1.size(); }

    private:
      const _FirstArg& _M_expr1;
      const _SecondArg& _M_expr2;
    };


  template<class _Oper, class _Clos>
    class _BinBase2
    {
    public:
      typedef typename _Clos::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;

      _BinBase2(const _Clos& __e, const _Vt& __t)
      : _M_expr1(__e), _M_expr2(__t) {}

      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr1[__i], _M_expr2); }

      size_t size() const { return _M_expr1.size(); }

    private:
      const _Clos& _M_expr1;
      const _Vt& _M_expr2;
    };

  template<class _Oper, class _Clos>
    class _BinBase1
    {
    public:
      typedef typename _Clos::value_type _Vt;
      typedef typename __fun<_Oper, _Vt>::result_type value_type;

      _BinBase1(const _Vt& __t, const _Clos& __e)
      : _M_expr1(__t), _M_expr2(__e) {}

      value_type operator[](size_t __i) const
      { return _Oper()(_M_expr1, _M_expr2[__i]); }

      size_t size() const { return _M_expr2.size(); }

    private:
      const _Vt& _M_expr1;
      const _Clos& _M_expr2;
    };

  template<class _Oper, class _Dom1, class _Dom2>
    struct _BinClos<_Oper, _Expr, _Expr, _Dom1, _Dom2>
    : _BinBase<_Oper, _Dom1, _Dom2>
    {
      typedef _BinBase<_Oper, _Dom1, _Dom2> _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const _Dom1& __e1, const _Dom2& __e2) : _Base(__e1, __e2) {}
    };

  template<class _Oper, typename _Tp>
    struct _BinClos<_Oper,_ValArray, _ValArray, _Tp, _Tp>
    : _BinBase<_Oper, valarray<_Tp>, valarray<_Tp> >
    {
      typedef _BinBase<_Oper, valarray<_Tp>, valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const valarray<_Tp>& __v, const valarray<_Tp>& __w)
      : _Base(__v, __w) {}
    };

  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _Expr, _ValArray, _Dom, typename _Dom::value_type>
    : _BinBase<_Oper, _Dom, valarray<typename _Dom::value_type> >
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase<_Oper,_Dom,valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const _Dom& __e1, const valarray<_Tp>& __e2)
      : _Base(__e1, __e2) {}
    };

  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _ValArray, _Expr, typename _Dom::value_type, _Dom>
    : _BinBase<_Oper, valarray<typename _Dom::value_type>,_Dom>
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase<_Oper, valarray<_Tp>, _Dom> _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const valarray<_Tp>& __e1, const _Dom& __e2)
      : _Base(__e1, __e2) {}
    };

  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _Expr, _Constant, _Dom, typename _Dom::value_type>
    : _BinBase2<_Oper, _Dom>
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase2<_Oper,_Dom> _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const _Dom& __e1, const _Tp& __e2) : _Base(__e1, __e2) {}
    };

  template<class _Oper, class _Dom>
    struct _BinClos<_Oper, _Constant, _Expr, typename _Dom::value_type, _Dom>
    : _BinBase1<_Oper, _Dom>
    {
      typedef typename _Dom::value_type _Tp;
      typedef _BinBase1<_Oper, _Dom> _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const _Tp& __e1, const _Dom& __e2) : _Base(__e1, __e2) {}
    };

  template<class _Oper, typename _Tp>
    struct _BinClos<_Oper, _ValArray, _Constant, _Tp, _Tp>
    : _BinBase2<_Oper, valarray<_Tp> >
    {
      typedef _BinBase2<_Oper,valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const valarray<_Tp>& __v, const _Tp& __t) : _Base(__v, __t) {}
    };

  template<class _Oper, typename _Tp>
    struct _BinClos<_Oper, _Constant, _ValArray, _Tp, _Tp>
    : _BinBase1<_Oper, valarray<_Tp> >
    {
      typedef _BinBase1<_Oper, valarray<_Tp> > _Base;
      typedef typename _Base::value_type value_type;

      _BinClos(const _Tp& __t, const valarray<_Tp>& __v) : _Base(__t, __v) {}
    };




  template<typename _Dom>
    class _SBase
    {
    public:
      typedef typename _Dom::value_type value_type;

      _SBase (const _Dom& __e, const slice& __s)
      : _M_expr (__e), _M_slice (__s) {}

      value_type
      operator[] (size_t __i) const
      { return _M_expr[_M_slice.start () + __i * _M_slice.stride ()]; }

      size_t
      size() const
      { return _M_slice.size (); }

    private:
      const _Dom& _M_expr;
      const slice& _M_slice;
    };

  template<typename _Tp>
    class _SBase<_Array<_Tp> >
    {
    public:
      typedef _Tp value_type;

      _SBase (_Array<_Tp> __a, const slice& __s)
      : _M_array (__a._M_data+__s.start()), _M_size (__s.size()),
 _M_stride (__s.stride()) {}

      value_type
      operator[] (size_t __i) const
      { return _M_array._M_data[__i * _M_stride]; }

      size_t
      size() const
      { return _M_size; }

    private:
      const _Array<_Tp> _M_array;
      const size_t _M_size;
      const size_t _M_stride;
    };

  template<class _Dom>
    struct _SClos<_Expr, _Dom>
    : _SBase<_Dom>
    {
      typedef _SBase<_Dom> _Base;
      typedef typename _Base::value_type value_type;

      _SClos (const _Dom& __e, const slice& __s) : _Base (__e, __s) {}
    };

  template<typename _Tp>
    struct _SClos<_ValArray, _Tp>
    : _SBase<_Array<_Tp> >
    {
      typedef _SBase<_Array<_Tp> > _Base;
      typedef _Tp value_type;

      _SClos (_Array<_Tp> __a, const slice& __s) : _Base (__a, __s) {}
    };


}
#91 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#115 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
  template<class _Tp>
    class valarray
    {
      template<class _Op>
 struct _UnaryOp
 {
   typedef typename __fun<_Op, _Tp>::result_type __rt;
   typedef _Expr<_UnClos<_Op, _ValArray, _Tp>, __rt> _Rt;
 };
    public:
      typedef _Tp value_type;



      valarray();


      explicit valarray(size_t);


      valarray(const _Tp&, size_t);


      valarray(const _Tp* __restrict__, size_t);


      valarray(const valarray&);


      valarray(const slice_array<_Tp>&);


      valarray(const gslice_array<_Tp>&);


      valarray(const mask_array<_Tp>&);


      valarray(const indirect_array<_Tp>&);






      template<class _Dom>
 valarray(const _Expr<_Dom, _Tp>& __e);

      ~valarray();
#174 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp>& operator=(const valarray<_Tp>&);
#183 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp>& operator=(const _Tp&);
#193 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp>& operator=(const slice_array<_Tp>&);
#203 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp>& operator=(const gslice_array<_Tp>&);
#213 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp>& operator=(const mask_array<_Tp>&);
#223 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp>& operator=(const indirect_array<_Tp>&);
#237 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      template<class _Dom> valarray<_Tp>&
 operator= (const _Expr<_Dom, _Tp>&);
#247 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      _Tp& operator[](size_t);



      const _Tp& operator[](size_t) const;
#264 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      _Expr<_SClos<_ValArray, _Tp>, _Tp> operator[](slice) const;
#276 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      slice_array<_Tp> operator[](slice);
#287 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      _Expr<_GClos<_ValArray, _Tp>, _Tp> operator[](const gslice&) const;
#299 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      gslice_array<_Tp> operator[](const gslice&);
#313 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp> operator[](const valarray<bool>&) const;
#327 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      mask_array<_Tp> operator[](const valarray<bool>&);
#340 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      _Expr<_IClos<_ValArray, _Tp>, _Tp>
        operator[](const valarray<size_t>&) const;
#355 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      indirect_array<_Tp> operator[](const valarray<size_t>&);



      typename _UnaryOp<__unary_plus>::_Rt operator+() const;


      typename _UnaryOp<__negate>::_Rt operator-() const;


      typename _UnaryOp<__bitwise_not>::_Rt operator~() const;


      typename _UnaryOp<__logical_not>::_Rt operator!() const;



      valarray<_Tp>& operator*=(const _Tp&);


      valarray<_Tp>& operator/=(const _Tp&);


      valarray<_Tp>& operator%=(const _Tp&);


      valarray<_Tp>& operator+=(const _Tp&);


      valarray<_Tp>& operator-=(const _Tp&);


      valarray<_Tp>& operator^=(const _Tp&);


      valarray<_Tp>& operator&=(const _Tp&);


      valarray<_Tp>& operator|=(const _Tp&);


      valarray<_Tp>& operator<<=(const _Tp&);


      valarray<_Tp>& operator>>=(const _Tp&);


      valarray<_Tp>& operator*=(const valarray<_Tp>&);


      valarray<_Tp>& operator/=(const valarray<_Tp>&);


      valarray<_Tp>& operator%=(const valarray<_Tp>&);


      valarray<_Tp>& operator+=(const valarray<_Tp>&);


      valarray<_Tp>& operator-=(const valarray<_Tp>&);


      valarray<_Tp>& operator^=(const valarray<_Tp>&);


      valarray<_Tp>& operator|=(const valarray<_Tp>&);


      valarray<_Tp>& operator&=(const valarray<_Tp>&);


      valarray<_Tp>& operator<<=(const valarray<_Tp>&);


      valarray<_Tp>& operator>>=(const valarray<_Tp>&);

      template<class _Dom>
 valarray<_Tp>& operator*=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator/=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator%=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator+=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator-=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator^=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator|=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator&=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
        valarray<_Tp>& operator<<=(const _Expr<_Dom, _Tp>&);
      template<class _Dom>
 valarray<_Tp>& operator>>=(const _Expr<_Dom, _Tp>&);



      size_t size() const;







      _Tp sum() const;


      _Tp min() const;


      _Tp max() const;
#485 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp> shift (int) const;
#502 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      valarray<_Tp> cshift(int) const;
#514 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      _Expr<_ValFunClos<_ValArray, _Tp>, _Tp> apply(_Tp func(_Tp)) const;
#526 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      _Expr<_RefFunClos<_ValArray, _Tp>, _Tp> apply(_Tp func(const _Tp&)) const;
#537 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
      void resize(size_t __size, _Tp __c = _Tp());

    private:
      size_t _M_size;
      _Tp* __restrict__ _M_data;

      friend class _Array<_Tp>;
    };

  template<typename _Tp>
    inline const _Tp&
    valarray<_Tp>::operator[](size_t __i) const
    {
      ;
      return _M_data[__i];
    }

  template<typename _Tp>
    inline _Tp&
    valarray<_Tp>::operator[](size_t __i)
    {
      ;
      return _M_data[__i];
    }




}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_after.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_after.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_after.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<class _Dom>
    class _GBase
    {
    public:
      typedef typename _Dom::value_type value_type;

      _GBase (const _Dom& __e, const valarray<size_t>& __i)
      : _M_expr (__e), _M_index(__i) {}

      value_type
      operator[] (size_t __i) const
      { return _M_expr[_M_index[__i]]; }

      size_t
      size () const
      { return _M_index.size(); }

    private:
      const _Dom& _M_expr;
      const valarray<size_t>& _M_index;
    };

  template<typename _Tp>
    class _GBase<_Array<_Tp> >
    {
    public:
      typedef _Tp value_type;

      _GBase (_Array<_Tp> __a, const valarray<size_t>& __i)
      : _M_array (__a), _M_index(__i) {}

      value_type
      operator[] (size_t __i) const
      { return _M_array._M_data[_M_index[__i]]; }

      size_t
      size () const
      { return _M_index.size(); }

    private:
      const _Array<_Tp> _M_array;
      const valarray<size_t>& _M_index;
    };

  template<class _Dom>
    struct _GClos<_Expr, _Dom>
    : _GBase<_Dom>
    {
      typedef _GBase<_Dom> _Base;
      typedef typename _Base::value_type value_type;

      _GClos (const _Dom& __e, const valarray<size_t>& __i)
      : _Base (__e, __i) {}
    };

  template<typename _Tp>
    struct _GClos<_ValArray, _Tp>
    : _GBase<_Array<_Tp> >
    {
      typedef _GBase<_Array<_Tp> > _Base;
      typedef typename _Base::value_type value_type;

      _GClos (_Array<_Tp> __a, const valarray<size_t>& __i)
      : _Base (__a, __i) {}
    };




  template<class _Dom>
    class _IBase
    {
    public:
      typedef typename _Dom::value_type value_type;

      _IBase (const _Dom& __e, const valarray<size_t>& __i)
      : _M_expr (__e), _M_index (__i) {}

      value_type
      operator[] (size_t __i) const
      { return _M_expr[_M_index[__i]]; }

      size_t
      size() const
      { return _M_index.size(); }

    private:
      const _Dom& _M_expr;
      const valarray<size_t>& _M_index;
    };

  template<class _Dom>
    struct _IClos<_Expr, _Dom>
    : _IBase<_Dom>
    {
      typedef _IBase<_Dom> _Base;
      typedef typename _Base::value_type value_type;

      _IClos (const _Dom& __e, const valarray<size_t>& __i)
      : _Base (__e, __i) {}
    };

  template<typename _Tp>
    struct _IClos<_ValArray, _Tp>
    : _IBase<valarray<_Tp> >
    {
      typedef _IBase<valarray<_Tp> > _Base;
      typedef _Tp value_type;

      _IClos (const valarray<_Tp>& __a, const valarray<size_t>& __i)
      : _Base (__a, __i) {}
    };




  template<class _Clos, typename _Tp>
    class _Expr
    {
    public:
      typedef _Tp value_type;

      _Expr(const _Clos&);

      const _Clos& operator()() const;

      value_type operator[](size_t) const;
      valarray<value_type> operator[](slice) const;
      valarray<value_type> operator[](const gslice&) const;
      valarray<value_type> operator[](const valarray<bool>&) const;
      valarray<value_type> operator[](const valarray<size_t>&) const;

      _Expr<_UnClos<__unary_plus, std::_Expr, _Clos>, value_type>
      operator+() const;

      _Expr<_UnClos<__negate, std::_Expr, _Clos>, value_type>
      operator-() const;

      _Expr<_UnClos<__bitwise_not, std::_Expr, _Clos>, value_type>
      operator~() const;

      _Expr<_UnClos<__logical_not, std::_Expr, _Clos>, bool>
      operator!() const;

      size_t size() const;
      value_type sum() const;

      valarray<value_type> shift(int) const;
      valarray<value_type> cshift(int) const;

      value_type min() const;
      value_type max() const;

      valarray<value_type> apply(value_type (*)(const value_type&)) const;
      valarray<value_type> apply(value_type (*)(value_type)) const;

    private:
      const _Clos _M_closure;
    };

  template<class _Clos, typename _Tp>
    inline
    _Expr<_Clos, _Tp>::_Expr(const _Clos& __c) : _M_closure(__c) {}

  template<class _Clos, typename _Tp>
    inline const _Clos&
    _Expr<_Clos, _Tp>::operator()() const
    { return _M_closure; }

  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::operator[](size_t __i) const
    { return _M_closure[__i]; }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](slice __s) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__s];
      return __v;
    }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](const gslice& __gs) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__gs];
      return __v;
    }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](const valarray<bool>& __m) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__m];
      return __v;
    }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::operator[](const valarray<size_t>& __i) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this)[__i];
      return __v;
    }

  template<class _Clos, typename _Tp>
    inline size_t
    _Expr<_Clos, _Tp>::size() const
    { return _M_closure.size(); }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::shift(int __n) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).shift(__n);
      return __v;
    }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::cshift(int __n) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).cshift(__n);
      return __v;
    }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::apply(_Tp __f(const _Tp&)) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).apply(__f);
      return __v;
    }

  template<class _Clos, typename _Tp>
    inline valarray<_Tp>
    _Expr<_Clos, _Tp>::apply(_Tp __f(_Tp)) const
    {
      valarray<_Tp> __v = valarray<_Tp>(*this).apply(__f);
      return __v;
    }


  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::sum() const
    {
      size_t __n = _M_closure.size();
      if (__n == 0)
 return _Tp();
      else
 {
   _Tp __s = _M_closure[--__n];
   while (__n != 0)
     __s += _M_closure[--__n];
   return __s;
        }
    }

  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::min() const
    { return __valarray_min(_M_closure); }

  template<class _Clos, typename _Tp>
    inline _Tp
    _Expr<_Clos, _Tp>::max() const
    { return __valarray_max(_M_closure); }

  template<class _Dom, typename _Tp>
    inline _Expr<_UnClos<__logical_not, _Expr, _Dom>, bool>
    _Expr<_Dom, _Tp>::operator!() const
    {
      typedef _UnClos<__logical_not, std::_Expr, _Dom> _Closure;
      return _Expr<_Closure, bool>(_Closure(this->_M_closure));
    }
#332 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_after.h" 3
    template<class _Dom, typename _Tp> inline _Expr<_UnClos<__unary_plus, std::_Expr, _Dom>, _Tp> _Expr<_Dom, _Tp>::operator +() const { typedef _UnClos<__unary_plus, std::_Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(this->_M_closure)); }
    template<class _Dom, typename _Tp> inline _Expr<_UnClos<__negate, std::_Expr, _Dom>, _Tp> _Expr<_Dom, _Tp>::operator -() const { typedef _UnClos<__negate, std::_Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(this->_M_closure)); }
    template<class _Dom, typename _Tp> inline _Expr<_UnClos<__bitwise_not, std::_Expr, _Dom>, _Tp> _Expr<_Dom, _Tp>::operator ~() const { typedef _UnClos<__bitwise_not, std::_Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(this->_M_closure)); }
#403 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_after.h" 3
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__plus, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__plus, typename _Dom1::value_type>::result_type> operator +(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__plus, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__plus, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__plus, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__plus, _Arg>::result_type _Value; typedef _BinClos<__plus, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__plus, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__plus, typename _Dom::value_type>::result_type> operator +(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__plus, _Tp>::result_type _Value; typedef _BinClos<__plus, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__minus, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__minus, typename _Dom1::value_type>::result_type> operator -(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__minus, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__minus, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__minus, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__minus, _Arg>::result_type _Value; typedef _BinClos<__minus, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__minus, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__minus, typename _Dom::value_type>::result_type> operator -(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__minus, _Tp>::result_type _Value; typedef _BinClos<__minus, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__multiplies, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__multiplies, typename _Dom1::value_type>::result_type> operator *(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__multiplies, _Arg>::result_type _Value; typedef _BinClos<__multiplies, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__multiplies, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__multiplies, typename _Dom::value_type>::result_type> operator *(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__multiplies, _Tp>::result_type _Value; typedef _BinClos<__multiplies, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__divides, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__divides, typename _Dom1::value_type>::result_type> operator /(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__divides, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__divides, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__divides, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__divides, _Arg>::result_type _Value; typedef _BinClos<__divides, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__divides, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__divides, typename _Dom::value_type>::result_type> operator /(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__divides, _Tp>::result_type _Value; typedef _BinClos<__divides, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__modulus, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__modulus, typename _Dom1::value_type>::result_type> operator %(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__modulus, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__modulus, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__modulus, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__modulus, _Arg>::result_type _Value; typedef _BinClos<__modulus, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__modulus, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__modulus, typename _Dom::value_type>::result_type> operator %(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__modulus, _Tp>::result_type _Value; typedef _BinClos<__modulus, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__bitwise_xor, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__bitwise_xor, typename _Dom1::value_type>::result_type> operator ^(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_xor, _Arg>::result_type _Value; typedef _BinClos<__bitwise_xor, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_xor, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Value; typedef _BinClos<__bitwise_xor, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__bitwise_and, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__bitwise_and, typename _Dom1::value_type>::result_type> operator &(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_and, _Arg>::result_type _Value; typedef _BinClos<__bitwise_and, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_and, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_and, typename _Dom::value_type>::result_type> operator &(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__bitwise_and, _Tp>::result_type _Value; typedef _BinClos<__bitwise_and, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__bitwise_or, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__bitwise_or, typename _Dom1::value_type>::result_type> operator |(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__bitwise_or, _Arg>::result_type _Value; typedef _BinClos<__bitwise_or, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__bitwise_or, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__bitwise_or, typename _Dom::value_type>::result_type> operator |(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__bitwise_or, _Tp>::result_type _Value; typedef _BinClos<__bitwise_or, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__shift_left, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__shift_left, typename _Dom1::value_type>::result_type> operator <<(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_left, _Arg>::result_type _Value; typedef _BinClos<__shift_left, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__shift_left, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_left, typename _Dom::value_type>::result_type> operator <<(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__shift_left, _Tp>::result_type _Value; typedef _BinClos<__shift_left, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__shift_right, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__shift_right, typename _Dom1::value_type>::result_type> operator >>(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__shift_right, _Arg>::result_type _Value; typedef _BinClos<__shift_right, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__shift_right, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__shift_right, typename _Dom::value_type>::result_type> operator >>(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__shift_right, _Tp>::result_type _Value; typedef _BinClos<__shift_right, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__logical_and, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__logical_and, typename _Dom1::value_type>::result_type> operator &&(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_and, _Arg>::result_type _Value; typedef _BinClos<__logical_and, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__logical_and, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_and, typename _Dom::value_type>::result_type> operator &&(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__logical_and, _Tp>::result_type _Value; typedef _BinClos<__logical_and, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__logical_or, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__logical_or, typename _Dom1::value_type>::result_type> operator ||(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__logical_or, _Arg>::result_type _Value; typedef _BinClos<__logical_or, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__logical_or, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__logical_or, typename _Dom::value_type>::result_type> operator ||(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__logical_or, _Tp>::result_type _Value; typedef _BinClos<__logical_or, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__equal_to, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__equal_to, typename _Dom1::value_type>::result_type> operator ==(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__equal_to, _Arg>::result_type _Value; typedef _BinClos<__equal_to, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__equal_to, typename _Dom::value_type>::result_type> operator ==(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__equal_to, _Tp>::result_type _Value; typedef _BinClos<__equal_to, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__not_equal_to, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__not_equal_to, typename _Dom1::value_type>::result_type> operator !=(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__not_equal_to, _Arg>::result_type _Value; typedef _BinClos<__not_equal_to, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__not_equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__not_equal_to, _Tp>::result_type _Value; typedef _BinClos<__not_equal_to, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__less, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__less, typename _Dom1::value_type>::result_type> operator <(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__less, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__less, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__less, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less, _Arg>::result_type _Value; typedef _BinClos<__less, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__less, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less, typename _Dom::value_type>::result_type> operator <(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__less, _Tp>::result_type _Value; typedef _BinClos<__less, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__greater, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__greater, typename _Dom1::value_type>::result_type> operator >(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__greater, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__greater, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__greater, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater, _Arg>::result_type _Value; typedef _BinClos<__greater, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__greater, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater, typename _Dom::value_type>::result_type> operator >(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__greater, _Tp>::result_type _Value; typedef _BinClos<__greater, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__less_equal, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__less_equal, typename _Dom1::value_type>::result_type> operator <=(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__less_equal, _Arg>::result_type _Value; typedef _BinClos<__less_equal, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__less_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__less_equal, typename _Dom::value_type>::result_type> operator <=(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__less_equal, _Tp>::result_type _Value; typedef _BinClos<__less_equal, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
    template<class _Dom1, class _Dom2> inline _Expr<_BinClos<__greater_equal, _Expr, _Expr, _Dom1, _Dom2>, typename __fun<__greater_equal, typename _Dom1::value_type>::result_type> operator >=(const _Expr<_Dom1, typename _Dom1::value_type>& __v, const _Expr<_Dom2, typename _Dom2::value_type>& __w) { typedef typename _Dom1::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __w())); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const _Expr<_Dom, typename _Dom::value_type>& __v, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Expr, _Constant, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__v(), __t)); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Constant, _Expr, _Arg, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__t, __v())); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const _Expr<_Dom,typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Arg; typedef typename __fun<__greater_equal, _Arg>::result_type _Value; typedef _BinClos<__greater_equal, _Expr, _ValArray, _Dom, _Arg> _Closure; return _Expr<_Closure, _Value>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<__greater_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename __fun<__greater_equal, typename _Dom::value_type>::result_type> operator >=(const valarray<typename _Dom::value_type>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef typename __fun<__greater_equal, _Tp>::result_type _Value; typedef _BinClos<__greater_equal, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Value>(_Closure(__v, __e ())); }
#443 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_after.h" 3
    template<class _Dom> inline _Expr<_UnClos<_Abs, _Expr, _Dom>, typename _Dom::value_type> abs(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Abs, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Abs, _ValArray, _Tp>, _Tp> abs(const valarray<_Tp>& __v) { typedef _UnClos<_Abs, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Cos, _Expr, _Dom>, typename _Dom::value_type> cos(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Cos, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Cos, _ValArray, _Tp>, _Tp> cos(const valarray<_Tp>& __v) { typedef _UnClos<_Cos, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Acos, _Expr, _Dom>, typename _Dom::value_type> acos(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Acos, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Acos, _ValArray, _Tp>, _Tp> acos(const valarray<_Tp>& __v) { typedef _UnClos<_Acos, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Cosh, _Expr, _Dom>, typename _Dom::value_type> cosh(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Cosh, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Cosh, _ValArray, _Tp>, _Tp> cosh(const valarray<_Tp>& __v) { typedef _UnClos<_Cosh, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Sin, _Expr, _Dom>, typename _Dom::value_type> sin(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Sin, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Sin, _ValArray, _Tp>, _Tp> sin(const valarray<_Tp>& __v) { typedef _UnClos<_Sin, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Asin, _Expr, _Dom>, typename _Dom::value_type> asin(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Asin, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Asin, _ValArray, _Tp>, _Tp> asin(const valarray<_Tp>& __v) { typedef _UnClos<_Asin, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Sinh, _Expr, _Dom>, typename _Dom::value_type> sinh(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Sinh, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Sinh, _ValArray, _Tp>, _Tp> sinh(const valarray<_Tp>& __v) { typedef _UnClos<_Sinh, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Tan, _Expr, _Dom>, typename _Dom::value_type> tan(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Tan, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Tan, _ValArray, _Tp>, _Tp> tan(const valarray<_Tp>& __v) { typedef _UnClos<_Tan, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Tanh, _Expr, _Dom>, typename _Dom::value_type> tanh(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Tanh, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Tanh, _ValArray, _Tp>, _Tp> tanh(const valarray<_Tp>& __v) { typedef _UnClos<_Tanh, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Atan, _Expr, _Dom>, typename _Dom::value_type> atan(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Atan, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Atan, _ValArray, _Tp>, _Tp> atan(const valarray<_Tp>& __v) { typedef _UnClos<_Atan, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Exp, _Expr, _Dom>, typename _Dom::value_type> exp(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Exp, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Exp, _ValArray, _Tp>, _Tp> exp(const valarray<_Tp>& __v) { typedef _UnClos<_Exp, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Log, _Expr, _Dom>, typename _Dom::value_type> log(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Log, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Log, _ValArray, _Tp>, _Tp> log(const valarray<_Tp>& __v) { typedef _UnClos<_Log, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Log10, _Expr, _Dom>, typename _Dom::value_type> log10(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Log10, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Log10, _ValArray, _Tp>, _Tp> log10(const valarray<_Tp>& __v) { typedef _UnClos<_Log10, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
    template<class _Dom> inline _Expr<_UnClos<_Sqrt, _Expr, _Dom>, typename _Dom::value_type> sqrt(const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _UnClos<_Sqrt, _Expr, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e())); } template<typename _Tp> inline _Expr<_UnClos<_Sqrt, _ValArray, _Tp>, _Tp> sqrt(const valarray<_Tp>& __v) { typedef _UnClos<_Sqrt, _ValArray, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v)); }
#544 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/valarray_after.h" 3
template<class _Dom1, class _Dom2> inline _Expr<_BinClos<_Atan2, _Expr, _Expr, _Dom1, _Dom2>, typename _Dom1::value_type> atan2(const _Expr<_Dom1, typename _Dom1::value_type>& __e1, const _Expr<_Dom2, typename _Dom2::value_type>& __e2) { typedef typename _Dom1::value_type _Tp; typedef _BinClos<_Atan2, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e1(), __e2())); } template<class _Dom> inline _Expr<_BinClos<_Atan2, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const _Expr<_Dom, typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Atan2, _Expr, _ValArray, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<_Atan2, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const valarray<typename _Dom::valarray>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Atan2, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __e())); } template<class _Dom> inline _Expr<_BinClos<_Atan2, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const _Expr<_Dom, typename _Dom::value_type>& __e, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Atan2, _Expr, _Constant, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __t)); } template<class _Dom> inline _Expr<_BinClos<_Atan2, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Atan2, _Constant, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __e())); } template<typename _Tp> inline _Expr<_BinClos<_Atan2, _ValArray, _ValArray, _Tp, _Tp>, _Tp> atan2(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { typedef _BinClos<_Atan2, _ValArray, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<_Atan2, _ValArray, _Constant, _Tp, _Tp>, _Tp> atan2(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<_Atan2, _ValArray, _Constant, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<_Atan2, _Constant, _ValArray, _Tp, _Tp>, _Tp> atan2(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<_Atan2, _Constant, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }
template<class _Dom1, class _Dom2> inline _Expr<_BinClos<_Pow, _Expr, _Expr, _Dom1, _Dom2>, typename _Dom1::value_type> pow(const _Expr<_Dom1, typename _Dom1::value_type>& __e1, const _Expr<_Dom2, typename _Dom2::value_type>& __e2) { typedef typename _Dom1::value_type _Tp; typedef _BinClos<_Pow, _Expr, _Expr, _Dom1, _Dom2> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e1(), __e2())); } template<class _Dom> inline _Expr<_BinClos<_Pow, _Expr, _ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const _Expr<_Dom, typename _Dom::value_type>& __e, const valarray<typename _Dom::value_type>& __v) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Pow, _Expr, _ValArray, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __v)); } template<class _Dom> inline _Expr<_BinClos<_Pow, _ValArray, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const valarray<typename _Dom::valarray>& __v, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Pow, _ValArray, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __e())); } template<class _Dom> inline _Expr<_BinClos<_Pow, _Expr, _Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const _Expr<_Dom, typename _Dom::value_type>& __e, const typename _Dom::value_type& __t) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Pow, _Expr, _Constant, _Dom, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__e(), __t)); } template<class _Dom> inline _Expr<_BinClos<_Pow, _Constant, _Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const typename _Dom::value_type& __t, const _Expr<_Dom, typename _Dom::value_type>& __e) { typedef typename _Dom::value_type _Tp; typedef _BinClos<_Pow, _Constant, _Expr, _Tp, _Dom> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __e())); } template<typename _Tp> inline _Expr<_BinClos<_Pow, _ValArray, _ValArray, _Tp, _Tp>, _Tp> pow(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { typedef _BinClos<_Pow, _ValArray, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<_Pow, _ValArray, _Constant, _Tp, _Tp>, _Tp> pow(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<_Pow, _ValArray, _Constant, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<_Pow, _Constant, _ValArray, _Tp, _Tp>, _Tp> pow(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<_Pow, _Constant, _ValArray, _Tp, _Tp> _Closure; return _Expr<_Closure, _Tp>(_Closure(__t, __v)); }




}
#568 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#65 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice.h" 3
  class gslice
  {
  public:

    gslice();
#81 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice.h" 3
    gslice(size_t, const valarray<size_t>&, const valarray<size_t>&);





    gslice(const gslice&);


    ~gslice();



    gslice& operator=(const gslice&);


    size_t start() const;


    valarray<size_t> size() const;


    valarray<size_t> stride() const;

  private:
    struct _Indexer
    {
      size_t _M_count;
      size_t _M_start;
      valarray<size_t> _M_size;
      valarray<size_t> _M_stride;
      valarray<size_t> _M_index;

      _Indexer()
      : _M_count(1), _M_start(0), _M_size(), _M_stride(), _M_index() {}

      _Indexer(size_t, const valarray<size_t>&,
        const valarray<size_t>&);

      void
      _M_increment_use()
      { ++_M_count; }

      size_t
      _M_decrement_use()
      { return --_M_count; }
    };

    _Indexer* _M_index;

    template<typename _Tp> friend class valarray;
  };

  inline size_t
  gslice::start() const
  { return _M_index ? _M_index->_M_start : 0; }

  inline valarray<size_t>
  gslice::size() const
  { return _M_index ? _M_index->_M_size : valarray<size_t>(); }

  inline valarray<size_t>
  gslice::stride() const
  { return _M_index ? _M_index->_M_stride : valarray<size_t>(); }



  inline
  gslice::gslice()
  : _M_index(new gslice::_Indexer()) {}

  inline
  gslice::gslice(size_t __o, const valarray<size_t>& __l,
   const valarray<size_t>& __s)
  : _M_index(new gslice::_Indexer(__o, __l, __s)) {}

  inline
  gslice::gslice(const gslice& __g)
  : _M_index(__g._M_index)
  { if (_M_index) _M_index->_M_increment_use(); }

  inline
  gslice::~gslice()
  {
    if (_M_index && _M_index->_M_decrement_use() == 0)
      delete _M_index;
  }

  inline gslice&
  gslice::operator=(const gslice& __g)
  {
    if (__g._M_index)
      __g._M_index->_M_increment_use();
    if (_M_index && _M_index->_M_decrement_use() == 0)
      delete _M_index;
    _M_index = __g._M_index;
    return *this;
  }




}
#570 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice_array.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice_array.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice_array.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice_array.h" 3
  template<typename _Tp>
    class gslice_array
    {
    public:
      typedef _Tp value_type;





      gslice_array(const gslice_array&);



      gslice_array& operator=(const gslice_array&);


      void operator=(const valarray<_Tp>&) const;

      void operator*=(const valarray<_Tp>&) const;

      void operator/=(const valarray<_Tp>&) const;

      void operator%=(const valarray<_Tp>&) const;

      void operator+=(const valarray<_Tp>&) const;

      void operator-=(const valarray<_Tp>&) const;

      void operator^=(const valarray<_Tp>&) const;

      void operator&=(const valarray<_Tp>&) const;

      void operator|=(const valarray<_Tp>&) const;

      void operator<<=(const valarray<_Tp>&) const;

      void operator>>=(const valarray<_Tp>&) const;

      void operator=(const _Tp&) const;

      template<class _Dom>
        void operator=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator*=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator/=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator%=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator+=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator-=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator^=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator&=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator|=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator<<=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
        void operator>>=(const _Expr<_Dom, _Tp>&) const;

    private:
      _Array<_Tp> _M_array;
      const valarray<size_t>& _M_index;

      friend class valarray<_Tp>;

      gslice_array(_Array<_Tp>, const valarray<size_t>&);


      gslice_array();
    };

  template<typename _Tp>
    inline
    gslice_array<_Tp>::gslice_array(_Array<_Tp> __a,
        const valarray<size_t>& __i)
    : _M_array(__a), _M_index(__i) {}

  template<typename _Tp>
    inline
    gslice_array<_Tp>::gslice_array(const gslice_array<_Tp>& __a)
    : _M_array(__a._M_array), _M_index(__a._M_index) {}

  template<typename _Tp>
    inline gslice_array<_Tp>&
    gslice_array<_Tp>::operator=(const gslice_array<_Tp>& __a)
    {
      std::__valarray_copy(_Array<_Tp>(__a._M_array),
      _Array<size_t>(__a._M_index), _M_index.size(),
      _M_array, _Array<size_t>(_M_index));
      return *this;
    }

  template<typename _Tp>
    inline void
    gslice_array<_Tp>::operator=(const _Tp& __t) const
    {
      std::__valarray_fill(_M_array, _Array<size_t>(_M_index),
      _M_index.size(), __t);
    }

  template<typename _Tp>
    inline void
    gslice_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    {
      std::__valarray_copy(_Array<_Tp>(__v), __v.size(),
      _M_array, _Array<size_t>(_M_index));
    }

  template<typename _Tp>
    template<class _Dom>
      inline void
      gslice_array<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e) const
      {
 std::__valarray_copy (__e, _M_index.size(), _M_array,
         _Array<size_t>(_M_index));
      }
#201 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/gslice_array.h" 3
template<typename _Tp> inline void gslice_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator *= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___multiplies(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator /= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___divides(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator %= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___modulus(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator += (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___plus(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator -= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___minus(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator ^= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator &= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator |= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator <<= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_left(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }
template<typename _Tp> inline void gslice_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _Array<size_t>(_M_index), _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void gslice_array<_Tp>::operator >>= (const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_right(_M_array, _Array<size_t>(_M_index), __e, _M_index.size()); }






}
#571 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/mask_array.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/mask_array.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/mask_array.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/mask_array.h" 3
  template <class _Tp>
    class mask_array
    {
    public:
      typedef _Tp value_type;





      mask_array (const mask_array&);



      mask_array& operator=(const mask_array&);

      void operator=(const valarray<_Tp>&) const;

      void operator*=(const valarray<_Tp>&) const;

      void operator/=(const valarray<_Tp>&) const;

      void operator%=(const valarray<_Tp>&) const;

      void operator+=(const valarray<_Tp>&) const;

      void operator-=(const valarray<_Tp>&) const;

      void operator^=(const valarray<_Tp>&) const;

      void operator&=(const valarray<_Tp>&) const;

      void operator|=(const valarray<_Tp>&) const;

      void operator<<=(const valarray<_Tp>&) const;

      void operator>>=(const valarray<_Tp>&) const;

      void operator=(const _Tp&) const;



      template<class _Dom>
        void operator=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator*=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator/=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator%=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator+=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator-=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator^=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator&=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator|=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator<<=(const _Expr<_Dom,_Tp>&) const;
      template<class _Dom>
        void operator>>=(const _Expr<_Dom,_Tp>&) const;

    private:
      mask_array(_Array<_Tp>, size_t, _Array<bool>);
      friend class valarray<_Tp>;

      const size_t _M_sz;
      const _Array<bool> _M_mask;
      const _Array<_Tp> _M_array;


      mask_array();
    };

  template<typename _Tp>
    inline mask_array<_Tp>::mask_array(const mask_array<_Tp>& a)
    : _M_sz(a._M_sz), _M_mask(a._M_mask), _M_array(a._M_array) {}

  template<typename _Tp>
    inline
    mask_array<_Tp>::mask_array(_Array<_Tp> __a, size_t __s, _Array<bool> __m)
    : _M_sz(__s), _M_mask(__m), _M_array(__a) {}

  template<typename _Tp>
    inline mask_array<_Tp>&
    mask_array<_Tp>::operator=(const mask_array<_Tp>& __a)
    {
      std::__valarray_copy(__a._M_array, __a._M_mask,
      _M_sz, _M_array, _M_mask);
      return *this;
    }

  template<typename _Tp>
    inline void
    mask_array<_Tp>::operator=(const _Tp& __t) const
    { std::__valarray_fill(_M_array, _M_sz, _M_mask, __t); }

  template<typename _Tp>
    inline void
    mask_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    { std::__valarray_copy(_Array<_Tp>(__v), __v.size(), _M_array, _M_mask); }

  template<typename _Tp>
    template<class _Ex>
      inline void
      mask_array<_Tp>::operator=(const _Expr<_Ex, _Tp>& __e) const
      { std::__valarray_copy(__e, __e.size(), _M_array, _M_mask); }
#191 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/mask_array.h" 3
template<typename _Tp> inline void mask_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator *=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___multiplies(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator /=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___divides(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator %=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___modulus(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator +=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___plus(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator -=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___minus(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator ^=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator &=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator |=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator <<=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_left(_M_array, _M_mask, __e, __e.size()); }
template<typename _Tp> inline void mask_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _M_mask, _Array<_Tp>(__v), __v.size()); } template<typename _Tp> template<class _Dom> inline void mask_array<_Tp>::operator >>=(const _Expr<_Dom, _Tp>& __e) const { _Array_augmented___shift_right(_M_array, _M_mask, __e, __e.size()); }






}
#572 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/indirect_array.h" 1 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/indirect_array.h" 3

#37 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/indirect_array.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{

#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/indirect_array.h" 3
  template <class _Tp>
    class indirect_array
    {
    public:
      typedef _Tp value_type;





      indirect_array(const indirect_array&);



      indirect_array& operator=(const indirect_array&);


      void operator=(const valarray<_Tp>&) const;

      void operator*=(const valarray<_Tp>&) const;

      void operator/=(const valarray<_Tp>&) const;

      void operator%=(const valarray<_Tp>&) const;

      void operator+=(const valarray<_Tp>&) const;

      void operator-=(const valarray<_Tp>&) const;

      void operator^=(const valarray<_Tp>&) const;

      void operator&=(const valarray<_Tp>&) const;

      void operator|=(const valarray<_Tp>&) const;

      void operator<<=(const valarray<_Tp>&) const;

      void operator>>=(const valarray<_Tp>&) const;

      void operator= (const _Tp&) const;


      template<class _Dom>
      void operator=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator*=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator/=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator%=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator+=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator-=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator^=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator&=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator|=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator<<=(const _Expr<_Dom, _Tp>&) const;
      template<class _Dom>
      void operator>>=(const _Expr<_Dom, _Tp>&) const;

    private:

      indirect_array(_Array<_Tp>, size_t, _Array<size_t>);

      friend class valarray<_Tp>;
      friend class gslice_array<_Tp>;

      const size_t _M_sz;
      const _Array<size_t> _M_index;
      const _Array<_Tp> _M_array;


      indirect_array();
    };

  template<typename _Tp>
    inline
    indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)
    : _M_sz(__a._M_sz), _M_index(__a._M_index), _M_array(__a._M_array) {}

  template<typename _Tp>
    inline
    indirect_array<_Tp>::indirect_array(_Array<_Tp> __a, size_t __s,
     _Array<size_t> __i)
    : _M_sz(__s), _M_index(__i), _M_array(__a) {}

  template<typename _Tp>
    inline indirect_array<_Tp>&
    indirect_array<_Tp>::operator=(const indirect_array<_Tp>& __a)
    {
      std::__valarray_copy(__a._M_array, _M_sz, __a._M_index, _M_array,
      _M_index);
      return *this;
    }

  template<typename _Tp>
    inline void
    indirect_array<_Tp>::operator=(const _Tp& __t) const
    { std::__valarray_fill(_M_array, _M_index, _M_sz, __t); }

  template<typename _Tp>
    inline void
    indirect_array<_Tp>::operator=(const valarray<_Tp>& __v) const
    { std::__valarray_copy(_Array<_Tp>(__v), _M_sz, _M_array, _M_index); }

  template<typename _Tp>
    template<class _Dom>
      inline void
      indirect_array<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e) const
      { std::__valarray_copy(__e, _M_sz, _M_array, _M_index); }
#195 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/indirect_array.h" 3
template<typename _Tp> inline void indirect_array<_Tp>::operator *=(const valarray<_Tp>& __v) const { _Array_augmented___multiplies(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator *=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___multiplies(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator /=(const valarray<_Tp>& __v) const { _Array_augmented___divides(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator /=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___divides(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator %=(const valarray<_Tp>& __v) const { _Array_augmented___modulus(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator %=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___modulus(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator +=(const valarray<_Tp>& __v) const { _Array_augmented___plus(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator +=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___plus(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator -=(const valarray<_Tp>& __v) const { _Array_augmented___minus(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator -=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___minus(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator ^=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_xor(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator ^=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_xor(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator &=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_and(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator &=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_and(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator |=(const valarray<_Tp>& __v) const { _Array_augmented___bitwise_or(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator |=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___bitwise_or(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator <<=(const valarray<_Tp>& __v) const { _Array_augmented___shift_left(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator <<=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_left(_M_array, _M_index, __e, _M_sz); }
template<typename _Tp> inline void indirect_array<_Tp>::operator >>=(const valarray<_Tp>& __v) const { _Array_augmented___shift_right(_M_array, _M_index, _Array<_Tp>(__v), _M_sz); } template<typename _Tp> template<class _Dom> inline void indirect_array<_Tp>::operator >>=(const _Expr<_Dom,_Tp>& __e) const { _Array_augmented___shift_right(_M_array, _M_index, __e, _M_sz); }






}
#573 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline
    valarray<_Tp>::valarray() : _M_size(0), _M_data(0) {}

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
    { std::__valarray_default_construct(_M_data, _M_data + __n); }

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const _Tp& __t, size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
    { std::__valarray_fill_construct(_M_data, _M_data + __n, __t); }

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const _Tp* __restrict__ __p, size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
    {
      ;
      std::__valarray_copy_construct(__p, __p + __n, _M_data);
    }

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const valarray<_Tp>& __v)
    : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))
    { std::__valarray_copy_construct(__v._M_data, __v._M_data + _M_size,
         _M_data); }

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const slice_array<_Tp>& __sa)
    : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))
    {
      std::__valarray_copy_construct
 (__sa._M_array, __sa._M_sz, __sa._M_stride, _Array<_Tp>(_M_data));
    }

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const gslice_array<_Tp>& __ga)
    : _M_size(__ga._M_index.size()),
      _M_data(__valarray_get_storage<_Tp>(_M_size))
    {
      std::__valarray_copy_construct
 (__ga._M_array, _Array<size_t>(__ga._M_index),
  _Array<_Tp>(_M_data), _M_size);
    }

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const mask_array<_Tp>& __ma)
    : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))
    {
      std::__valarray_copy_construct
 (__ma._M_array, __ma._M_mask, _Array<_Tp>(_M_data), _M_size);
    }

  template<typename _Tp>
    inline
    valarray<_Tp>::valarray(const indirect_array<_Tp>& __ia)
    : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))
    {
      std::__valarray_copy_construct
 (__ia._M_array, __ia._M_index, _Array<_Tp>(_M_data), _M_size);
    }
#661 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
  template<typename _Tp> template<class _Dom>
    inline
    valarray<_Tp>::valarray(const _Expr<_Dom, _Tp>& __e)
    : _M_size(__e.size()), _M_data(__valarray_get_storage<_Tp>(_M_size))
    { std::__valarray_copy_construct(__e, _M_size, _Array<_Tp>(_M_data)); }

  template<typename _Tp>
    inline
    valarray<_Tp>::~valarray()
    {
      std::__valarray_destroy_elements(_M_data, _M_data + _M_size);
      std::__valarray_release_memory(_M_data);
    }

  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const valarray<_Tp>& __v)
    {


      if (_M_size == __v._M_size)
 std::__valarray_copy(__v._M_data, _M_size, _M_data);
      else
 {
   if (_M_data)
     {
       std::__valarray_destroy_elements(_M_data, _M_data + _M_size);
       std::__valarray_release_memory(_M_data);
     }
   _M_size = __v._M_size;
   _M_data = __valarray_get_storage<_Tp>(_M_size);
   std::__valarray_copy_construct(__v._M_data, __v._M_data + _M_size,
      _M_data);
 }
      return *this;
    }
#723 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const _Tp& __t)
    {
      std::__valarray_fill(_M_data, _M_size, __t);
      return *this;
    }

  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const slice_array<_Tp>& __sa)
    {
      ;
      std::__valarray_copy(__sa._M_array, __sa._M_sz,
      __sa._M_stride, _Array<_Tp>(_M_data));
      return *this;
    }

  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const gslice_array<_Tp>& __ga)
    {
      ;
      std::__valarray_copy(__ga._M_array, _Array<size_t>(__ga._M_index),
      _Array<_Tp>(_M_data), _M_size);
      return *this;
    }

  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const mask_array<_Tp>& __ma)
    {
      ;
      std::__valarray_copy(__ma._M_array, __ma._M_mask,
      _Array<_Tp>(_M_data), _M_size);
      return *this;
    }

  template<typename _Tp>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const indirect_array<_Tp>& __ia)
    {
      ;
      std::__valarray_copy(__ia._M_array, __ia._M_index,
      _Array<_Tp>(_M_data), _M_size);
      return *this;
    }

  template<typename _Tp> template<class _Dom>
    inline valarray<_Tp>&
    valarray<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e)
    {
      ;
      std::__valarray_copy(__e, _M_size, _Array<_Tp>(_M_data));
      return *this;
    }

  template<typename _Tp>
    inline _Expr<_SClos<_ValArray,_Tp>, _Tp>
    valarray<_Tp>::operator[](slice __s) const
    {
      typedef _SClos<_ValArray,_Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure (_Array<_Tp>(_M_data), __s));
    }

  template<typename _Tp>
    inline slice_array<_Tp>
    valarray<_Tp>::operator[](slice __s)
    { return slice_array<_Tp>(_Array<_Tp>(_M_data), __s); }

  template<typename _Tp>
    inline _Expr<_GClos<_ValArray,_Tp>, _Tp>
    valarray<_Tp>::operator[](const gslice& __gs) const
    {
      typedef _GClos<_ValArray,_Tp> _Closure;
      return _Expr<_Closure, _Tp>
 (_Closure(_Array<_Tp>(_M_data), __gs._M_index->_M_index));
    }

  template<typename _Tp>
    inline gslice_array<_Tp>
    valarray<_Tp>::operator[](const gslice& __gs)
    {
      return gslice_array<_Tp>
 (_Array<_Tp>(_M_data), __gs._M_index->_M_index);
    }

  template<typename _Tp>
    inline valarray<_Tp>
    valarray<_Tp>::operator[](const valarray<bool>& __m) const
    {
      size_t __s = 0;
      size_t __e = __m.size();
      for (size_t __i=0; __i<__e; ++__i)
 if (__m[__i]) ++__s;
      return valarray<_Tp>(mask_array<_Tp>(_Array<_Tp>(_M_data), __s,
        _Array<bool> (__m)));
    }

  template<typename _Tp>
    inline mask_array<_Tp>
    valarray<_Tp>::operator[](const valarray<bool>& __m)
    {
      size_t __s = 0;
      size_t __e = __m.size();
      for (size_t __i=0; __i<__e; ++__i)
 if (__m[__i]) ++__s;
      return mask_array<_Tp>(_Array<_Tp>(_M_data), __s, _Array<bool>(__m));
    }

  template<typename _Tp>
    inline _Expr<_IClos<_ValArray,_Tp>, _Tp>
    valarray<_Tp>::operator[](const valarray<size_t>& __i) const
    {
      typedef _IClos<_ValArray,_Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure(*this, __i));
    }

  template<typename _Tp>
    inline indirect_array<_Tp>
    valarray<_Tp>::operator[](const valarray<size_t>& __i)
    {
      return indirect_array<_Tp>(_Array<_Tp>(_M_data), __i.size(),
     _Array<size_t>(__i));
    }

  template<class _Tp>
    inline size_t
    valarray<_Tp>::size() const
    { return _M_size; }

  template<class _Tp>
    inline _Tp
    valarray<_Tp>::sum() const
    {
      ;
      return std::__valarray_sum(_M_data, _M_data + _M_size);
    }

  template<class _Tp>
     inline valarray<_Tp>
     valarray<_Tp>::shift(int __n) const
     {
       valarray<_Tp> __ret;

       if (_M_size == 0)
  return __ret;

       _Tp* __restrict__ __tmp_M_data =
  std::__valarray_get_storage<_Tp>(_M_size);

       if (__n == 0)
  std::__valarray_copy_construct(_M_data,
     _M_data + _M_size, __tmp_M_data);
       else if (__n > 0)
  {
    if (size_t(__n) > _M_size)
      __n = int(_M_size);

    std::__valarray_copy_construct(_M_data + __n,
       _M_data + _M_size, __tmp_M_data);
    std::__valarray_default_construct(__tmp_M_data + _M_size - __n,
          __tmp_M_data + _M_size);
  }
       else
  {
    if (-size_t(__n) > _M_size)
      __n = -int(_M_size);

    std::__valarray_copy_construct(_M_data, _M_data + _M_size + __n,
       __tmp_M_data - __n);
    std::__valarray_default_construct(__tmp_M_data,
          __tmp_M_data - __n);
  }

       __ret._M_size = _M_size;
       __ret._M_data = __tmp_M_data;
       return __ret;
     }

  template<class _Tp>
     inline valarray<_Tp>
     valarray<_Tp>::cshift(int __n) const
     {
       valarray<_Tp> __ret;

       if (_M_size == 0)
  return __ret;

       _Tp* __restrict__ __tmp_M_data =
  std::__valarray_get_storage<_Tp>(_M_size);

       if (__n == 0)
  std::__valarray_copy_construct(_M_data,
     _M_data + _M_size, __tmp_M_data);
       else if (__n > 0)
  {
    if (size_t(__n) > _M_size)
      __n = int(__n % _M_size);

    std::__valarray_copy_construct(_M_data, _M_data + __n,
       __tmp_M_data + _M_size - __n);
    std::__valarray_copy_construct(_M_data + __n, _M_data + _M_size,
       __tmp_M_data);
  }
       else
  {
    if (-size_t(__n) > _M_size)
      __n = -int(-size_t(__n) % _M_size);

    std::__valarray_copy_construct(_M_data + _M_size + __n,
       _M_data + _M_size, __tmp_M_data);
    std::__valarray_copy_construct(_M_data, _M_data + _M_size + __n,
       __tmp_M_data - __n);
  }

       __ret._M_size = _M_size;
       __ret._M_data = __tmp_M_data;
       return __ret;
     }

  template<class _Tp>
    inline void
    valarray<_Tp>::resize(size_t __n, _Tp __c)
    {



      std::__valarray_destroy_elements(_M_data, _M_data + _M_size);
      if (_M_size != __n)
 {
   std::__valarray_release_memory(_M_data);
   _M_size = __n;
   _M_data = __valarray_get_storage<_Tp>(__n);
 }
      std::__valarray_fill_construct(_M_data, _M_data + __n, __c);
    }

  template<typename _Tp>
    inline _Tp
    valarray<_Tp>::min() const
    {
      ;
      return *std::min_element(_M_data, _M_data + _M_size);
    }

  template<typename _Tp>
    inline _Tp
    valarray<_Tp>::max() const
    {
      ;
      return *std::max_element(_M_data, _M_data + _M_size);
    }

  template<class _Tp>
    inline _Expr<_ValFunClos<_ValArray, _Tp>, _Tp>
    valarray<_Tp>::apply(_Tp func(_Tp)) const
    {
      typedef _ValFunClos<_ValArray, _Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure(*this, func));
    }

  template<class _Tp>
    inline _Expr<_RefFunClos<_ValArray, _Tp>, _Tp>
    valarray<_Tp>::apply(_Tp func(const _Tp &)) const
    {
      typedef _RefFunClos<_ValArray, _Tp> _Closure;
      return _Expr<_Closure, _Tp>(_Closure(*this, func));
    }
#1003 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__unary_plus>::_Rt valarray<_Tp>::operator +() const { typedef _UnClos<__unary_plus, _ValArray, _Tp> _Closure; typedef typename __fun<__unary_plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__negate>::_Rt valarray<_Tp>::operator -() const { typedef _UnClos<__negate, _ValArray, _Tp> _Closure; typedef typename __fun<__negate, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__bitwise_not>::_Rt valarray<_Tp>::operator ~() const { typedef _UnClos<__bitwise_not, _ValArray, _Tp> _Closure; typedef typename __fun<__bitwise_not, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
    template<typename _Tp> inline typename valarray<_Tp>::template _UnaryOp<__logical_not>::_Rt valarray<_Tp>::operator !() const { typedef _UnClos<__logical_not, _ValArray, _Tp> _Closure; typedef typename __fun<__logical_not, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(*this)); }
#1029 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator +=(const _Tp &__t) { _Array_augmented___plus(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator +=(const valarray<_Tp> &__v) { ; _Array_augmented___plus(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator -=(const _Tp &__t) { _Array_augmented___minus(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator -=(const valarray<_Tp> &__v) { ; _Array_augmented___minus(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator *=(const _Tp &__t) { _Array_augmented___multiplies(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator *=(const valarray<_Tp> &__v) { ; _Array_augmented___multiplies(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator /=(const _Tp &__t) { _Array_augmented___divides(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator /=(const valarray<_Tp> &__v) { ; _Array_augmented___divides(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator %=(const _Tp &__t) { _Array_augmented___modulus(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator %=(const valarray<_Tp> &__v) { ; _Array_augmented___modulus(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator ^=(const _Tp &__t) { _Array_augmented___bitwise_xor(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator ^=(const valarray<_Tp> &__v) { ; _Array_augmented___bitwise_xor(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator &=(const _Tp &__t) { _Array_augmented___bitwise_and(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator &=(const valarray<_Tp> &__v) { ; _Array_augmented___bitwise_and(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator |=(const _Tp &__t) { _Array_augmented___bitwise_or(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator |=(const valarray<_Tp> &__v) { ; _Array_augmented___bitwise_or(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator <<=(const _Tp &__t) { _Array_augmented___shift_left(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator <<=(const valarray<_Tp> &__v) { ; _Array_augmented___shift_left(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator >>=(const _Tp &__t) { _Array_augmented___shift_right(_Array<_Tp>(_M_data), _M_size, __t); return *this; } template<class _Tp> inline valarray<_Tp>& valarray<_Tp>::operator >>=(const valarray<_Tp> &__v) { ; _Array_augmented___shift_right(_Array<_Tp>(_M_data), _M_size, _Array<_Tp>(__v._M_data)); return *this; }
#1051 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator +=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___plus(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator -=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___minus(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator *=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___multiplies(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator /=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___divides(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator %=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___modulus(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator ^=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___bitwise_xor(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator &=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___bitwise_and(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator |=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___bitwise_or(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator <<=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___shift_left(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
template<class _Tp> template<class _Dom> inline valarray<_Tp>& valarray<_Tp>::operator >>=(const _Expr<_Dom, _Tp>& __e) { _Array_augmented___shift_right(_Array<_Tp>(_M_data), __e, _M_size); return *this; }
#1097 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3
template<typename _Tp> inline _Expr<_BinClos<__plus, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__plus, _Tp>::result_type> operator +(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__plus, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__plus, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__plus, _Tp>::result_type> operator +(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__plus, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__plus, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__plus, _Tp>::result_type> operator +(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__plus, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__plus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__minus, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__minus, _Tp>::result_type> operator -(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__minus, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__minus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__minus, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__minus, _Tp>::result_type> operator -(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__minus, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__minus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__minus, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__minus, _Tp>::result_type> operator -(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__minus, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__minus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__multiplies, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__multiplies, _Tp>::result_type> operator *(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__multiplies, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__multiplies, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__multiplies, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__multiplies, _Tp>::result_type> operator *(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__multiplies, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__multiplies, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__multiplies, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__multiplies, _Tp>::result_type> operator *(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__multiplies, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__multiplies, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__divides, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__divides, _Tp>::result_type> operator /(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__divides, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__divides, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__divides, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__divides, _Tp>::result_type> operator /(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__divides, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__divides, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__divides, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__divides, _Tp>::result_type> operator /(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__divides, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__divides, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__modulus, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__modulus, _Tp>::result_type> operator %(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__modulus, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__modulus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__modulus, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__modulus, _Tp>::result_type> operator %(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__modulus, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__modulus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__modulus, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__modulus, _Tp>::result_type> operator %(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__modulus, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__modulus, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__bitwise_xor, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_xor, _Tp>::result_type> operator ^(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__bitwise_xor, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_xor, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__bitwise_xor, _Tp>::result_type> operator ^(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__bitwise_xor, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_xor, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_xor, _Tp>::result_type> operator ^(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__bitwise_xor, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_xor, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__bitwise_and, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_and, _Tp>::result_type> operator &(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__bitwise_and, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_and, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__bitwise_and, _Tp>::result_type> operator &(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__bitwise_and, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_and, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_and, _Tp>::result_type> operator &(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__bitwise_and, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__bitwise_or, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_or, _Tp>::result_type> operator |(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__bitwise_or, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_or, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__bitwise_or, _Tp>::result_type> operator |(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__bitwise_or, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__bitwise_or, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__bitwise_or, _Tp>::result_type> operator |(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__bitwise_or, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__bitwise_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__shift_left, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__shift_left, _Tp>::result_type> operator <<(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__shift_left, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_left, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__shift_left, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__shift_left, _Tp>::result_type> operator <<(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__shift_left, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__shift_left, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__shift_left, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__shift_left, _Tp>::result_type> operator <<(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__shift_left, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_left, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__shift_right, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__shift_right, _Tp>::result_type> operator >>(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__shift_right, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_right, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__shift_right, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__shift_right, _Tp>::result_type> operator >>(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__shift_right, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__shift_right, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__shift_right, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__shift_right, _Tp>::result_type> operator >>(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__shift_right, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__shift_right, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__logical_and, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__logical_and, _Tp>::result_type> operator &&(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__logical_and, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__logical_and, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__logical_and, _Tp>::result_type> operator &&(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__logical_and, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__logical_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__logical_and, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__logical_and, _Tp>::result_type> operator &&(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__logical_and, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_and, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__logical_or, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__logical_or, _Tp>::result_type> operator ||(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__logical_or, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__logical_or, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__logical_or, _Tp>::result_type> operator ||(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__logical_or, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__logical_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__logical_or, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__logical_or, _Tp>::result_type> operator ||(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__logical_or, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__logical_or, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__equal_to, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__equal_to, _Tp>::result_type> operator ==(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__equal_to, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__equal_to, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__equal_to, _Tp>::result_type> operator ==(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__equal_to, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__equal_to, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__equal_to, _Tp>::result_type> operator ==(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__equal_to, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__not_equal_to, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__not_equal_to, _Tp>::result_type> operator !=(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__not_equal_to, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__not_equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__not_equal_to, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__not_equal_to, _Tp>::result_type> operator !=(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__not_equal_to, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__not_equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__not_equal_to, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__not_equal_to, _Tp>::result_type> operator !=(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__not_equal_to, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__not_equal_to, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__less, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__less, _Tp>::result_type> operator <(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__less, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__less, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__less, _Tp>::result_type> operator <(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__less, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__less, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__less, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__less, _Tp>::result_type> operator <(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__less, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__greater, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__greater, _Tp>::result_type> operator >(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__greater, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__greater, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__greater, _Tp>::result_type> operator >(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__greater, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__greater, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__greater, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__greater, _Tp>::result_type> operator >(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__greater, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__less_equal, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__less_equal, _Tp>::result_type> operator <=(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__less_equal, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__less_equal, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__less_equal, _Tp>::result_type> operator <=(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__less_equal, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__less_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__less_equal, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__less_equal, _Tp>::result_type> operator <=(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__less_equal, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__less_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
template<typename _Tp> inline _Expr<_BinClos<__greater_equal, _ValArray, _ValArray, _Tp, _Tp>, typename __fun<__greater_equal, _Tp>::result_type> operator >=(const valarray<_Tp>& __v, const valarray<_Tp>& __w) { ; typedef _BinClos<__greater_equal, _ValArray, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __w)); } template<typename _Tp> inline _Expr<_BinClos<__greater_equal, _ValArray,_Constant, _Tp, _Tp>, typename __fun<__greater_equal, _Tp>::result_type> operator >=(const valarray<_Tp>& __v, const _Tp& __t) { typedef _BinClos<__greater_equal, _ValArray, _Constant, _Tp, _Tp> _Closure; typedef typename __fun<__greater_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__v, __t)); } template<typename _Tp> inline _Expr<_BinClos<__greater_equal, _Constant, _ValArray, _Tp, _Tp>, typename __fun<__greater_equal, _Tp>::result_type> operator >=(const _Tp& __t, const valarray<_Tp>& __v) { typedef _BinClos<__greater_equal, _Constant, _ValArray, _Tp, _Tp> _Closure; typedef typename __fun<__greater_equal, _Tp>::result_type _Rt; return _Expr<_Closure, _Rt>(_Closure(__t, __v)); }
#1162 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/valarray" 3

}
#77 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp" 2

namespace cv
{

enum RETINA_COLORSAMPLINGMETHOD
{
    RETINA_COLOR_RANDOM,
    RETINA_COLOR_DIAGONAL,
    RETINA_COLOR_BAYER
};

class RetinaFilter;
#113 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
class Retina {

public:


    struct RetinaParameters{
        struct OPLandIplParvoParameters{
               OPLandIplParvoParameters():colorMode(true),
                                 normaliseOutput(true),
                                 photoreceptorsLocalAdaptationSensitivity(0.7f),
                                 photoreceptorsTemporalConstant(0.5f),
                                 photoreceptorsSpatialConstant(0.53f),
                                 horizontalCellsGain(0.0f),
                                 hcellsTemporalConstant(1.f),
                                 hcellsSpatialConstant(7.f),
                                 ganglionCellsSensitivity(0.7f){};
               bool colorMode, normaliseOutput;
               float photoreceptorsLocalAdaptationSensitivity, photoreceptorsTemporalConstant, photoreceptorsSpatialConstant, horizontalCellsGain, hcellsTemporalConstant, hcellsSpatialConstant, ganglionCellsSensitivity;
           };
           struct IplMagnoParameters{
               IplMagnoParameters():
                          normaliseOutput(true),
                          parasolCells_beta(0.f),
                          parasolCells_tau(0.f),
                          parasolCells_k(7.f),
                          amacrinCellsTemporalCutFrequency(1.2f),
                          V0CompressionParameter(0.95f),
                          localAdaptintegration_tau(0.f),
                          localAdaptintegration_k(7.f){};
               bool normaliseOutput;
               float parasolCells_beta, parasolCells_tau, parasolCells_k, amacrinCellsTemporalCutFrequency, V0CompressionParameter, localAdaptintegration_tau, localAdaptintegration_k;
           };
            struct OPLandIplParvoParameters OPLandIplParvo;
            struct IplMagnoParameters IplMagno;
    };





    Retina(Size inputSize);
#164 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
    Retina(Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0);

    virtual ~Retina();




    Size inputSize();




    Size outputSize();
#185 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
    void setup(std::string retinaParameterFile="", const bool applyDefaultSetupOnFailure=true);
#195 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
    void setup(cv::FileStorage &fs, const bool applyDefaultSetupOnFailure=true);
#204 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
    void setup(RetinaParameters newParameters);




    Retina::RetinaParameters getParameters();





    const std::string printSetup();





    virtual void write( std::string fs ) const;






    virtual void write( FileStorage& fs ) const;
#245 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
    void setupOPLandIPLParvoChannel(const bool colorMode=true, const bool normaliseOutput = true, const float photoreceptorsLocalAdaptationSensitivity=0.7, const float photoreceptorsTemporalConstant=0.5, const float photoreceptorsSpatialConstant=0.53, const float horizontalCellsGain=0, const float HcellsTemporalConstant=1, const float HcellsSpatialConstant=7, const float ganglionCellsSensitivity=0.7);
#259 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
    void setupIPLMagnoChannel(const bool normaliseOutput = true, const float parasolCells_beta=0, const float parasolCells_tau=0, const float parasolCells_k=7, const float amacrinCellsTemporalCutFrequency=1.2, const float V0CompressionParameter=0.95, const float localAdaptintegration_tau=0, const float localAdaptintegration_k=7);





    void run(const Mat &inputImage);





    void getParvo(Mat &retinaOutput_parvo);





    void getParvo(std::valarray<float> &retinaOutput_parvo);





    void getMagno(Mat &retinaOutput_magno);





    void getMagno(std::valarray<float> &retinaOutput_magno);


    const std::valarray<float> & getMagno() const;
    const std::valarray<float> & getParvo() const;







    void setColorSaturation(const bool saturateColors=true, const float colorSaturationValue=4.0);




    void clearBuffers();





    void activateMovingContoursProcessing(const bool activate);





    void activateContoursProcessing(const bool activate);

protected:

    RetinaParameters _retinaParameters;


    std::valarray<float> _inputBuffer;


    RetinaFilter* _retinaFilter;
#338 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/retina.hpp"
    void _convertValarrayBuffer2cvMat(const std::valarray<float> &grayMatrixToConvert, const unsigned int nbRows, const unsigned int nbColumns, const bool colorMode, Mat &outBuffer);







        bool _convertCvMat2ValarrayBuffer(const cv::Mat inputMatToConvert, std::valarray<float> &outputValarrayMatrix);


    void _init(const Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0);


};

}
#980 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp" 2

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/openfabmap.hpp" 1
#61 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/openfabmap.hpp"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/set" 1 3
#58 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/set" 3

#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/set" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 1 3
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#87 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
#160 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
#176 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
 { _M_t._M_insert_unique(__first, __last); }
#190 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
#228 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
#276 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
#363 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
#388 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      void
      swap(set& __x)
      { _M_t.swap(__x._M_t); }
#406 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
#443 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
#462 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
#510 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#526 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
#560 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#571 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      void
      clear()
      { _M_t.clear(); }
#585 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
#603 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
#624 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
#640 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
#665 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
#694 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
#711 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
#62 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/set" 2 3
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 1 3
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#84 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
#153 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
#169 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
#183 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
#221 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
#269 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
#356 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
#381 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      { _M_t.swap(__x._M_t); }
#397 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
#427 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
#445 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
#493 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#509 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
#545 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#556 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      clear()
      { _M_t.clear(); }
#567 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
#585 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
#606 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
#622 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
#647 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
#677 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
#694 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
#63 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/set" 2 3
#62 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/openfabmap.hpp" 2


namespace cv {

namespace of2 {

using std::list;
using std::map;
using std::multiset;




struct IMatch {

    IMatch() :
        queryIdx(-1), imgIdx(-1), likelihood(-double(1.79769313486231570815e+308L)), match(-double(1.79769313486231570815e+308L)) {
    }
    IMatch(int _queryIdx, int _imgIdx, double _likelihood, double _match) :
        queryIdx(_queryIdx), imgIdx(_imgIdx), likelihood(_likelihood), match(
                _match) {
    }

    int queryIdx;
    int imgIdx;

    double likelihood;
    double match;

    bool operator<(const IMatch& m) const {
        return match < m.match;
    }

};




class FabMap {
public:


    enum {
        MEAN_FIELD = 1,
        SAMPLED = 2,
        NAIVE_BAYES = 4,
        CHOW_LIU = 8,
        MOTION_MODEL = 16
    };

    FabMap(const Mat& clTree, double PzGe, double PzGNe, int flags,
            int numSamples = 0);
    virtual ~FabMap();


    virtual void addTraining(const Mat& queryImgDescriptor);
    virtual void addTraining(const vector<Mat>& queryImgDescriptors);


    virtual void add(const Mat& queryImgDescriptor);
    virtual void add(const vector<Mat>& queryImgDescriptors);


    const vector<Mat>& getTrainingImgDescriptors() const;
    const vector<Mat>& getTestImgDescriptors() const;


    void compare(const Mat& queryImgDescriptor,
            vector<IMatch>& matches, bool addQuery = false,
            const Mat& mask = Mat());
    void compare(const Mat& queryImgDescriptor,
            const Mat& testImgDescriptors, vector<IMatch>& matches,
            const Mat& mask = Mat());
    void compare(const Mat& queryImgDescriptor,
            const vector<Mat>& testImgDescriptors,
            vector<IMatch>& matches, const Mat& mask = Mat());
    void compare(const vector<Mat>& queryImgDescriptors, vector<
            IMatch>& matches, bool addQuery = false, const Mat& mask =
            Mat());
    void compare(const vector<Mat>& queryImgDescriptors,
            const vector<Mat>& testImgDescriptors,
            vector<IMatch>& matches, const Mat& mask = Mat());

protected:

    void compareImgDescriptor(const Mat& queryImgDescriptor,
            int queryIndex, const vector<Mat>& testImgDescriptors,
            vector<IMatch>& matches);

    void addImgDescriptor(const Mat& queryImgDescriptor);



    virtual void getLikelihoods(const Mat& queryImgDescriptor,
            const vector<Mat>& testImgDescriptors,
            vector<IMatch>& matches);
    virtual double getNewPlaceLikelihood(const Mat& queryImgDescriptor);


    void normaliseDistribution(vector<IMatch>& matches);


    int pq(int q);
    double Pzq(int q, bool zq);
    double PzqGzpq(int q, bool zq, bool zpq);


    double PzqGeq(bool zq, bool eq);
    double PeqGL(int q, bool Lzq, bool eq);
    double PzqGL(int q, bool zq, bool zpq, bool Lzq);
    double PzqGzpqL(int q, bool zq, bool zpq, bool Lzq);
    double (FabMap::*PzGL)(int q, bool zq, bool zpq, bool Lzq);


    Mat clTree;
    vector<Mat> trainingImgDescriptors;
    vector<Mat> testImgDescriptors;
    vector<IMatch> priorMatches;


    double PzGe;
    double PzGNe;
    double Pnew;

    double mBias;
    double sFactor;

    int flags;
    int numSamples;

};





class FabMap1: public FabMap {
public:
    FabMap1(const Mat& clTree, double PzGe, double PzGNe, int flags,
            int numSamples = 0);
    virtual ~FabMap1();
protected:


    void getLikelihoods(const Mat& queryImgDescriptor, const vector<
            Mat>& testImgDescriptors, vector<IMatch>& matches);
};





class FabMapLUT: public FabMap {
public:
    FabMapLUT(const Mat& clTree, double PzGe, double PzGNe,
            int flags, int numSamples = 0, int precision = 6);
    virtual ~FabMapLUT();
protected:


    void getLikelihoods(const Mat& queryImgDescriptor, const vector<
            Mat>& testImgDescriptors, vector<IMatch>& matches);


    int (*table)[8];


    int precision;
};





class FabMapFBO: public FabMap {
public:
    FabMapFBO(const Mat& clTree, double PzGe, double PzGNe, int flags,
            int numSamples = 0, double rejectionThreshold = 1e-8, double PsGd =
                    1e-8, int bisectionStart = 512, int bisectionIts = 9);
    virtual ~FabMapFBO();

protected:


    void getLikelihoods(const Mat& queryImgDescriptor, const vector<
            Mat>& testImgDescriptors, vector<IMatch>& matches);


    struct WordStats {
        WordStats() :
            q(0), info(0), V(0), M(0) {
        }

        WordStats(int _q, double _info) :
            q(_q), info(_info), V(0), M(0) {
        }

        int q;
        double info;
        mutable double V;
        mutable double M;

        bool operator<(const WordStats& w) const {
            return info < w.info;
        }

    };


    void setWordStatistics(const Mat& queryImgDescriptor, multiset<WordStats>& wordData);
    double limitbisection(double v, double m);
    double bennettInequality(double v, double m, double delta);
    static bool compInfo(const WordStats& first, const WordStats& second);


    double PsGd;
    double rejectionThreshold;
    int bisectionStart;
    int bisectionIts;
};





class FabMap2: public FabMap {
public:

    FabMap2(const Mat& clTree, double PzGe, double PzGNe, int flags);
    virtual ~FabMap2();



    void addTraining(const Mat& queryImgDescriptors) {
        FabMap::addTraining(queryImgDescriptors);
    }
    void addTraining(const vector<Mat>& queryImgDescriptors);

    void add(const Mat& queryImgDescriptors) {
        FabMap::add(queryImgDescriptors);
    }
    void add(const vector<Mat>& queryImgDescriptors);

protected:


    void getLikelihoods(const Mat& queryImgDescriptor, const vector<
            Mat>& testImgDescriptors, vector<IMatch>& matches);
    double getNewPlaceLikelihood(const Mat& queryImgDescriptor);


    void getIndexLikelihoods(const Mat& queryImgDescriptor, vector<
                             double>& defaults, map<int, vector<int> >& invertedMap,
            vector<IMatch>& matches);
    void addToIndex(const Mat& queryImgDescriptor,
            vector<double>& defaults,
            map<int, vector<int> >& invertedMap);


    vector<double> d1, d2, d3, d4;
    vector<vector<int> > children;



    vector<double> trainingDefaults;
    map<int, vector<int> > trainingInvertedMap;

    vector<double> testDefaults;
    map<int, vector<int> > testInvertedMap;

};





class ChowLiuTree {
public:
    ChowLiuTree();
    virtual ~ChowLiuTree();


    void add(const Mat& imgDescriptor);
    void add(const vector<Mat>& imgDescriptors);

    const vector<Mat>& getImgDescriptors() const;

    Mat make(double infoThreshold = 0.0);

private:
    vector<Mat> imgDescriptors;
    Mat mergedImgDescriptors;

    typedef struct info {
        float score;
        short word1;
        short word2;
    } info;


    double P(int a, bool za);
    double JP(int a, bool za, int b, bool zb);
    double CP(int a, bool za, int b, bool zb);


    void createBaseEdges(list<info>& edges, double infoThreshold);
    double calcMutInfo(int word1, int word2);
    static bool sortInfoScores(const info& first, const info& second);


    bool reduceEdgesToMinSpan(list<info>& edges);


    Mat buildTree(int root_word, list<info> &edges);
    void recAddToTree(Mat &cltree, int q, int pq,
        list<info> &remaining_edges);
    vector<int> extractChildren(list<info> &remaining_edges, int q);

};





class BOWMSCTrainer: public BOWTrainer {
public:
    BOWMSCTrainer(double clusterSize = 0.4);
    virtual ~BOWMSCTrainer();


    virtual Mat cluster() const;
    virtual Mat cluster(const Mat& descriptors) const;

protected:

    double clusterSize;

};

}

}
#982 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/contrib/contrib.hpp" 2
#60 "/opt/Xilinx/Vivado_HLS/2017.1/include/opencv2/opencv.hpp" 2
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h" 2


#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 1
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_axi_sdata.h" 1
#86 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_axi_sdata.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_int.h" 1
#74 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_int.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h" 1
#32 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
#33 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h" 2
using std::fpclassify;
using std::isfinite;




using std::isinf;
using std::isnan;

using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;







#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h" 1
#59 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h"
#1 "/usr/include/assert.h" 1 3 4
#60 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h" 2
#165 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h"
#1 "/usr/include/stdio.h" 1 3 4
#29 "/usr/include/stdio.h" 3 4
extern "C" {



#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#34 "/usr/include/stdio.h" 2 3 4
#74 "/usr/include/stdio.h" 3 4
#1 "/usr/include/libio.h" 1 3 4
#31 "/usr/include/libio.h" 3 4
#1 "/usr/include/_G_config.h" 1 3 4
#15 "/usr/include/_G_config.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#16 "/usr/include/_G_config.h" 2 3 4





typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
#32 "/usr/include/libio.h" 2 3 4
#49 "/usr/include/libio.h" 3 4
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stdarg.h" 1 3 4
#50 "/usr/include/libio.h" 2 3 4
#144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
#173 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
#241 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
#289 "/usr/include/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
#333 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
#429 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
#459 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
#521 "/usr/include/libio.h" 3 4
}
#75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
#108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
#164 "/usr/include/stdio.h" 3 4
#1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
#165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) ;
#205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
#227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

#252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
#262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
#295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
#463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
#522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

#550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
#561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

#594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
#638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


#649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
#665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

#726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
#737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

#773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
#792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
#815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






#1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
#26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
#854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
#872 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
#942 "/usr/include/stdio.h" 3 4
}
#166 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h" 2






#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/floating_point_v7_0_bitacc_cmodel.h" 1
#115 "/opt/Xilinx/Vivado_HLS/2017.1/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int8_t xint8;
typedef int16_t xint16;
typedef int32_t xint32;
typedef int64_t xint64;
typedef uint8_t xuint8;
typedef uint16_t xuint16;
typedef uint32_t xuint32;
typedef uint64_t xuint64;


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stdbool.h" 1 3 4
#126 "/opt/Xilinx/Vivado_HLS/2017.1/include/floating_point_v7_0_bitacc_cmodel.h" 2
#143 "/opt/Xilinx/Vivado_HLS/2017.1/include/floating_point_v7_0_bitacc_cmodel.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h" 1
#27 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
#92 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
#148 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
namespace __gnu_cxx
{
#166 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
#28 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h" 2
#53 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 3


#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstddef" 2 3
#54 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h" 2
#201 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
typedef unsigned long int mp_limb_t;
typedef long int mp_limb_signed_t;






typedef unsigned long int mp_bitcnt_t;





typedef struct
{
  int _mp_alloc;

  int _mp_size;


  mp_limb_t *_mp_d;
} __mpz_struct;



typedef __mpz_struct mpz_t[1];

typedef mp_limb_t * mp_ptr;
typedef const mp_limb_t * mp_srcptr;






typedef long int mp_size_t;
typedef long int mp_exp_t;


typedef struct
{
  __mpz_struct _mp_num;
  __mpz_struct _mp_den;
} __mpq_struct;

typedef __mpq_struct mpq_t[1];

typedef struct
{
  int _mp_prec;



  int _mp_size;


  mp_exp_t _mp_exp;
  mp_limb_t *_mp_d;
} __mpf_struct;

typedef __mpf_struct mpf_t[1];


typedef enum
{
  GMP_RAND_ALG_DEFAULT = 0,
  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
} gmp_randalg_t;


typedef struct
{
  mpz_t _mp_seed;
  gmp_randalg_t _mp_alg;
  union {
    void *_mp_lc;
  } _mp_algdata;
} __gmp_randstate_struct;
typedef __gmp_randstate_struct gmp_randstate_t[1];



typedef const __mpz_struct *mpz_srcptr;
typedef __mpz_struct *mpz_ptr;
typedef const __mpf_struct *mpf_srcptr;
typedef __mpf_struct *mpf_ptr;
typedef const __mpq_struct *mpq_srcptr;
typedef __mpq_struct *mpq_ptr;
#532 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
extern "C" {
using std::FILE;



 void __gmp_set_memory_functions (void *(*) (size_t), void *(*) (void *, size_t, size_t), void (*) (void *, size_t))

                                      throw ();


 void __gmp_get_memory_functions (void *(**) (size_t), void *(**) (void *, size_t, size_t), void (**) (void *, size_t))

                                                                   throw ();


 extern const int __gmp_bits_per_limb;


 extern int __gmp_errno;


 extern const char * const __gmp_version;


 extern const char * const __mpir_version;





 void __gmp_randinit_default (gmp_randstate_t);


 void __gmp_randinit_lc_2exp (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t)

                          ;


 int __gmp_randinit_lc_2exp_size (gmp_randstate_t, mp_bitcnt_t);


 void __gmp_randinit_mt (gmp_randstate_t);


 void __gmp_randinit_set (gmp_randstate_t, const __gmp_randstate_struct *);


 void __gmp_randseed (gmp_randstate_t, mpz_srcptr);


 void __gmp_randseed_ui (gmp_randstate_t, unsigned long int);


 void __gmp_randclear (gmp_randstate_t);


 unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);


 unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);





 int __gmp_asprintf (char **, const char *, ...);



 int __gmp_fprintf (FILE *, const char *, ...);
#615 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
 int __gmp_printf (const char *, ...);


 int __gmp_snprintf (char *, size_t, const char *, ...);


 int __gmp_sprintf (char *, const char *, ...);
#653 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
 int __gmp_fscanf (FILE *, const char *, ...);



 int __gmp_scanf (const char *, ...);


 int __gmp_sscanf (const char *, const char *, ...);
#684 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
 void *__gmpz_realloc (mpz_ptr, mp_size_t);




 void __gmpz_abs (mpz_ptr, mpz_srcptr);




 void __gmpz_add (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_add_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_addmul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_addmul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_and (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_array_init (mpz_ptr, mp_size_t, mp_size_t);


 void __gmpz_bin_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_bin_uiui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_cdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_q_2exp (mpz_ptr, mpz_srcptr, unsigned long);


 unsigned long int __gmpz_cdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_cdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_cdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_cdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_clear (mpz_ptr);


 void __gmpz_clears (mpz_ptr, ...);


 void __gmpz_clrbit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_cmp (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmp_si (mpz_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmpabs_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpz_com (mpz_ptr, mpz_srcptr);


 void __gmpz_combit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_congruent_p (mpz_srcptr, mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_congruent_2exp_p (mpz_srcptr, mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 int __gmpz_congruent_ui_p (mpz_srcptr, unsigned long, unsigned long) __attribute__ ((__pure__));


 void __gmpz_divexact (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_divexact_ui (mpz_ptr, mpz_srcptr, unsigned long);


 int __gmpz_divisible_p (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_divisible_ui_p (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_divisible_2exp_p (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_dump (mpz_srcptr);


 void *__gmpz_export (void *, size_t *, int, size_t, int, size_t, mpz_srcptr);


 void __gmpz_fac_ui (mpz_ptr, unsigned long int);


 void __gmpz_fdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_fdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_fdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_fib_ui (mpz_ptr, unsigned long int);


 void __gmpz_fib2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_fits_sint_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_slong_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_sshort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 int __gmpz_fits_uint_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ulong_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ushort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_gcd (mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_gcd_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_gcdext (mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 double __gmpz_get_d (mpz_srcptr) __attribute__ ((__pure__));


 double __gmpz_get_d_2exp (signed long int *, mpz_srcptr);


 long int __gmpz_get_si (mpz_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpz_get_str (char *, int, mpz_srcptr);



 unsigned long int __gmpz_get_ui (mpz_srcptr) throw () __attribute__ ((__pure__));




 mp_limb_t __gmpz_getlimbn (mpz_srcptr, mp_size_t) throw () __attribute__ ((__pure__));



 mp_bitcnt_t __gmpz_hamdist (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 void __gmpz_import (mpz_ptr, size_t, int, size_t, int, size_t, const void *);


 void __gmpz_init (mpz_ptr);


 void __gmpz_init2 (mpz_ptr, mp_bitcnt_t);


 void __gmpz_inits (mpz_ptr, ...);


 void __gmpz_init_set (mpz_ptr, mpz_srcptr);


 void __gmpz_init_set_d (mpz_ptr, double);


 void __gmpz_init_set_si (mpz_ptr, signed long int);


 int __gmpz_init_set_str (mpz_ptr, const char *, int);


 void __gmpz_init_set_ui (mpz_ptr, unsigned long int);



 size_t __gmpz_inp_raw (mpz_ptr, FILE *);




 size_t __gmpz_inp_str (mpz_ptr, FILE *, int);



 int __gmpz_invert (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_ior (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_jacobi (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));




 int __gmpz_kronecker_si (mpz_srcptr, long) __attribute__ ((__pure__));


 int __gmpz_kronecker_ui (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_si_kronecker (long, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_ui_kronecker (unsigned long, mpz_srcptr) __attribute__ ((__pure__));


 void __gmpz_lcm (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_lcm_ui (mpz_ptr, mpz_srcptr, unsigned long);




 void __gmpz_lucnum_ui (mpz_ptr, unsigned long int);


 void __gmpz_lucnum2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_millerrabin (mpz_srcptr, int) __attribute__ ((__pure__));


 void __gmpz_mod (mpz_ptr, mpz_srcptr, mpz_srcptr);





 void __gmpz_mul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_mul_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);



 void __gmpz_mul_si (mpz_ptr, mpz_srcptr, long int);



 void __gmpz_mul_ui (mpz_ptr, mpz_srcptr, unsigned long int);




 void __gmpz_neg (mpz_ptr, mpz_srcptr);



 void __gmpz_nextprime (mpz_ptr, mpz_srcptr);


 void __gmpz_next_likely_prime (mpz_ptr, mpz_srcptr,gmp_randstate_t);



 size_t __gmpz_out_raw (FILE *, mpz_srcptr);




 size_t __gmpz_out_str (FILE *, int, mpz_srcptr);



 int __gmpz_perfect_power_p (mpz_srcptr) __attribute__ ((__pure__));



 int __gmpz_perfect_square_p (mpz_srcptr) __attribute__ ((__pure__));




 mp_bitcnt_t __gmpz_popcount (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_pow_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_powm (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_powm_ui (mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr);


 int __gmpz_probab_prime_p (mpz_srcptr, int) __attribute__ ((__pure__));


 int __gmpz_probable_prime_p (mpz_srcptr,gmp_randstate_t, int,unsigned long);


 int __gmpz_likely_prime_p (mpz_srcptr,gmp_randstate_t, unsigned long);


 void __gmpz_realloc2 (mpz_ptr, mp_bitcnt_t);


 unsigned long int __gmpz_remove (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_root (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_nthroot (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rootrem (mpz_ptr,mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 mp_bitcnt_t __gmpz_scan0 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpz_scan1 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));



 void __gmpz_set (mpz_ptr, mpz_srcptr);


 void __gmpz_set_d (mpz_ptr, double);


 void __gmpz_set_f (mpz_ptr, mpf_srcptr);



 void __gmpz_set_q (mpz_ptr, mpq_srcptr);




 void __gmpz_set_si (mpz_ptr, signed long int);


 int __gmpz_set_str (mpz_ptr, const char *, int);



 void __gmpz_set_ui (mpz_ptr, unsigned long int);


 void __gmpz_setbit (mpz_ptr, mp_bitcnt_t);



 size_t __gmpz_size (mpz_srcptr) throw () __attribute__ ((__pure__));



 size_t __gmpz_sizeinbase (mpz_srcptr, int) throw () __attribute__ ((__pure__));


 void __gmpz_sqrt (mpz_ptr, mpz_srcptr);


 void __gmpz_sqrtrem (mpz_ptr, mpz_ptr, mpz_srcptr);



 void __gmpz_sub (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_sub_ui (mpz_ptr, mpz_srcptr, unsigned long int);



 void __gmpz_ui_sub (mpz_ptr, unsigned long int, mpz_srcptr);


 void __gmpz_submul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_submul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_swap (mpz_ptr, mpz_ptr) throw ();


 unsigned long int __gmpz_tdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_tdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_tdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 int __gmpz_tstbit (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_ui_pow_ui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);



 void __gmpz_xor (mpz_ptr, mpz_srcptr, mpz_srcptr);






 void __gmpq_abs (mpq_ptr, mpq_srcptr);



 void __gmpq_add (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_canonicalize (mpq_ptr);


 void __gmpq_clear (mpq_ptr);


 void __gmpq_clears (mpq_ptr, ...);


 int __gmpq_cmp (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));


 int __gmpq_cmp_si (mpq_srcptr, long, unsigned long) __attribute__ ((__pure__));


 int __gmpq_cmp_ui (mpq_srcptr, unsigned long int, unsigned long int) __attribute__ ((__pure__));


 void __gmpq_div (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_div_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);


 int __gmpq_equal (mpq_srcptr, mpq_srcptr) throw () __attribute__ ((__pure__));


 void __gmpq_get_num (mpz_ptr, mpq_srcptr);


 void __gmpq_get_den (mpz_ptr, mpq_srcptr);


 double __gmpq_get_d (mpq_srcptr) __attribute__ ((__pure__));


 char *__gmpq_get_str (char *, int, mpq_srcptr);


 void __gmpq_init (mpq_ptr);


 void __gmpq_inits (mpq_ptr, ...);



 size_t __gmpq_inp_str (mpq_ptr, FILE *, int);



 void __gmpq_inv (mpq_ptr, mpq_srcptr);


 void __gmpq_mul (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_mul_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);



 void __gmpq_neg (mpq_ptr, mpq_srcptr);




 size_t __gmpq_out_str (FILE *, int, mpq_srcptr);



 void __gmpq_set (mpq_ptr, mpq_srcptr);


 void __gmpq_set_d (mpq_ptr, double);


 void __gmpq_set_den (mpq_ptr, mpz_srcptr);


 void __gmpq_set_f (mpq_ptr, mpf_srcptr);


 void __gmpq_set_num (mpq_ptr, mpz_srcptr);


 void __gmpq_set_si (mpq_ptr, signed long int, unsigned long int);


 int __gmpq_set_str (mpq_ptr, const char *, int);


 void __gmpq_set_ui (mpq_ptr, unsigned long int, unsigned long int);


 void __gmpq_set_z (mpq_ptr, mpz_srcptr);


 void __gmpq_sub (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_swap (mpq_ptr, mpq_ptr) throw ();





 void __gmpf_abs (mpf_ptr, mpf_srcptr);


 void __gmpf_add (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_add_ui (mpf_ptr, mpf_srcptr, unsigned long int);

 void __gmpf_ceil (mpf_ptr, mpf_srcptr);


 void __gmpf_clear (mpf_ptr);


 void __gmpf_clears (mpf_ptr, ...);


 int __gmpf_cmp (mpf_srcptr, mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_d (mpf_srcptr, double) __attribute__ ((__pure__));


 int __gmpf_cmp_si (mpf_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_ui (mpf_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpf_div (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_div_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_div_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_dump (mpf_srcptr);


 int __gmpf_eq (mpf_srcptr, mpf_srcptr, unsigned long int) __attribute__ ((__pure__));


 int __gmpf_fits_sint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_slong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_sshort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_uint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ulong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ushort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_floor (mpf_ptr, mpf_srcptr);


 double __gmpf_get_d (mpf_srcptr) __attribute__ ((__pure__));


 double __gmpf_get_d_2exp (signed long int *, mpf_srcptr);


 mp_bitcnt_t __gmpf_get_default_prec (void) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpf_get_prec (mpf_srcptr) throw () __attribute__ ((__pure__));


 long __gmpf_get_si (mpf_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpf_get_str (char *, mp_exp_t *, int, size_t, mpf_srcptr);


 unsigned long __gmpf_get_ui (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_init (mpf_ptr);


 void __gmpf_init2 (mpf_ptr, mp_bitcnt_t);


 void __gmpf_inits (mpf_ptr, ...);


 void __gmpf_init_set (mpf_ptr, mpf_srcptr);


 void __gmpf_init_set_d (mpf_ptr, double);


 void __gmpf_init_set_si (mpf_ptr, signed long int);


 int __gmpf_init_set_str (mpf_ptr, const char *, int);


 void __gmpf_init_set_ui (mpf_ptr, unsigned long int);



 size_t __gmpf_inp_str (mpf_ptr, FILE *, int);



 int __gmpf_integer_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_mul (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_mul_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_mul_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_neg (mpf_ptr, mpf_srcptr);



 size_t __gmpf_out_str (FILE *, int, size_t, mpf_srcptr);



 void __gmpf_pow_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);


 void __gmpf_rrandomb (mpf_ptr, gmp_randstate_t, mp_size_t, mp_exp_t);


 void __gmpf_reldiff (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_set (mpf_ptr, mpf_srcptr);


 void __gmpf_set_d (mpf_ptr, double);


 void __gmpf_set_default_prec (mp_bitcnt_t) throw ();


 void __gmpf_set_prec (mpf_ptr, mp_bitcnt_t);


 void __gmpf_set_prec_raw (mpf_ptr, mp_bitcnt_t) throw ();


 void __gmpf_set_q (mpf_ptr, mpq_srcptr);


 void __gmpf_set_si (mpf_ptr, signed long int);


 int __gmpf_set_str (mpf_ptr, const char *, int);


 void __gmpf_set_ui (mpf_ptr, unsigned long int);


 void __gmpf_set_z (mpf_ptr, mpz_srcptr);


 size_t __gmpf_size (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_sqrt (mpf_ptr, mpf_srcptr);


 void __gmpf_sqrt_ui (mpf_ptr, unsigned long int);


 void __gmpf_sub (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_sub_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_swap (mpf_ptr, mpf_ptr) throw ();


 void __gmpf_trunc (mpf_ptr, mpf_srcptr);


 void __gmpf_ui_div (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_ui_sub (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
#1516 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
 mp_limb_t __gmpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_bdivmod (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, unsigned long int);


 mp_limb_t __gmpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t);


 int __gmpn_mulmod_2expp1 (mp_ptr, mp_srcptr, mp_srcptr,int,unsigned long, mp_ptr);


 void __gmpn_mulmod_2expm1 (mp_ptr, mp_ptr, mp_ptr,unsigned long, mp_ptr);



 int __gmpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));






 mp_limb_t __gmpn_divexact_by3c (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);





 mp_limb_t __gmpn_divrem_1 (mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_divrem_2 (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr);


 void __gmpn_invert (mp_ptr xp, mp_srcptr ap, mp_size_t n);


 mp_limb_t __gmpn_sb_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dip)
                                               ;


 mp_limb_t __gmpn_dc_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dip, mp_ptr tp)
                                     ;


 void __gmpn_dc_bdiv_q_n (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr scratch)
                                                 ;


 mp_limb_t __gmpn_inv_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_srcptr dip)
                                        ;


 mp_limb_t __gmpn_dc_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_limb_t dinv)
                                 ;


 mp_limb_t __gmpn_dc_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_inv_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_srcptr dinv)
                                 ;


 mp_limb_t __gmpn_inv_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                    ;


 mp_limb_t __gmpn_sb_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_sb_bdiv_q (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_dc_bdiv_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                                               ;


 mp_limb_t __gmpn_sb_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_sb_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_tdiv_q (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_divexact (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_redc_1 (mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_size_t __gmpn_gcd (mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 mp_limb_t __gmpn_gcd_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_gcdext (mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 size_t __gmpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);


 mp_bitcnt_t __gmpn_hamdist (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_limb_t __gmpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_limb_t __gmpn_mod_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_limb_t __gmpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_sqr (mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_neg_n (mp_ptr, mp_srcptr, mp_size_t);



 void __gmpn_com_n (mp_ptr, mp_srcptr, mp_size_t);


 int __gmpn_perfect_square_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_popcount (mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_size_t __gmpn_pow_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr);



 mp_limb_t __gmpn_preinv_mod_1 (mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t) __attribute__ ((__pure__));


 void __gmpn_random (mp_ptr, mp_size_t);


 void __gmpn_random2 (mp_ptr, mp_size_t);


 void __gmpn_urandomb (mp_ptr, gmp_randstate_t, unsigned long);


 void __gmpn_urandomm (mp_ptr, gmp_randstate_t, mp_srcptr, mp_size_t);


 void __gmpn_randomb (mp_ptr, gmp_randstate_t, mp_size_t);


 void __gmpn_rrandom (mp_ptr, gmp_randstate_t, mp_size_t);


 mp_limb_t __gmpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_bitcnt_t __gmpn_scan0 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_scan1 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_set_str (mp_ptr, const unsigned char *, size_t, int);


 mp_size_t __gmpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_tdiv_qr (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 void __gmpn_and_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_andn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nand_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_ior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_iorn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xnor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_copyi (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_copyd (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_zero (mp_ptr, mp_size_t);
#1799 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = ((__gmp_w->_mp_size) >= 0 ? (__gmp_w->_mp_size) : -(__gmp_w->_mp_size));
}
#1823 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_uint_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ulong_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned long) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= ((unsigned short) ~0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

unsigned long
__gmpz_get_ui (mpz_srcptr __gmp_z) throw ()
{
  mp_ptr __gmp_p = __gmp_z->_mp_d;
  mp_size_t __gmp_n = __gmp_z->_mp_size;
  mp_limb_t __gmp_l = __gmp_p[0];






  return (unsigned long)(__gmp_n != 0 ? __gmp_l : 0);
#1879 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n) throw ()
{
  mp_limb_t __gmp_result = 0;
  if (__builtin_expect ((__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))) != 0, 1))
    __gmp_result = __gmp_z->_mp_d[__gmp_n];
  return __gmp_result;
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
{
  mp_size_t __gmp_asize;
  int __gmp_result;

  __gmp_asize = __gmp_a->_mp_size;
  __gmp_result = (__gmp_asize >= 0);
  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_bitcnt_t
__gmpz_popcount (mpz_srcptr __gmp_u) throw ()
{
  mp_size_t __gmp_usize;
  mp_bitcnt_t __gmp_result;

  __gmp_usize = __gmp_u->_mp_size;
  __gmp_result = (__gmp_usize < 0 ? (~ (unsigned long) 0) : 0);
  if (__builtin_expect ((__gmp_usize > 0) != 0, 1))
    __gmp_result = __gmpn_popcount (__gmp_u->_mp_d, __gmp_usize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

void
__gmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  __gmpz_tdiv_q (__gmp_w, (&((__gmp_u)->_mp_num)), (&((__gmp_u)->_mp_den)));
}




extern __inline__ __attribute__((__gnu_inline__))

size_t
__gmpz_size (mpz_srcptr __gmp_z) throw ()
{
  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
}






extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = ((__gmp_w->_mp_num._mp_size) >= 0 ? (__gmp_w->_mp_num._mp_size) : -(__gmp_w->_mp_num._mp_size));
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
}
#2220 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_add_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)) == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x + (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_r) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x + 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_r) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size) throw ()
{
  int __gmp_result;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (__gmp_result) = 0; __gmp_i = (__gmp_size); while (--__gmp_i >= 0) { __gmp_x = (__gmp_xp)[__gmp_i]; __gmp_y = (__gmp_yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (__gmp_result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_sub_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)), __gmp_x == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x - (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_x) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x - 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_x) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}



}
#2328 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
 std::ostream& operator<< (std::ostream &, mpz_srcptr);
 std::ostream& operator<< (std::ostream &, mpq_srcptr);
 std::ostream& operator<< (std::ostream &, mpf_srcptr);
 std::istream& operator>> (std::istream &, mpz_ptr);
 std::istream& operator>> (std::istream &, mpq_ptr);
 std::istream& operator>> (std::istream &, mpf_ptr);
#2348 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
typedef __mpz_struct MP_INT;
typedef __mpq_struct MP_RAT;
#2358 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h"
enum
{
  GMP_ERROR_NONE = 0,
  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
  GMP_ERROR_DIVISION_BY_ZERO = 2,
  GMP_ERROR_SQRT_OF_NEGATIVE = 4,
  GMP_ERROR_INVALID_ARGUMENT = 8
};
#144 "/opt/Xilinx/Vivado_HLS/2017.1/include/floating_point_v7_0_bitacc_cmodel.h" 2




#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h" 1
#73 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
typedef void mpfr_void;
typedef int mpfr_int;
typedef unsigned int mpfr_uint;
typedef long mpfr_long;
typedef unsigned long mpfr_ulong;
typedef size_t mpfr_size_t;
#95 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
typedef enum {
  MPFR_RNDN=0,
  MPFR_RNDZ,
  MPFR_RNDU,
  MPFR_RNDD,
  MPFR_RNDA,
  MPFR_RNDF,
  MPFR_RNDNA=-1
} mpfr_rnd_t;
#130 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
typedef long mpfr_prec_t;
typedef unsigned long mpfr_uprec_t;
#143 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
typedef int mpfr_sign_t;


typedef mp_exp_t mpfr_exp_t;






typedef struct {
  mpfr_prec_t _mpfr_prec;
  mpfr_sign_t _mpfr_sign;
  mpfr_exp_t _mpfr_exp;
  mp_limb_t *_mpfr_d;
} __mpfr_struct;
#179 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
typedef __mpfr_struct mpfr_t[1];
typedef __mpfr_struct *mpfr_ptr;
typedef const __mpfr_struct *mpfr_srcptr;
#192 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
typedef enum {
  MPFR_NAN_KIND = 0,
  MPFR_INF_KIND = 1, MPFR_ZERO_KIND = 2, MPFR_REGULAR_KIND = 3
} mpfr_kind_t;
#241 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
extern "C" {


 const char * mpfr_get_version (void);
 const char * mpfr_get_patches (void);
 int mpfr_buildopt_tls_p (void);
 int mpfr_buildopt_decimal_p (void);

 mpfr_exp_t mpfr_get_emin (void);
 int mpfr_set_emin (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emin_min (void);
 mpfr_exp_t mpfr_get_emin_max (void);
 mpfr_exp_t mpfr_get_emax (void);
 int mpfr_set_emax (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emax_min (void);
 mpfr_exp_t mpfr_get_emax_max (void);

 void mpfr_set_default_rounding_mode (mpfr_rnd_t);
 mpfr_rnd_t mpfr_get_default_rounding_mode (void);
 const char *
   mpfr_print_rnd_mode (mpfr_rnd_t);

 void mpfr_clear_flags (void);
 void mpfr_clear_underflow (void);
 void mpfr_clear_overflow (void);
 void mpfr_clear_nanflag (void);
 void mpfr_clear_inexflag (void);
 void mpfr_clear_erangeflag (void);

 void mpfr_set_underflow (void);
 void mpfr_set_overflow (void);
 void mpfr_set_nanflag (void);
 void mpfr_set_inexflag (void);
 void mpfr_set_erangeflag (void);

 int mpfr_underflow_p (void);
 int mpfr_overflow_p (void);
 int mpfr_nanflag_p (void);
 int mpfr_inexflag_p (void);
 int mpfr_erangeflag_p (void);

 int
  mpfr_check_range (mpfr_ptr, int, mpfr_rnd_t);

 void mpfr_init2 (mpfr_ptr, mpfr_prec_t);
 void mpfr_init (mpfr_ptr);
 void mpfr_clear (mpfr_ptr);

 void
  mpfr_inits2 (mpfr_prec_t, mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_inits (mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_clears (mpfr_ptr, ...) __attribute__ ((sentinel));

 int
  mpfr_prec_round (mpfr_ptr, mpfr_prec_t, mpfr_rnd_t);
 int
  mpfr_can_round (mpfr_srcptr, mpfr_exp_t, mpfr_rnd_t, mpfr_rnd_t, mpfr_prec_t)
                                            ;
 mpfr_prec_t mpfr_min_prec (mpfr_srcptr);

 mpfr_exp_t mpfr_get_exp (mpfr_srcptr);
 int mpfr_set_exp (mpfr_ptr, mpfr_exp_t);
 mpfr_prec_t mpfr_get_prec (mpfr_srcptr);
 void mpfr_set_prec (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_prec_raw (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_default_prec (mpfr_prec_t);
 mpfr_prec_t mpfr_get_default_prec (void);

 int mpfr_set_d (mpfr_ptr, double, mpfr_rnd_t);
 int mpfr_set_flt (mpfr_ptr, float, mpfr_rnd_t);




 int
  mpfr_set_ld (mpfr_ptr, long double, mpfr_rnd_t);
 int
  mpfr_set_z (mpfr_ptr, mpz_srcptr, mpfr_rnd_t);
 int
  mpfr_set_z_2exp (mpfr_ptr, mpz_srcptr, mpfr_exp_t, mpfr_rnd_t);
 void mpfr_set_nan (mpfr_ptr);
 void mpfr_set_inf (mpfr_ptr, int);
 void mpfr_set_zero (mpfr_ptr, int);
 int
  mpfr_set_f (mpfr_ptr, mpf_srcptr, mpfr_rnd_t);
 int
  mpfr_get_f (mpf_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_set_si (mpfr_ptr, long, mpfr_rnd_t);
 int
  mpfr_set_ui (mpfr_ptr, unsigned long, mpfr_rnd_t);
 int
  mpfr_set_si_2exp (mpfr_ptr, long, mpfr_exp_t, mpfr_rnd_t);
 int
  mpfr_set_ui_2exp (mpfr_ptr,unsigned long,mpfr_exp_t,mpfr_rnd_t);
 int
  mpfr_set_q (mpfr_ptr, mpq_srcptr, mpfr_rnd_t);
 int
  mpfr_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t);
 int
  mpfr_init_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t)
                                              ;
 int
  mpfr_set4 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t, int);
 int
  mpfr_abs (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int
  mpfr_set (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_neg (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_signbit (mpfr_srcptr);
 int
  mpfr_setsign (mpfr_ptr, mpfr_srcptr, int, mpfr_rnd_t);
 int
  mpfr_copysign (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
#364 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
 int __gmpfr_set_sj (mpfr_t, intmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_sj_2exp (mpfr_t, intmax_t, intmax_t, mpfr_rnd_t);
 int __gmpfr_set_uj (mpfr_t, uintmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_uj_2exp (mpfr_t, uintmax_t, intmax_t, mpfr_rnd_t);
 intmax_t __gmpfr_mpfr_get_sj (mpfr_srcptr, mpfr_rnd_t);
 uintmax_t __gmpfr_mpfr_get_uj (mpfr_srcptr, mpfr_rnd_t);


 mpfr_exp_t mpfr_get_z_2exp (mpz_ptr, mpfr_srcptr);
 float mpfr_get_flt (mpfr_srcptr, mpfr_rnd_t);
 double mpfr_get_d (mpfr_srcptr, mpfr_rnd_t);




 long double mpfr_get_ld (mpfr_srcptr, mpfr_rnd_t)
                                                                  ;
 double mpfr_get_d1 (mpfr_srcptr);
 double mpfr_get_d_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                 ;
 long double mpfr_get_ld_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 long mpfr_get_si (mpfr_srcptr, mpfr_rnd_t);
 unsigned long mpfr_get_ui (mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 char*mpfr_get_str (char*, mpfr_exp_t*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_get_z (mpz_ptr z, mpfr_srcptr f, mpfr_rnd_t)
                                                         ;

 void mpfr_free_str (char *);

 int mpfr_urandom (mpfr_ptr, gmp_randstate_t, mpfr_rnd_t)
                                                           ;
 int mpfr_urandomb (mpfr_ptr, gmp_randstate_t);

 void mpfr_nextabove (mpfr_ptr);
 void mpfr_nextbelow (mpfr_ptr);
 void mpfr_nexttoward (mpfr_ptr, mpfr_srcptr);




 size_t __gmpfr_inp_str (mpfr_ptr, FILE*, int, mpfr_rnd_t)
                                                              ;
 size_t __gmpfr_out_str (FILE*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                           ;

 int __gmpfr_fprintf (FILE*, const char*, ...)
                                                    ;

 int mpfr_printf (const char*, ...);
 int mpfr_asprintf (char**, const char*, ...)
                                                     ;
 int mpfr_sprintf (char*, const char*, ...)
                                                    ;
 int mpfr_snprintf (char*, size_t, const char*, ...)
                                                                        ;
#444 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h"
 int mpfr_pow (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_ui (mpfr_ptr, mpfr_srcptr, unsigned long int, mpfr_rnd_t)
                                                                             ;
 int mpfr_ui_pow_ui (mpfr_ptr, unsigned long int, unsigned long int, mpfr_rnd_t)
                                                                            ;
 int mpfr_ui_pow (mpfr_ptr, unsigned long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_pow_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;

 int mpfr_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                        ;
 int mpfr_sqrt_ui (mpfr_ptr, unsigned long, mpfr_rnd_t)
                                                           ;
 int mpfr_rec_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                            ;

 int mpfr_add (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_mul (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_div (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;

 int mpfr_add_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_sub_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_sub (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_div_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_div (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_sub (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_div_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_div (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_sub_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_sub (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_div_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_div (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_sqr (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_const_pi (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_log2 (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_euler (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_catalan (mpfr_ptr, mpfr_rnd_t);

 int mpfr_agm (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_log (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_log1p (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;

 int mpfr_exp (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_expm1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_eint (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_li2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);

 int mpfr_cmp (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp3 (mpfr_srcptr, mpfr_srcptr, int);
 int mpfr_cmp_d (mpfr_srcptr, double);
 int mpfr_cmp_ld (mpfr_srcptr, long double);
 int mpfr_cmpabs (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp_ui (mpfr_srcptr, unsigned long);
 int mpfr_cmp_si (mpfr_srcptr, long);
 int mpfr_cmp_ui_2exp (mpfr_srcptr, unsigned long, mpfr_exp_t)
                                                               ;
 int mpfr_cmp_si_2exp (mpfr_srcptr, long, mpfr_exp_t)
                                                               ;
 void mpfr_reldiff (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_eq (mpfr_srcptr, mpfr_srcptr, unsigned long)
                                                        ;
 int mpfr_sgn (mpfr_srcptr);

 int mpfr_mul_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_div_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_mul_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_div_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_mul_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;
 int mpfr_div_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;

 int mpfr_rint (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_round (mpfr_ptr, mpfr_srcptr);
 int mpfr_trunc (mpfr_ptr, mpfr_srcptr);
 int mpfr_ceil (mpfr_ptr, mpfr_srcptr);
 int mpfr_floor (mpfr_ptr, mpfr_srcptr);
 int mpfr_rint_round (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_trunc (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_ceil (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                             ;
 int mpfr_rint_floor (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_frac (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_modf (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_remquo (mpfr_ptr, long*, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_remainder (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;
 int mpfr_fmod (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;

 int mpfr_fits_ulong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_slong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_ushort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sshort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uintmax_p (mpfr_srcptr,mpfr_rnd_t);
 int mpfr_fits_intmax_p (mpfr_srcptr, mpfr_rnd_t);

 void mpfr_extract (mpz_ptr, mpfr_srcptr, unsigned int)
                                                              ;
 void mpfr_swap (mpfr_ptr, mpfr_ptr);
 void mpfr_dump (mpfr_srcptr);

 int mpfr_nan_p (mpfr_srcptr);
 int mpfr_inf_p (mpfr_srcptr);
 int mpfr_number_p (mpfr_srcptr);
 int mpfr_integer_p (mpfr_srcptr);
 int mpfr_zero_p (mpfr_srcptr);
 int mpfr_regular_p (mpfr_srcptr);

 int mpfr_greater_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_greaterequal_p (mpfr_srcptr, mpfr_srcptr)
                                                                   ;
 int mpfr_less_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessequal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessgreater_p (mpfr_srcptr,mpfr_srcptr);
 int mpfr_equal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_unordered_p (mpfr_srcptr, mpfr_srcptr);

 int mpfr_atanh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_acosh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asinh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cosh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_tanh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh_cosh (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;

 int mpfr_sech (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csch (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_coth (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_acos (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asin (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin_cos (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;
 int mpfr_cos (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_tan (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan2 (mpfr_ptr,mpfr_srcptr,mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_sec (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cot (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_hypot (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                      ;
 int mpfr_erf (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_erfc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cbrt (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_root (mpfr_ptr,mpfr_srcptr,unsigned long,mpfr_rnd_t);
 int mpfr_gamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lngamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lgamma (mpfr_ptr,int*,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_digamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta_ui (mpfr_ptr,unsigned long,mpfr_rnd_t);
 int mpfr_fac_ui (mpfr_ptr, unsigned long int, mpfr_rnd_t)
                                                          ;
 int mpfr_j0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_j1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_jn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;
 int mpfr_y0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_y1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_yn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;

 int mpfr_ai (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

 int mpfr_min (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_max (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_dim (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_mul_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_z (mpfr_srcptr, mpz_srcptr);

 int mpfr_mul_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_q (mpfr_srcptr, mpq_srcptr);

 int mpfr_cmp_f (mpfr_srcptr, mpf_srcptr);

 int mpfr_fma (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_fms (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sum (mpfr_ptr, mpfr_ptr *const, unsigned long, mpfr_rnd_t)
                                                                      ;

 void mpfr_free_cache (void);

 int mpfr_subnormalize (mpfr_ptr, int, mpfr_rnd_t)
                                                                 ;

 int mpfr_strtofr (mpfr_ptr, const char *, char **, int, mpfr_rnd_t)
                                                                          ;

 size_t mpfr_custom_get_size (mpfr_prec_t);
 void mpfr_custom_init (void *, mpfr_prec_t);
 void * mpfr_custom_get_significand (mpfr_srcptr);
 mpfr_exp_t mpfr_custom_get_exp (mpfr_srcptr);
 void mpfr_custom_move (mpfr_ptr, void *);
 void mpfr_custom_init_set (mpfr_ptr, int, mpfr_exp_t, mpfr_prec_t, void *)
                                                                              ;
 int mpfr_custom_get_kind (mpfr_srcptr);


}
#149 "/opt/Xilinx/Vivado_HLS/2017.1/include/floating_point_v7_0_bitacc_cmodel.h" 2



typedef long xip_fpo_prec_t;


typedef int xip_fpo_sign_t;


typedef long xip_fpo_exp_t;


typedef struct {
  xip_fpo_prec_t _xip_fpo_exp_prec;
  xip_fpo_prec_t _xip_fpo_mant_prec;
  xip_fpo_sign_t _xip_fpo_sign;
  xip_fpo_exp_t _xip_fpo_exp;
  mp_limb_t *_xip_fpo_d;
} __xip_fpo_struct;


typedef struct {
  xip_fpo_prec_t _xip_fpo_i_prec;
  xip_fpo_prec_t _xip_fpo_frac_prec;
  xint64 _xip_fpo_i;
  xint64 _xip_fpo_frac;
} __xip_fpo_fix_struct;


typedef __xip_fpo_struct xip_fpo_t[1];
typedef __xip_fpo_fix_struct xip_fpo_fix_t[1];


typedef __xip_fpo_struct *xip_fpo_ptr;
typedef const __xip_fpo_struct *xip_fpo_srcptr;
typedef __xip_fpo_fix_struct *xip_fpo_fix_ptr;
typedef const __xip_fpo_fix_struct *xip_fpo_fix_srcptr;
#197 "/opt/Xilinx/Vivado_HLS/2017.1/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int xip_fpo_exc_t;


extern "C" {


typedef struct xil_fpo_accum_state xil_fpo_accum_state;


 const char * xip_fpo_get_version (void);


 void xip_fpo_init2 (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_init2 (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_clear (xip_fpo_ptr);
 void xip_fpo_fix_clear (xip_fpo_fix_ptr);
 void xip_fpo_clears (xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_clears (xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_set_prec (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_set_prec (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 xip_fpo_prec_t xip_fpo_get_prec_mant (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_get_prec_exp (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_frac (xip_fpo_fix_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_int (xip_fpo_fix_ptr);


 xip_fpo_exc_t xip_fpo_set (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set (xip_fpo_fix_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui (xip_fpo_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_fix_set_ui (xip_fpo_fix_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_set_si (xip_fpo_ptr, long);
 xip_fpo_exc_t xip_fpo_fix_set_si (xip_fpo_fix_ptr, long);
 xip_fpo_exc_t xip_fpo_set_uj (xip_fpo_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_uj (xip_fpo_fix_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_set_sj (xip_fpo_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_sj (xip_fpo_fix_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_set_flt (xip_fpo_ptr, float);
 xip_fpo_exc_t xip_fpo_fix_set_flt (xip_fpo_fix_ptr, float);
 xip_fpo_exc_t xip_fpo_set_d (xip_fpo_ptr, double);
 xip_fpo_exc_t xip_fpo_fix_set_d (xip_fpo_fix_ptr, double);
 xip_fpo_exc_t xip_fpo_set_z (xip_fpo_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_z (xip_fpo_fix_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_set_q (xip_fpo_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_q (xip_fpo_fix_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_set_f (xip_fpo_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_f (xip_fpo_fix_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_set_fr (xip_fpo_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_fr (xip_fpo_fix_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui_2exp (xip_fpo_ptr, unsigned long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_si_2exp (xip_fpo_ptr, long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_uj_2exp (xip_fpo_ptr, uintmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_sj_2exp (xip_fpo_ptr, intmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_str (xip_fpo_ptr, const char *, int);
 xip_fpo_exc_t xip_fpo_fix_set_str (xip_fpo_fix_ptr, const char *, int);
 void xip_fpo_set_nan (xip_fpo_ptr);
 void xip_fpo_set_inf (xip_fpo_ptr, int);
 void xip_fpo_set_zero (xip_fpo_ptr, int);


 unsigned long xip_fpo_get_ui (xip_fpo_srcptr);
 unsigned long xip_fpo_fix_get_ui (xip_fpo_fix_srcptr);
 long xip_fpo_get_si (xip_fpo_srcptr);
 long xip_fpo_fix_get_si (xip_fpo_fix_srcptr);
 uintmax_t xip_fpo_get_uj (xip_fpo_srcptr);
 uintmax_t xip_fpo_fix_get_uj (xip_fpo_fix_srcptr);
 intmax_t xip_fpo_get_sj (xip_fpo_srcptr);
 intmax_t xip_fpo_fix_get_sj (xip_fpo_fix_srcptr);
 float xip_fpo_get_flt (xip_fpo_srcptr);
 float xip_fpo_fix_get_flt (xip_fpo_fix_srcptr);
 double xip_fpo_get_d (xip_fpo_srcptr);
 double xip_fpo_fix_get_d (xip_fpo_fix_srcptr);
 double xip_fpo_get_d_2exp (long *, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_get_z (mpz_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_z (mpz_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_f (mpf_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_f (mpf_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_fr (mpfr_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_fr (mpfr_ptr, xip_fpo_fix_srcptr);
 char * xip_fpo_get_str (char *, xip_fpo_exp_t *, int, int, xip_fpo_srcptr);
 char * xip_fpo_fix_get_str (char *, int, xip_fpo_fix_srcptr);
 void xip_fpo_free_str (char *);
 void xip_fpo_fix_free_str (char *);
 int xip_fpo_sizeinbase (xip_fpo_srcptr, int);
 int xip_fpo_fix_sizeinbase (xip_fpo_fix_srcptr, int);


 xip_fpo_exc_t xip_fpo_add (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_add_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_add_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_sub (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sub_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_sub_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_mul (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_mul_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_mul_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_fma (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fma_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fma_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_fms (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fms_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fms_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_div (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_div_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_div_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_rec (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_rec_flt (float *, float);
 xip_fpo_exc_t xip_fpo_rec_d (double *, double);
 xip_fpo_exc_t xip_fpo_abs (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_abs_flt (float *, float);
 xip_fpo_exc_t xip_fpo_abs_d (double *, double);
 xip_fpo_exc_t xip_fpo_log (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_log_flt (float *, float);
 xip_fpo_exc_t xip_fpo_log_d (double *, double);
 int xip_fpo_exp_array (xip_fpo_t * , xip_fpo_t * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_flt_array (float * , float * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_d_array (double * , double * , xip_fpo_exc_t *, unsigned long long);
 xip_fpo_exc_t xip_fpo_exp (xip_fpo_ptr , xip_fpo_srcptr );
 xip_fpo_exc_t xip_fpo_exp_flt (float * , float );
 xip_fpo_exc_t xip_fpo_exp_d (double * , double );
 struct xil_fpo_accum_state * xip_fpo_accum_create_state (int , int , int , int , int);
 void xip_fpo_accum_reset_state (struct xil_fpo_accum_state *);
 void xip_fpo_accum_destroy_state (struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample (xip_fpo_t, xip_fpo_t, bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_flt (float *, float , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_d (double *, double , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_sqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_sqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_recsqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_recsqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_recsqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_unordered (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_unordered_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_unordered_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_equal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_equal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_equal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_less (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_less_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_less_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_lessequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_lessequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_lessequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greater (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greater_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greater_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greaterequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greaterequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greaterequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_notequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_notequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_notequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_condcode (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_condcode_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_condcode_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_flttofix (xip_fpo_fix_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttofix_int_flt (int *, float);
 xip_fpo_exc_t xip_fpo_flttofix_int_d (int *, double);
 xip_fpo_exc_t xip_fpo_fixtoflt (xip_fpo_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_fixtoflt_flt_int (float *, int);
 xip_fpo_exc_t xip_fpo_fixtoflt_d_int (double *, int);
 xip_fpo_exc_t xip_fpo_flttoflt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_d (float *, double);
 xip_fpo_exc_t xip_fpo_flttoflt_d_flt (double *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_d_d (double *, double);


}
#173 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h" 2


#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/gmp.h" 1
#176 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/mpfr.h" 1
#177 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_fpo.h" 2





inline float xil_fpo_add_flt(float a, float b)
{
  float res_flt;


  xip_fpo_add_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_add_d(double a, double b)
{
  double res_d;


  xip_fpo_add_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_sub_flt(float a, float b)
{
  float res_flt;


  xip_fpo_sub_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_sub_d(double a, double b)
{
  double res_d;


  xip_fpo_sub_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_mul_flt(float a, float b)
{
  float res_flt;


  xip_fpo_mul_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_mul_d(double a, double b)
{
  double res_d;


  xip_fpo_mul_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_div_flt(float a, float b)
{
  float res_flt;


  xip_fpo_div_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_div_d(double a, double b)
{
  double res_d;


  xip_fpo_div_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_rec_flt(float a)
{
  float res_flt;


  xip_fpo_rec_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_rec_d(double a)
{
  double res_d;


  xip_fpo_rec_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_sqrt_flt(float a)
{

  float res_flt;


  xip_fpo_sqrt_flt(&res_flt, a);

  return res_flt;
}

inline double xil_fpo_sqrt_d(double a)
{
  double res_d;


  xip_fpo_sqrt_d(&res_d, a);

  return res_d;
}





inline float xil_fpo_recsqrt_flt(float a)
{
  float res_flt;


  xip_fpo_recsqrt_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_recsqrt_d(double a)
{
  double res_d;


  xip_fpo_recsqrt_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_abs_flt(float a)
{
  float res_flt;

  xip_fpo_abs_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_abs_d(double a)
{
  double res_d;

  xip_fpo_abs_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_log_flt(float a)
{
  float res_flt;


  xip_fpo_log_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_log_d(double a)
{
  double res_d;


  xip_fpo_log_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_exp_flt(float a)
{
  float res_flt;



  xip_fpo_exp_flt(&res_flt, a);



  return res_flt;
}

inline double xil_fpo_exp_d(double a)
{
  double res_d;



  xip_fpo_exp_d(&res_d, a);



  return res_d;
}





inline int xil_fpo_unordered_flt(float a, float b)
{
  int res_int;


  xip_fpo_unordered_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_unordered_d(double a, double b)
{
  int res_int;


  xip_fpo_unordered_d(&res_int, a, b);
  return res_int;
}






inline int xil_fpo_equal_flt(float a, float b)
{
  int res_int;


  xip_fpo_equal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_equal_d(double a, double b)
{
  int res_int;


  xip_fpo_equal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_less_flt(float a, float b)
{
  int res_int;


  xip_fpo_less_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_less_d(double a, double b)
{
  int res_int;


  xip_fpo_less_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_lessequal_flt(float a, float b)
{
  int res_int;


  xip_fpo_lessequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_lessequal_d(double a, double b)
{
  int res_int;


  xip_fpo_lessequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greater_flt(float a, float b)
{
  int res_int;


  xip_fpo_greater_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greater_d(double a, double b)
{
  int res_int;


  xip_fpo_greater_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greaterequal_flt(float a, float b)
{
  int res_int;


  xip_fpo_greaterequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greaterequal_d(double a, double b)
{
  int res_int;


  xip_fpo_greaterequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_notequal_flt(float a, float b)
{
  int res_int;


  xip_fpo_notequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_notequal_d(double a, double b)
{
  int res_int;

  xip_fpo_notequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_condcode_flt(float a, float b)
{
  int res_int;


  xip_fpo_condcode_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_condcode_d(double a, double b)
{
  int res_int;


  xip_fpo_condcode_d(&res_int, a, b);
  return res_int;
}




inline int xil_fpo_flttofix_int_flt(float a)
{
  int res_int;


  xip_fpo_flttofix_int_flt(&res_int, a);
  return res_int;
}

inline int xil_fpo_flttofix_int_d(double a)
{
  int res_int;


  xip_fpo_flttofix_int_d(&res_int, a);
  return res_int;
}

inline float xil_fpo_fixtoflt_flt_int(int a)
{
  float res_flt;


  xip_fpo_fixtoflt_flt_int(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_fixtoflt_d_int(int a)
{
  double res_d;


  xip_fpo_fixtoflt_d_int(&res_d, a);
  return res_d;
}

inline float xil_fpo_flttoflt_flt_flt(float a)
{
  float res_flt;


  xip_fpo_flttoflt_flt_flt(&res_flt, a);
  return res_flt;
}

inline float xil_fpo_flttoflt_flt_d(double a)
{
  float res_flt;


  xip_fpo_flttoflt_flt_d(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_flttoflt_d_flt(float a)
{
  double res_d;


  xip_fpo_flttoflt_d_flt(&res_d, a);
  return res_d;
}

inline double xil_fpo_flttoflt_d_d(double a)
{
  double res_d;


  xip_fpo_flttoflt_d_d(&res_d, a);
  return res_d;
}
#58 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h" 2
#223 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/climits" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/climits" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/climits" 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 1 3 4
#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/climits" 2 3
#224 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h" 2

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 3
#73 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
#122 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 3

}
#226 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h" 2
#302 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
 class half;



 namespace detail
 {
#321 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<bool,typename T,typename> struct conditional { typedef T type; };
  template<typename T,typename F> struct conditional<false,T,F> { typedef F type; };


  template<bool> struct bool_type {};
  typedef bool_type<true> true_type;
  typedef bool_type<false> false_type;


  template<typename> struct is_float : false_type {};
  template<typename T> struct is_float<const T> : is_float<T> {};
  template<typename T> struct is_float<volatile T> : is_float<T> {};
  template<typename T> struct is_float<const volatile T> : is_float<T> {};
  template<> struct is_float<float> : true_type {};
  template<> struct is_float<double> : true_type {};
  template<> struct is_float<long double> : true_type {};
#350 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  typedef unsigned short uint16;


  typedef conditional<std::numeric_limits<unsigned int>::digits>=32,unsigned int,unsigned long>::type uint32;


  typedef conditional<std::numeric_limits<int>::digits>=16,int,long>::type int17;



  struct binary_t {};


  const binary_t binary = binary_t();



  struct expr
  {


   explicit expr(float f) : value_(f) {}



   operator float() const { return value_; }

  private:

   float value_;
  };





  template<typename T,typename,typename=void,typename=void> struct enable {};
  template<typename T> struct enable<T,half,void,void> { typedef T type; };
  template<typename T> struct enable<T,float,void,void> { typedef T type; };
  template<typename T> struct enable<T,double,void,void> { typedef T type; };
  template<typename T> struct enable<T,long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long,void,void> { typedef T type; };
  template<typename T> struct enable<T,int,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned int,void,void> { typedef T type; };
  template<typename T> struct enable<T,short,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned short,void,void> { typedef T type; };
  template<typename T> struct enable<T,char,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned char,void,void> { typedef T type; };
  template<typename T> struct enable<T,expr,void,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,void> { typedef T type; };
  template<typename T> struct enable<T,half,long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long,void> { typedef T type; };
  template<typename T> struct enable<T,half,int,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned int,void> { typedef T type; };
  template<typename T> struct enable<T,half,short,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned short,void> { typedef T type; };
  template<typename T> struct enable<T,half,char,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned char,void> { typedef T type; };
  template<typename T> struct enable<T,float,half,void> { typedef float type; };
  template<typename T> struct enable<T,half,float,void> { typedef float type; };
  template<typename T> struct enable<T,double,half,void> { typedef double type; };
  template<typename T> struct enable<T,half,double,void> { typedef double type; };
  template<typename T> struct enable<T,half,expr,void> { typedef T type; };
  template<typename T> struct enable<T,expr,half,void> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,half> { typedef T type; };
  template<typename T> struct enable<T,half,half,expr> { typedef T type; };
  template<typename T> struct enable<T,half,expr,half> { typedef T type; };
  template<typename T> struct enable<T,half,expr,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,half,half> { typedef T type; };
  template<typename T> struct enable<T,expr,half,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,half> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,expr> { typedef T type; };






  template<typename T,typename U> struct result : enable<expr,T,U> {};
  template<> struct result<half,half> { typedef half type; };
#444 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T> bool builtin_isinf(T arg)
  {





   return arg == std::numeric_limits<T>::infinity() || arg == -std::numeric_limits<T>::infinity();

  }






  template<typename T> bool builtin_isnan(T arg)
  {





   return arg != arg;

  }






  template<typename T> bool builtin_signbit(T arg)
  {



   return arg < T() || (arg == T() && T(1)/arg < T());

  }
#494 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<std::float_round_style R> uint16 float2half_impl(float value, true_type)
  {




   static const uint16 base_table[512] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
    0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
    0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
    0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
    0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };
   static const unsigned char shift_table[512] = {
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };
   uint32 bits;
   std::memcpy(&bits, &value, sizeof(float));
   uint16 hbits = base_table[bits>>23] + static_cast<uint16>((bits&0x7FFFFF)>>shift_table[bits>>23]);
   if(R == std::round_to_nearest)
    hbits += (((bits&0x7FFFFF)>>(shift_table[bits>>23]-1))|(((bits>>23)&0xFF)==102)) & ((hbits&0x7C00)!=0x7C00)

     & (((((static_cast<uint32>(1)<<(shift_table[bits>>23]-1))-1)&bits)!=0)|hbits)

    ;
   else if(R == std::round_toward_zero)
    hbits -= ((hbits&0x7FFF)==0x7C00) & ~shift_table[bits>>23];
   else if(R == std::round_toward_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=102)&
     ((bits>>23)!=0)))&(hbits<0x7C00)) - ((hbits==0xFC00)&((bits>>23)!=511));
   else if(R == std::round_toward_neg_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=358)&
     ((bits>>23)!=256)))&(hbits<0xFC00)&(hbits>>15)) - ((hbits==0x7C00)&((bits>>23)!=255));
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half_impl(float value, false_type)
  {
   uint16 hbits = builtin_signbit(value) << 15;
   if(value == 0.0f)
    return hbits;
   if(builtin_isnan(value))
    return hbits | 0x7FFF;
   if(builtin_isinf(value))
    return hbits | 0x7C00;
   int exp;
   std::frexp(value, &exp);
   if(exp > 16)
   {
    if(R == std::round_toward_zero)
     return hbits | 0x7BFF;
    else if(R == std::round_toward_infinity)
     return hbits | 0x7C00 - (hbits>>15);
    else if(R == std::round_toward_neg_infinity)
     return hbits | 0x7BFF + (hbits>>15);
    return hbits | 0x7C00;
   }
   if(exp < -13)
    value = std::ldexp(value, 24);
   else
   {
    value = std::ldexp(value, 11-exp);
    hbits |= ((exp+14)<<10);
   }
   int ival = static_cast<int>(value);
   hbits |= static_cast<uint16>(std::abs(ival)&0x3FF);
   if(R == std::round_to_nearest)
   {
    float diff = std::abs(value-static_cast<float>(ival));

     hbits += (diff>0.5f) | ((diff==0.5f)&hbits);



   }
   else if(R == std::round_toward_infinity)
    hbits += value > static_cast<float>(ival);
   else if(R == std::round_toward_neg_infinity)
    hbits += value < static_cast<float>(ival);
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half(float value)
  {
   return float2half_impl<R>(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool S,typename T> uint16 int2half_impl(T value)
  {
   if(S)
    value = -value;
   uint16 bits = S << 15;
   if(value > 65504)
   {
    if(R == std::round_toward_infinity)
     bits |= 0x7C00 - S;
    else if(R == std::round_toward_neg_infinity)
     bits |= 0x7BFF + S;
    else
     bits |= 0x7BFF + (R!=std::round_toward_zero);
   }
   else if(value)
   {
    unsigned int m = value, exp = 25;
    for(; m<0x400; m<<=1,--exp) ;
    for(; m>0x7FF; m>>=1,++exp) ;
    bits |= (exp<<10) | (m&0x3FF);
    if(exp > 25)
    {
     if(R == std::round_to_nearest)
      bits += (value>>(exp-26)) & 1

       & (((((1<<(exp-26))-1)&value)!=0)|bits)

      ;
     else if(R == std::round_toward_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & !S;
     else if(R == std::round_toward_neg_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & S;
    }
   }
   return bits;
  }






  template<std::float_round_style R,typename T> uint16 int2half(T value)
  {
   return (value<0) ? int2half_impl<R,true>(value) : int2half_impl<R,false>(value);
  }





  inline float half2float_impl(uint16 value, true_type)
  {




   static const uint32 mantissa_table[2048] = {
    0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
    0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
    0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
    0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
    0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
    0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
    0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
    0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
    0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
    0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
    0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
    0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
    0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
    0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
    0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
    0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
    0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
    0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
    0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
    0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
    0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
    0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
    0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
    0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
    0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
    0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
    0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
    0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
    0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
    0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
    0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
    0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
    0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
    0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
    0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
    0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
    0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
    0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
    0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
    0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
    0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
    0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
    0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
    0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
    0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
    0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
    0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
    0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
    0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
    0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
    0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
    0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
    0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
    0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
    0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
    0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
    0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
    0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
    0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
    0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
    0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
    0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
    0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
    0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
    0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
    0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
    0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
    0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
    0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
    0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
    0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
    0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
    0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
    0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
    0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
    0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
    0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
    0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
    0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
    0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
    0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
    0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
    0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
    0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
    0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
    0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
    0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
    0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
    0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
    0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
    0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
    0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
    0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
    0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
    0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
    0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
    0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
    0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
    0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
    0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
    0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
    0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
    0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
    0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
    0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
    0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
    0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
    0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
    0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
    0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
    0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
    0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
    0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
    0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
    0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
    0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
    0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
    0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
    0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
    0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
    0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
    0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
    0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
    0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
    0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
    0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
    0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
    0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
   static const uint32 exponent_table[64] = {
    0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
    0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
    0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
    0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
   static const unsigned short offset_table[64] = {
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
   uint32 bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];


   float out;
   std::memcpy(&out, &bits, sizeof(float));
   return out;
  }




  inline float half2float_impl(uint16 value, false_type)
  {
   float out;
   int abs = value & 0x7FFF;
   if(abs > 0x7C00)
    out = std::numeric_limits<float>::has_quiet_NaN ? std::numeric_limits<float>::quiet_NaN() : 0.0f;
   else if(abs == 0x7C00)
    out = std::numeric_limits<float>::has_infinity ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::max();
   else if(abs > 0x3FF)
    out = std::ldexp(static_cast<float>((value&0x3FF)|0x400), (abs>>10)-25);
   else
    out = std::ldexp(static_cast<float>(abs), -24);
   return (value&0x8000) ? -out : out;
  }




  inline float half2float(uint16 value)
  {
   return half2float_impl(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool E,typename T> T half2int_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   if(e >= 0x7C00)
    return (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
   if(e < 0x3800)
   {
    if(R == std::round_toward_infinity)
     return T(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     return -T(value>0x8000);
    return T();
   }
   int17 m = (value&0x3FF) | 0x400;
   e >>= 10;
   if(e < 25)
   {
    if(R == std::round_indeterminate || R == std::round_toward_zero)
     m >>= 25 - e;
    else
    {
     if(R == std::round_to_nearest)
      m += (1<<(24-e)) - (~(m>>(25-e))&E);
     else if(R == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(25-e))-1U);
     else if(R == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(25-e))-1U);
     m >>= 25 - e;
    }
   }
   else
    m <<= e - 25;


   return static_cast<T>((value&0x8000) ? -m : m);
  }






  template<std::float_round_style R,typename T> T half2int(uint16 value) { return half2int_impl<R,1,T>(value); }





  template<typename T> T half2int_up(uint16 value) { return half2int_impl<std::round_to_nearest,0,T>(value); }






  template<std::float_round_style R,bool E> uint16 round_half_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   uint16 result = value;
   if(e < 0x3C00)
   {
    result &= 0x8000;
    if(R == std::round_to_nearest)
     result |= 0x3C00U & -(e>=(0x3800+E));
    else if(R == std::round_toward_infinity)
     result |= 0x3C00U & -(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     result |= 0x3C00U & -(value>0x8000);
   }
   else if(e < 0x6400)
   {
    e = 25 - (e>>10);
    unsigned int mask = (1<<e) - 1;
    if(R == std::round_to_nearest)
     result += (1<<(e-1)) - (~(result>>e)&E);
    else if(R == std::round_toward_infinity)
     result += mask & ((value>>15)-1);
    else if(R == std::round_toward_neg_infinity)
     result += mask & -(value>>15);
    result &= ~mask;
   }
   return result;
  }





  template<std::float_round_style R> uint16 round_half(uint16 value) { return round_half_impl<R,1>(value); }




  inline uint16 round_half_up(uint16 value) { return round_half_impl<std::round_to_nearest,0>(value); }


  struct functions;
  template<typename> struct unary_specialized;
  template<typename,typename> struct binary_specialized;
  template<typename,typename,std::float_round_style> struct half_caster;
 }
#989 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
 class half
 {
  friend struct detail::functions;
  friend struct detail::unary_specialized<half>;
  friend struct detail::binary_specialized<half,half>;
  template<typename,typename,std::float_round_style> friend struct detail::half_caster;
  friend struct std::numeric_limits<half>;




 public:



  half() : data_() {}




  half(detail::expr rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }



  half(float rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }



  operator float() const {



            return xip_fpo_half_get_flt();

        }





  half& operator=(detail::expr rhs) { return *this = static_cast<float>(rhs); }





  template<typename T> typename detail::enable<half&,T>::type operator+=(T rhs) { return *this = *this + rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator-=(T rhs) { return *this = *this - rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator*=(T rhs) { return *this = *this * rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator/=(T rhs) { return *this = *this / rhs; }




  half& operator=(float rhs) {



                    xip_fpo_half_set_flt(rhs);

                    return *this;
                }
#1097 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  half& operator++() { return *this += 1.0f; }



  half& operator--() { return *this -= 1.0f; }



  half operator++(int) { half out(*this); ++*this; return out; }



  half operator--(int) { half out(*this); --*this; return out; }



        detail::uint16 get_bits() { return data_; }



        void set_bits(detail::uint16 bits) { data_ = bits; }





        xip_fpo_exc_t xip_fpo_get_data(xip_fpo_ptr op) const {
            int exc = 0;
            op->_xip_fpo_sign = ((data_ & 0x8000) ? -1 : 1);
            op->_xip_fpo_exp = ((data_ & 0x7C00) >> 10) - 14;
            *(op->_xip_fpo_d) = ((mp_limb_t)(data_ & 0x3FF) + (mp_limb_t)(0x400)) << (8*sizeof(*(op->_xip_fpo_d)) - 11);
            if ((data_ & 0x7C00) == 0) {
                exc |= 0x1;
                xip_fpo_set_zero(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) == 0x7C00) {
                exc |= 0x2;
                xip_fpo_set_inf(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) > 0x7C00) {
                exc |= 0x4;
                xip_fpo_set_nan(op);
            }
            return exc;
        }


        float xip_fpo_half_get_flt() const {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_exc_t exc = xip_fpo_get_data(op);
            float res;
            if (exc & 0x1) {
                res = (op->_xip_fpo_sign > 0 ? 0.0f : -0.0f);
            } else if (exc & 0x2) {
                res = (op->_xip_fpo_sign > 0 ? std::numeric_limits<float>::infinity() : -std::numeric_limits<float>::infinity());
            } else if (exc & 0x4) {
                res = std::numeric_limits<float>::quiet_NaN();
            } else {
                res = xip_fpo_get_flt(op);
            }
            xip_fpo_clear(op);
            return res;
        }



        void xip_fpo_set_data(xip_fpo_ptr op) {
            mpfr_t fr;
            (fr)->_mpfr_prec = (op)->_xip_fpo_mant_prec; (fr)->_mpfr_sign = (op)->_xip_fpo_sign; (fr)->_mpfr_exp = (op)->_xip_fpo_exp; (fr)->_mpfr_d = (op)->_xip_fpo_d;;
            data_ = 0;
            data_ |= (op->_xip_fpo_sign == 1 ? 0 : 1) << 15;
            if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+1)))) {
                data_ &= 0x8000;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+3)))) {
                data_ |= 0x7C00;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+2)))) {
                data_ |= 0x7E00;
            } else {
                data_ |= (op->_xip_fpo_exp + 14) << 10;
                data_ |= (*(op->_xip_fpo_d) << 1) >> (8*sizeof(*(op->_xip_fpo_d)) - 10);
            }
        }


        void xip_fpo_half_set_flt(float rhs) {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_set_flt(op, rhs);
            xip_fpo_set_data(op);
            xip_fpo_clear(op);
        }


        private:

  static const std::float_round_style round_style = (std::float_round_style)(1);



  half(detail::binary_t, detail::uint16 bits) : data_(bits) {}


  detail::uint16 data_;
 };



    template<typename F>
    half math_function_1arg(F f, half x) {
        half res;
        xip_fpo_t rop, xop;
        xip_fpo_inits2(5, 11, rop, xop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        f(rop, xop);
        res.xip_fpo_set_data(rop);
        xip_fpo_clears(rop, xop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    half binary_operator(F f, half x, half y) {
        half res;
        xip_fpo_t op, xop, yop;
        xip_fpo_inits2(5, 11, op, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(op, xop, yop);
        res.xip_fpo_set_data(op);
        xip_fpo_clears(op, xop, yop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    bool binary_operator_compare(F f, half x, half y) {
        int res;
        xip_fpo_t xop, yop;
        xip_fpo_inits2(5, 11, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(&res, xop, yop);
        xip_fpo_clears(xop, yop, (xip_fpo_ptr)0);
        return res;
    }
#1260 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
 namespace detail
 {

  struct functions
  {
#1273 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half plus(T1 x, T2 y) { return binary_operator(xip_fpo_add, x, y); }
   static float plus(float x, half y) { return xil_fpo_add_flt(x,y); }
   static float plus(half x, float y) { return xil_fpo_add_flt(x,y); }
   static double plus(double x, half y) { return xil_fpo_add_d(x,y); }
   static double plus(half x, double y) { return xil_fpo_add_d(x,y); }
#1289 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half minus(T1 x, T2 y) { return binary_operator(xip_fpo_sub, x, y); }
   static float minus(float x, half y) { return xil_fpo_sub_flt(x,y); }
   static float minus(half x, float y) { return xil_fpo_sub_flt(x,y); }
   static double minus(double x, half y) { return xil_fpo_sub_d(x,y); }
   static double minus(half x, double y) { return xil_fpo_sub_d(x,y); }
#1305 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half multiplies(T1 x, T2 y) { return binary_operator(xip_fpo_mul, x, y); }
   static float multiplies(float x, half y) { return xil_fpo_mul_flt(x,y); }
   static float multiplies(half x, float y) { return xil_fpo_mul_flt(x,y); }
   static double multiplies(double x, half y) { return xil_fpo_mul_d(x,y); }
   static double multiplies(half x, double y) { return xil_fpo_mul_d(x,y); }
#1321 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half divides(T1 x, T2 y) { return binary_operator(xip_fpo_div, x, y); }
   static float divides(float x, half y) { return xil_fpo_div_flt(x,y); }
   static float divides(half x, float y) { return xil_fpo_div_flt(x,y); }
   static double divides(double x, half y) { return xil_fpo_div_d(x,y); }
   static double divides(half x, double y) { return xil_fpo_div_d(x,y); }






   template<typename charT,typename traits> static std::basic_ostream<charT,traits>& write(std::basic_ostream<charT,traits> &out, float arg) { return out << arg; }





   template<typename charT,typename traits> static std::basic_istream<charT,traits>& read(std::basic_istream<charT,traits> &in, half &arg)
   {
    float f;
    if(in >> f)
     arg = f;
    return in;
   }





   static expr fmod(float x, float y) { return expr(std::fmod(x, y)); }





   static expr remainder(float x, float y)
   {



    if(builtin_isnan(x) || builtin_isnan(y))
     return expr(std::numeric_limits<float>::quiet_NaN());
    float ax = std::fabs(x), ay = std::fabs(y);
    if(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))
     return expr(std::numeric_limits<float>::quiet_NaN());
    if(ay >= 65536.0f)
     return expr(x);
    if(ax == ay)
     return expr(builtin_signbit(x) ? -0.0f : 0.0f);
    ax = std::fmod(ax, ay+ay);
    float y2 = 0.5f * ay;
    if(ax > y2)
    {
     ax -= ay;
     if(ax >= y2)
      ax -= ay;
    }
    return expr(builtin_signbit(x) ? -ax : ax);

   }






   static expr remquo(float x, float y, int *quo)
   {



    if(builtin_isnan(x) || builtin_isnan(y))
     return expr(std::numeric_limits<float>::quiet_NaN());
    bool sign = builtin_signbit(x), qsign = static_cast<bool>(sign^builtin_signbit(y));
    float ax = std::fabs(x), ay = std::fabs(y);
    if(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))
     return expr(std::numeric_limits<float>::quiet_NaN());
    if(ay >= 65536.0f)
     return expr(x);
    if(ax == ay)
     return *quo = qsign ? -1 : 1, expr(sign ? -0.0f : 0.0f);
    ax = std::fmod(ax, 8.0f*ay);
    int cquo = 0;
    if(ax >= 4.0f * ay)
    {
     ax -= 4.0f * ay;
     cquo += 4;
    }
    if(ax >= 2.0f * ay)
    {
     ax -= 2.0f * ay;
     cquo += 2;
    }
    float y2 = 0.5f * ay;
    if(ax > y2)
    {
     ax -= ay;
     ++cquo;
     if(ax >= y2)
     {
      ax -= ay;
      ++cquo;
     }
    }
    return *quo = qsign ? -cquo : cquo, expr(sign ? -ax : ax);

   }





   static expr fdim(float x, float y)
   {



    return expr((x<=y) ? 0.0f : (x-y));

   }

                        static expr maxmag(float x, float y)
                        {
    if (fabs(y)>fabs(x)) return expr(y);
    else return expr(x);
                        }

                        static expr minmag(float x, float y)
                        {
    if (fabs(y)<fabs(x)) return expr(y);
    else return expr(x);
                        }






   static expr fma(float x, float y, float z)
   {



    return expr(x*y+z);

   }



   static half nanh(const char*) { return half(binary, 0x7FFF); }




   static expr exp(float arg) { return expr(std::exp(arg)); }




   static expr expm1(float arg)
   {



    return expr(static_cast<float>(std::exp(static_cast<double>(arg))-1.0));

   }




   static expr exp2(float arg)
   {



    return expr(static_cast<float>(std::exp(arg*0.69314718055994530941723212145818)));

   }




   static expr log(float arg) { return expr(std::log(arg)); }




   static expr log10(float arg) { return expr(std::log10(arg)); }




   static expr log1p(float arg)
   {



    return expr(static_cast<float>(std::log(1.0+arg)));

   }




   static expr log2(float arg)
   {



    return expr(static_cast<float>(std::log(static_cast<double>(arg))*1.4426950408889634073599246810019));

   }

                        static expr logb(float arg)
                        {



                                return expr(static_cast<float>(std::log(static_cast<double>(fabs(arg)))*1.4426950408889634073599246810019));

                        }




   static expr sqrt(float arg) { return expr(std::sqrt(arg)); }




   static expr cbrt(float arg)
   {



    if(builtin_isnan(arg) || builtin_isinf(arg))
     return expr(arg);
    return expr(builtin_signbit(arg) ? -static_cast<float>(std::pow(std::fabs(static_cast<double>(arg)), 1.0/3.0)) :
     static_cast<float>(std::pow(static_cast<double>(arg), 1.0/3.0)));

   }





   static expr hypot(float x, float y)
   {



    return expr((builtin_isinf(x) || builtin_isinf(y)) ? std::numeric_limits<float>::infinity() :
     static_cast<float>(std::sqrt(static_cast<double>(x)*x+static_cast<double>(y)*y)));

   }





   static expr pow(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr powr(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr pown(float base, int exp) { return expr(std::pow(base, exp)); }
   static expr rootn(float base, int exp) { return expr(std::pow(base, float(float(1)/float(exp)))); }




   static expr sin(float arg) { return expr(std::sin(arg)); }




   static expr cos(float arg) { return expr(std::cos(arg)); }




   static expr tan(float arg) { return expr(std::tan(arg)); }




   static expr asin(float arg) { return expr(std::asin(arg)); }




   static expr acos(float arg) { return expr(std::acos(arg)); }




   static expr atan(float arg) { return expr(std::atan(arg)); }





   static expr atan2(float x, float y) { return expr(std::atan2(x, y)); }




   static expr sinh(float arg) { return expr(std::sinh(arg)); }




   static expr cosh(float arg) { return expr(std::cosh(arg)); }




   static expr tanh(float arg) { return expr(std::tanh(arg)); }




   static expr asinh(float arg)
   {



    return expr((arg==-std::numeric_limits<float>::infinity()) ? arg : static_cast<float>(std::log(arg+std::sqrt(arg*arg+1.0))));

   }




   static expr acosh(float arg)
   {



    return expr((arg<-1.0f) ? std::numeric_limits<float>::quiet_NaN() : static_cast<float>(std::log(arg+std::sqrt(arg*arg-1.0))));

   }




   static expr atanh(float arg)
   {



    return expr(static_cast<float>(0.5*std::log((1.0+arg)/(1.0-arg))));

   }




   static expr erf(float arg)
   {



    return expr(static_cast<float>(erf(static_cast<double>(arg))));

   }




   static expr erfc(float arg)
   {



    return expr(static_cast<float>(1.0-erf(static_cast<double>(arg))));

   }




   static expr lgamma(float arg)
   {



    if(builtin_isinf(arg))
     return expr(std::numeric_limits<float>::infinity());
    double z = static_cast<double>(arg);
    if(z < 0)
    {
     double i, f = std::modf(-z, &i);
     if(f == 0.0)
      return expr(std::numeric_limits<float>::infinity());
     return expr(static_cast<float>(1.1447298858494001741434273513531-std::log(std::abs(std::sin(3.1415926535897932384626433832795*f)))-lgamma(1.0-z)));
    }

     return expr(static_cast<float>(lgamma(static_cast<double>(arg))));
    return expr(static_cast<float>(0.5*(1.8378770664093454835606594728112-std::log(z))+z*(std::log(z+1.0/(12.0*z-1.0/(10.0*z)-1.0))-1.0)));

   }




   static expr tgamma(float arg)
   {



    double z = static_cast<double>(arg);
    if(z == 0.0)
     return builtin_signbit(z) ? expr(-std::numeric_limits<float>::infinity()) : expr(std::numeric_limits<float>::infinity());
    if(z < 0.0)
    {
     double i, f = std::modf(-z, &i);
     if(f == 0.0)
      return expr(std::numeric_limits<float>::quiet_NaN());
     double sign = (std::fmod(i, 2.0)==0.0) ? -1.0 : 1.0;
     return expr(static_cast<float>(sign*3.1415926535897932384626433832795/(std::sin(3.1415926535897932384626433832795*f)*std::exp(lgamma(1.0-z)))));
    }
    if(builtin_isinf(arg))
     return expr(arg);

     return expr(static_cast<float>(std::exp(lgamma(z))));
    return expr(static_cast<float>(std::sqrt(6.283185307179586476925286766559/z)*std::pow(0.36787944117144232159552377016146*(z+1.0/(12.0*z-1.0/(10.0*z))), z)));

   }




   static half floor(half arg) { return half(binary, round_half<std::round_toward_neg_infinity>(arg.data_)); }




   static half ceil(half arg) { return half(binary, round_half<std::round_toward_infinity>(arg.data_)); }




   static half trunc(half arg) { return half(binary, round_half<std::round_toward_zero>(arg.data_)); }




   static half round(half arg) { return half(binary, round_half_up(arg.data_)); }




   static long lround(half arg) { return detail::half2int_up<long>(arg.data_); }




   static half rint(half arg) { return half(binary, round_half<half::round_style>(arg.data_)); }




   static long lrint(half arg) { return detail::half2int<half::round_style,long>(arg.data_); }
#1801 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
   static half frexp(half arg, int *exp)
   {
    unsigned int m = arg.data_ & 0x7FFF;
    if(m >= 0x7C00 || !m)
     return *exp = 0, arg;
    int e = m >> 10;
    if(!e)
     for(m<<=1; m<0x400; m<<=1,--e) ;
    return *exp = e-14, half(binary, static_cast<uint16>((arg.data_&0x8000)|0x3800|(m&0x3FF)));
   }





   static half modf(half arg, half *iptr)
   {
    unsigned int e = arg.data_ & 0x7C00;
    if(e > 0x6000)
     return *iptr = arg, (e==0x7C00&&(arg.data_&0x3FF)) ? arg : half(binary, arg.data_&0x8000);
    if(e < 0x3C00)
     return iptr->data_ = arg.data_ & 0x8000, arg;
    e >>= 10;
    unsigned int mask = (1<<(25-e)) - 1, m = arg.data_ & mask;
    iptr->data_ = arg.data_ & ~mask;
    if(!m)
     return half(binary, arg.data_&0x8000);
    for(; m<0x400; m<<=1,--e) ;
    return half(binary, static_cast<uint16>((arg.data_&0x8000)|(e<<10)|(m&0x3FF)));
   }





   static half scalbln(half arg, long exp)
   {
    long e = arg.data_ & 0x7C00;
    if(e == 0x7C00)
     return arg;
    unsigned int m = arg.data_ & 0x3FF;
    if(e >>= 10)
     m |= 0x400;
    else
    {
     if(!m)
      return arg;
     for(m<<=1; m<0x400; m<<=1,--e) ;
    }
    e += exp;
    uint16 value = arg.data_ & 0x8000;
    if(e > 30)
    {
     if(half::round_style == std::round_toward_zero)
      value |= 0x7BFF;
     else if(half::round_style == std::round_toward_infinity)
      value |= 0x7C00 - (value>>15);
     else if(half::round_style == std::round_toward_neg_infinity)
      value |= 0x7BFF + (value>>15);
     else
      value |= 0x7C00;
    }
    else if(e > 0)
     value |= (e<<10) | (m&0x3FF);
    else if(e > -11)
    {
     if(half::round_style == std::round_to_nearest)
     {
      m += 1 << -e;

      m -= (m>>(1-e)) & 1;

     }
     else if(half::round_style == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(1-e))-1U);
     else if(half::round_style == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(1-e))-1U);
     value |= m >> (1-e);
    }
    else if(half::round_style == std::round_toward_infinity)
     value |= ((value>>15)-1) & 1;
    else if(half::round_style == std::round_toward_neg_infinity)
     value |= value >> 15;
    return half(binary, value);
   }




   static int ilogb(half arg)
   {
    int exp = arg.data_ & 0x7FFF;
    if(!exp)
     return (-2147483647 - 1);
    if(exp < 0x7C00)
    {
     if(!(exp>>=10))
      for(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;
     return exp - 15;
    }
    if(exp > 0x7C00)
     return (-2147483647 - 1);
    return 2147483647;
   }




   static half nextafter(half from, half to)
   {
    uint16 fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;
    if(fabs > 0x7C00)
     return from;
    if(tabs > 0x7C00 || from.data_ == to.data_ || !(fabs|tabs))
     return to;
    if(!fabs)
     return half(binary, (to.data_&0x8000)+1);
    bool lt = (signbit(from) ? (static_cast<int17>(0x8000)-from.data_) : static_cast<int17>(from.data_)) <
     (signbit(to) ? (static_cast<int17>(0x8000)-to.data_) : static_cast<int17>(to.data_));
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lt))<<1)-1);
   }





   static half nexttoward(half from, long double to)
   {
    if(isnan(from))
     return from;
    long double lfrom = static_cast<long double>(from);
    if(builtin_isnan(to) || lfrom == to)
     return half(static_cast<float>(to));
    if(!(from.data_&0x7FFF))
     return half(binary, (static_cast<detail::uint16>(builtin_signbit(to))<<15)+1);
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lfrom<to))<<1)-1);
   }





   static half copysign(half x, half y) { return half(binary, x.data_^((x.data_^y.data_)&0x8000)); }





   static int fpclassify(half arg)
   {
    unsigned int abs = arg.data_ & 0x7FFF;
    if(abs > 0x7C00)
     return 0;
    if(abs == 0x7C00)
     return 1;
    if(abs > 0x3FF)
     return 4;
    return abs ? 3 : 2;
   }





   static bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }





   static bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }





   static bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }





   static bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }





   static bool signbit(half arg) { return (arg.data_&0x8000) != 0; }
#1999 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_equal, x, y); }
   static bool isequal(float x, half y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(half x, float y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(double x, half y) { return xil_fpo_equal_d(x,y); }
   static bool isequal(half x, double y) { return xil_fpo_equal_d(x,y); }
#2015 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isnotequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_notequal, x, y); }
   static bool isnotequal(float x, half y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(half x, float y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(double x, half y) { return xil_fpo_notequal_d(x,y); }
   static bool isnotequal(half x, double y) { return xil_fpo_notequal_d(x,y); }
#2032 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreater(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greater, x, y); }
   static bool isgreater(float x, half y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(half x, float y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(double x, half y) { return xil_fpo_greater_d(x,y); }
   static bool isgreater(half x, double y) { return xil_fpo_greater_d(x,y); }
#2049 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreaterequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greaterequal, x, y); }
   static bool isgreaterequal(float x, half y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(half x, float y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(double x, half y) { return xil_fpo_greaterequal_d(x,y); }
   static bool isgreaterequal(half x, double y) { return xil_fpo_greaterequal_d(x,y); }
#2066 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isless(T1 x, T2 y) { return binary_operator_compare(xip_fpo_less, x, y); }
   static bool isless(float x, half y) { return xil_fpo_less_flt(x,y); }
   static bool isless(half x, float y) { return xil_fpo_less_flt(x,y); }
   static bool isless(double x, half y) { return xil_fpo_less_d(x,y); }
   static bool isless(half x, double y) { return xil_fpo_less_d(x,y); }
#2083 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool islessequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_lessequal, x, y); }
   static bool islessequal(float x, half y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(half x, float y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(double x, half y) { return xil_fpo_lessequal_d(x,y); }
   static bool islessequal(half x, double y) { return xil_fpo_lessequal_d(x,y); }







   static bool islessgreater(half x, half y)
   {
    if(isnan(x) || isnan(y))
     return false;



                return isless(x, y) || isgreater(x, y);
   }






   static bool isunordered(half x, half y) { return isnan(x) || isnan(y); }

  private:
   static double erf(double arg)
   {
    if(builtin_isinf(arg))
     return (arg<0.0) ? -1.0 : 1.0;
    double x2 = static_cast<double>(arg) * static_cast<double>(arg), ax2 = 0.147 * x2;
    double value = std::sqrt(1.0-std::exp(-x2*(1.2732395447351626861510701069801+ax2)/(1.0+ax2)));
    return builtin_signbit(arg) ? -value : value;
   }

   static double lgamma(double arg)
   {
    double v = 1.0;
    for(; arg<8.0; ++arg) v *= arg;
    double w = 1.0 / (arg * arg);
    return (((((((-0.02955065359477124183006535947712*w+0.00641025641025641025641025641026)*w+
     -0.00191752691752691752691752691753)*w+8.4175084175084175084175084175084e-4)*w+
     -5.952380952380952380952380952381e-4)*w+7.9365079365079365079365079365079e-4)*w+
     -0.00277777777777777777777777777778)*w+0.08333333333333333333333333333333)/arg +
     0.91893853320467274178032973640562 - std::log(v) - arg + (arg-0.5) * std::log(arg);
   }
  };



  template<typename T> struct unary_specialized
  {



   static half negate(half arg) { return half(binary, arg.data_^0x8000); }




   static half fabs(half arg) { return half(binary, arg.data_&0x7FFF); }
  };
  template<> struct unary_specialized<expr>
  {
   static expr negate(float arg) { return expr(-arg); }
   static expr fabs(float arg) { return expr(std::fabs(arg)); }
  };




  template<typename T,typename U> struct binary_specialized
  {




   static expr fmin(float x, float y)
   {



    if(builtin_isnan(x))
     return expr(y);
    if(builtin_isnan(y))
     return expr(x);
    return expr(std::min(x, y));

   }





   static expr fmax(float x, float y)
   {



    if(builtin_isnan(x))
     return expr(y);
    if(builtin_isnan(y))
     return expr(x);
    return expr(std::max(x, y));

   }
  };
  template<> struct binary_specialized<half,half>
  {
   static half fmin(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) >
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
   static half fmax(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) <
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
  };







  template<typename T,typename U,std::float_round_style R=(std::float_round_style)(1)> struct half_caster {};
  template<typename U,std::float_round_style R> struct half_caster<half,U,R>
  {




   typedef half type;
   static half cast(U arg) { return cast_impl(arg, is_float<U>()); };

  private:
   static half cast_impl(U arg, true_type) { return half(binary, float2half<R>(static_cast<float>(arg))); }
   static half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,half,R>
  {




   typedef T type;
   template<typename U> static T cast(U arg) { return cast_impl(arg, is_float<T>()); }

  private:
   static T cast_impl(float arg, true_type) { return static_cast<T>(arg); }
   static T cast_impl(half arg, false_type) { return half2int<R,T>(arg.data_); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,expr,R> : public half_caster<T,half,R> {};
  template<std::float_round_style R> struct half_caster<half,half,R>
  {
   typedef half type;
   static half cast(half arg) { return arg; }
  };
  template<std::float_round_style R> struct half_caster<half,expr,R> : public half_caster<half,half,R> {};
#2269 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,typename U> typename enable<bool,T,U>::type operator==(T x, U y) { return functions::isequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator!=(T x, U y) { return functions::isnotequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<(T x, U y) { return functions::isless(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>(T x, U y) { return functions::isgreater(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<=(T x, U y) { return functions::islessequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>=(T x, U y) { return functions::isgreaterequal(x, y); }
#2317 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }
#2327 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }
#2337 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }
#2347 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }





  template<typename T> typename enable<T,T>::type operator+(T arg) { return arg; }




  template<typename T> typename enable<T,T>::type operator-(T arg) { return unary_specialized<T>::negate(arg); }
#2368 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,typename charT,typename traits> typename enable<std::basic_ostream<charT,traits>&,T>::type
   operator<<(std::basic_ostream<charT,traits> &out, T arg) { return functions::write(out, arg); }





  template<typename charT,typename traits> std::basic_istream<charT,traits>&
   operator>>(std::basic_istream<charT,traits> &in, half &arg) { return functions::read(in, arg); }
#2386 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline half abs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr abs(expr arg) { return unary_specialized<expr>::fabs(arg); }





  inline half fabs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr fabs(expr arg) { return unary_specialized<expr>::fabs(arg); }






  inline expr fmod(half x, half y) { return functions::fmod(x, y); }
  inline expr fmod(half x, expr y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, half y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, expr y) { return functions::fmod(x, y); }






  inline expr remainder(half x, half y) { return functions::remainder(x, y); }
  inline expr remainder(half x, expr y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, half y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, expr y) { return functions::remainder(x, y); }







  inline expr remquo(half x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(half x, expr y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, expr y, int *quo) { return functions::remquo(x, y, quo); }







  inline expr fma(half x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, expr z) { return functions::fma(x, y, z); }

                inline expr mad(half x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, expr z) { return functions::fma(x, y, z); }






  inline half fmax(half x, half y) { return binary_specialized<half,half>::fmax(x, y); }
  inline expr fmax(half x, expr y) { return binary_specialized<half,expr>::fmax(x, y); }
  inline expr fmax(expr x, half y) { return binary_specialized<expr,half>::fmax(x, y); }
  inline expr fmax(expr x, expr y) { return binary_specialized<expr,expr>::fmax(x, y); }






  inline half fmin(half x, half y) { return binary_specialized<half,half>::fmin(x, y); }
  inline expr fmin(half x, expr y) { return binary_specialized<half,expr>::fmin(x, y); }
  inline expr fmin(expr x, half y) { return binary_specialized<expr,half>::fmin(x, y); }
  inline expr fmin(expr x, expr y) { return binary_specialized<expr,expr>::fmin(x, y); }






  inline expr fdim(half x, half y) { return functions::fdim(x, y); }
  inline expr fdim(half x, expr y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, half y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, expr y) { return functions::fdim(x, y); }

                inline expr maxmag(half x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(half x, expr y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, expr y) { return functions::maxmag(x, y); }

                inline expr minmag(half x, half y) { return functions::minmag(x, y); }
                inline expr minmag(half x, expr y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, half y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, expr y) { return functions::minmag(x, y); }




  inline half nanh(const char *arg) { return functions::nanh(arg); }
#2504 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline expr exp(half arg) { return functions::exp(arg); }
  inline expr exp(expr arg) { return functions::exp(arg); }





  inline expr expm1(half arg) { return functions::expm1(arg); }
  inline expr expm1(expr arg) { return functions::expm1(arg); }





  inline expr exp2(half arg) { return functions::exp2(arg); }
  inline expr exp2(expr arg) { return functions::exp2(arg); }





  inline expr log(half arg) { return functions::log(arg); }
  inline expr log(expr arg) { return functions::log(arg); }





  inline expr log10(half arg) { return functions::log10(arg); }
  inline expr log10(expr arg) { return functions::log10(arg); }





  inline expr log1p(half arg) { return functions::log1p(arg); }
  inline expr log1p(expr arg) { return functions::log1p(arg); }





  inline expr log2(half arg) { return functions::log2(arg); }
  inline expr log2(expr arg) { return functions::log2(arg); }
#2560 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline half sqrt(half arg) { return math_function_1arg(xip_fpo_sqrt, arg); }

  inline expr sqrt(expr arg) { return functions::sqrt(arg); }





  inline expr cbrt(half arg) { return functions::cbrt(arg); }
  inline expr cbrt(expr arg) { return functions::cbrt(arg); }






  inline expr hypot(half x, half y) { return functions::hypot(x, y); }
  inline expr hypot(half x, expr y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, half y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, expr y) { return functions::hypot(x, y); }






  inline expr pow(half base, half exp) { return functions::pow(base, exp); }
  inline expr pow(half base, expr exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, half exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, expr exp) { return functions::pow(base, exp); }
                inline expr powr(half base, half exp) { return functions::powr(base, exp); }
                inline expr powr(half base, expr exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, half exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, expr exp) { return functions::powr(base, exp); }
                inline expr pown(half base, int exp) { return functions::pown(base, exp); }
                inline expr pown(expr base, int exp) { return functions::pown(base, exp); }
#2605 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline expr sin(half arg) { return functions::sin(arg); }
  inline expr sin(expr arg) { return functions::sin(arg); }





  inline expr cos(half arg) { return functions::cos(arg); }
  inline expr cos(expr arg) { return functions::cos(arg); }





  inline expr tan(half arg) { return functions::tan(arg); }
  inline expr tan(expr arg) { return functions::tan(arg); }





  inline expr asin(half arg) { return functions::asin(arg); }
  inline expr asin(expr arg) { return functions::asin(arg); }





  inline expr acos(half arg) { return functions::acos(arg); }
  inline expr acos(expr arg) { return functions::acos(arg); }





  inline expr atan(half arg) { return functions::atan(arg); }
  inline expr atan(expr arg) { return functions::atan(arg); }






  inline expr atan2(half x, half y) { return functions::atan2(x, y); }
  inline expr atan2(half x, expr y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, half y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, expr y) { return functions::atan2(x, y); }
#2661 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline expr sinh(half arg) { return functions::sinh(arg); }
  inline expr sinh(expr arg) { return functions::sinh(arg); }





  inline expr cosh(half arg) { return functions::cosh(arg); }
  inline expr cosh(expr arg) { return functions::cosh(arg); }





  inline expr tanh(half arg) { return functions::tanh(arg); }
  inline expr tanh(expr arg) { return functions::tanh(arg); }





  inline expr asinh(half arg) { return functions::asinh(arg); }
  inline expr asinh(expr arg) { return functions::asinh(arg); }





  inline expr acosh(half arg) { return functions::acosh(arg); }
  inline expr acosh(expr arg) { return functions::acosh(arg); }





  inline expr atanh(half arg) { return functions::atanh(arg); }
  inline expr atanh(expr arg) { return functions::atanh(arg); }
#2707 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline expr erf(half arg) { return functions::erf(arg); }
  inline expr erf(expr arg) { return functions::erf(arg); }





  inline expr erfc(half arg) { return functions::erfc(arg); }
  inline expr erfc(expr arg) { return functions::erfc(arg); }





                inline expr lgamma_r(half arg, int *signgamp) { return functions::lgamma(arg); }
                inline expr lgamma_r(expr arg, int *signgamp) { return functions::lgamma(arg); }
  inline expr lgamma(half arg) { return functions::lgamma(arg); }
  inline expr lgamma(expr arg) { return functions::lgamma(arg); }





  inline expr tgamma(half arg) { return functions::tgamma(arg); }
  inline expr tgamma(expr arg) { return functions::tgamma(arg); }
#2741 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline half ceil(half arg) { return functions::ceil(arg); }
  inline half ceil(expr arg) { return functions::ceil(arg); }





  inline half floor(half arg) { return functions::floor(arg); }
  inline half floor(expr arg) { return functions::floor(arg); }





  inline half trunc(half arg) { return functions::trunc(arg); }
  inline half trunc(expr arg) { return functions::trunc(arg); }





  inline half round(half arg) { return functions::round(arg); }
  inline half round(expr arg) { return functions::round(arg); }





  inline long lround(half arg) { return functions::lround(arg); }
  inline long lround(expr arg) { return functions::lround(arg); }





  inline half nearbyint(half arg) { return functions::rint(arg); }
  inline half nearbyint(expr arg) { return functions::rint(arg); }





  inline half rint(half arg) { return functions::rint(arg); }
  inline half rint(expr arg) { return functions::rint(arg); }





  inline long lrint(half arg) { return functions::lrint(arg); }
  inline long lrint(expr arg) { return functions::lrint(arg); }
#2817 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline half frexp(half arg, int *exp) { return functions::frexp(arg, exp); }
  inline half frexp(expr arg, int *exp) { return functions::frexp(arg, exp); }






  inline half ldexp(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half ldexp(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half modf(half arg, half *iptr) { return functions::modf(arg, iptr); }
  inline half modf(expr arg, half *iptr) { return functions::modf(arg, iptr); }






  inline half scalbn(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half scalbn(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half scalbln(half arg, long exp) { return functions::scalbln(arg, exp); }
  inline half scalbln(expr arg, long exp) { return functions::scalbln(arg, exp); }
#2859 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline int ilogb(half arg) { return functions::ilogb(arg); }
  inline int ilogb(expr arg) { return functions::ilogb(arg); }





  inline half logb(half arg) { return functions::logb(arg); }
  inline half logb(expr arg) { return functions::logb(arg); }






  inline half nextafter(half from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(half from, expr to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, expr to) { return functions::nextafter(from, to); }






  inline half nexttoward(half from, long double to) { return functions::nexttoward(from, to); }
  inline half nexttoward(expr from, long double to) { return functions::nexttoward(from, to); }






  inline half copysign(half x, half y) { return functions::copysign(x, y); }
  inline half copysign(half x, expr y) { return functions::copysign(x, y); }
  inline half copysign(expr x, half y) { return functions::copysign(x, y); }
  inline half copysign(expr x, expr y) { return functions::copysign(x, y); }
#2910 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline int fpclassify(half arg) { return functions::fpclassify(arg); }
  inline int fpclassify(expr arg) { return functions::fpclassify(arg); }






  inline bool isfinite(half arg) { return functions::isfinite(arg); }
  inline bool isfinite(expr arg) { return functions::isfinite(arg); }






  inline bool isinf(half arg) { return functions::isinf(arg); }
  inline bool isinf(expr arg) { return functions::isinf(arg); }






  inline bool isnan(half arg) { return functions::isnan(arg); }
  inline bool isnan(expr arg) { return functions::isnan(arg); }






  inline bool isnormal(half arg) { return functions::isnormal(arg); }
  inline bool isnormal(expr arg) { return functions::isnormal(arg); }






  inline bool signbit(half arg) { return functions::signbit(arg); }
  inline bool signbit(expr arg) { return functions::signbit(arg); }
#2963 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  inline bool isgreater(half x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(half x, expr y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, expr y) { return functions::isgreater(x, y); }







  inline bool isgreaterequal(half x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(half x, expr y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, expr y) { return functions::isgreaterequal(x, y); }







  inline bool isless(half x, half y) { return functions::isless(x, y); }
  inline bool isless(half x, expr y) { return functions::isless(x, y); }
  inline bool isless(expr x, half y) { return functions::isless(x, y); }
  inline bool isless(expr x, expr y) { return functions::isless(x, y); }







  inline bool islessequal(half x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(half x, expr y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, expr y) { return functions::islessequal(x, y); }







  inline bool islessgreater(half x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(half x, expr y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, expr y) { return functions::islessgreater(x, y); }







  inline bool isunordered(half x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(half x, expr y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, expr y) { return functions::isunordered(x, y); }
#3040 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,typename U> typename half_caster<T,U>::type half_cast(U arg) { return half_caster<T,U>::cast(arg); }
#3057 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  template<typename T,std::float_round_style R,typename U> typename half_caster<T,U,R>::type half_cast(U arg)
   { return half_caster<T,U,R>::cast(arg); }

 }

 using detail::operator==;
 using detail::operator!=;
 using detail::operator<;
 using detail::operator>;
 using detail::operator<=;
 using detail::operator>=;
 using detail::operator+;
 using detail::operator-;
 using detail::operator*;
 using detail::operator/;
 using detail::operator<<;
 using detail::operator>>;
#3135 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
  using detail::fpclassify;
  using detail::isfinite;
  using detail::isinf;
  using detail::isnan;
  using detail::isnormal;
  using detail::signbit;
  using detail::isgreater;
  using detail::isgreaterequal;
  using detail::isless;
  using detail::islessequal;
  using detail::islessgreater;
  using detail::isunordered;

 using detail::half_cast;


namespace std
{



 template<> struct numeric_limits<half> : public numeric_limits<float>
 {
 public:

  static const bool is_signed = true;


  static const bool is_exact = false;


  static const bool is_modulo = false;


  static const bool is_iec559 = true;


  static const bool has_infinity = true;


  static const bool has_quiet_NaN = true;


  static const float_denorm_style has_denorm = denorm_present;





  static const float_round_style round_style = (std::numeric_limits<float>::round_style==
   half::round_style) ? half::round_style : round_indeterminate;


  static const int digits = 11;


  static const int digits10 = 3;


  static const int max_digits10 = 5;


  static const int radix = 2;


  static const int min_exponent = -13;


  static const int min_exponent10 = -4;


  static const int max_exponent = 16;


  static const int max_exponent10 = 4;


  static half min() throw() { return half(detail::binary, 0x0400); }


  static half lowest() throw() { return half(detail::binary, 0xFBFF); }


  static half max() throw() { return half(detail::binary, 0x7BFF); }


  static half epsilon() throw() { return half(detail::binary, 0x1400); }


  static half round_error() throw()
   { return half(detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }


  static half infinity() throw() { return half(detail::binary, 0x7C00); }


  static half quiet_NaN() throw() { return half(detail::binary, 0x7FFF); }


  static half signaling_NaN() throw() { return half(detail::binary, 0x7DFF); }


  static half denorm_min() throw() { return half(detail::binary, 0x0001); }
 };
#3258 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
}
#3274 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h"
extern half half_nan(const char *tagp);





extern half half_atan(half t);
extern half half_atan2(half y, half x);
extern half half_copysign(half x, half y);

extern half half_fabs(half x);

extern half half_abs(half x);
extern half half_fma(half x, half y, half z);
extern half half_mad(half x, half y, half z);
extern half half_frexp (half x, int* exp);
extern half half_ldexp (half x, int exp);
extern half half_fmax(half x, half y);

extern half half_fmin(half x, half y);

extern half half_asin(half t_in);
extern half half_acos(half t_in);
extern half half_sin(half t_in);
extern half half_cos(half t_in);
extern void half_sincos(half x, half *sin, half *cos);
extern half half_sinh(half t_in);
extern half half_cosh(half t_in);
extern half half_sinpi(half t_in);
extern half half_cospi(half t_in);
extern half half_recip(half x);
extern half half_sqrt(half x);
extern half half_rsqrt(half x);
extern half half_cbrt(half x);
extern half half_hypot(half x, half y);
extern half half_log(half x);
extern half half_log10(half x);
extern half half_log2(half x);
extern half half_logb(half x);
extern half half_log1p(half x);
extern half half_exp(half x);
extern half half_exp10(half x);
extern half half_exp2(half x);
extern half half_expm1(half x);
extern half half_pow(half x, half y);
extern half half_powr(half x, half y);
extern half half_pown(half x, int y);
extern half half_rootn(half x, int y);
extern half half_floor(half x);

extern half half_ceil(half x);

extern half half_trunc(half x);

extern half half_round(half x);

extern half half_nearbyint(half x);
extern half half_rint(half x);
extern long int half_lrint(half x);
extern long long int half_llrint(half x);
extern long int half_lround(half x);
extern long long int half_llround(half x);
extern half half_modf(half x, half *intpart);

extern half half_fract(half x, half *intpart);
extern half half_nextafter(half x, half y);
extern half half_fmod(half x, half y);
extern half half_remainder(half x, half y);
extern half half_remquo(half x, half y, int* quo);
extern half half_divide(half x, half y);
#75 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_int.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h" 1
#97 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include-fixed/limits.h" 1 3 4
#98 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h" 1
#82 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_half.h" 1
#83 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h" 2
#107 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
namespace AESL_std {
    template <class DataType>
    DataType inline min(DataType a, DataType b) {


        return (a>=b) ? b : a;
    }

    template <class DataType>
    DataType inline max(DataType a, DataType b) {


        return (a>=b) ? a : b;
    }
}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cassert" 1 3
#43 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cassert" 3

#44 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cassert" 3

#1 "/usr/include/assert.h" 1 3 4
#45 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cassert" 2 3
#124 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h" 2




#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstring" 3
#129 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
#130 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 1 3
#38 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3

#39 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
#48 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
#94 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
#125 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
#162 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
#193 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
#223 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }
#320 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
#131 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h" 2


template<int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64> class ap_private;
namespace ap_private_ops {

static inline uint32_t Hi_32(uint64_t Value) {
    return static_cast<uint32_t>(Value >> 32);
}


static inline uint32_t Lo_32(uint64_t Value) {
    return static_cast<uint32_t>(Value);
}

template<int _AP_W>
inline bool isNegative(const ap_private<_AP_W, false>& a) {
    return false;
}


template<int _AP_W>
inline bool isNegative(const ap_private<_AP_W, true>& a) {
    enum {APINT_BITS_PER_WORD=64,_AP_N=(_AP_W+APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD};
    static const uint64_t sign_mask = 1ULL << ((_AP_W - 1) %APINT_BITS_PER_WORD);
 return (sign_mask & a.get_pVal(_AP_N-1)) != 0;
}





static inline unsigned CountLeadingZeros_32(uint32_t Value) {
    unsigned Count;



    if (Value == 0) return 32;

    Count = __builtin_clz(Value);
#183 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    return Count;
}





static inline unsigned CountLeadingZeros_64(uint64_t Value) {
    unsigned Count;



    if (!Value) return 64;

    Count = __builtin_clzll(Value);
#227 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    return Count;
}





static inline unsigned CountTrailingZeros_64(uint64_t Value) {

    return (Value != 0) ? __builtin_ctzll(Value) : 64;
#247 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
}



static inline unsigned CountPopulation_64(uint64_t Value) {

    return __builtin_popcountll(Value);






}

static inline uint32_t countLeadingOnes_64(uint64_t __V, uint32_t skip) {
    uint32_t Count = 0;
    if (skip)
        (__V) <<= (skip);
    while (__V && (__V & (1ULL << 63))) {
        Count++;
        (__V) <<= 1;
    }
    return Count;
}

static inline std::string oct2Bin(char oct) {
    switch (oct) {
        case '\0': {
            return "";
        }
        case '.': {
            return ".";
        }
        case '0': {
            return "000";
        }
        case '1': {
            return "001";
        }
        case '2': {
            return "010";
        }
        case '3': {
            return "011";
        }
        case '4': {
            return "100";
        }
        case '5': {
            return "101";
        }
        case '6': {
            return "110";
        }
        case '7': {
            return "111";
        }
    }

    ((0 && "Invalid character in digit string") ? static_cast<void> (0) : __assert_fail ("0 && \"Invalid character in digit string\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 307, __PRETTY_FUNCTION__));
    return "";
}

static inline std::string hex2Bin(char hex) {
    switch (hex) {
        case '\0': {
            return "";
        }
        case '.': {
            return ".";
        }
        case '0': {
            return "0000";
        }
        case '1': {
            return "0001";
        }
        case '2': {
            return "0010";
        }
        case '3': {
            return "0011";
        }
        case '4': {
            return "0100";
        }
        case '5': {
            return "0101";
        }
        case '6': {
            return "0110";
        }
        case '7': {
            return "0111";
        }
        case '8': {
            return "1000";
        }
        case '9': {
            return "1001";
        }
        case 'A':
        case 'a': {
            return "1010";
        }
        case 'B':
        case 'b': {
            return "1011";
        }
        case 'C':
        case 'c': {
            return "1100";
        }
        case 'D':
        case 'd': {
            return "1101";
        }
        case 'E':
        case 'e': {
            return "1110";
        }
        case 'F':
        case 'f': {
            return "1111";
        }
    }
    ((0 && "Invalid character in digit string") ? static_cast<void> (0) : __assert_fail ("0 && \"Invalid character in digit string\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 374, __PRETTY_FUNCTION__));
    return "";
}

static inline uint32_t decode_digit(char cdigit, int radix) {
    uint32_t digit = 0;
    if (radix == 16) {


            if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F')))
                ((0 && "Invalid hex digit in string") ? static_cast<void> (0) : __assert_fail ("0 && \"Invalid hex digit in string\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 384, __PRETTY_FUNCTION__));
            if (((cdigit) >= '0' && (cdigit) <= '9'))
                digit = cdigit - '0';
            else if (cdigit >= 'a')
                digit = cdigit - 'a' + 10;
            else if (cdigit >= 'A')
                digit = cdigit - 'A' + 10;
            else
                ((0 && "huh? we shouldn't get here") ? static_cast<void> (0) : __assert_fail ("0 && \"huh? we shouldn't get here\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 392, __PRETTY_FUNCTION__));
        } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
            digit = cdigit - '0';
        } else {
            ((0 && "Invalid character in digit string") ? static_cast<void> (0) : __assert_fail ("0 && \"Invalid character in digit string\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 396, __PRETTY_FUNCTION__));
        }


        return digit;
}


static inline std::string parseString(const std::string& input, int& radix) {

    size_t len = input.length();
    if(len == 0) return input;

    size_t startPos = 0;

    while(input[startPos] == ' ' && startPos < len) startPos++;
    while(input[len-1] == ' ' && startPos < len) len--;

    std::string val = input.substr(startPos, len-startPos);

    len = val.length();
    startPos = 0;



    if (len < 2)
        return val;

    bool isNegative = false;
    std::string ans;


    if (val[0] == '-') {
        ans = "-";
        ++startPos;
        isNegative = true;
    } else if (val[0] == '+')
        ++startPos;

    if (len - startPos < 2)
        return val;

    if (val.substr(startPos, 2) == "0x" || val.substr(startPos, 2) == "0X") {

        radix = 16;
        startPos += 2;
    } else if (val.substr(startPos, 2) == "0b" || val.substr(startPos, 2) == "0B") {

        radix = 2;
        startPos += 2;
    } if (val.substr(startPos, 2) == "0o" || val.substr(startPos, 2) == "0O") {

        radix = 8;
        startPos += 2;
    }

    int exp = 0;
    if (radix == 10) {


        size_t expPos = val.find('e');
        bool has_exponent = true;
        if (expPos == std::string::npos)
            expPos = val.find('E');
        if (expPos == std::string::npos) {

            expPos = len;
            has_exponent = false;
        }


        ans += val.substr(startPos, expPos-startPos);
        if(has_exponent) {

            std::istringstream iss(val.substr(expPos+1, len-expPos-1));
            iss >> exp;
        }
    } else {

        size_t expPos = val.find('p');
        bool has_exponent = true;
        if (expPos == std::string::npos)
            expPos = val.find('P');
        if (expPos == std::string::npos) {

            expPos = len;
            has_exponent = false;
        }



        ((startPos <= expPos) ? static_cast<void> (0) : __assert_fail ("startPos <= expPos", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 487, __PRETTY_FUNCTION__));

        for (size_t i=startPos; i<expPos; ++i) {
            if(radix == 16) {
                ans += hex2Bin(val[i]);
            } else if(radix == 8) {
                ans += oct2Bin(val[i]);
            } else {
                ans += val[i];
            }
        }

        radix = 2;
        if (has_exponent) {

            std::istringstream iss(val.substr(expPos+1, len-expPos-1));
            iss >> exp;
        }
    }
    if (exp == 0)
        return ans;

    size_t decPos = ans.find('.');
    if (decPos == std::string::npos)
        decPos = ans.length();
    if ((int) decPos + exp >= (int) ans.length()) {
        int i = decPos;
        for (; i< (int) ans.length()-1; ++i)
            ans[i] = ans[i+1];
        for (; i< (int) ans.length(); ++i)
            ans[i] = '0';
        for (; i< (int) decPos + exp; ++i)
            ans += '0';
        return ans;
    } else if ((int) decPos + exp < (int) isNegative) {
        std::string dupAns = "0.";
        if (ans[0] == '-')
            dupAns = "-0.";
        for (int i=0; i<isNegative-(int)decPos-exp; ++i)
            dupAns += '0';
        for (size_t i=isNegative; i< ans.length(); ++i)
            if (ans[i] != '.')
                dupAns += ans[i];
        return dupAns;
    }

    if (exp > 0)
        for (size_t i=decPos; i<decPos+exp; ++i)
            ans[i] = ans[i+1];
    else {
        if (decPos == ans.length())
            ans += ' ';
        for (int i=decPos; i>(int)decPos+exp; --i)
            ans[i] = ans[i-1];
    }
    ans[decPos+exp] = '.';
    return ans;
}







static inline bool sub_1(uint64_t x[], uint32_t len, uint64_t y) {
    for (uint32_t i = 0; i < len; ++i) {
        uint64_t __X = x[i];
        x[i] -= y;
        if (y > __X)
            y = 1;
        else {
            y = 0;
            break;
        }
    }
    return (y != 0);
}





static inline bool add_1(uint64_t dest[], uint64_t x[], uint32_t len, uint64_t y) {
    for (uint32_t i = 0; i < len; ++i) {
        dest[i] = y + x[i];
        if (dest[i] < y)
            y = 1;
        else {
            y = 0;
            break;
        }
    }
    return (y != 0);
}





static inline bool add(uint64_t *dest, const uint64_t *x, const uint64_t *y,
                uint32_t destlen, uint32_t xlen, uint32_t ylen, bool xsigned, bool ysigned) {
    bool carry = false;
    uint32_t len = AESL_std::min(xlen, ylen);
    uint32_t i;
    for (i = 0; i< len && i < destlen; ++i) {
        uint64_t limit = AESL_std::min(x[i],y[i]);
        dest[i] = x[i] + y[i] + carry;
        carry = dest[i] < limit || (carry && dest[i] == limit);
    }
    if (xlen > ylen) {
        const uint64_t yext = ysigned && int64_t(y[ylen-1])<0 ? -1 : 0;
        for (i=ylen; i< xlen && i < destlen; i++) {
            uint64_t limit = AESL_std::min(x[i], yext);
            dest[i] = x[i] + yext + carry;
            carry = (dest[i] < limit)||(carry && dest[i] == limit);
        }
    } else if (ylen> xlen) {
        const uint64_t xext = xsigned && int64_t(x[xlen-1])<0 ? -1 : 0;
        for (i=xlen; i< ylen && i < destlen; i++) {
            uint64_t limit = AESL_std::min(xext, y[i]);
            dest[i] = xext + y[i] + carry;
            carry = (dest[i] < limit)||(carry && dest[i] == limit);
        }
    }
    return carry;
}



static inline bool sub(uint64_t *dest, const uint64_t *x, const uint64_t *y,
                uint32_t destlen, uint32_t xlen, uint32_t ylen, bool xsigned, bool ysigned) {
    bool borrow = false;
    uint32_t i;
    uint32_t len = AESL_std::min(xlen, ylen);
    for (i = 0; i < len && i < destlen; ++i) {
        uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
        borrow = y[i] > x_tmp || (borrow && x[i] == 0);
        dest[i] = x_tmp - y[i];
    }
    if (xlen > ylen) {
        const uint64_t yext = ysigned && int64_t(y[ylen-1])<0 ? -1 : 0;
        for (i=ylen; i< xlen && i < destlen; i++) {
            uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
            borrow = yext > x_tmp || (borrow && x[i] == 0);
            dest[i] = x_tmp - yext;
        }
    } else if (ylen> xlen) {
        const uint64_t xext = xsigned && int64_t(x[xlen-1])<0 ? -1 : 0;
        for (i=xlen; i< ylen && i < destlen; i++) {
            uint64_t x_tmp = borrow ? xext - 1 : xext;
            borrow = y[i] > x_tmp || (borrow && xext==0);
            dest[i] = x_tmp - y[i];
        }
    }
    return borrow;
}
#653 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
static inline uint64_t mul_1(uint64_t dest[], const uint64_t x[], uint32_t len, uint64_t y) {

    uint64_t ly = y & 0xffffffffULL, hy = (y) >> 32;
    uint64_t carry = 0;
    static const uint64_t two_power_32 = 1ULL << 32;

    for (uint32_t i = 0; i < len; ++i) {

        uint64_t lx = x[i] & 0xffffffffULL;
        uint64_t hx = (x[i]) >> 32;




        uint8_t hasCarry = 0;
        dest[i] = carry + lx * ly;

        hasCarry = (dest[i] < carry) ? 1 : 0;
        carry = hx * ly + ((dest[i]) >> 32) + (hasCarry ? two_power_32 : 0);


        hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);

        carry += (lx * hy) & 0xffffffffULL;
        dest[i] = ((carry) << 32) | (dest[i] & 0xffffffffULL);
        carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? two_power_32 : 0) +
            ((carry) >> 32) + ((lx * hy) >> 32) + hx * hy;
    }
    return carry;
}






static inline void mul(uint64_t dest[], const uint64_t x[], uint32_t xlen, const uint64_t y[],
                uint32_t ylen, uint32_t destlen) {
    ((xlen > 0) ? static_cast<void> (0) : __assert_fail ("xlen > 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 691, __PRETTY_FUNCTION__));
    ((ylen > 0) ? static_cast<void> (0) : __assert_fail ("ylen > 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 692, __PRETTY_FUNCTION__));
    ((destlen >= xlen + ylen) ? static_cast<void> (0) : __assert_fail ("destlen >= xlen + ylen", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 693, __PRETTY_FUNCTION__));
    if(xlen < destlen)
        dest[xlen] = mul_1(dest, x, xlen, y[0]);
    for (uint32_t i = 1; i < ylen; ++i) {
        uint64_t ly = y[i] & 0xffffffffULL, hy = (y[i]) >> 32;
        uint64_t carry = 0, lx = 0, hx = 0;
        for (uint32_t j = 0; j < xlen; ++j) {
            lx = x[j] & 0xffffffffULL;
            hx = (x[j]) >> 32;




            uint8_t hasCarry = 0;
            uint64_t resul = carry + lx * ly;
            hasCarry = (resul < carry) ? 1 : 0;
            carry = (hasCarry ? (1ULL << 32) : 0) + hx * ly + ((resul) >> 32);
            hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);
            carry += (lx * hy) & 0xffffffffULL;
            resul = ((carry) << 32) | (resul & 0xffffffffULL);
            if(i+j < destlen)
                dest[i+j] += resul;
            carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? (1ULL << 32) : 0)+
                ((carry) >> 32) + (dest[i+j] < resul ? 1 : 0) +
                ((lx * hy) >> 32) + hx * hy;
        }
        if (i+xlen < destlen)
            dest[i+xlen] = carry;
    }
}





static inline void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,
                     uint32_t m, uint32_t n) {
    ((u && "Must provide dividend") ? static_cast<void> (0) : __assert_fail ("u && \"Must provide dividend\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 730, __PRETTY_FUNCTION__));
    ((v && "Must provide divisor") ? static_cast<void> (0) : __assert_fail ("v && \"Must provide divisor\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 731, __PRETTY_FUNCTION__));
    ((q && "Must provide quotient") ? static_cast<void> (0) : __assert_fail ("q && \"Must provide quotient\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 732, __PRETTY_FUNCTION__));
    ((u != v && u != q && v != q && "Must us different memory") ? static_cast<void> (0) : __assert_fail ("u != v && u != q && v != q && \"Must us different memory\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 733, __PRETTY_FUNCTION__));
    ((n>1 && "n must be > 1") ? static_cast<void> (0) : __assert_fail ("n>1 && \"n must be > 1\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 734, __PRETTY_FUNCTION__));



    uint64_t b = uint64_t(1) << 32;
#754 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    uint32_t shift = CountLeadingZeros_32(v[n-1]);
    uint32_t v_carry = 0;
    uint32_t u_carry = 0;
    if (shift) {
        for (uint32_t i = 0; i < m+n; ++i) {
            uint32_t u_tmp = (u[i]) >> (32 - shift);
            u[i] = ((u[i]) << (shift)) | u_carry;
            u_carry = u_tmp;
        }
        for (uint32_t i = 0; i < n; ++i) {
            uint32_t v_tmp = (v[i]) >> (32 - shift);
            v[i] = ((v[i]) << (shift)) | v_carry;
            v_carry = v_tmp;
        }
    }
    u[m+n] = u_carry;







    int j = m;
    do {
#788 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
        uint64_t dividend = ((uint64_t(u[j+n]) << 32) + u[j+n-1]);

        uint64_t qp = dividend / v[n-1];
        uint64_t rp = dividend % v[n-1];
        if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {
            qp--;
            rp += v[n-1];
            if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))
                qp--;
        }






        bool isNeg = false;
        for (uint32_t i = 0; i < n; ++i) {
            uint64_t u_tmp = uint64_t(u[j+i]) | ((uint64_t(u[j+i+1])) << 32);
            uint64_t subtrahend = uint64_t(qp) * uint64_t(v[i]);
            bool borrow = subtrahend > u_tmp;




            uint64_t result = u_tmp - subtrahend;
            uint32_t k = j + i;
            u[k++] = (uint32_t)(result & (b-1));
            u[k++] = (uint32_t)((result) >> 32);
            while (borrow && k <= m+n) {
                borrow = u[k] == 0;
                u[k]--;
                k++;
            }
            isNeg |= borrow;


        }
#834 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
        if (isNeg) {
            bool carry = true;
            for (uint32_t i = 0; i <= m+n; ++i) {
                u[i] = ~u[i] + carry;
                carry = carry && u[i] == 0;
            }
        }






        q[j] = (uint32_t)qp;
        if (isNeg) {



            q[j]--;



            bool carry = false;
            for (uint32_t i = 0; i < n; i++) {
                uint32_t limit = AESL_std::min(u[j+i],v[i]);
                u[j+i] += v[i] + carry;
                carry = u[j+i] < limit || (carry && u[j+i] == limit);
            }
            u[j+n] += carry;
        }





    } while (--j >= 0);
#878 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    if (r) {



        if (shift) {
            uint32_t carry = 0;

            for (int i = n-1; i >= 0; i--) {
                r[i] = ((u[i]) >> (shift)) | carry;
                carry = (u[i]) << (32 - shift);

            }
        } else {
            for (int i = n-1; i >= 0; i--) {
                r[i] = u[i];

            }
        }

    }

}

template<int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            const ap_private<_AP_W, _AP_S>& RHS, uint32_t rhsWords,
            ap_private<_AP_W, _AP_S> *Quotient, ap_private<_AP_W, _AP_S> *Remainder) {
    ((lhsWords >= rhsWords && "Fractional result") ? static_cast<void> (0) : __assert_fail ("lhsWords >= rhsWords && \"Fractional result\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 905, __PRETTY_FUNCTION__));
    enum {APINT_BITS_PER_WORD=64};







    uint64_t mask = ~0ull >> (sizeof(uint32_t)*8);
    uint32_t n = rhsWords * 2;
    uint32_t m = (lhsWords * 2) - n;



    uint32_t SPACE[128];
    uint32_t *__U = 0;
    uint32_t *__V = 0;
    uint32_t *__Q = 0;
    uint32_t *__R = 0;
    if ((Remainder?4:3)*n+2*m+1 <= 128) {
        __U = &SPACE[0];
        __V = &SPACE[m+n+1];
        __Q = &SPACE[(m+n+1) + n];
        if (Remainder)
            __R = &SPACE[(m+n+1) + n + (m+n)];
    } else {
        __U = new uint32_t[m + n + 1];
        __V = new uint32_t[n];
        __Q = new uint32_t[m+n];
        if (Remainder)
            __R = new uint32_t[n];
    }


    memset(__U, 0, (m+n+1)*sizeof(uint32_t));
    for (unsigned i = 0; i < lhsWords; ++i) {
        uint64_t tmp = LHS.get_pVal(i);
        __U[i * 2] = (uint32_t)(tmp & mask);
        __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }
    __U[m+n] = 0;


    memset(__V, 0, (n)*sizeof(uint32_t));
    for (unsigned i = 0; i < rhsWords; ++i) {
        uint64_t tmp = RHS.get_pVal(i);
        __V[i * 2] = (uint32_t)(tmp & mask);
        __V[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }


    memset(__Q, 0, (m+n) * sizeof(uint32_t));
    if (Remainder)
        memset(__R, 0, n * sizeof(uint32_t));





    for (unsigned i = n; i > 0 && __V[i-1] == 0; i--) {
        n--;
        m++;
    }
    for (unsigned i = m+n; i > 0 && __U[i-1] == 0; i--)
        m--;







    ((n != 0 && "Divide by zero?") ? static_cast<void> (0) : __assert_fail ("n != 0 && \"Divide by zero?\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 978, __PRETTY_FUNCTION__));
    if (n == 1) {
        uint32_t divisor = __V[0];
        uint32_t remainder = 0;
        for (int i = m+n-1; i >= 0; i--) {
            uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
            if (partial_dividend == 0) {
                __Q[i] = 0;
                remainder = 0;
            } else if (partial_dividend < divisor) {
                __Q[i] = 0;
                remainder = (uint32_t)partial_dividend;
            } else if (partial_dividend == divisor) {
                __Q[i] = 1;
                remainder = 0;
            } else {
                __Q[i] = (uint32_t)(partial_dividend / divisor);
                remainder = (uint32_t)(partial_dividend - (__Q[i] * divisor));
            }
        }
        if (__R)
            __R[0] = remainder;
    } else {


        KnuthDiv(__U, __V, __Q, __R, m, n);
    }


    if (Quotient) {

        if (Quotient->BitWidth != LHS.BitWidth) {
            if (Quotient->isSingleWord())
                Quotient->set_VAL(0);
        } else
            Quotient->clear();



        if (lhsWords == 1) {
            uint64_t tmp =
                uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
            Quotient->set_VAL(tmp);
        } else {
            ((!Quotient->isSingleWord() && "Quotient ap_private not large enough") ? static_cast<void> (0) : __assert_fail ("!Quotient->isSingleWord() && \"Quotient ap_private not large enough\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1022, __PRETTY_FUNCTION__));
            for (unsigned i = 0; i < lhsWords; ++i)
                Quotient->set_pVal(i,
                    uint64_t(__Q[i*2]) | ((uint64_t(__Q[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Quotient->clearUnusedBits();
    }


    if (Remainder) {

        if (Remainder->BitWidth != RHS.BitWidth) {
            if (Remainder->isSingleWord())
                Remainder->set_VAL(0);
        } else
            Remainder->clear();



        if (rhsWords == 1) {
            uint64_t tmp =
                uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
            Remainder->set_VAL(tmp);
        } else {
            ((!Remainder->isSingleWord() && "Remainder ap_private not large enough") ? static_cast<void> (0) : __assert_fail ("!Remainder->isSingleWord() && \"Remainder ap_private not large enough\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1046, __PRETTY_FUNCTION__));
            for (unsigned i = 0; i < rhsWords; ++i)
                Remainder->set_pVal(i,
                    uint64_t(__R[i*2]) | ((uint64_t(__R[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Remainder->clearUnusedBits();
    }


    if (__U != &SPACE[0]) {
        delete [] __U;
        delete [] __V;
        delete [] __Q;
        delete [] __R;
    }
}

template<int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            uint64_t RHS,
            ap_private<_AP_W, _AP_S> *Quotient, ap_private<_AP_W, _AP_S> *Remainder) {
    uint32_t rhsWords=1;
    ((lhsWords >= rhsWords && "Fractional result") ? static_cast<void> (0) : __assert_fail ("lhsWords >= rhsWords && \"Fractional result\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1068, __PRETTY_FUNCTION__));
    enum {APINT_BITS_PER_WORD=64};







    uint64_t mask = ~0ull >> (sizeof(uint32_t)*8);
    uint32_t n = 2;
    uint32_t m = (lhsWords * 2) - n;



    uint32_t SPACE[128];
    uint32_t *__U = 0;
    uint32_t *__V = 0;
    uint32_t *__Q = 0;
    uint32_t *__R = 0;
    if ((Remainder?4:3)*n+2*m+1 <= 128) {
        __U = &SPACE[0];
        __V = &SPACE[m+n+1];
        __Q = &SPACE[(m+n+1) + n];
        if (Remainder)
            __R = &SPACE[(m+n+1) + n + (m+n)];
    } else {
        __U = new uint32_t[m + n + 1];
        __V = new uint32_t[n];
        __Q = new uint32_t[m+n];
        if (Remainder)
            __R = new uint32_t[n];
    }


    memset(__U, 0, (m+n+1)*sizeof(uint32_t));
    for (unsigned i = 0; i < lhsWords; ++i) {
        uint64_t tmp = LHS.get_pVal(i);
        __U[i * 2] = tmp & mask;
        __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }
    __U[m+n] = 0;


    memset(__V, 0, (n)*sizeof(uint32_t));
    __V[0] = RHS & mask;
    __V[1] = (RHS) >> (sizeof(uint32_t)*8);


    memset(__Q, 0, (m+n) * sizeof(uint32_t));
    if (Remainder)
        memset(__R, 0, n * sizeof(uint32_t));





    for (unsigned i = n; i > 0 && __V[i-1] == 0; i--) {
        n--;
        m++;
    }
    for (unsigned i = m+n; i > 0 && __U[i-1] == 0; i--)
        m--;







    ((n != 0 && "Divide by zero?") ? static_cast<void> (0) : __assert_fail ("n != 0 && \"Divide by zero?\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1138, __PRETTY_FUNCTION__));
    if (n == 1) {
        uint32_t divisor = __V[0];
        uint32_t remainder = 0;
        for (int i = m+n-1; i >= 0; i--) {
            uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
            if (partial_dividend == 0) {
                __Q[i] = 0;
                remainder = 0;
            } else if (partial_dividend < divisor) {
                __Q[i] = 0;
                remainder = partial_dividend;
            } else if (partial_dividend == divisor) {
                __Q[i] = 1;
                remainder = 0;
            } else {
                __Q[i] = partial_dividend / divisor;
                remainder = partial_dividend - (__Q[i] * divisor);
            }
        }
        if (__R)
            __R[0] = remainder;
    } else {


        KnuthDiv(__U, __V, __Q, __R, m, n);
    }


    if (Quotient) {

        if (Quotient->BitWidth != LHS.BitWidth) {
            if (Quotient->isSingleWord())
                Quotient->set_VAL(0);
        } else
            Quotient->clear();



        if (lhsWords == 1) {
            uint64_t tmp =
                uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
            Quotient->set_VAL(tmp);
        } else {
            ((!Quotient->isSingleWord() && "Quotient ap_private not large enough") ? static_cast<void> (0) : __assert_fail ("!Quotient->isSingleWord() && \"Quotient ap_private not large enough\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1182, __PRETTY_FUNCTION__));
            for (unsigned i = 0; i < lhsWords; ++i)
                Quotient->set_pVal(i,
                    uint64_t(__Q[i*2]) | ((uint64_t(__Q[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Quotient->clearUnusedBits();
    }


    if (Remainder) {

        if (Remainder->BitWidth != 64 ) {
            if (Remainder->isSingleWord())
                Remainder->set_VAL(0);
        } else
            Remainder->clear();



        if (rhsWords == 1) {
            uint64_t tmp =
                uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
            Remainder->set_VAL(tmp);
        } else {
            ((!Remainder->isSingleWord() && "Remainder ap_private not large enough") ? static_cast<void> (0) : __assert_fail ("!Remainder->isSingleWord() && \"Remainder ap_private not large enough\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1206, __PRETTY_FUNCTION__));
            for (unsigned i = 0; i < rhsWords; ++i)
                Remainder->set_pVal(i,
                    uint64_t(__R[i*2]) | ((uint64_t(__R[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Remainder->clearUnusedBits();
    }


    if (__U != &SPACE[0]) {
        delete [] __U;
        delete [] __V;
        delete [] __Q;
        delete [] __R;
    }
}


template<int _AP_W, bool _AP_S, bool _AP_C> inline ap_private<_AP_W, _AP_S, _AP_C> lshr(const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
    return LHS.lshr(shiftAmt);
}



template<int _AP_W, bool _AP_S, bool _AP_C> inline ap_private<_AP_W, _AP_S, _AP_C> shl(const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
    return LHS.shl(shiftAmt);
}

}







enum ap_q_mode {
    AP_RND,
    AP_RND_ZERO,
    AP_RND_MIN_INF,
    AP_RND_INF,
    AP_RND_CONV,
    AP_TRN,
    AP_TRN_ZERO

};
enum ap_o_mode {
    AP_SAT,
    AP_SAT_ZERO,
    AP_SAT_SYM,
    AP_WRAP,
    AP_WRAP_SM
};

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
    ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
    ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
    ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;

template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2> struct ap_concat_ref;


    enum {
        MIN_INT_BITS = 1,

        MAX_INT_BITS = (1<<23)-1

    };
#1317 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    typedef unsigned long long ap_ulong;
    typedef signed long long ap_slong;

template <int _AP_N8, bool _AP_S> struct valtype;

template<int _AP_N8> struct valtype<_AP_N8, false> {
    typedef uint64_t Type;
};

template<int _AP_N8> struct valtype<_AP_N8, true> {
    typedef int64_t Type;
};

template<> struct valtype<1, false> {
    typedef unsigned char Type;
};
template<> struct valtype<2, false> {
    typedef unsigned short Type;
};
template<> struct valtype<3, false> {
    typedef unsigned int Type;
};
template<> struct valtype<4, false> {
    typedef unsigned int Type;
};
template<> struct valtype<1, true> {
    typedef signed char Type;
};
template<> struct valtype<2, true> {
    typedef short Type;
};
template<> struct valtype<3, true> {
    typedef int Type;
};
template<> struct valtype<4, true> {
    typedef int Type;
};

template<bool enable> struct ap_private_enable_if {};
template<> struct ap_private_enable_if<true> {static const bool isValid = true;};


template<int _AP_W, bool _AP_S> class ap_private <_AP_W, _AP_S, true> {


    const static bool valid = ap_private_enable_if<_AP_W <= 64>::isValid;




public:
  typedef typename valtype<(_AP_W+7)/8, _AP_S>::Type ValType;
    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
        typedef ap_private<mult_w, mult_s> mult;
        typedef ap_private<plus_w, plus_s> plus;
        typedef ap_private<minus_w, minus_s> minus;
        typedef ap_private<logic_w, logic_s> logic;
        typedef ap_private<div_w, div_s> div;
        typedef ap_private<mod_w, mod_s> mod;
        typedef ap_private<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };
    enum { APINT_BITS_PER_WORD = sizeof(uint64_t) * 8 };
    enum { excess_bits = (_AP_W%APINT_BITS_PER_WORD) ? APINT_BITS_PER_WORD -(_AP_W%APINT_BITS_PER_WORD) : 0};
    static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));
    static const uint64_t not_mask = ~mask;
    static const uint64_t sign_bit_mask = 1ULL << (APINT_BITS_PER_WORD-1);
    template<int _AP_W1> struct sign_ext_mask { static const uint64_t mask=~0ULL<<_AP_W1;};
    static const int width = _AP_W;


    enum { BitWidth=_AP_W, _AP_N = 1, };
    ValType VAL;
#1414 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    void check_canary() {}
    void set_canary() {}


    inline ValType& get_VAL(void) {
        return VAL;
    }
    inline ValType get_VAL(void) const{
        return VAL;
    }
    inline ValType get_VAL(void) const volatile{
        return VAL;
    }
    inline void set_VAL(uint64_t value) {
        VAL = (ValType)value;
    }
    inline ValType& get_pVal(int i) {
        return VAL;
    }
    inline ValType get_pVal(int i) const{
        return VAL;
    }
    inline const uint64_t* get_pVal() const{
        ((0 && "invalid usage") ? static_cast<void> (0) : __assert_fail ("0 && \"invalid usage\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1437, __PRETTY_FUNCTION__));
        return 0;
    }
    inline ValType get_pVal(int i) const volatile {
        return VAL;
    }
    inline uint64_t* get_pVal() const volatile {
        ((0 && "invalid usage") ? static_cast<void> (0) : __assert_fail ("0 && \"invalid usage\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1444, __PRETTY_FUNCTION__));
        return 0;
    }
    inline void set_pVal(int i, uint64_t value) {
        VAL = (ValType)value;
    }

    inline uint32_t getBitWidth() const {
        return BitWidth;
    }

    template<int _AP_W1, bool _AP_S1>
    ap_private<_AP_W, _AP_S>& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    ap_private<_AP_W, _AP_S>& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }


    void operator=(const ap_private& RHS) volatile {

        VAL = RHS.get_VAL();
    }
    ap_private& operator=(const ap_private& RHS) {

        VAL = RHS.get_VAL();
        return *this;
    }

    void operator=(const volatile ap_private& RHS) volatile {

        VAL = RHS.get_VAL();
    }
    ap_private& operator=(const volatile ap_private& RHS) {

        VAL = RHS.get_VAL();
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private& operator = (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        *this = ap_private<_AP_W2, false>(op2);
        return *this;
    }

private:
    explicit inline ap_private(uint64_t* val):VAL(val[0]) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }

    inline bool isSingleWord() const { return true; }

    inline void fromString(const char *strStart, uint32_t slen,
                           uint8_t radix) {

        (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? static_cast<void> (0) : __assert_fail ("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
#1508 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
        ,
 1509
#1508 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
        , __PRETTY_FUNCTION__))
                                                   ;
        ((strStart && "String is null?") ? static_cast<void> (0) : __assert_fail ("strStart && \"String is null?\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1510, __PRETTY_FUNCTION__));
        uint64_t tmpVAL = VAL;
        bool isNeg = false;
        if (*strStart == '-') {
            isNeg = true;
            strStart++;
        }
        switch(radix) {
            case 2:


                for (;*strStart; ++strStart) {
                    (((*strStart=='0'|| *strStart=='1')&&("Wrong binary number")) ? static_cast<void> (0) : __assert_fail ("(*strStart=='0'|| *strStart=='1')&&(\"Wrong binary number\")", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1522, __PRETTY_FUNCTION__));
                    tmpVAL <<=1;
                    tmpVAL |= (*strStart-'0');
                }
                break;
            case 8:
#1536 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
                sscanf(strStart,"%lo",&tmpVAL);







                break;
            case 10:
#1554 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
                sscanf(strStart,"%lu",&tmpVAL);







                break;
            case 16:
#1572 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
                sscanf(strStart,"%lx",&tmpVAL);







                break;
            default:
                ((true && "Unknown radix") ? static_cast<void> (0) : __assert_fail ("true && \"Unknown radix\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1582, __PRETTY_FUNCTION__));

        }
        VAL = isNeg ? (ValType)(-tmpVAL) : (ValType) (tmpVAL);

        clearUnusedBits();
    }


    inline ap_private(const std::string& val, uint8_t radix=2): VAL(0) {
        ((!val.empty() && "String empty?") ? static_cast<void> (0) : __assert_fail ("!val.empty() && \"String empty?\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 1592, __PRETTY_FUNCTION__));
        set_canary();
        fromString(val.c_str(), val.size(), radix);
        check_canary();
    }

    inline ap_private(const char strStart[], uint32_t slen, uint8_t radix) : VAL(0) {
        set_canary();
        fromString(strStart, slen, radix);
        check_canary();
    }

    inline ap_private(uint32_t numWords, const uint64_t bigVal[]): VAL(bigVal[0]) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }


public:
    inline ap_private() {
 clear();
        set_canary();
        clearUnusedBits();
        check_canary();
    }







    inline ap_private(int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(bool v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(signed char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(long long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(half v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(float v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(double v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
#1652 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W1, bool _AP_S1, bool _AP_OPT>
    inline ap_private(const ap_private<_AP_W1, _AP_S1, _AP_OPT>& that) : VAL((ValType)that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }


    template<int _AP_W1, bool _AP_S1, bool _AP_OPT>
    inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, _AP_OPT>& that) : VAL((ValType)that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }

    explicit inline ap_private(const char* val) {
        set_canary();
        int radix = 10;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');

        if (pos != std::string::npos)
            str = str.substr(pos);

        ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
        operator = (ap_private_val);
        check_canary();
    }

    inline ap_private(const char* val, signed char rd) {
        set_canary();
        int radix = rd;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');

        if (pos != std::string::npos)
            str = str.substr(pos);

        ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
        operator = (ap_private_val);
        check_canary();
    }

    inline ~ap_private() {check_canary();}

    inline bool isNegative() const {
        static const uint64_t sign_mask = 1ULL << (_AP_W-1);
        return _AP_S && (sign_mask & VAL);
    }

    inline bool isPositive() const {
        return !isNegative();
    }

    inline bool isStrictlyPositive() const {
        return !isNegative() && VAL!=0;
    }

    inline bool isAllOnesValue() const {
        return (mask & VAL) == mask;
    }

    inline bool operator==(const ap_private<_AP_W, _AP_S>& RHS) const { return VAL == RHS.get_VAL(); }
    inline bool operator==(const ap_private<_AP_W, !_AP_S>& RHS) const { return (uint64_t)VAL == (uint64_t)RHS.get_VAL(); }

    inline bool operator==(uint64_t Val) const { return ((uint64_t)VAL == Val); }
    inline bool operator!=(uint64_t Val) const { return ((uint64_t)VAL != Val); }
    inline bool operator!=(const ap_private<_AP_W, _AP_S>& RHS) const { return VAL != RHS.get_VAL(); }
    inline bool operator!=(const ap_private<_AP_W, !_AP_S>& RHS) const { return (uint64_t)VAL != (uint64_t)RHS.get_VAL(); }
    const ap_private operator++() { ++VAL; clearUnusedBits(); return *this; }
    const ap_private operator--(int) {
           ap_private orig(*this);
           --VAL; clearUnusedBits();
           return orig;
    }
    const ap_private operator--() { --VAL; clearUnusedBits(); return *this;}
    inline bool operator !() const { return !VAL;}

    const ap_private operator++(int) {
        ap_private orig(*this);
        VAL++; clearUnusedBits();
        return orig;
    }

    inline ap_private<((64) < (_AP_W + 1) ? (64) : (_AP_W + 1)), true>
                          operator-() const {
        return ap_private<1,false>(0) - (*this);
    }

    inline std::string toString(uint8_t radix, bool wantSigned) const ;
    inline std::string toStringUnsigned(uint8_t radix = 10) const {
        return toString(radix, false);
    }
    inline std::string toStringSigned(uint8_t radix = 10) const {
        return toString(radix, true);
    }
    inline void clear() {
        VAL=0;
    }
    inline ap_private& clear(uint32_t bitPosition) { VAL &= ~(1ULL<<(bitPosition)); clearUnusedBits(); return *this;}

    inline ap_private ashr(uint32_t shiftAmt) const {
        if (_AP_S)
            return ap_private((shiftAmt == BitWidth) ? 0 : ((int64_t)VAL) >> (shiftAmt));
        else
            return ap_private((shiftAmt == BitWidth) ? 0 : ((uint64_t)VAL) >> (shiftAmt));
    }

    inline ap_private lshr(uint32_t shiftAmt) const {
        return ap_private((shiftAmt == BitWidth) ? ap_private(0) : ap_private((VAL&mask) >> (shiftAmt)));
    }

    inline ap_private shl(uint32_t shiftAmt) const




    {
        if (shiftAmt > BitWidth) {
            if (!isNegative())
                return ap_private(0);
            else return ap_private(-1);
        }
        if (shiftAmt == BitWidth) return ap_private(0);
        else return ap_private((VAL) << (shiftAmt));

    }

    inline int64_t getSExtValue() const {
        return VAL;
    }

    inline uint64_t getZExtValue() const {
        return VAL & mask;
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this=ref.get();
        check_canary();
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this = ((uint64_t)(bool)ref);
        check_canary();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private(const ap_concat_ref<_AP_W2, _AP_T2,_AP_W3, _AP_T3>& ref) {
        set_canary();
        *this=ref.get();
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = ((val.operator ap_private<_AP_W2, false> ()));
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = (uint64_t)(bool)val;
        check_canary();
    }

    inline void write(const ap_private<_AP_W, _AP_S>& op2) volatile {
        *this = (op2);
    }



    inline operator ValType () const {
        return get_VAL();
    }

    inline int to_uchar() const {
        return (unsigned char) get_VAL();
    }

    inline int to_char() const {
        return (signed char) get_VAL();
    }

    inline int to_ushort() const {
        return (unsigned short) get_VAL();
    }

    inline int to_short() const {
        return (short) get_VAL();
    }

    inline int to_int() const {

        return (int) get_VAL();
    }

    inline unsigned to_uint() const {
        return (unsigned) get_VAL();
    }

    inline long to_long() const {
        return (long) get_VAL();
    }

    inline unsigned long to_ulong() const {
        return (unsigned long) get_VAL();
    }

    inline ap_slong to_int64() const {
        return (ap_slong) get_VAL();
    }

    inline ap_ulong to_uint64() const {
        return (ap_ulong) get_VAL();
    }

    inline double to_double() const {
        if (isNegative())
            return roundToDouble(true);
        else
            return roundToDouble(false);
    }

    inline unsigned length() const { return _AP_W; }

    inline bool isMinValue() const { return VAL == 0;}
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator&=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(((uint64_t)VAL)&RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator|=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(((uint64_t)VAL)|RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator^=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)^RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)*RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)+RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)-RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
    inline const ap_private& operator<<=(uint32_t shiftAmt) { VAL<<=shiftAmt; clearUnusedBits(); return *this; }

    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator&(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) & RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret & RHS;
        }
    }

    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator^(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) ^ RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret ^ RHS;
        }
    }

    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator|(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) | RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret | RHS;
        }
    }

    inline ap_private And(const ap_private& RHS) const {
        return ap_private(VAL & RHS.get_VAL());
    }

    inline ap_private Or(const ap_private& RHS) const {
        return ap_private(VAL | RHS.get_VAL());
    }

    inline ap_private Xor(const ap_private& RHS) const {
        return ap_private(VAL ^ RHS.get_VAL());
    }

    template <int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1, _AP_S1>::mult operator*(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::mult_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::mult Result(((uint64_t)VAL) * RHS.get_VAL());
            return Result;
        } else {
            typename RType<_AP_W1, _AP_S1>::mult Result(*this);
            Result *= RHS;
            return Result;
        }
    }

    inline ap_private Mul(const ap_private& RHS) const {
        return ap_private(VAL * RHS.get_VAL());
    }

    inline ap_private Add(const ap_private& RHS) const {
        return ap_private(VAL + RHS.get_VAL());
    }

    inline ap_private Sub(const ap_private& RHS) const {
        return ap_private(VAL - RHS.get_VAL());
    }


    inline ap_private& operator&=(uint64_t RHS) { VAL &= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator|=(uint64_t RHS) { VAL |= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator^=(uint64_t RHS){ VAL ^= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator*=(uint64_t RHS){ VAL *= (ValType)RHS; clearUnusedBits(); return *this; }
    inline ap_private& operator+=(uint64_t RHS){ VAL += (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator-=(uint64_t RHS){ VAL -= (ValType)RHS; clearUnusedBits(); return *this; }
#2007 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline bool isMinSignedValue() const {
        static const uint64_t min_mask = ~(~0ULL << (_AP_W-1));
        return BitWidth == 1 ? VAL == 1 :
           (ap_private_ops::isNegative<_AP_W>(*this) && ((min_mask & VAL)==0));
    }


    template<int _AP_W1, bool _AP_S1> inline
    typename RType<_AP_W1,_AP_S1>::plus operator+(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1,_AP_S1>::plus_w <=64)
            return typename RType<_AP_W1,_AP_S1>::plus(RType<_AP_W1,_AP_S1>::plus_s ? int64_t(((uint64_t)VAL)+RHS.get_VAL()):uint64_t(((uint64_t)VAL)+RHS.get_VAL()));
        typename RType<_AP_W1,_AP_S1>::plus Result=RHS;
        Result += VAL;
        return Result;
    }

    template<int _AP_W1, bool _AP_S1> inline
    typename RType<_AP_W1,_AP_S1>::minus operator-(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1,_AP_S1>::minus_w <=64)
            return typename RType<_AP_W1,_AP_S1>::minus(int64_t(((uint64_t)VAL)-RHS.get_VAL()));
        typename RType<_AP_W1,_AP_S1>::minus Result=*this;
        Result -= RHS;
        return Result;
    }

    inline ap_private& flip() {
        VAL = (ValType)((~0ULL^VAL)&mask);
        clearUnusedBits();
        return *this;
    }

    inline uint32_t countPopulation() const { return ap_private_ops::CountPopulation_64(VAL);}
    inline uint32_t countLeadingZeros() const {
        int remainder = BitWidth % 64;
        int excessBits = (64 - remainder) % 64;
        uint32_t Count = ap_private_ops::CountLeadingZeros_64(VAL);
        if (Count)
            Count-=excessBits;
        return AESL_std::min(Count, (uint32_t)_AP_W);
    }


    inline ap_private<_AP_W, _AP_S> getHiBits(uint32_t numBits) const {
        ap_private<_AP_W, _AP_S> ret(*this);
        ret = (ret)>>(BitWidth - numBits);
        return ret;
    }


    inline ap_private<_AP_W, _AP_S> getLoBits(uint32_t numBits) const {
        ap_private<_AP_W, _AP_S> ret(((uint64_t)VAL) << (BitWidth - numBits));
        ret = (ret)>>(BitWidth - numBits);
        return ret;

    }

    inline ap_private<_AP_W, _AP_S>& set(uint32_t bitPosition) {
        VAL |= (1ULL << (bitPosition));
        clearUnusedBits();
        return *this;
    }

    inline void set() {
        VAL = (ValType)~0ULL;
        clearUnusedBits();
    }

    template<int _AP_W3>
    inline void set(const ap_private<_AP_W3, false> & val) {
        operator = (ap_private<_AP_W3, _AP_S>(val));
    }

    inline void set(const ap_private & val) {
        operator = (val);
    }

    inline void clearUnusedBits(void)




    {
        enum { excess_bits = (_AP_W%64) ? 64 -_AP_W%64 : 0};
        VAL = (ValType)(_AP_S ? ((((int64_t)VAL)<<(excess_bits))>> (excess_bits)) : (excess_bits ? (((uint64_t)VAL)<<(excess_bits))>>(excess_bits) : (uint64_t)VAL));
    }

    inline void clearUnusedBitsToZero(void) {
        enum { excess_bits = (_AP_W%64) ? 64 -_AP_W%64 : 0};
        static uint64_t mask = ~0ULL >> (excess_bits);
        VAL &= mask;
    }

    inline ap_private udiv(const ap_private& RHS) const {
        return ap_private((uint64_t)VAL / RHS.get_VAL());
    }



    inline ap_private sdiv(const ap_private& RHS) const {
        if (isNegative())
            if (RHS.isNegative())
                return ((uint64_t)(0 -(*this))) / (uint64_t) (0-RHS);
            else
                return 0 -((uint64_t)(0-(*this)) / (uint64_t)(RHS));
        else if (RHS.isNegative())
            return 0 -(this->udiv((ap_private)(0-RHS)));
        return this->udiv(RHS);
    }

    template<bool _AP_S2>
    inline ap_private urem(const ap_private<_AP_W, _AP_S2>& RHS) const {
        ((RHS.get_VAL() != 0 && "Divide by 0") ? static_cast<void> (0) : __assert_fail ("RHS.get_VAL() != 0 && \"Divide by 0\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2118, __PRETTY_FUNCTION__));
        return ap_private(((uint64_t)VAL)%((uint64_t)RHS.get_VAL()));
    }



    template<bool _AP_S2>
    inline ap_private srem(const ap_private<_AP_W, _AP_S2>& RHS) const {
        if (isNegative()) {
            ap_private lhs = 0 -(*this);
            if (RHS.isNegative()) {
                ap_private rhs = 0 -RHS;
                return 0 -(lhs.urem(rhs));
            } else
                return 0 -(lhs.urem(RHS));
        } else if (RHS.isNegative()) {
            ap_private rhs = 0-RHS;
            return this->urem(rhs);
        }
        return this->urem(RHS);
    }

    template <int _AP_W1, bool _AP_S1> inline bool eq(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return (*this) == RHS;
    }

    template <int _AP_W1, bool _AP_S1> inline bool ne(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !((*this) == RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool ult(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (_AP_W1 <= 64) {
            uint64_t lhsZext = ((uint64_t(VAL)) << (64-_AP_W)) >> (64-_AP_W);
            uint64_t rhsZext = ((uint64_t(RHS.get_VAL())) <<
                                 (64-_AP_W1)) >> (64-_AP_W1);
            return lhsZext < rhsZext;
        } else
            return RHS.uge(*this);
    }





    template <int _AP_W1, bool _AP_S1> inline bool slt(const ap_private<_AP_W1, _AP_S1>& RHS) const




    {
        if (_AP_W1 <= 64) {
            int64_t lhsSext = ((int64_t(VAL)) << (64-_AP_W)) >> (64-_AP_W);
            int64_t rhsSext = ((int64_t(RHS.get_VAL())) << (64-_AP_W1))
                                >> (64-_AP_W1);
            return lhsSext < rhsSext;
        } else
            return RHS.sge(*this);
    }






    template <int _AP_W1, bool _AP_S1> inline bool ule(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return ult(RHS) || eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool sle(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return slt(RHS) || eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool ugt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !ult(RHS) && !eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool sgt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !slt(RHS) && !eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool uge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !ult(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool sge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !slt(RHS);
    }

    inline ap_private abs() const {
        if (isNegative())
            return -(*this);
        return *this;
    }

    inline ap_private<_AP_W, false> get() const {
        ap_private<_AP_W,false> ret(*this);
        return ret;
    }

    inline static uint32_t getBitsNeeded(const char* str, uint32_t slen, uint8_t radix) {
        return _AP_W;
    }

    inline uint32_t getActiveBits() const {
        uint32_t bits=_AP_W - countLeadingZeros();
        return bits?bits:1;
    }

    inline double roundToDouble(bool isSigned=false) const {
        return isSigned ? double((int64_t)VAL) : double((uint64_t)VAL);
    }


    inline ap_private& reverse () {
        for (int i = 0; i < _AP_W/2; ++i) {
            bool tmp = operator[](i);
            if (operator[](_AP_W - 1 - i))
                set(i);
            else
                clear(i);
            if (tmp)
                set(_AP_W - 1 - i);
            else
                clear(_AP_W - 1 - i);
        }
        clearUnusedBits();
        return *this;
    }


    inline bool iszero () const {
        return isMinValue();
    }

    inline bool to_bool() const {
        return !iszero();
    }


    inline bool sign () const {
        if (isNegative())
            return true;
        return false;
    }


    inline void invert (int i) {
        ((i >= 0 && "Attempting to read bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to read bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2289, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to read bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2290, __PRETTY_FUNCTION__));
        flip(i);
    }


    inline bool test (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to read bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2296, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to read bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2297, __PRETTY_FUNCTION__));
        return operator[](i);
    }



    inline void lrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? static_cast<void> (0) : __assert_fail ("n >= 0 && \"Attempting to shift negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2304, __PRETTY_FUNCTION__));
        ((n < _AP_W && "Shift value larger than bit width") ? static_cast<void> (0) : __assert_fail ("n < _AP_W && \"Shift value larger than bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2305, __PRETTY_FUNCTION__));
        operator = (shl(n) | lshr(_AP_W - n));
    }



    inline void rrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? static_cast<void> (0) : __assert_fail ("n >= 0 && \"Attempting to shift negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2312, __PRETTY_FUNCTION__));
        ((n < _AP_W && "Shift value larger than bit width") ? static_cast<void> (0) : __assert_fail ("n < _AP_W && \"Shift value larger than bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2313, __PRETTY_FUNCTION__));
        operator = (lshr(n) | shl(_AP_W - n));
    }


    inline void set (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to write bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2319, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to write bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2320, __PRETTY_FUNCTION__));
        v ? set(i) : clear(i);
    }


    inline void set_bit (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to write bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2326, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to write bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2327, __PRETTY_FUNCTION__));
        v ? set(i) : clear(i);
    }


    inline bool get_bit (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to read bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2333, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to read bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2334, __PRETTY_FUNCTION__));
        return (((1ULL << i) & VAL) != 0);
    }


    inline void b_not() {
        flip();
    }
#2361 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::div
    operator / (const ap_private<_AP_W2,_AP_S2>&op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        return typename RType<_AP_W2,_AP_S2>::div((_AP_S||_AP_S2)?lhs.sdiv(rhs):lhs.udiv(rhs));
    }


    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::mod
    operator % (const ap_private<_AP_W2,_AP_S2>&op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        typename RType<_AP_W2,_AP_S2>::mod res = typename RType<_AP_W2,_AP_S2>::mod (_AP_S?lhs.srem(rhs):lhs.urem(rhs));
        return res;
    }
#2387 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator /=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator / (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator %=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator % (op); return *this; }
#2406 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private operator << (const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }

    inline ap_private operator << (const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator << (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this << sh;
        } else {
            int sh = op2.to_int();
            return *this << sh;
        }
    }
#2449 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private operator >> (const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }

    inline ap_private operator >> (const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator >> (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this >> sh;
        } else {
            int sh = op2.to_int();
            return *this >> sh;
        }
    }
#2484 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator >>=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator >> (op.get_VAL()); return *this; }




    template<int _AP_W1, bool _AP_S1>
    inline bool operator == (const ap_private<_AP_W1, _AP_S1>& op) const {
        enum { _AP_MAX_W = ((((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) > (32) ? (((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) : (32))};
        ap_private<_AP_MAX_W, false> lhs(*this);
        ap_private<_AP_MAX_W, false> rhs(op);
        if (_AP_MAX_W <= 64) {
            return (uint64_t) lhs.get_VAL() ==
                   (uint64_t) rhs.get_VAL();
        } else
            return lhs == rhs;

    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this==op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);


        if (_AP_S == _AP_S2)
            return _AP_S?lhs.sgt(rhs):lhs.ugt(rhs);
        else if (_AP_W < 32 && _AP_W2 < 32)

            return lhs.sgt(rhs);
        else


            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);

    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this>op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.slt(rhs):lhs.ult(rhs);
        else if (_AP_W < 32 && _AP_W2 < 32)
            return lhs.slt(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator >=(const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this<op);
    }




    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,
                _AP_S>*>(this), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>((const_cast<ap_private<_AP_W,
                    _AP_S>*> (this)), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }


    inline ap_bit_ref<_AP_W,_AP_S> operator [] (int index) {
        return ap_bit_ref<_AP_W,_AP_S> (*this, index);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    inline const ap_bit_ref<_AP_W,_AP_S> operator [](int index) const {
        return ap_bit_ref<_AP_W,_AP_S> (const_cast<ap_private<_AP_W,_AP_S>& >(*this), index);
    }

    template<int _AP_W2, bool _AP_S2>
    inline const ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2>& index) const {
        return ap_bit_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,_AP_S>& >(*this), index.to_int() );
    }

    inline ap_bit_ref<_AP_W,_AP_S> bit (int index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    inline const ap_bit_ref<_AP_W,_AP_S> bit (int index) const {
        return ap_bit_ref<_AP_W,_AP_S> (const_cast<ap_private<_AP_W,_AP_S>& >(*this), index);
    }

    template<int _AP_W2, bool _AP_S2>
    inline const ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2>& index) const {
        return ap_bit_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,_AP_S>& >(*this), index.to_int() );
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(const ap_private<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                                                                                                  const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(ap_private<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                             const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                  const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                      const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this & a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this | a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this ^ a2.get();
    }




    inline bool and_reduce() const {
        return (VAL & mask) == mask;
    }

    inline bool nand_reduce() const {
        return (VAL & mask) != mask;
    }

    inline bool or_reduce() const {
        return (bool)VAL;
    }

    inline bool nor_reduce() const {
        return VAL==0;
    }

    inline bool xor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?true:false;
    }

    inline bool xnor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?false:true;
    }

    inline std::string to_string(uint8_t radix=2, bool sign=false) const {
        return toString(radix, radix==10?_AP_S:sign);
    }
};

template<int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, true>::toString(uint8_t radix, bool wantSigned) const {
    (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? static_cast<void> (0) : __assert_fail ("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
#2803 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    ,
 2804
#2803 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    , __PRETTY_FUNCTION__))
                                               ;
    static const char *digits[] = {
        "0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"
    };
    std::string result;
    if (radix != 10) {





        if (*this == (uint64_t)(0)) {


            switch (radix) {
                case 2: result = "0b0"; break;
                case 8: result = "0o0"; break;
                case 16: result = "0x0"; break;
                default: (("invalid radix" && 0) ? static_cast<void> (0) : __assert_fail ("\"invalid radix\" && 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2822, __PRETTY_FUNCTION__));
            }
        } else {
            ap_private<_AP_W, false, true> tmp(*this);
            size_t insert_at = 0;
            bool leading_zero = true;
            if (wantSigned && isNegative()) {



                tmp.flip();
                tmp++;
                result = "-";
                insert_at = 1;
                leading_zero = false;
            }
            switch (radix) {
                case 2: result += "0b"; break;
                case 8: result += "0o"; break;
                case 16: result += "0x"; break;
                default: (("invalid radix" && 0) ? static_cast<void> (0) : __assert_fail ("\"invalid radix\" && 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2842, __PRETTY_FUNCTION__));
            }
            insert_at += 2;


            uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
            uint64_t mask = radix - 1;
            ap_private<_AP_W, false, true> zero(0);
            unsigned bits = 0;
            bool msb = false;
            while (tmp.ne(zero)) {
                unsigned digit = (unsigned)(tmp.get_VAL() & mask);
                result.insert(insert_at, digits[digit]);
                tmp = tmp.lshr(shift);
                bits++;
                msb = (digit >> (shift - 1)) == 1;
            }
            bits *= shift;
            if (bits < _AP_W && leading_zero && msb)
                result.insert(insert_at, digits[0]);
        }
        return result;
    }

    ap_private<_AP_W, false, true> tmp(*this);
    ap_private<6, false, true> divisor(radix);
    ap_private<_AP_W, _AP_S, true> zero(0);
    size_t insert_at = 0;
    if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        result = "-";
        insert_at = 1;
    }
    if (tmp == ap_private<_AP_W, false, true>(0ULL))
        result = "0";
    else while (tmp.ne(zero)) {
        ap_private<_AP_W, false, true> APdigit = tmp%divisor;
        ap_private<_AP_W, false, true> tmp2 = tmp/divisor;
        uint32_t digit = (uint32_t)(APdigit.getZExtValue());
        ((digit < radix && "divide failed") ? static_cast<void> (0) : __assert_fail ("digit < radix && \"divide failed\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2885, __PRETTY_FUNCTION__));
        result.insert(insert_at,digits[digit]);
        tmp = tmp2;
    }
    return result;

}


template<int _AP_W, bool _AP_S>
class ap_private <_AP_W, _AP_S, false> {

    const static bool valid = ap_private_enable_if<(_AP_W > 64)>::isValid;




public:
    enum { BitWidth = _AP_W, _AP_N = (_AP_W + 63) / 64 };
    static const int width = _AP_W;

private:
#2916 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private(uint32_t numWords, const uint64_t bigVal[]) {
        set_canary();
        ((bigVal && "Null pointer detected!") ? static_cast<void> (0) : __assert_fail ("bigVal && \"Null pointer detected!\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2918, __PRETTY_FUNCTION__));
        {

            memset(pVal, 0, _AP_N * sizeof(uint64_t));


            uint32_t words = AESL_std::min<uint32_t>(numWords, _AP_N);

            memcpy(pVal, bigVal, words * APINT_WORD_SIZE);
            if (words >= _AP_W)
                clearUnusedBits();

        }
        check_canary();
    }
#2943 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private(const std::string& val, uint8_t radix=2) {
        set_canary();
        ((!val.empty() && "The input string is empty.") ? static_cast<void> (0) : __assert_fail ("!val.empty() && \"The input string is empty.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 2945, __PRETTY_FUNCTION__));
        const char *c_str = val.c_str();
        fromString(c_str, val.size(), radix);
        check_canary();
    }
#2962 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private(const char strStart[], uint32_t slen, uint8_t radix) {
        set_canary();
        fromString(strStart, slen, radix);
        check_canary();
    }

    inline void report() {







            if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
                fprintf(stderr, "[E] ap_%sint<%d>: Bitwidth exceeds the "
                        "default max value %d. Please use macro "
                        "AP_INT_MAX_W to set a larger max value.\n",
                        _AP_S?"":"u", _AP_W,
                        ((1024 + 1023) / 1024) * 1024);
                exit(1);
            }
    }





    uint64_t pVal[_AP_N];
#3000 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline void check_canary() {}
    inline void set_canary() {}


public:
    typedef typename valtype<8, _AP_S>::Type ValType;
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct ap_fixed_base;


    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
        typedef ap_private<mult_w, mult_s> mult;
        typedef ap_private<plus_w, plus_s> plus;
        typedef ap_private<minus_w, minus_s> minus;
        typedef ap_private<logic_w, logic_s> logic;
        typedef ap_private<div_w, div_s> div;
        typedef ap_private<mod_w, mod_s> mod;
        typedef ap_private<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };


   inline uint64_t& get_VAL(void) {
        return pVal[0];
    }
    inline uint64_t get_VAL(void) const {
        return pVal[0];
    }
    inline uint64_t get_VAL(void) const volatile{
        return pVal[0];
    }
    inline void set_VAL(uint64_t value) {
        pVal[0] = value;
    }
    inline uint64_t& get_pVal(int index) {
        return pVal[index];
    }
    inline uint64_t* get_pVal() {
        return pVal;
    }
    inline const uint64_t* get_pVal() const{
        return pVal;
    }
    inline uint64_t get_pVal(int index) const{
        return pVal[index];
    }
    inline uint64_t* get_pVal() const volatile {
        return pVal;
    }
    inline uint64_t get_pVal(int index) const volatile {
        return pVal[index];
    }
    inline void set_pVal(int i, uint64_t value) {
        pVal[i] = value;
    }


    enum {
        APINT_BITS_PER_WORD = sizeof(uint64_t) * 8,
        APINT_WORD_SIZE = sizeof(uint64_t)
    };

    enum { excess_bits = (_AP_W%APINT_BITS_PER_WORD) ? APINT_BITS_PER_WORD -(_AP_W%APINT_BITS_PER_WORD) : 0};
    static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));

public:

    inline ap_private(const char* val) {
        set_canary();
        int radix = 10;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
        if (pos != std::string::npos)
            str = str.substr(pos);
        ap_private ap_private_val(str, radix);
        operator = (ap_private_val);
        report();
        check_canary();
    }

    inline ap_private(const char* val, int rd) {
        set_canary();
        int radix = rd;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
        if (pos != std::string::npos)
            str = str.substr(pos);
        ap_private ap_private_val(str, radix);
        operator = (ap_private_val);
        report();

        report();
        check_canary();
    }


    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this=ref.get();
        report();
        check_canary();
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this = ((uint64_t)(bool)ref);
        report();
        check_canary();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private(const ap_concat_ref<_AP_W2, _AP_T2,_AP_W3, _AP_T3>& ref) {
        set_canary();
        *this=ref.get();
        report();
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
        ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
            _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
       *this = ((val.operator ap_private<_AP_W2, false> ()));
        report();
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
        ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
            _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = (uint64_t)(bool)val;
        report();
        check_canary();
    }



    template<int _AP_W1, bool _AP_S1>
    inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, false>& that) {
        set_canary();
        operator = (const_cast<const ap_private<_AP_W1, _AP_S1, false>& >(that));
        check_canary();
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private(const ap_private<_AP_W1, _AP_S1, false>& that) {
        set_canary();
        operator = (that);
        check_canary();
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private(const ap_private<_AP_W1, _AP_S1, true>& that) {
        set_canary();
        static const uint64_t that_sign_ext_mask = (_AP_W1==APINT_BITS_PER_WORD)?0:~0ULL>>(_AP_W1%APINT_BITS_PER_WORD)<<(_AP_W1%APINT_BITS_PER_WORD);
        if (that.isNegative()) {
            pVal[0] = that.get_VAL()|that_sign_ext_mask;
            memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1));
        } else {
            pVal[0] = that.get_VAL();
            memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1));
        }
        clearUnusedBits();
        check_canary();
    }
#3194 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ~ap_private() {check_canary();}



    inline ap_private(){
 clear();
        set_canary();
        clearUnusedBits();
        check_canary();
    }

    inline ap_private(uint64_t* val, uint32_t bits=_AP_W) {((0) ? static_cast<void> (0) : __assert_fail ("0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3205, __PRETTY_FUNCTION__));}
    inline ap_private(const uint64_t *const val, uint32_t bits) {((0) ? static_cast<void> (0) : __assert_fail ("0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3206, __PRETTY_FUNCTION__));}
#3231 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private(int val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(bool val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(signed char val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned char val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(short val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned short val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned int val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(long val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long long val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(long long val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(half val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(float val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    inline ap_private(double val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
#3254 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline bool isSingleWord() const {
        return false;
    }



    static inline uint32_t whichWord(uint32_t bitPosition) {

        return (bitPosition) >> 6;
    }




    static inline uint32_t whichBit(uint32_t bitPosition) {

        return bitPosition & 0x3f;
    }





    static inline uint64_t maskBit(uint32_t bitPosition) {
        return 1ULL << (whichBit(bitPosition));
    }



    inline uint64_t getWord(uint32_t bitPosition) const {
        return pVal[whichWord(bitPosition)];
    }






    inline void clearUnusedBits(void)




    {
        pVal[_AP_N-1] = _AP_S ? ((((int64_t)pVal[_AP_N-1])<<(excess_bits))>> excess_bits) : (excess_bits ? ((pVal[_AP_N-1])<<(excess_bits))>>(excess_bits) : pVal[_AP_N-1]);
    }

    inline void clearUnusedBitsToZero(void) {
        pVal[_AP_N-1] &= mask;
    }

    inline void clearUnusedBitsToOne(void) {
        pVal[_AP_N-1] |= mask;
    }



    inline void fromString(const char *str, uint32_t slen,
            uint8_t radix) {
        enum { numbits=_AP_W};

        (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? static_cast<void> (0) : __assert_fail ("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
#3315 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
        ,
 3316
#3315 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
        , __PRETTY_FUNCTION__))
                                                   ;
        ((str && "String is null?") ? static_cast<void> (0) : __assert_fail ("str && \"String is null?\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3317, __PRETTY_FUNCTION__));
        bool isNeg = str[0] == '-';
        if (isNeg)
            str++, slen--;


        while(*str == '0' && *(str+1) != '\0') {str++; slen--;}
        (((slen <= numbits || radix != 2) && "Insufficient bit width") ? static_cast<void> (0) : __assert_fail ("(slen <= numbits || radix != 2) && \"Insufficient bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3324, __PRETTY_FUNCTION__));
        ((((slen - 1)*3 <= numbits || radix != 8) && "Insufficient bit width") ? static_cast<void> (0) : __assert_fail ("((slen - 1)*3 <= numbits || radix != 8) && \"Insufficient bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3325, __PRETTY_FUNCTION__));
        ((((slen - 1)*4 <= numbits || radix != 16) && "Insufficient bit width") ? static_cast<void> (0) : __assert_fail ("((slen - 1)*4 <= numbits || radix != 16) && \"Insufficient bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3326, __PRETTY_FUNCTION__));
        (((((slen -1)*64)/22 <= numbits || radix != 10) && "Insufficient bit width") ? static_cast<void> (0) : __assert_fail ("(((slen -1)*64)/22 <= numbits || radix != 10) && \"Insufficient bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3327, __PRETTY_FUNCTION__));

        memset(pVal, 0, _AP_N * sizeof(uint64_t));


        uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);



        uint64_t bigVal[_AP_N];
        memset(bigVal, 0, _AP_N * sizeof(uint64_t));
        ap_private<_AP_W, _AP_S> apdigit(getBitWidth(), bigVal);
        ap_private<_AP_W, _AP_S> apradix(radix);


        for (unsigned i = 0; i < slen; i++) {

            uint32_t digit = 0;
            char cdigit = str[i];
            if (radix == 16) {


                if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F')))
                    ((0 && "Invalid hex digit in string") ? static_cast<void> (0) : __assert_fail ("0 && \"Invalid hex digit in string\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3350, __PRETTY_FUNCTION__));
                if (((cdigit) >= '0' && (cdigit) <= '9'))
                    digit = cdigit - '0';
                else if (cdigit >= 'a')
                    digit = cdigit - 'a' + 10;
                else if (cdigit >= 'A')
                    digit = cdigit - 'A' + 10;
                else
                    ((0 && "huh? we shouldn't get here") ? static_cast<void> (0) : __assert_fail ("0 && \"huh? we shouldn't get here\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3358, __PRETTY_FUNCTION__));
            } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
                digit = cdigit - '0';
            } else if (cdigit != '\0'){
                ((0 && "Invalid character in digit string") ? static_cast<void> (0) : __assert_fail ("0 && \"Invalid character in digit string\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3362, __PRETTY_FUNCTION__));
            }



            if (shift)
                *this <<= shift;
            else
                *this *= apradix;


            apdigit.set_VAL(digit);
            *this += apdigit;
        }

        if (isNeg) {
            (*this)--;
            this->flip();
        }
        clearUnusedBits();
    }

    inline ap_private read() volatile {
        return *this;
    }

    inline void write(const ap_private& op2) volatile {
        *this = (op2);
    }

    inline operator ValType () const {
        return get_VAL();
    }

    inline int to_uchar() const {
        return (unsigned char) get_VAL();
    }

    inline int to_char() const {
        return (signed char) get_VAL();
    }

    inline int to_ushort() const {
        return (unsigned short) get_VAL();
    }

    inline int to_short() const {
        return (short) get_VAL();
    }

    inline int to_int() const {
        return (int) get_VAL();
    }

    inline unsigned to_uint() const {
        return (unsigned) get_VAL();
    }

    inline long to_long() const {
        return (long) get_VAL();
    }

    inline unsigned long to_ulong() const {
        return (unsigned long) get_VAL();
    }

    inline ap_slong to_int64() const {
        return (ap_slong) get_VAL();
    }

    inline ap_ulong to_uint64() const {
        return (ap_ulong) get_VAL();
    }

    inline double to_double() const {
        if (isNegative())
            return roundToDouble(true);
        else
            return roundToDouble(false);
    }

    inline unsigned length() const { return _AP_W; }


    inline ap_private& reverse () {
        for (int i = 0; i < _AP_W/2; ++i) {
            bool tmp = operator[](i);
            if (operator[](_AP_W - 1 - i))
                set(i);
            else
                clear(i);
            if (tmp)
                set(_AP_W - 1 - i);
            else
                clear(_AP_W - 1 - i);
        }
        clearUnusedBits();
        return *this;
    }


    inline bool iszero () const {
        return isMinValue();
    }

    inline bool to_bool() const {
        return !iszero();
    }


    inline bool sign () const {
        if (isNegative())
            return true;
        return false;
    }


    inline void invert (int i) {
        ((i >= 0 && "Attempting to read bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to read bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3480, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to read bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3481, __PRETTY_FUNCTION__));
        flip(i);
    }


    inline bool test (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to read bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3487, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to read bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3488, __PRETTY_FUNCTION__));
        return operator[](i);
    }


    inline void set (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to write bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3494, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to write bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3495, __PRETTY_FUNCTION__));
        v ? set(i) : clear(i);
    }


    inline void set_bit (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to write bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3501, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to write bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3502, __PRETTY_FUNCTION__));
        v ? set(i) : clear(i);
    }

    inline ap_private& set(uint32_t bitPosition) {
        pVal[whichWord(bitPosition)] |= maskBit(bitPosition);
        clearUnusedBits();
        return *this;
    }

    inline void set() {
        for (int i = 0; i < _AP_N; ++i)
            pVal[i] = ~0ULL;
        clearUnusedBits();
    }


    inline bool get (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to read bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3520, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to read bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3521, __PRETTY_FUNCTION__));
        return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
    }


    inline bool get_bit (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? static_cast<void> (0) : __assert_fail ("i >= 0 && \"Attempting to read bit with negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3527, __PRETTY_FUNCTION__));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? static_cast<void> (0) : __assert_fail ("i < _AP_W && \"Attempting to read bit beyond MSB\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3528, __PRETTY_FUNCTION__));
        return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
    }



    inline void lrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? static_cast<void> (0) : __assert_fail ("n >= 0 && \"Attempting to shift negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3535, __PRETTY_FUNCTION__));
        ((n < _AP_W && "Shift value larger than bit width") ? static_cast<void> (0) : __assert_fail ("n < _AP_W && \"Shift value larger than bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3536, __PRETTY_FUNCTION__));
        operator = (shl(n) | lshr(_AP_W - n));
    }



    inline void rrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? static_cast<void> (0) : __assert_fail ("n >= 0 && \"Attempting to shift negative index\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3543, __PRETTY_FUNCTION__));
        ((n < _AP_W && "Shift value larger than bit width") ? static_cast<void> (0) : __assert_fail ("n < _AP_W && \"Shift value larger than bit width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3544, __PRETTY_FUNCTION__));
        operator = (lshr(n) | shl(_AP_W - n));
    }



    inline ap_private& clear(uint32_t bitPosition) {
        pVal[whichWord(bitPosition)] &= ~maskBit(bitPosition);
        clearUnusedBits();
        return *this;
    }


    inline void clear() {
        memset(pVal, 0, _AP_N * APINT_WORD_SIZE);
    }


    ap_private& flip() {
        for (int i = 0; i < _AP_N; ++i)
            pVal[i] ^= ~0ULL;
        clearUnusedBits();
        return *this;
    }




    inline ap_private& flip(uint32_t bitPosition) {
        ((bitPosition < BitWidth && "Out of the bit-width range!") ? static_cast<void> (0) : __assert_fail ("bitPosition < BitWidth && \"Out of the bit-width range!\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 3573, __PRETTY_FUNCTION__));
        if ((*this)[bitPosition]) clear(bitPosition);
        else set(bitPosition);
        return *this;
    }


    inline void b_not() {
        flip();
    }

    inline ap_private getLoBits(uint32_t numBits) const {
        return ap_private_ops::lshr(ap_private_ops::shl(*this, _AP_W - numBits),
               _AP_W - numBits);
    }

    inline ap_private getHiBits(uint32_t numBits) const {
        return ap_private_ops::lshr(*this, _AP_W - numBits);
    }




    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this & a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this | a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this ^ a2.get();
    }
#3635 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator &=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] &= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] &= ext; } clearUnusedBits(); return *this; };
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator |=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] |= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] |= ext; } clearUnusedBits(); return *this; };
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator ^=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] ^= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] ^= ext; } clearUnusedBits(); return *this; };





    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        ap_private_ops::add(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S, _AP_S1);
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        ap_private_ops::sub(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S, _AP_S1);
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {

        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : whichWord(lhsBits - 1) + 1;
        if (!lhsWords) {

            return *this;
        }

        ap_private dupRHS = RHS;

        uint32_t rhsBits = dupRHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : whichWord(rhsBits - 1) + 1;
        if (!rhsWords) {

            clear();
            return *this;
        }


        uint32_t destWords = rhsWords + lhsWords;
        uint64_t *dest = (uint64_t*) malloc(destWords*sizeof(uint64_t));


        ap_private_ops::mul(dest, pVal, lhsWords, dupRHS.get_pVal(), rhsWords, destWords);


        clear();
        uint32_t wordsToCopy = destWords >= _AP_N ? _AP_N : destWords;

        memcpy(pVal, dest, wordsToCopy* APINT_WORD_SIZE);

        uint64_t ext = (isNegative() ^ RHS.isNegative()) ? ~0ULL : 0ULL;
        for (int i=wordsToCopy; i<_AP_N; i++)
            pVal[i]=ext;
        clearUnusedBits();

        free(dest);
        return *this;
    }
#3715 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator /=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator / (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator %=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator % (op); return *this; }
#3749 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator | (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] | RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] | ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) | ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext | ext2); } } Result.clearUnusedBits(); return Result; };
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator & (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] & RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] & ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) & ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext & ext2); } } Result.clearUnusedBits(); return Result; };
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator ^ (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] ^ RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] ^ ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) ^ ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext ^ ext2); } } Result.clearUnusedBits(); return Result; };



    template<int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1,_AP_S1>::plus operator+(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1,_AP_S1>::plus Result, lhs(*this), rhs(RHS);
        const int Result_AP_N = (RType<_AP_W1,_AP_S1>::plus_w + 63) / 64;
        ap_private_ops::add(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(), Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
        Result.clearUnusedBits();
        return Result;
    }

    template<int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1,_AP_S1>::minus operator-(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1,_AP_S1>::minus Result, lhs(*this), rhs(RHS);
        const int Result_AP_N = (RType<_AP_W1,_AP_S1>::minus_w + 63) / 64;
        ap_private_ops::sub(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(), Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
        Result.clearUnusedBits();
        return Result;
    }

    template<int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1, _AP_S1>::mult operator*(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1, _AP_S1>::mult temp = *this;
        temp *= RHS;
        return temp;
    }

    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::div
    operator / (const ap_private<_AP_W2,_AP_S2>& op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        return typename RType<_AP_W2,_AP_S2>::div((_AP_S||_AP_S2)?lhs.sdiv(rhs):lhs.udiv(rhs));
    }

    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::mod
    operator % (const ap_private<_AP_W2,_AP_S2>& op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs= op;
        typename RType<_AP_W2,_AP_S2>::mod res = typename RType<_AP_W2,_AP_S2>::mod(_AP_S?lhs.srem(rhs):lhs.urem(rhs));
        return res;
    }
#3807 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private operator << (const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }

    inline ap_private operator << (const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }


    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator << (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this << sh;
        } else {
            int sh = op2.to_int();
            return *this << sh;
        }
    }
#3852 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private operator >> (const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }

    inline ap_private operator >> (const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }


    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator >> (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this >> sh;
        } else {
            int sh = op2.to_int();
            return *this >> sh;
        }
    }
#3900 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >> (op); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >> (op); return *this; } template<int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2,_AP_S2>& op) { *this = operator >> (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator << (op); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator << (op); return *this; } template<int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2,_AP_S2>& op) { *this = operator << (op); return *this; }



    inline bool operator==(const ap_private& RHS) const {

        uint32_t n1 = getActiveBits();
        uint32_t n2 = RHS.getActiveBits();


        if (n1 != n2)
            return false;


        if (n1 <= APINT_BITS_PER_WORD)
            return pVal[0] == RHS.get_pVal(0);


        for (int i = whichWord(n1 - 1); i >= 0; --i)
            if (pVal[i] != RHS.get_pVal(i))
                return false;
        return true;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)),};
        ap_private<_AP_MAX_W, false> lhs(*this);
        ap_private<_AP_MAX_W, false> rhs(op);
        return lhs==rhs;
    }

    inline bool operator==(uint64_t Val) const {
        uint32_t n = getActiveBits();
        if (n <= APINT_BITS_PER_WORD)
            return pVal[0] == Val;
        else
            return false;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this==op);
    }

    template<bool _AP_S1>
    inline bool operator!=(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !((*this) == RHS);
    }

    inline bool operator!=(uint64_t Val) const {
        return !((*this) == Val);
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_private<_AP_W2,_AP_S2>& op) const {
        return !(*this>op);
    }

    inline bool operator <(const ap_private& op) const {
        return _AP_S ? slt(op):ult(op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.slt(rhs):lhs.ult(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);

    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator >=(const ap_private<_AP_W2,_AP_S2>& op) const {
        return !(*this<op);
    }

    inline bool operator >(const ap_private& op) const {
        return _AP_S ? sgt(op):ugt(op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.sgt(rhs):lhs.ugt(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);

    }



    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,
                _AP_S>*>(this), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>((const_cast<ap_private<_AP_W,
                    _AP_S>*> (this)), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    range (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    range (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private*>(this), Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }

    inline ap_bit_ref<_AP_W,_AP_S> operator [] (int index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    template<int _AP_W2, bool _AP_S2>
    inline const ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2>& index) const {
        return ap_bit_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,_AP_S>& >(*this), index.to_int() );
    }

    inline const ap_bit_ref<_AP_W,_AP_S> operator [](int index) const {
        return ap_bit_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,_AP_S>& >(*this), index );
    }

    inline ap_bit_ref<_AP_W,_AP_S> bit (int index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    inline const ap_bit_ref<_AP_W,_AP_S> bit (int index) const {
        return ap_bit_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,_AP_S>& >(*this), index );
    }

    template<int _AP_W2, bool _AP_S2>
    inline const ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2>& index) const {
        return ap_bit_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,_AP_S>& >(*this), index.to_int() );
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(ap_private<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(const ap_private<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                                                                                                  const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                             const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                  const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                      const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    inline ap_private<_AP_W,false> get() const {
        ap_private<_AP_W,false> ret(*this);
        return ret;
    }

    template<int _AP_W3>
    inline void set(const ap_private<_AP_W3, false> & val) {
        operator = (ap_private<_AP_W3, _AP_S>(val));
    }







    inline bool isNegative() const {

        enum {shift = (_AP_W-APINT_BITS_PER_WORD*(_AP_N-1)-1)};
        static const uint64_t mask = 1ULL << (shift);
        return _AP_S && (pVal[_AP_N-1]&mask);
    }



    inline bool isPositive() const {
        return !isNegative();
    }




    inline bool isStrictlyPositive() const {
        return isPositive() && (*this) != 0;
    }



    inline bool isAllOnesValue() const {
        return countPopulation() == _AP_W;
    }




    inline bool isMaxValue() const {
        return countPopulation() == _AP_W;
    }




    inline bool isMaxSignedValue() const {
        return !isNegative() && countPopulation() == _AP_W - 1;
    }




    inline bool isMinValue() const {
        return countPopulation() == 0;
    }




    inline bool isMinSignedValue() const {
        return isNegative() && countPopulation() == 1;
    }




    inline const uint64_t* getRawData() const {
        return &pVal[0];
    }
#4318 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private sqrt() const {


        uint32_t magnitude = getActiveBits();



        if (magnitude <= 5) {
            static const uint8_t results[32] = {
                            0,
                            1, 1,
                            2, 2, 2, 2,
                            3, 3, 3, 3, 3, 3,
                            4, 4, 4, 4, 4, 4, 4, 4,
                            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                            6
            };
            return ap_private<_AP_W, _AP_S>( results[get_VAL()]);
        }





        if (magnitude < 52) {





            return ap_private<_AP_W, _AP_S>(
                    uint64_t(::round(::sqrt(double(get_VAL())))));

        }






        uint32_t nbits = BitWidth, i = 4;
        ap_private<_AP_W, _AP_S> testy(16);
        ap_private<_AP_W, _AP_S> x_old( 1);
        ap_private<_AP_W, _AP_S> x_new(0);
        ap_private<_AP_W, _AP_S> two( 2);


        for ( ; ; i += 2, testy = testy.shl(2))
            if (i >= nbits || this->ule(testy)) {
                x_old = x_old.shl(i / 2);
                break;
            }


        for ( ; ; ) {
            x_new = (this->udiv(x_old) + x_old).udiv(two);
            if (x_old.ule(x_new))
                break;
            x_old = x_new;
        }







        ap_private<_AP_W, _AP_S> square(x_old * x_old);
        ap_private<_AP_W, _AP_S> nextSquare((x_old + 1) * (x_old +1));
        if (this->ult(square))
            return x_old;
        else if (this->ule(nextSquare)) {
            ap_private<_AP_W, _AP_S> midpoint((nextSquare - square).udiv(two));
            ap_private<_AP_W, _AP_S> offset(*this - square);
            if (offset.ult(midpoint))
                return x_old;
            else
                return x_old + 1;
        } else
            ((0 && "Error in ap_private<_AP_W, _AP_S>::sqrt computation") ? static_cast<void> (0) : __assert_fail ("0 && \"Error in ap_private<_AP_W, _AP_S>::sqrt computation\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 4397, __PRETTY_FUNCTION__));
        return x_old + 1;
    }






    inline ap_private& operator=(const ap_private& RHS) {
        if (this != &RHS)
            memcpy(pVal, RHS.get_pVal(), _AP_N * APINT_WORD_SIZE);
        return *this;
    }
    inline ap_private& operator=(const volatile ap_private& RHS) {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
        return *this;
    }
    inline void operator=(const ap_private& RHS) volatile {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
    }
    inline void operator=(const volatile ap_private& RHS) volatile {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        if (_AP_S1)
            cpSextOrTrunc(RHS);
        else
            cpZextOrTrunc(RHS);
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
        if (_AP_S1)
            cpSextOrTrunc(RHS);
        else
            cpZextOrTrunc(RHS);
        clearUnusedBits();
        return *this;
    }
#4481 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline const ap_private operator++(int) {
        ap_private API(*this);
        ++(*this);
        return API;
    }



    inline ap_private& operator++() {
        ap_private_ops::add_1(pVal, pVal, _AP_N, 1);
        clearUnusedBits();
        return *this;
    }



    inline const ap_private operator--(int) {
        ap_private API(*this);
        --(*this);
        return API;
    }



    inline ap_private& operator--() {
        ap_private_ops::sub_1(pVal, _AP_N, 1);
        clearUnusedBits();
        return *this;
    }




    inline ap_private<_AP_W + !_AP_S, true> operator~() const {
        ap_private<_AP_W + !_AP_S, true> Result(*this);
        Result.flip();
        return Result;
    }




    inline typename RType<1,false>::minus operator-() const {
        return ap_private<1,false>(0) - (*this);
    }




    inline bool operator !() const {
        for (int i = 0; i < _AP_N; ++i)
            if (pVal[i])
                return false;
        return true;
    }

    template<bool _AP_S1>
    inline ap_private<_AP_W, _AP_S||_AP_S1> And(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator&(RHS);
    }
    template<bool _AP_S1>
    inline ap_private Or(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator|(RHS);
    }
    template<bool _AP_S1>
    inline ap_private Xor(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator^(RHS);
    }

    inline ap_private Mul(const ap_private& RHS) const {
        ap_private Result(*this);
        Result *= RHS;
        return Result;
    }

    inline ap_private Add(const ap_private& RHS) const {
        ap_private Result(0);
        ap_private_ops::add(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N, _AP_N, _AP_S, _AP_S);
        Result.clearUnusedBits();
        return Result;
    }

    inline ap_private Sub(const ap_private& RHS) const {
        ap_private Result(0);
        ap_private_ops::sub(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N, _AP_N, _AP_S, _AP_S);
        Result.clearUnusedBits();
        return Result;
    }



    inline ap_private ashr(uint32_t shiftAmt) const {
        ((shiftAmt <= BitWidth && "Invalid shift amount, too big") ? static_cast<void> (0) : __assert_fail ("shiftAmt <= BitWidth && \"Invalid shift amount, too big\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 4573, __PRETTY_FUNCTION__));

        if (shiftAmt == 0)
            return *this;




        if (shiftAmt == BitWidth) {
            if (isNegative())
                return ap_private(-1);
            else
                return ap_private(0);
        }


        ap_private Retval(0);
        uint64_t * val = Retval.get_pVal();


        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
        uint32_t breakWord = _AP_N - 1 - offset;
        uint32_t bitsInWord = whichBit(BitWidth);
        if (bitsInWord == 0)
            bitsInWord = APINT_BITS_PER_WORD;


        if (wordShift == 0) {

            for (uint32_t i = 0; i <= breakWord; ++i)
                val[i] = pVal[i+offset];


            if (isNegative())
                if (bitsInWord < APINT_BITS_PER_WORD)
                    val[breakWord] |= ~0ULL << (bitsInWord);
        } else {

            for (uint32_t i = 0; i < breakWord; ++i) {


                val[i] = ((pVal[i+offset]) >> (wordShift));
                val[i] |= ((pVal[i+offset+1]) << (APINT_BITS_PER_WORD - wordShift));
            }



            val[breakWord] = (pVal[breakWord+offset]) >> (wordShift);



            if (isNegative()) {
                if (wordShift > bitsInWord) {
                    if (breakWord > 0)
                        val[breakWord-1] |=
                            ~0ULL << (APINT_BITS_PER_WORD - (wordShift - bitsInWord));
                    val[breakWord] |= ~0ULL;
                } else
                    val[breakWord] |= (~0ULL << (bitsInWord - wordShift));
            }
        }


        uint64_t fillValue = (isNegative() ? ~0ULL : 0);
        for (int i = breakWord+1; i < _AP_N; ++i)
            val[i] = fillValue;
        Retval.clearUnusedBits();
        return Retval;
    }



    inline ap_private lshr(uint32_t shiftAmt) const {



        if (shiftAmt == BitWidth)
            return ap_private(0);




        if (shiftAmt == 0)
            return *this;


        ap_private Retval(0);
        uint64_t * val = Retval.get_pVal();


        if (shiftAmt < APINT_BITS_PER_WORD) {
            uint64_t carry = 0;
            for (int i = _AP_N-1; i >= 0; --i) {
                val[i] = ((pVal[i]) >> (shiftAmt)) | carry;
                carry = (pVal[i]) << (APINT_BITS_PER_WORD - shiftAmt);
            }
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


        if (wordShift == 0) {
            for (uint32_t i = 0; i < _AP_N - offset; ++i)
                val[i] = pVal[i+offset];
            for (uint32_t i = _AP_N-offset; i < _AP_N; i++)
                val[i] = 0;
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t breakWord = _AP_N - offset -1;
        for (uint32_t i = 0; i < breakWord; ++i)
            val[i] = ((pVal[i+offset]) >> (wordShift)) |
                ((pVal[i+offset+1]) << (APINT_BITS_PER_WORD - wordShift));

        val[breakWord] = (pVal[breakWord+offset]) >> (wordShift);


        for (int i = breakWord+1; i < _AP_N; ++i)
            val[i] = 0;
        Retval.clearUnusedBits();
        return Retval;
    }



    inline ap_private shl(uint32_t shiftAmt) const {
        ((shiftAmt <= BitWidth && "Invalid shift amount, too big") ? static_cast<void> (0) : __assert_fail ("shiftAmt <= BitWidth && \"Invalid shift amount, too big\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 4706, __PRETTY_FUNCTION__));



        if (shiftAmt == BitWidth)
            return ap_private(0);




        if (shiftAmt == 0)
            return *this;


        ap_private Retval(0);
        uint64_t* val = Retval.get_pVal();

        if (shiftAmt < APINT_BITS_PER_WORD) {
            uint64_t carry = 0;
            for (int i = 0; i < _AP_N; i++) {
                val[i] = ((pVal[i]) << (shiftAmt)) | carry;
                carry = (pVal[i]) >> (APINT_BITS_PER_WORD - shiftAmt);
            }
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


        if (wordShift == 0) {
            for (uint32_t i = 0; i < offset; i++)
                val[i] = 0;
            for (int i = offset; i < _AP_N; i++)
                val[i] = pVal[i-offset];
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t i = _AP_N - 1;
        for (; i > offset; --i)
            val[i] = (pVal[i-offset]) << (wordShift) |
                (pVal[i-offset-1]) >> (APINT_BITS_PER_WORD - wordShift);
        val[offset] = (pVal[0]) << (wordShift);
        for (i = 0; i < offset; ++i)
            val[i] = 0;
        Retval.clearUnusedBits();
        return Retval;
    }

    inline ap_private rotl(uint32_t rotateAmt) const {
        if (rotateAmt == 0)
            return *this;

        ap_private hi(*this);
        ap_private lo(*this);
        hi.shl(rotateAmt);
        lo.lshr(BitWidth - rotateAmt);
        return hi | lo;
    }

    inline ap_private rotr(uint32_t rotateAmt) const {
        if (rotateAmt == 0)
            return *this;

        ap_private hi(*this);
        ap_private lo(*this);
        lo.lshr(rotateAmt);
        hi.shl(BitWidth - rotateAmt);
        return hi | lo;
    }





    inline ap_private udiv(const ap_private& RHS) const {

        uint32_t rhsBits = RHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
        ((rhsWords && "Divided by zero???") ? static_cast<void> (0) : __assert_fail ("rhsWords && \"Divided by zero???\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 4789, __PRETTY_FUNCTION__));
        uint32_t lhsBits = this->getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


        if (!lhsWords)

            return ap_private(0);
        else if (lhsWords < rhsWords || this->ult(RHS)) {

            return ap_private(0);
        } else if (*this == RHS) {

            return ap_private(1);
        } else if (lhsWords == 1 && rhsWords == 1) {

            return ap_private(this->pVal[0] / RHS.get_pVal(0));
        }


        ap_private Quotient(0);
        ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, &Quotient, (ap_private*)0);
        return Quotient;
    }



    inline ap_private sdiv(const ap_private& RHS) const {
        if (isNegative())
            if (RHS.isNegative())
                return (-(*this)).udiv(-RHS);
            else
                return -((-(*this)).udiv(RHS));
        else if (RHS.isNegative())
            return -(this->udiv((ap_private)(-RHS)));
        return this->udiv(RHS);
    }
#4834 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline ap_private urem(const ap_private& RHS) const {

        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


        uint32_t rhsBits = RHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
        ((rhsWords && "Performing remainder operation by zero ???") ? static_cast<void> (0) : __assert_fail ("rhsWords && \"Performing remainder operation by zero ???\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 4842, __PRETTY_FUNCTION__));


        if (lhsWords == 0) {

            return ap_private(0);
        } else if (lhsWords < rhsWords || this->ult(RHS)) {

            return *this;
        } else if (*this == RHS) {

            return ap_private(0);
        } else if (lhsWords == 1) {

            return ap_private(pVal[0] % RHS.get_pVal(0));
        }


        ap_private Remainder(0);
        ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, (ap_private*)(0), &Remainder);
        return Remainder;
    }

    inline ap_private urem(uint64_t RHS) const {

        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);

        uint32_t rhsWords = 1;
        ((rhsWords && "Performing remainder operation by zero ???") ? static_cast<void> (0) : __assert_fail ("rhsWords && \"Performing remainder operation by zero ???\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 4871, __PRETTY_FUNCTION__));

        if (lhsWords == 0) {

            return ap_private(0);
        } else if (lhsWords < rhsWords || this->ult(RHS)) {

            return *this;
        } else if (*this == RHS) {

            return ap_private(0);
        } else if (lhsWords == 1) {

            return ap_private(pVal[0] % RHS);
        }


        ap_private Remainder(0);
        divide(*this, lhsWords, RHS, (ap_private*)(0), &Remainder);
        return Remainder;
    }



    inline ap_private srem(const ap_private& RHS) const {
        if (isNegative()) {
            ap_private lhs = -(*this);
            if (RHS.isNegative()) {
                ap_private rhs = -RHS;
                return -(lhs.urem(rhs));
            } else
                return -(lhs.urem(RHS));
        } else if (RHS.isNegative()) {
            ap_private rhs = -RHS;
            return this->urem(rhs);
        }
        return this->urem(RHS);
    }



    inline ap_private srem(int64_t RHS) const {
        if (isNegative())
            if (RHS<0)
                return -((-(*this)).urem(-RHS));
            else
                return -((-(*this)).urem(RHS));
        else if (RHS<0)
            return this->urem(-RHS);
        return this->urem(RHS);
    }





    template<bool _AP_S1>
    inline bool eq(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return (*this) == RHS;
    }





    template<bool _AP_S1>
    inline bool ne(const ap_private<_AP_W, _AP_S1> &RHS) const {
        return !((*this) == RHS);
    }





    template<bool _AP_S1>
    inline bool ult(const ap_private<_AP_W, _AP_S1>& RHS) const {

        uint32_t n1 = getActiveBits();
        uint32_t n2 = RHS.getActiveBits();


        if (n1 < n2)
            return true;


        if (n2 < n1)
            return false;


        if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
            return pVal[0] < RHS.get_pVal(0);


        uint32_t topWord = whichWord(AESL_std::max(n1,n2)-1);
        for (int i = topWord; i >= 0; --i) {
            if (pVal[i] > RHS.get_pVal(i))
                return false;
            if (pVal[i] < RHS.get_pVal(i))
                return true;
        }
        return false;
    }

    inline bool ult(uint64_t RHS) const {

        uint32_t n1 = getActiveBits();
        uint32_t n2 = 64 - ap_private_ops::CountLeadingZeros_64(RHS);


        if (n1 < n2)
            return true;


        if (n2 < n1)
            return false;


        if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
            return pVal[0] < RHS;
        ((0) ? static_cast<void> (0) : __assert_fail ("0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 4990, __PRETTY_FUNCTION__));
    }

    template<bool _AP_S1>
    inline bool slt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        ap_private lhs(*this);
        ap_private<_AP_W, _AP_S1> rhs(RHS);
        bool lhsNeg = isNegative();
        bool rhsNeg = rhs.isNegative();
        if (lhsNeg) {

            lhs.flip();
            lhs++;
        }
        if (rhsNeg) {

            rhs.flip();
            rhs++;
        }



        if (lhsNeg)
            if (rhsNeg)
                return lhs.ugt(rhs);
            else
                return true;
        else if (rhsNeg)
            return false;
        else
            return lhs.ult(rhs);
    }





    template<bool _AP_S1>
    inline bool ule(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return ult(RHS) || eq(RHS);
    }





    template<bool _AP_S1>
    inline bool sle(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return slt(RHS) || eq(RHS);
    }





    template<bool _AP_S1>
    inline bool ugt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !ult(RHS) && !eq(RHS);
    }





    template<bool _AP_S1>
    inline bool sgt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !slt(RHS) && !eq(RHS);
    }





    template<bool _AP_S1>
    inline bool uge(const ap_private<_AP_W, _AP_S>& RHS) const {
        return !ult(RHS);
    }





    template<bool _AP_S1>
    inline bool sge(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !slt(RHS);
    }


    template<int _AP_W1, bool _AP_S1>
    inline void cpSext(const ap_private<_AP_W1, _AP_S1>& that) {
        ((_AP_W1 < BitWidth && "Invalid ap_private SignExtend request") ? static_cast<void> (0) : __assert_fail ("_AP_W1 < BitWidth && \"Invalid ap_private SignExtend request\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5080, __PRETTY_FUNCTION__));
        ((_AP_W1 <= MAX_INT_BITS && "Too many bits") ? static_cast<void> (0) : __assert_fail ("_AP_W1 <= MAX_INT_BITS && \"Too many bits\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5081, __PRETTY_FUNCTION__));

        if (!that.isNegative()) {
            cpZext(that);
            return;
        }


        enum { wordBits = _AP_W1 % APINT_BITS_PER_WORD};
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;

        if (_AP_N1 == _AP_N) {
            enum { newWordBits = _AP_W % APINT_BITS_PER_WORD};

            static const uint64_t mask = wordBits?(~0ULL<<(wordBits)):0ULL;
            for (int i = 0; i < _AP_N; ++i)
                pVal[i] = that.get_pVal(i);
            pVal[_AP_N-1] |= mask;
            return;
        }

        enum { newWordBits = _AP_W % APINT_BITS_PER_WORD};

        static const uint64_t mask = wordBits?(~0ULL<<(wordBits)):0ULL;
        int i;
        for (i = 0; i < _AP_N1; ++i)
            pVal[i] = that.get_pVal(i);
        pVal[i - 1] |= mask;
        for (; i < _AP_N-1; i++)
            pVal[i] = ~0ULL;
        pVal[i] = ~0ULL;
        clearUnusedBits();
        return;
    }


    template <int _AP_W1, bool _AP_S1>
    inline void cpZext(const ap_private<_AP_W1, _AP_S1>& that) {
        ((_AP_W1 < BitWidth && "Invalid ap_private ZeroExtend request") ? static_cast<void> (0) : __assert_fail ("_AP_W1 < BitWidth && \"Invalid ap_private ZeroExtend request\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5119, __PRETTY_FUNCTION__));
        ((_AP_W1 <= MAX_INT_BITS && "Too many bits") ? static_cast<void> (0) : __assert_fail ("_AP_W1 <= MAX_INT_BITS && \"Too many bits\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5120, __PRETTY_FUNCTION__));
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        int i = 0;
        for (; i < _AP_N1; ++i)
            pVal[i] = that.get_pVal(i);
        for (; i < _AP_N; ++i)
            pVal[i] = 0;
        clearUnusedBits();
    }

    template<int _AP_W1, bool _AP_S1>
    inline void cpZextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
        if (BitWidth > _AP_W1)
            cpZext(that);
        else {
            for (int i=0; i<_AP_N; ++i)
                pVal[i]=that.get_pVal(i);
            clearUnusedBits();
        }
    }

    template<int _AP_W1, bool _AP_S1>
    inline void cpSextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
        if (BitWidth > _AP_W1)
            cpSext(that);
        else {
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = that.get_pVal(i);
            clearUnusedBits();
        }
    }






    inline uint32_t getBitWidth() const {
        return BitWidth;
    }




    inline uint32_t getNumWords() const {
        return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
    }





    inline uint32_t getActiveBits() const {
        uint32_t bits=BitWidth - countLeadingZeros();
        return bits?bits:1;
    }






    inline uint64_t getZExtValue() const {
        ((getActiveBits() <= 64 && "Too many bits for uint64_t") ? static_cast<void> (0) : __assert_fail ("getActiveBits() <= 64 && \"Too many bits for uint64_t\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5183, __PRETTY_FUNCTION__));
        return *pVal;
    }





    inline int64_t getSExtValue() const {
        ((getActiveBits() <= 64 && "Too many bits for int64_t") ? static_cast<void> (0) : __assert_fail ("getActiveBits() <= 64 && \"Too many bits for int64_t\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5192, __PRETTY_FUNCTION__));
        return int64_t(pVal[0]);
    }




    inline static uint32_t getBitsNeeded(const char* str, uint32_t slen, uint8_t radix) {
        ((str != 0 && "Invalid value string") ? static_cast<void> (0) : __assert_fail ("str != 0 && \"Invalid value string\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5200, __PRETTY_FUNCTION__));
        ((slen > 0 && "Invalid string length") ? static_cast<void> (0) : __assert_fail ("slen > 0 && \"Invalid string length\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5201, __PRETTY_FUNCTION__));


        uint32_t isNegative = str[0] == '-';
        if (isNegative) {
            slen--;
            str++;
        }


        if (radix == 2)
            return slen + isNegative;
        if (radix == 8)
            return slen * 3 + isNegative;
        if (radix == 16)
            return slen * 4 + isNegative;


        ((radix == 10 && "Invalid radix") ? static_cast<void> (0) : __assert_fail ("radix == 10 && \"Invalid radix\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5219, __PRETTY_FUNCTION__));






        return isNegative + slen * 4;
    }







    inline uint32_t countLeadingZeros() const {
        enum { msw_bits = (BitWidth % APINT_BITS_PER_WORD)?(BitWidth % APINT_BITS_PER_WORD):APINT_BITS_PER_WORD,
            excessBits = APINT_BITS_PER_WORD - msw_bits };
        uint32_t Count = ap_private_ops::CountLeadingZeros_64(pVal[_AP_N-1]);
        if (Count>=excessBits)
            Count -= excessBits;
        if (!pVal[_AP_N-1]) {
            for (int i = _AP_N-1 ; i ; --i) {
                if (!pVal[i-1])
                    Count += APINT_BITS_PER_WORD;
                else {
                    Count += ap_private_ops::CountLeadingZeros_64(pVal[i-1]);
                    break;
                }
            }
        }
        return Count;
    }






    inline uint32_t countLeadingOnes() const {
        if (isSingleWord())
            return countLeadingOnes_64(get_VAL(), APINT_BITS_PER_WORD - BitWidth);

        uint32_t highWordBits = BitWidth % APINT_BITS_PER_WORD;
        uint32_t shift = (highWordBits == 0 ? 0 : APINT_BITS_PER_WORD - highWordBits);
        int i = _AP_N - 1;
        uint32_t Count = countLeadingOnes_64(get_pVal(i), shift);
        if (Count == highWordBits) {
            for (i--; i >= 0; --i) {
                if (get_pVal(i) == ~0ULL)
                    Count += APINT_BITS_PER_WORD;
                else {
                    Count += countLeadingOnes_64(get_pVal(i), 0);
                    break;
                }
            }
        }
        return Count;
    }
#5287 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    inline uint32_t countTrailingZeros() const {
        uint32_t Count = 0;
        uint32_t i = 0;
        for (; i < _AP_N && get_pVal(i) == 0; ++i)
            Count += APINT_BITS_PER_WORD;
        if (i < _AP_N)
            Count += ap_private_ops::CountTrailingZeros_64(get_pVal(i));
        return AESL_std::min(Count, BitWidth);
    }






    inline uint32_t countPopulation() const {
        uint32_t Count = 0;
        for (int i = 0; i<_AP_N-1 ; ++i)
            Count += ap_private_ops::CountPopulation_64(pVal[i]);
        Count += ap_private_ops::CountPopulation_64(pVal[_AP_N-1]&mask);
        return Count;
    }







    inline std::string toString(uint8_t radix, bool wantSigned) const
        ;





    inline std::string toStringUnsigned(uint8_t radix = 10) const {
        return toString(radix, false);
    }





    inline std::string toStringSigned(uint8_t radix = 10) const {
        return toString(radix, true);
    }


    inline double roundToDouble(bool isSigned) const {


        if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {
            uint64_t val = pVal[0];
            if (isSigned) {
                int64_t sext = ((int64_t(val)) << (64-BitWidth)) >> (64-BitWidth);
                return double(sext);
            } else
                return double(val);
        }


        bool isNeg = isSigned ? (*this)[BitWidth-1] : false;


        ap_private<_AP_W, _AP_S> Tmp(isNeg ? -(*this) : (*this));


        uint32_t n = Tmp.getActiveBits();




        uint64_t exp = n;


        if (exp > 1023) {
            if (!isSigned || !isNeg)
                return std::numeric_limits<double>::infinity();
            else
                return -std::numeric_limits<double>::infinity();
        }
        exp += 1023;



        uint64_t mantissa;
        unsigned hiWord = whichWord(n-1);
        if (hiWord == 0) {
            mantissa = Tmp.get_pVal(0);
            if (n > 52)
                (mantissa) >>= (n - 52);
        } else {
            ((hiWord > 0 && "High word is negative?") ? static_cast<void> (0) : __assert_fail ("hiWord > 0 && \"High word is negative?\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5380, __PRETTY_FUNCTION__));
            uint64_t hibits = (Tmp.get_pVal(hiWord)) << (52 - n % APINT_BITS_PER_WORD);
            uint64_t lobits = (Tmp.get_pVal(hiWord-1)) >> (11 + n % APINT_BITS_PER_WORD);
            mantissa = hibits | lobits;
        }


        uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;
        union {
            double __D;
            uint64_t __I;
        } __T;
        __T.__I = sign | ((exp) << 52) | mantissa;
        return __T.__D;
    }


    inline double roundToDouble() const {
        return roundToDouble(false);
    }


    inline double signedRoundToDouble() const {
        return roundToDouble(true);
    }





    inline double bitsToDouble() const {
        union {
            uint64_t __I;
            double __D;
        } __T;
        __T.__I = pVal[0];
        return __T.__D;
    }





    inline float bitsToFloat() const {
        union {
            uint32_t __I;
            float __F;
        } __T;
        __T.__I = uint32_t(pVal[0]);
        return __T.__F;
    }





    inline ap_private& doubleToBits(double __V) {
        union {
            uint64_t __I;
            double __D;
        } __T;
        __T.__D = __V;
        pVal[0] = __T.__I;
        return *this;
    }





    inline ap_private& floatToBits(float __V) {
        union {
            uint32_t __I;
            float __F;
        } __T;
        __T.__F = __V;
        pVal[0] = __T.__I;
    }



    inline bool and_reduce() const {
        return isMaxValue();
    }

    inline bool nand_reduce() const {
        return isMinValue();
    }

    inline bool or_reduce() const {
        return (bool)countPopulation();
    }

    inline bool nor_reduce() const {
        return countPopulation()==0;
    }

    inline bool xor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?true:false;
    }

    inline bool xnor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?false:true;
    }
    inline std::string to_string(uint8_t radix=16, bool sign=false) const {
        return toString(radix, radix==10?_AP_S:sign);
    }
};

namespace ap_private_ops {
    enum {APINT_BITS_PER_WORD=64};
    template<int _AP_W, bool _AP_S>
    inline bool operator==(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
        return V2 == V1;
    }

    template<int _AP_W, bool _AP_S>
    inline bool operator!=(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
        return V2 != V1;
    }


    template<int _AP_W, bool _AP_S, int index>
    inline bool get(const ap_private<_AP_W, _AP_S>& a) {
        static const uint64_t mask=1ULL << (index&0x3f);
        return ((mask & a.get_pVal((index)>>6)) != 0);
    }

    template<int _AP_W, bool _AP_S, int msb_index, int lsb_index>
    inline void set(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                    const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
        enum { APINT_BITS_PER_WORD=64,
            lsb_word = lsb_index /APINT_BITS_PER_WORD,
            msb_word = msb_index / APINT_BITS_PER_WORD,
            msb = msb_index % APINT_BITS_PER_WORD,
            lsb=lsb_index % APINT_BITS_PER_WORD};
        if (msb_word==lsb_word) {
            const uint64_t mask = ~0ULL >> (lsb) << (APINT_BITS_PER_WORD-msb+lsb-1)>>(APINT_BITS_PER_WORD-msb-1);

            a.get_pVal(msb_word) |= mask;
        } else {
            const uint64_t lsb_mask = ~0ULL >> (lsb) << (lsb);
            const uint64_t msb_mask = ~0ULL << (APINT_BITS_PER_WORD-msb-1)>>(APINT_BITS_PER_WORD-msb-1);

            a.get_pVal(lsb_word) |=lsb_mask;
            for (int i=lsb_word+1; i<msb_word; i++) {
                a.set_pVal(i, ~0ULL);

            }


            a.get_pVal(msb_word) |= msb_mask;
        }
        a.clearUnusedBits();
    }

    template<int _AP_W, bool _AP_S, int msb_index, int lsb_index>
    inline void clear(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                    const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
        enum { APINT_BITS_PER_WORD=64,
            lsb_word = lsb_index /APINT_BITS_PER_WORD,
            msb_word = msb_index / APINT_BITS_PER_WORD,
            msb = msb_index % APINT_BITS_PER_WORD,
            lsb=lsb_index % APINT_BITS_PER_WORD};
        if (msb_word == lsb_word) {
            const uint64_t mask = ~(~0ULL >> (lsb) << (APINT_BITS_PER_WORD-msb+lsb-1)>>(APINT_BITS_PER_WORD-msb-1));

            a.get_pVal(msb_word) &= mask;
        } else {
            const uint64_t lsb_mask = ~(~0ULL >> (lsb) << (lsb));
            const uint64_t msb_mask = ~(~0ULL << (APINT_BITS_PER_WORD-msb-1)>>(APINT_BITS_PER_WORD-msb-1));

            a.get_pVal(lsb_word) &=lsb_mask;
            for (int i=lsb_word+1; i<msb_word; i++) {

                a.get_pVal(i)=0;
            }

            a.get_pVal(msb_word) &= msb_mask;
        }
        a.clearUnusedBits();
    }


    template<int _AP_W, bool _AP_S, int index>
    inline void set(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
        enum { APINT_BITS_PER_WORD=64, word = index/APINT_BITS_PER_WORD};
        static const uint64_t mask=1ULL << (index%APINT_BITS_PER_WORD);

        a.get_pVal(word) |= mask;
        a.clearUnusedBits();
    }

    template<int _AP_W, bool _AP_S, int index>
    inline void clear(ap_private<_AP_W, _AP_S>& a,
                      const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
        enum { APINT_BITS_PER_WORD=64, word = index/APINT_BITS_PER_WORD};
        static const uint64_t mask=~(1ULL << (index%APINT_BITS_PER_WORD));

        a.get_pVal(word) &= mask;
        a.clearUnusedBits();
    }

}

template<int _AP_W, bool _AP_S>
inline std::string ap_private<_AP_W, _AP_S, false>::toString(uint8_t radix, bool wantSigned) const {
    (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? static_cast<void> (0) : __assert_fail ("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
#5592 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    ,
 5593
#5592 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h"
    , __PRETTY_FUNCTION__))
                                               ;
    static const char *digits[] = {
        "0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"
    };
    std::string result;

    if (radix != 10) {





        if (*this == (uint64_t)(0))
            result = "0";
        else {
            ap_private<_AP_W, false> tmp(*this);
            size_t insert_at = 0;
            bool leading_zero = true;
            if (wantSigned && isNegative()) {



                tmp.flip();
                tmp++;
                tmp.clearUnusedBitsToZero();
                result = "-";
                insert_at = 1;
                leading_zero = false;
            }
            switch (radix) {
                case 2: result += "0b"; break;
                case 8: result += "0o"; break;
                case 16: result += "0x"; break;
                default: (("invalid radix" && 0) ? static_cast<void> (0) : __assert_fail ("\"invalid radix\" && 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5626, __PRETTY_FUNCTION__));
            }
            insert_at += 2;

            uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
            uint64_t mask = radix - 1;
            ap_private<_AP_W, false> zero(0);
            unsigned bits = 0;
            while (tmp.ne(zero)) {
                uint64_t digit = tmp.get_VAL() & mask;
                result.insert(insert_at, digits[digit]);
                tmp = tmp.lshr(shift);
                ++bits;
            }
            bits *= shift;
            if (bits < _AP_W && leading_zero)
                result.insert(insert_at, digits[0]);
        }
        return result;
    }

    ap_private<_AP_W, false> tmp(*this);
    ap_private<_AP_W, false> divisor(radix);
    ap_private<_AP_W, false> zero(0);
    size_t insert_at = 0;
    if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        tmp.clearUnusedBitsToZero();
        result = "-";
        insert_at = 1;
    }
    if (tmp == ap_private<_AP_W, false>(0))
        result = "0";
    else while (tmp.ne(zero)) {
        ap_private<_AP_W, false> APdigit(0);
        ap_private<_AP_W, false> tmp2(0);
        ap_private_ops::divide(tmp, tmp.getNumWords(), divisor, divisor.getNumWords(), &tmp2,
                &APdigit);
        uint64_t digit = APdigit.getZExtValue();
        ((digit < radix && "divide failed") ? static_cast<void> (0) : __assert_fail ("digit < radix && \"divide failed\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_private.h", 5669, __PRETTY_FUNCTION__));
        result.insert(insert_at,digits[digit]);
        tmp = tmp2;
    }

    return result;
}
#99 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h" 2
#170 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;
template<int _AP_W> class ap_uint;

enum {AP_BIN=2,AP_OCT=8,AP_DEC=10,AP_HEX=16};
#193 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {



    enum {_AP_WR=_AP_W1+_AP_W2,};
    _AP_T1& mbv1;
    _AP_T2& mbv2;

    inline ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1,
          _AP_W2, _AP_T2>& ref):
           mbv1(ref.mbv1), mbv2(ref.mbv2) {}

    inline ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2):mbv1(bv1),mbv2(bv2) {}


    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator = (const ap_private<_AP_W3,_AP_S3>& val) {
        ap_private<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1=mbv1.length();
        int W_ref2=mbv2.length();
        ap_private<_AP_W1,false> mask1(-1);
        mask1>>=_AP_W1-W_ref1;
        ap_private<_AP_W2,false> mask2(-1);
        mask2>>=_AP_W2-W_ref2;
        mbv1.set(ap_private<_AP_W1,false>((vval>>W_ref2)&mask1));
        mbv2.set(ap_private<_AP_W2,false>(vval&mask2));
        return *this;
    }


    inline ap_concat_ref& operator = (unsigned long long val) {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_concat_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }

    inline ap_concat_ref& operator =
        (const ap_concat_ref <_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }



    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator =(const ap_bit_ref<_AP_W3, _AP_S3>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }


    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator =(tmpVal);
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const af_range_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = ((const ap_private<_AP_W3, false>)(val));
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = (val.to_ap_private());
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator=((unsigned long long)(bool)(val));
     }


    inline operator ap_private<_AP_WR, false> () const
    {
        return get();
    }

    inline operator unsigned long long () const
    {
         return get().to_uint64();
    }

    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >
        operator, (const ap_range_ref<_AP_W3, _AP_S3> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >(*this,
                           const_cast<ap_range_ref<_AP_W3, _AP_S3> &>(a2));
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3> >
        operator, (ap_private<_AP_W3, _AP_S3> &a2)
    {
          return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3, ap_private<_AP_W3, _AP_S3> >(*this, a2);
    }

    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3> >
        operator, (const ap_private<_AP_W3, _AP_S3> &a2)
    {
          return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3, ap_private<_AP_W3, _AP_S3> >(*this,
                               const_cast<ap_private<_AP_W3, _AP_S3>&>(a2));
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
        operator, (const ap_bit_ref<_AP_W3, _AP_S3> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                               1, ap_bit_ref<_AP_W3, _AP_S3> >(*this,
                          const_cast<ap_bit_ref<_AP_W3, _AP_S3> &>(a2));
    }

    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> >
        operator, (const ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,
                               _AP_T4> >(*this, const_cast<ap_concat_ref<_AP_W3,
                               _AP_T3,_AP_W4, _AP_T4>& >(a2));
    }

    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline
    ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_range_ref<_AP_W3,_AP_I3, _AP_S3, _AP_Q3,
                _AP_O3, _AP_N3>& >(a2));
    }

    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline
    ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_bit_ref<_AP_W3,_AP_I3, _AP_S3,
                _AP_Q3, _AP_O3, _AP_N3>& >(a2));
    }

    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator & (const ap_private<_AP_W3,_AP_S3>& a2)
    {
        return get() & a2;
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator | (const ap_private<_AP_W3,_AP_S3>& a2)
    {
        return get() | a2;
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator ^ (const ap_private<_AP_W3,_AP_S3>& a2)
    {
      return ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>(get() ^ a2);
    }


    inline const ap_private<_AP_WR, false> get() const
    {
      ap_private<_AP_W1+_AP_W2, false> tmpVal = ap_private<_AP_W1+_AP_W2, false> (mbv1.get());
      ap_private<_AP_W1+_AP_W2, false> tmpVal2 = ap_private<_AP_W1+_AP_W2, false> (mbv2.get());
        int W_ref2 = mbv2.length();
        tmpVal <<= W_ref2;
        tmpVal |= tmpVal2;
        return tmpVal;
    }


    inline const ap_private<_AP_WR, false> get()
    {
      ap_private<_AP_W1+_AP_W2, false> tmpVal =ap_private<_AP_W1+_AP_W2, false> ( mbv1.get());
      ap_private<_AP_W1+_AP_W2, false> tmpVal2 = ap_private<_AP_W1+_AP_W2, false> (mbv2.get());
        int W_ref2 = mbv2.length();
        tmpVal <<= W_ref2;
        tmpVal |= tmpVal2;
        return tmpVal;
    }


    template <int _AP_W3>
    inline void set(const ap_private<_AP_W3,false> & val)
    {
        ap_private<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1=mbv1.length();
        int W_ref2=mbv2.length();
        ap_private<_AP_W1,false> mask1(-1);
        mask1>>=_AP_W1-W_ref1;
        ap_private<_AP_W2,false> mask2(-1);
        mask2>>=_AP_W2-W_ref2;
        mbv1.set(ap_private<_AP_W1,false>((vval>>W_ref2)&mask1));
        mbv2.set(ap_private<_AP_W2,false>(vval&mask2));
    }


    inline int length() const {
        return mbv1.length()+mbv2.length();
    }

    inline std::string to_string(uint8_t radix=2) const {
        return get().to_string(radix);
    }
};






template<int _AP_W, bool _AP_S>
struct ap_range_ref {



    ap_private<_AP_W,_AP_S> &d_bv;
    int l_index;
    int h_index;

public:
    inline ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref):
         d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

    inline ap_range_ref(ap_private<_AP_W,_AP_S>* bv, int h, int l):
        d_bv(*bv),l_index(l),h_index(h)
    {
        if (h < 0 || l < 0)
     fprintf(stderr, "Warning! Higher bound (%d) and lower bound (%d) cannot be negative.\n", h, l);
        if (h >= _AP_W || l >= _AP_W)
     fprintf(stderr, "Warning! Higher bound (%d) or lower bound (%d) out of range (%d).\n", h, l, _AP_W);





    }


    inline operator ap_private<_AP_W, false> () const
    {
        ap_private<_AP_W, false> val(0);
        if(h_index>=l_index) {
   if (_AP_W > 64) {
            val=d_bv;
            ap_private<_AP_W,false> mask(-1);
            mask>>=_AP_W-(h_index-l_index+1);
            val>>=l_index;
            val&=mask;
   } else {
     const static uint64_t mask = (~0ULL>> (64>_AP_W ? (64-_AP_W):0));
     val = (d_bv >> l_index) & (mask >>(_AP_W-(h_index-l_index+1)));
   }
        } else {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    if((d_bv)[j]) val.set(i);
        }
        return val;
    }

    inline operator unsigned long long () const
    {
        return to_uint64();
    }

    template<int _AP_W2,bool _AP_S2>
    inline ap_range_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val)
    {
      ap_private<_AP_W,false> vval=ap_private<_AP_W,false>(val);
      if(l_index>h_index)
 {
   for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
     (vval)[i]? d_bv.set(j):d_bv.clear(j);
        } else {
 if (_AP_W > 64) {
   ap_private<_AP_W,false> mask(-1);
   if(l_index>0)
     {
       mask<<=l_index;
       vval<<=l_index;
     }
   if(h_index<_AP_W-1)
     {
       ap_private<_AP_W,false> mask2(-1);
       mask2>>=_AP_W-h_index-1;
       mask&=mask2;
       vval&=mask2;
     }
   mask.flip();
   d_bv&=mask;
   d_bv|=vval;
 } else {
   unsigned shift = 64-_AP_W;
   uint64_t mask = ~0ULL>>(shift);
   if(l_index>0)
     {
       vval = mask & vval << l_index;
       mask = mask & mask << l_index;
     }
   if(h_index<_AP_W-1)
     {
       uint64_t mask2 = mask;
       mask2 >>= (_AP_W-h_index-1);
       mask&=mask2;
       vval&=mask2;
     }
   mask = ~mask;
   d_bv&=mask;
   d_bv|=vval;
 }
      }
      return *this;
    }

  inline ap_range_ref& operator = (unsigned long long val)
    {
        const ap_private<_AP_W,_AP_S> vval=val;
        return operator = (vval);
    }


    inline ap_range_ref& operator =(const ap_range_ref<_AP_W, _AP_S>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }



    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_range_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template <int _AP_W3, bool _AP_S3>
    inline ap_range_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, _AP_S2>)(val));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_private());
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_range_ref& operator= (const ap_bit_ref<_AP_W2, _AP_S2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template <int _AP_W2, bool _AP_S2>
    inline
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2,_AP_S2> &a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                   ap_range_ref<_AP_W2,_AP_S2> >(*this,
                   const_cast<ap_range_ref<_AP_W2,_AP_S2>& >(a2));
    }


    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_private<_AP_W2,_AP_S2> >
    operator , (ap_private<_AP_W2,_AP_S2>& a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }

    inline ap_concat_ref<_AP_W,ap_range_ref,_AP_W,ap_private<_AP_W,_AP_S> >
    operator , (ap_private<_AP_W, _AP_S>& a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                          ap_private<_AP_W,_AP_S> >(*this, a2);
    }



    template <int _AP_W2, bool _AP_S2>
    inline
    ap_concat_ref<_AP_W,ap_range_ref,1,ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2,_AP_S2> &a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, 1,
                      ap_bit_ref<_AP_W2,_AP_S2> >(*this, const_cast<ap_bit_ref<
                      _AP_W2,_AP_S2>& >(a2));
    }


    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2)
    {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                       const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3,
                       _AP_T3>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }


    template<int _AP_W2>
    inline void set(const ap_private<_AP_W2,false>& val)
    {
        ap_private<_AP_W,_AP_S> vval=val;
        if(l_index>h_index)
        {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    (vval)[i]? d_bv.set(j):d_bv.clear(j);
        } else {
   if (_AP_W>64 ) {
            ap_private<_AP_W,_AP_S> mask(-1);
            if(l_index>0)
       {
                ap_private<_AP_W,false> mask1(-1);
                mask1>>=_AP_W-l_index;
                mask1.flip();
                mask=mask1;

                vval<<=l_index;
       }
            if(h_index<_AP_W-1)
       {
                ap_private<_AP_W,false> mask2(-1);
                mask2<<=h_index+1;
                mask2.flip();
                mask&=mask2;
                vval&=mask2;
       }
            mask.flip();
            d_bv&=mask;
            d_bv|=vval;
   } else {
     uint64_t mask = ~0ULL >> (64-_AP_W);
            if(l_index>0)
       {
  uint64_t mask1 = mask;
  mask1=mask & (mask1>>(_AP_W-l_index));
  vval =mask&( vval <<l_index);
  mask=~mask1&mask;

       }
            if(h_index<_AP_W-1) {
  uint64_t mask2 = ~0ULL >> (64-_AP_W);
  mask2 = mask &(mask2<<(h_index+1));
  mask&=~mask2;
  vval&=~mask2;
       }
            d_bv&=(~mask&(~0ULL >> (64-_AP_W)));
            d_bv|=vval;
   }
 }
    }


    inline ap_private<_AP_W,false> get() const
    {
      ap_private<_AP_W,false> val(0);
      if(h_index<l_index) {
 for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
   if((d_bv)[j]) val.set(i);
      } else {
 val=d_bv;
 val>>=l_index;
 if(h_index<_AP_W-1)
   {
     if (_AP_W <= 64) {
       const static uint64_t mask = (~0ULL>> (64>_AP_W ? (64-_AP_W):0));
       val &= (mask>> (_AP_W-(h_index-l_index+1)));
     } else {
       ap_private<_AP_W,false> mask(-1);
       mask>>=_AP_W-(h_index-l_index+1);
       val&=mask;
     }
   }
      }
      return val;
    }


  inline ap_private<_AP_W,false> get()
  {
    ap_private<_AP_W,false> val(0);
    if(h_index<l_index) {
      for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
 if((d_bv)[j]) val.set(i);
    } else {
      val=d_bv;
      val>>=l_index;
      if(h_index<_AP_W-1)
 {
   if (_AP_W <= 64 ) {
     static const uint64_t mask = ~0ULL>> (64>_AP_W ? (64-_AP_W):0);
     return val &= ( (mask) >> (_AP_W - (h_index-l_index+1)));
   } else {
     ap_private<_AP_W,false> mask(-1);
     mask>>=_AP_W-(h_index-l_index+1);
     val&=mask;
   }
 }
    }
    return val;
  }


    inline int length() const
    {
        return h_index>=l_index?h_index-l_index+1:l_index-h_index+1;
    }


    inline int to_int() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_int();
    }


    inline unsigned int to_uint() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_uint();
    }


    inline long to_long() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_long();
    }


    inline unsigned long to_ulong() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_ulong();
    }


    inline ap_slong to_int64() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_int64();
    }


    inline ap_ulong to_uint64() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_uint64();
    }

    inline std::string to_string(uint8_t radix=2) const {
        return get().to_string(radix);
    }

    inline bool and_reduce() {
        bool ret = true;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret &= d_bv[i];
        return ret;
    }

    inline bool or_reduce() {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret |= d_bv[i];
        return ret;
    }

    inline bool xor_reduce() {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret ^= d_bv[i];
        return ret;
    }
};






template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



    ap_private<_AP_W,_AP_S>& d_bv;
    int d_index;

public:
    inline ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref):
            d_bv(ref.d_bv), d_index(ref.d_index) {}

    inline ap_bit_ref(ap_private<_AP_W,_AP_S>& bv, int index=0):
        d_bv(bv),d_index(index)
    {
        if (d_index < 0 )
     fprintf(stderr, "Warning! Index of bit vector  (%d) cannot be negative.\n", d_index);
        if (d_index >= _AP_W)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W);


    }


    inline operator bool () const
    {
      return d_bv.get_bit(d_index);
    }


    inline bool to_bool() const
    {
        return operator bool ();
    }


    inline ap_bit_ref& operator = (unsigned long long val)
    {
        if(val)
            d_bv.set(d_index);
        else
            d_bv.clear(d_index);
        return *this;
    }
#972 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(val != 0));
    }


    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_bit_ref<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(bool)val);
    }

    inline ap_bit_ref& operator =(const ap_bit_ref<_AP_W,_AP_S>& val)
    {
        return operator =((unsigned long long)(bool)val);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_range_ref<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(bool) val);
    }


    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, false>)(val));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_bit_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_private<_AP_W2 + _AP_W3, false>)(val));
    }


    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >
    operator , (ap_private<_AP_W2, _AP_S2>& a2) const
     {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >(const_cast<ap_bit_ref<_AP_W,_AP_S>& >(*this), a2);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const
    {
        return
            ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >(const_cast<ap_bit_ref<_AP_W,_AP_S>& >(*this),
                    const_cast<ap_range_ref<_AP_W2, _AP_S2> &>(a2));
    }


    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const
    {
        return
            ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >(const_cast<ap_bit_ref<_AP_W,_AP_S>& >(*this),
                    const_cast<ap_bit_ref<_AP_W2, _AP_S2> &>(a2));
    }


    inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref >
    operator, (const ap_bit_ref &a2) const
    {
        return
            ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref >(const_cast<ap_bit_ref<_AP_W,_AP_S>& >(*this),
                const_cast<ap_bit_ref&>(a2));
    }


    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >
    operator, (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> &a2) const
    {
        return
            ap_concat_ref<1,ap_bit_ref,_AP_W2+_AP_W3,
                    ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >(const_cast<ap_bit_ref<_AP_W,_AP_S>& >(*this),
                    const_cast<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const
    {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_bit_ref<_AP_W,_AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const
    {
        return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_bit_ref<_AP_W,_AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_bit_ref<_AP_W2, _AP_S2>& op) const
    {
        return get() == op.get();
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_bit_ref<_AP_W2, _AP_S2>& op) const
    {
        return get() != op.get();
    }


    inline bool get() const
    {
        return operator bool ();
    }


    template <int _AP_W3>
    inline void set(const ap_private<_AP_W3, false>& val)
    {
        operator = (val);
    }

    inline bool operator ~ () const
    {
        bool bit = (d_bv)[d_index];
        return bit ? false : true;
    }

    inline int length() const { return 1; }

    inline std::string to_string() const
    {
        bool val = get();
        return val ? "1" : "0";
    }
};
#1146 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator + (PTR_TYPE* i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator + (const ap_private<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; }
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator - (PTR_TYPE* i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator - (const ap_private<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
#1171 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline float operator * (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline float operator * (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 * i_op; } template<int _AP_W, bool _AP_S> inline float operator / (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline float operator / (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 / i_op; } template<int _AP_W, bool _AP_S> inline float operator + (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline float operator + (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; } template<int _AP_W, bool _AP_S> inline float operator - (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline float operator - (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
template<int _AP_W, bool _AP_S> inline double operator * (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline double operator * (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 * i_op; } template<int _AP_W, bool _AP_S> inline double operator / (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline double operator / (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 / i_op; } template<int _AP_W, bool _AP_S> inline double operator + (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline double operator + (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; } template<int _AP_W, bool _AP_S> inline double operator - (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline double operator - (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
#1270 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::mult operator * ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator * (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::plus operator + ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator + (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::minus operator - ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator - (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::div operator / ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator / (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::mod operator % ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator % (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator & ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator & (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator | ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator | (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator ^ (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> bool operator >> ( bool i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> bool operator << ( bool i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator == (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator != (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator > (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator >= (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator < (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator <= (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator += (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator -= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator *= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator /= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator %= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator &= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator |= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator ^= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, bool op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, bool op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::mult operator * ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator * (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::plus operator + ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator + (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::minus operator - ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator - (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::div operator / ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::div operator / ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator / (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::mod operator % ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator % (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::logic operator & ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator & (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::logic operator | ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator | (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-127 - 1) != 0>::template RType<_AP_W,_AP_S>::logic operator ^ ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator ^ (ap_private<8,(-127 - 1) != 0>(i_op)); } template<int _AP_W, bool _AP_S> char operator >> ( char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> char operator << ( char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-127 - 1) != 0>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator == (ap_private<8, (-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator != (ap_private<8, (-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator > (ap_private<8, (-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator >= (ap_private<8, (-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator < (ap_private<8, (-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator <= (ap_private<8, (-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator += (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator -= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator *= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator /= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator %= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator &= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator |= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator ^= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::mult operator * ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator * (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::plus operator + ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator + (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::minus operator - ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator - (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::div operator / ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator / (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::mod operator % ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator % (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator & ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator & (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator | ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator | (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator ^ (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> signed char operator >> ( signed char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> signed char operator << ( signed char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator == (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator != (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator > (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator >= (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator < (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator <= (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator += (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator -= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator *= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator /= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator %= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator &= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator |= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator ^= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator * (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator + (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator - (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator / (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator % (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator & (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator | (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator ^ (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned char operator >> ( unsigned char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned char operator << ( unsigned char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator == (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator != (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator > (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator >= (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator < (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator <= (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator += (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator -= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator *= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator /= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator %= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator &= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator |= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator ^= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::mult operator * ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator * (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::plus operator + ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator + (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::minus operator - ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator - (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::div operator / ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator / (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::mod operator % ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator % (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator & ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator & (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator | ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator | (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator ^ (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> short operator >> ( short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> short operator << ( short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator == (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator != (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator > (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator >= (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator < (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator <= (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator += (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator -= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator *= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator /= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator %= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator &= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator |= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator ^= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, short op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, short op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator * (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator + (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator - (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator / (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator % (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator & (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator | (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator ^ (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned short operator >> ( unsigned short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned short operator << ( unsigned short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator == (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator != (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator > (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator >= (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator < (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator <= (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator += (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator -= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator *= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator /= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator %= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator &= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator |= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator ^= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mult operator * ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator * (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::plus operator + ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator + (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::minus operator - ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator - (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::div operator / ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator / (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mod operator % ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator % (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator & ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator & (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator | ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator | (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator ^ (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> int operator >> ( int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> int operator << ( int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator == (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator != (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator > (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator >= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator < (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator <= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator += (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator -= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator *= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator /= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator %= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator &= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator |= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator ^= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, int op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, int op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator * (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator + (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator - (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator / (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator % (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator & (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator | (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator ^ (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned int operator >> ( unsigned int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned int operator << ( unsigned int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator == (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator != (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator > (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator >= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator < (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator <= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator += (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator -= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator *= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator /= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator %= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator &= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator |= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator ^= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { op = op.operator << (op2); return op; }

template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mult operator * ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator * (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::plus operator + ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator + (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::minus operator - ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator - (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::div operator / ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator / (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mod operator % ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator % (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator & ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator & (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator | ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator | (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator ^ (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> long operator >> ( long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> long operator << ( long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator == (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator != (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator > (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator >= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator < (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator <= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator += (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator -= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator *= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator /= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator %= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator &= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator |= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator ^= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, long op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, long op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator * (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator + (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator - (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator / (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator % (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator & (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator | (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator ^ (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned long operator >> ( unsigned long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned long operator << ( unsigned long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator == (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator != (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator > (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator >= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator < (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator <= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator += (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator -= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator *= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator /= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator %= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator &= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator |= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator ^= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { op = op.operator << (op2); return op; }




template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mult operator * ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator * (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::plus operator + ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator + (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::minus operator - ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator - (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::div operator / ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator / (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mod operator % ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator % (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator & ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator & (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator | ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator | (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator ^ (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> ap_slong operator >> ( ap_slong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> ap_slong operator << ( ap_slong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator == (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator != (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator > (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator >= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator < (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator <= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator += (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator -= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator *= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator /= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator %= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator &= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator |= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator ^= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mult operator * ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator * (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::plus operator + ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator + (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::minus operator - ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator - (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::div operator / ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator / (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mod operator % ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator % (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator & ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator & (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator | ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator | (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator ^ (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> ap_ulong operator >> ( ap_ulong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> ap_ulong operator << ( ap_ulong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator == (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator != (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator > (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator >= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator < (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator <= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator += (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator -= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator *= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator /= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator %= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator &= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator |= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator ^= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { op = op.operator << (op2); return op; }
#1324 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator += ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator += (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator -= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator -= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator *= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator *= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator /= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator /= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator %= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator %= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator >>= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator >>= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator <<= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator <<= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator &= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator &= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator |= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator |= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator ^= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator ^= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (op2.operator ap_private<_AP_W2, false>()); }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_private<_AP_W2, false>(op2)); }
#1389 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator += ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator += ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator -= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator -= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator *= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator *= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator /= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator /= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator %= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator %= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator >>= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator >>= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator <<= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator <<= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator &= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator &= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator |= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator |= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator ^= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator ^= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (ap_private<1, false>(op2)); }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::plus operator + ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::minus operator - ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::mult operator * ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::div operator / ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::mod operator % ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator >> ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator << ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator & ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator | ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator ^ ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_private<1, false>(op2)); }
#1452 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }

template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }




template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
#1494 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::plus operator + ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::minus operator - ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::mult operator * ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::div operator / ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::mod operator % ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::arg1 operator >> ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::arg1 operator << ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator & ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator | ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator ^ ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::plus operator + ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::minus operator - ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::mult operator * ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::div operator / ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::mod operator % ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::arg1 operator >> ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::arg1 operator << ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::logic operator & ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::logic operator | ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-127 - 1) != 0>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,(-127 - 1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-127 - 1) != 0>::template RType<_AP_W,false>::logic operator ^ ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-127 - 1) != 0>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::plus operator + ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::minus operator - ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::mult operator * ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::div operator / ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::mod operator % ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::arg1 operator >> ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::arg1 operator << ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator & ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator | ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator ^ ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::plus operator + ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::minus operator - ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::mult operator * ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::div operator / ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::mod operator % ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator & ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator | ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::plus operator + ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::minus operator - ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::mult operator * ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::div operator / ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::mod operator % ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::arg1 operator >> ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::arg1 operator << ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator & ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator | ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator ^ ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::plus operator + ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::minus operator - ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::mult operator * ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::div operator / ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::mod operator % ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator & ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator | ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::plus operator + ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::minus operator - ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mult operator * ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::div operator / ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mod operator % ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator >> ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator << ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator & ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator | ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator ^ ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::plus operator + ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::minus operator - ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mult operator * ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::div operator / ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mod operator % ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator & ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator | ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }

template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::plus operator + ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::minus operator - ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mult operator * ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::div operator / ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mod operator % ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator >> ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator << ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator & ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator | ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator ^ ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::plus operator + ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::minus operator - ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mult operator * ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::div operator / ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mod operator % ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator & ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator | ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }




template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::plus operator + ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::minus operator - ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mult operator * ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::div operator / ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mod operator % ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator >> ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator << ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator & ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator | ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator ^ ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::plus operator + ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::minus operator - ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mult operator * ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::div operator / ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mod operator % ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator >> ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator << ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator & ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator | ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator ^ ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
#1519 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::plus operator + (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator + (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::minus operator - (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator - (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mult operator * (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator * (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::div operator / (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator / (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mod operator % (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator % (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >> (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator >> (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator << (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator << (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator & (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator & (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator | (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator | (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^ (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator ^ (ap_private<_AP_W2, false>(rhs)); }
#1566 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::plus operator + (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator + (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::minus operator - (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator - (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::mult operator * (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator * (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::div operator / (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator / (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::mod operator % (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator % (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::arg1 operator >> (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator >> (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::arg1 operator << (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator << (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::logic operator & (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator & (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::logic operator | (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator | (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline typename ap_private<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::logic operator ^ (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2> &lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2> &rhs) { return ap_private<_AP_LW1+_AP_LW2,false>(lhs).operator ^ (ap_private<_AP_RW1+_AP_RW2,false>(rhs)); }
#1721 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (const ap_private<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (bool op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<1 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<1 + 1, false > operator, (bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 1, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_private<1 + _AP_W + _AP_W2, false> val(op2); ap_private<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 1, false > operator, (bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<1 + _AP_W + _AP_W2, false> val(op1); ap_private<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 1, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 1, false > operator, (bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 1, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_private<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 1, false> operator, (bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-127 - 1) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-127 - 1) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_private<8 + _AP_W + _AP_W2, (-127 - 1) != 0> val(op2); ap_private<8 + _AP_W + _AP_W2, (-127 - 1) != 0> ret(op1); if ((-127 - 1) != 0) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, (-127 - 1) != 0> val(op1); ap_private<8 + _AP_W + _AP_W2, (-127 - 1) != 0> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if ((-127 - 1) != 0) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_private<8 + 1, (-127 - 1) != 0> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, (-127 - 1) != 0> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (signed char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_private<8 + _AP_W + _AP_W2, true> val(op2); ap_private<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, true> val(op1); ap_private<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_private<8 + 1, true> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_private<8 + _AP_W + _AP_W2, false> val(op2); ap_private<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, false> val(op1); ap_private<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_private<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (short op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_private<16 + _AP_W + _AP_W2, true> val(op2); ap_private<16 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<16 + _AP_W + _AP_W2, true> val(op1); ap_private<16 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_private<16 + 1, true> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_private<16 + _AP_W + _AP_W2, false> val(op2); ap_private<16 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<16 + _AP_W + _AP_W2, false> val(op1); ap_private<16 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (int op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op2); ap_private<32 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op1); ap_private<32 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_private<32 + 1, true> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op2); ap_private<32 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op1); ap_private<32 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }

template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, long op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (long op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op2); ap_private<64 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op1); ap_private<64 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_private<64 + 1, true> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (unsigned long op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op2); ap_private<64 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op1); ap_private<64 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }




template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op2); ap_private<64 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op1); ap_private<64 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_private<64 + 1, true> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op2); ap_private<64 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op1); ap_private<64 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
#1747 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
#1768 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& out, const ap_private<_AP_W,_AP_S> &op)
{
  ap_private<_AP_W, _AP_S> v=op;
    const std::ios_base::fmtflags basefield = out.flags() & std::ios_base::basefield;
    unsigned radix = (basefield == std::ios_base::hex) ? 16 :
                     ((basefield == std::ios_base::oct) ? 8 : 10);
    std::string str=v.toString(radix,_AP_S);
    out<<str;
    return out;

}

template<int _AP_W, bool _AP_S>
inline std::istream& operator >> (std::istream& in, ap_private<_AP_W,_AP_S> &op)
{
    std::string str;
    in >> str;
    const std::ios_base::fmtflags basefield = in.flags() & std::ios_base::basefield;
    unsigned radix = (basefield == std::ios_base::hex) ? 16 :
                     ((basefield == std::ios_base::oct) ? 8 : 10);
    op = ap_private<_AP_W, _AP_S>(str.c_str(), radix);
    return in;

}

template<int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& out, const ap_range_ref<_AP_W,_AP_S> &op)
{
    return operator<<(out, ap_private<_AP_W, _AP_S>(op));
}

template<int _AP_W, bool _AP_S>
inline std::istream& operator >> (std::istream& in, ap_range_ref<_AP_W,_AP_S> &op)
{
    return operator>>(in, ap_private<_AP_W, _AP_S>(op));
}

template<int _AP_W, bool _AP_S>
inline void print(const ap_private<_AP_W,_AP_S> &op, bool fill=true )
{
    ap_private<_AP_W, _AP_S> v=op;
    uint32_t ws=v.getNumWords();
    const uint64_t *ptr=v.getRawData();
    int i=ws-1;

    if(_AP_W%64 != 0) {
        uint32_t offset=_AP_W%64;
        uint32_t count=(offset+3)/4;
        int64_t data=*(ptr+i);
        if(_AP_S)
            data=(data<<(64-offset))>>(64-offset);
        else
            count=(offset+4)/4;
        while(count-->0)

            printf("%lx",(data>>(count*4))&0xf);



    } else {
        if(_AP_S==false)
            printf("0");


        printf("%016lx",*(ptr+i));



    }
    for(--i;i>=0;i--)

        printf("%016lx",*(ptr+i));



    printf("\n");

}
#76 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_int.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h" 1
#75 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_int_sim.h" 1
#76 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h" 2
#97 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_bit_ref {



    ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& d_bv;
    int d_index;
public:
    inline af_bit_ref(const af_bit_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& ref):
           d_bv(ref.d_bv), d_index(ref.d_index) {
        if (d_index < 0 )
     fprintf(stderr, "Warning! Index of bit vector  (%d) cannot be negative.\n", d_index);
        if (d_index >= _AP_W)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W);


    }

    inline af_bit_ref(ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>* bv, int index=0):
    d_bv(*bv),d_index(index) {}

    inline operator bool() const {
        return d_bv.V[d_index];
    }

    inline af_bit_ref& operator=(unsigned long long val) {
        if(val)
            d_bv.V.set(d_index);
        else
            d_bv.V.clear(d_index);
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val) {
        return operator=(val!=0);
    }

    inline af_bit_ref& operator =(const af_bit_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& val) {
        return operator=((unsigned long long)(bool)val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_bit_ref operator=(const af_bit_ref<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)val);
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator = ( const ap_bit_ref<_AP_W2, _AP_S2> &val) {
        return operator =((unsigned long long) (bool) val);
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator = ( const ap_range_ref<_AP_W2,_AP_S2>& val) {
        return operator =((const ap_private<_AP_W2, false>) val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, false>)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline af_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_private<_AP_W2 + _AP_W3, false>)(val));
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_private<_AP_W2, _AP_S2> >(*this, op);
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
             _AP_N2> >(*this, const_cast<af_range_ref<_AP_W2, _AP_I2,
             _AP_S2, _AP_Q2, _AP_O2,_AP_N2>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
              _AP_O2, _AP_N2>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() == op.get();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() != op.get();
    }

    inline bool operator ~ () const {
        bool bit = (d_bv.V)[d_index];
        return bit ? false : true;
    }

    inline int length() const {
        return 1;
    }

    inline bool get() {
        return d_bv.V[d_index];
    }

    inline bool get() const {
        return d_bv.V[d_index];
    }

    inline std::string to_string() const {
        return d_bv.V[d_index] ? "1" : "0";
    }
};



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_range_ref {



    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &d_bv;
    int l_index;
    int h_index;

public:
    inline af_range_ref(const af_range_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& ref):
           d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

    inline af_range_ref(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>* bv, int h, int l):
        d_bv(*bv),l_index(l),h_index(h) {
        if (h < 0 || l < 0)
     fprintf(stderr, "Warning! Higher bound (%d) and lower bound (%d) cannot be negative.\n", h, l);
        if (h >= _AP_W || l >= _AP_W)
     fprintf(stderr, "Warning! Higher bound (%d) or lower bound (%d) out of range (%d).\n", h, l, _AP_W);





    }

    inline operator ap_private<_AP_W, false> () const {
        if(h_index >= l_index) {
          ap_private<_AP_W, false> val(d_bv.V);
          ap_private<_AP_W,false> mask(-1);
          mask>>=_AP_W-(h_index-l_index+1);
          val>>=l_index;
          return val&=mask;
        } else {
          ap_private<_AP_W, false> val = 0;
          for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
            if((d_bv.V)[j]) val.set(i);
          return val;
        }
    }

    inline operator unsigned long long() const {
        return get().to_uint64();
    }

    template<int _AP_W2,bool _AP_S2>
    inline af_range_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val) {
      ap_private<_AP_W, false> vval= ap_private<_AP_W, false>(val);
        if(l_index > h_index) {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    vval[i]? d_bv.V.set(j):d_bv.V.clear(j);
        } else {
          ap_private<_AP_W,false> mask(-1);
            if(l_index>0) {
                mask<<=l_index;
                vval<<=l_index;
            }
            if(h_index<_AP_W-1) {
              ap_private<_AP_W,false> mask2(-1);
              mask2>>=_AP_W-h_index-1;
              mask&=mask2;
              vval&=mask2;
            }
            mask.flip();
            d_bv.V &= mask;
            d_bv.V |= vval;
        }
        return *this;
    }





inline af_range_ref& operator = (const char val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const signed char val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const short val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned short val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const int val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned int val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const long long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned long long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }


    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline af_range_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template <int _AP_W3, bool _AP_S3>
    inline af_range_ref& operator =(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template <int _AP_W3, bool _AP_S3>
    inline af_range_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline af_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        const ap_private<_AP_W2, false> tmp= val.get();
        return operator = (tmp);
    }

    inline af_range_ref& operator= (const char* val) {
        const ap_private<_AP_W, false> tmp(val);
        return operator = (tmp);
    }

    inline af_range_ref& operator= (const af_range_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& val) {
        const ap_private<_AP_W, false> tmp= val.get();
        return operator = (tmp);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_range_ref& operator= (const ap_fixed_base<_AP_W2,
                          _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_private());
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator > (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator >= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator < (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator <= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }

    template<int _AP_W2>
    inline void set(const ap_private<_AP_W2,false>& val) {
        ap_private<_AP_W,_AP_S> vval=val;
        if(l_index>h_index) {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    vval[i]? d_bv.V.set(j):d_bv.V.clear(j);
        } else {
          ap_private<_AP_W,_AP_S> mask(-1);
            if(l_index>0) {
                ap_private<_AP_W,false> mask1(-1);
                mask1>>=_AP_W-l_index;
                mask1.flip();
                mask=mask1;

                vval<<=l_index;
            }
            if(h_index<_AP_W-1) {
                ap_private<_AP_W,false> mask2(-1);
                mask2<<=h_index+1;
                mask2.flip();
                mask&=mask2;
                vval&=mask2;
            }
            mask.flip();
            d_bv&=mask;
            d_bv|=vval;
        }

    }

    inline ap_private<_AP_W,false> get() const {
        if(h_index<l_index) {
          ap_private<_AP_W, false> val(0);
          for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
            if((d_bv.V)[j]) val.set(i);
          return val;
        } else {
          ap_private<_AP_W, false> val = ap_private<_AP_W,false>(d_bv.V);
          val>>= l_index;
          if(h_index<_AP_W-1)
            {
              ap_private<_AP_W,false> mask(-1);
              mask>>=_AP_W-(h_index-l_index+1);
              val&=mask;
            }
          return val;
        }
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_private<_AP_W2, _AP_S2> >(*this, op);
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3,
                  _AP_T3>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
             _AP_N2>& > (op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }

    inline int length() const {
        return h_index>=l_index?h_index-l_index+1:l_index-h_index+1;
    }

    inline int to_int() const {
        ap_private<_AP_W,false> val=get();
        return val.to_int();
    }

    inline unsigned int to_uint() const {
        ap_private<_AP_W,false> val=get();
        return val.to_uint();
    }

    inline long to_long() const {
        ap_private<_AP_W,false> val=get();
        return val.to_long();
    }

    inline unsigned long to_ulong() const {
        ap_private<_AP_W,false> val=get();
        return val.to_ulong();
    }

    inline ap_slong to_int64() const {
        ap_private<_AP_W,false> val=get();
        return val.to_int64();
    }

    inline ap_ulong to_uint64() const {
        ap_private<_AP_W,false> val=get();
        return val.to_uint64();
    }

    inline std::string to_string(uint8_t radix) const {
        return get().to_string(radix);
    }

};



template<int _AP_W, int _AP_I, bool _AP_S=true, ap_q_mode _AP_Q=AP_TRN,
         ap_o_mode _AP_O=AP_WRAP, int _AP_N=0>
struct ap_fixed_base {



private:

    inline ap_fixed_base(const std::string& val) {


        fromString(val);





    }

    void fromString(const std::string& val) {
        int radix = 10;

        std::string s = ap_private_ops::parseString(val, radix);

        fromString(s, radix);
    }

    void fromString(const std::string& val, unsigned char radix) {
        ((radix == 2 || radix == 8 || radix == 10 || radix == 16) ? static_cast<void> (0) : __assert_fail ("radix == 2 || radix == 8 || radix == 10 || radix == 16", "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h", 657, __PRETTY_FUNCTION__));
        V = 0;
        int startPos = 0;
        int endPos = val.length();
        int decPos = val.find(".");
        if (decPos == -1)
            decPos = endPos;
        bool isNegative = false;
        if (val[0] == '-') {
            isNegative = true;
            ++startPos;
        } else if (val[0] == '+')
            ++startPos;
#692 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
        ap_fixed_base<((_AP_I) > (4) ? (_AP_I) : (4))+4, ((_AP_I) > (4) ? (_AP_I) : (4))+4, false> integer_bits = 0;


        uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);




        bool sticky_int = false;


        for (int i = startPos; i < decPos; i++) {

            char cdigit = val[i];
            if (cdigit == '\0') continue;
            uint32_t digit = ap_private_ops::decode_digit(cdigit, radix);

            sticky_int |= integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 1] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 2] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 4];

            if (shift)
                integer_bits <<= shift;
            else
                integer_bits *= radix;


            integer_bits += digit;

        }
        integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] = integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] | sticky_int;

        ap_fixed_base<((_AP_W-_AP_I) > (0) ? (_AP_W-_AP_I) : (0))+4+4, 4, false> fractional_bits = 0;
        bool sticky = false;


        for (int i = endPos-1; i >= decPos+1; i--) {

            char cdigit = val[i];
            if (cdigit == '\0') continue;
            uint32_t digit = ap_private_ops::decode_digit(cdigit, radix);

            fractional_bits += digit;

            sticky |= fractional_bits[0] | fractional_bits[1] | fractional_bits[2] | fractional_bits[3];

            if (shift)
                fractional_bits >>= shift;
            else
                fractional_bits /= radix;


        }



        fractional_bits[0] = fractional_bits[0] | sticky;

        if(isNegative)
            *this = -(integer_bits + fractional_bits);
        else
            *this = integer_bits + fractional_bits;


    }

    inline void report() {







        if (!_AP_S && _AP_O == AP_WRAP_SM) {
            fprintf(stderr, "ap_ufxied<...> cannot support AP_WRAP_SM.\n");
            exit(1);
        }
        if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
            fprintf(stderr, "[E] ap_%sfixed<%d, ...>: Bitwidth exceeds the "
                   "default max value %d. Please use macro "
                   "AP_INT_MAX_W to set a larger max value.\n",
                            _AP_S?"":"u", _AP_W,
                            ((1024 + 1023) / 1024) * 1024);
            exit(1);
        }
    }


    inline unsigned long long doubleToRawBits(double pf)const {
        union {
            unsigned long long __L;
            double __D;
        }LD;
        LD.__D=pf;
        return LD.__L;
    }


    inline double rawBitsToDouble(unsigned long long pi) const {
        union {
            unsigned long long __L;
            double __D;
        }LD;
        LD.__L=pi;
        return LD.__D;
    }

    inline float rawBitsToFloat(uint32_t pi) const {
        union {
            uint32_t __L;
            float __D;
        }LD;
        LD.__L = pi;
        return LD.__D;
    }

    inline half rawBitsToHalf(uint16_t pi) const {
        half f;
        f.set_bits(pi);
        return f;
    }


public:
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct
ap_fixed_base;
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct
af_bit_ref;

    inline void overflow_adjust(bool underflow, bool overflow,
                                bool lD, bool sign) {
        if (!overflow && !underflow) return;
        switch (_AP_O) {
            case AP_WRAP:
                if (_AP_N == 0)
                    return;
                if (_AP_S) {


                    if (_AP_N > 1) {
                        ap_private<_AP_W, _AP_S> mask(-1);
                        if (_AP_N >= _AP_W) mask = 0;
                        else mask.lshr(_AP_N);
                        if (sign)
                            V &= mask;
                        else
                            V |= ~mask;
                    }
                    sign ? V.set(_AP_W - 1) : V.clear(_AP_W - 1);
                } else {

                    ap_private<_AP_W, _AP_S> mask(-1);
                    if (_AP_N >= _AP_W) mask = 0;
                    else mask.lshr(_AP_N);
                    mask.flip();
                    V |= mask;
                }
                break;
            case AP_SAT_ZERO:
                V.clear();
                break;
            case AP_WRAP_SM:
                {
                bool Ro = ap_private_ops::get<_AP_W, _AP_S, _AP_W -1>(V);
                if (_AP_N == 0) {
                    if (lD != Ro) {
                        V.flip();
                        lD ? ap_private_ops::set<_AP_W, _AP_S, _AP_W - 1>(V) :
                            ap_private_ops::clear<_AP_W, _AP_S, _AP_W - 1>(V);
                    }
                } else {
                    if (_AP_N == 1 && sign != Ro) {
                        V.flip();
                    } else if (_AP_N > 1) {
                        bool lNo = ap_private_ops::get<_AP_W, _AP_S, _AP_W - _AP_N> (V);
                        if (lNo == sign)
                            V.flip();
                        ap_private<_AP_W, false> mask(-1);
                        if (_AP_N >= _AP_W) mask = 0;
                        else mask.lshr(_AP_N);
                        if (sign)
                            V &= mask;
                        else
                            V |= mask.flip();
                        sign ? ap_private_ops::set<_AP_W, _AP_S, _AP_W - 1>(V) : ap_private_ops::clear<_AP_W, _AP_S, _AP_W - 1>(V);
                    }
                }
                }
                break;
            default:
                if (_AP_S) {
                    if (overflow) {
                        V.set(); ap_private_ops::clear<_AP_W, _AP_S, _AP_W-1>(V);
                    } else if (underflow) {
                        V.clear();
                        ap_private_ops::set<_AP_W, _AP_S, _AP_W-1>(V);
                        if(_AP_O == AP_SAT_SYM)
                            ap_private_ops::set<_AP_W, _AP_S, 0>(V);
                    }
                } else {
                    if (overflow)
                        V.set();
                    else if (underflow)
                        V.clear();
                }
        }
    }

    inline bool quantization_adjust(bool qb, bool r, bool s) {
        bool carry=ap_private_ops::get<_AP_W, _AP_S, _AP_W-1>(V);
        switch (_AP_Q) {
            case AP_TRN:
                return false;
            case AP_RND_ZERO:
                qb &= s || r;
                break;
            case AP_RND_MIN_INF:
                qb &= r;
                break;
            case AP_RND_INF:
                qb &= !s || r;
                break;
            case AP_RND_CONV:
                qb &= ap_private_ops::get<_AP_W, _AP_S, 0>(V) || r;
                break;
            case AP_TRN_ZERO:
                qb = s && ( qb || r );
                break;
            default:;

        }
        if(qb) ++V;

        return carry && !(ap_private_ops::get<_AP_W, _AP_S, _AP_W-1>(V));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2>
    struct RType {
        enum {
            _AP_F=_AP_W-_AP_I,
            F2=_AP_W2-_AP_I2,
            mult_w = _AP_W+_AP_W2,
            mult_i = _AP_I+_AP_I2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            plus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            minus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,

            div_w = _AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)) + _AP_S2,



            div_i = _AP_I + (_AP_W2-_AP_I2) + _AP_S2,
            div_s = _AP_S||_AP_S2,
            logic_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            logic_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };

        typedef ap_fixed_base<mult_w, mult_i, mult_s> mult;
        typedef ap_fixed_base<plus_w, plus_i, plus_s> plus;
        typedef ap_fixed_base<minus_w, minus_i, minus_s> minus;
        typedef ap_fixed_base<logic_w, logic_i, logic_s> logic;
        typedef ap_fixed_base<div_w, div_i, div_s> div;
        typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1;
    };
#971 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    inline ap_fixed_base() {
    }



    inline ap_fixed_base(const ap_fixed_base& op):V(op.V) {}
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op):V(0) {
        enum {N2=_AP_W2,_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2,QUAN_INC=F2>_AP_F && !(_AP_Q==AP_TRN ||
                (_AP_Q==AP_TRN_ZERO && !_AP_S2))};
        if (!op) return;
        bool carry=false;

        enum { sh_amt =(F2>_AP_F)?F2-_AP_F:_AP_F-F2};
        const ap_private<_AP_W2, _AP_S2>& val = op.V;
        bool neg_src=val.isNegative();
        if (F2==_AP_F)
            V=val;

        else if (F2>_AP_F) {
            if (sh_amt >= _AP_W2)
                V = neg_src ? -1 : 0;
            else
                V = _AP_S2?val.ashr(sh_amt):val.lshr(sh_amt);
            if (_AP_Q!=AP_TRN && !(_AP_Q==AP_TRN_ZERO && !_AP_S2)) {
                bool qb = false;
                if (F2-_AP_F>_AP_W2)
                    qb = neg_src;
                else
                    qb = ap_private_ops::get<_AP_W2, _AP_S2, F2-_AP_F-1>(val);

                bool r=false;
                enum { pos3 = F2-_AP_F-2};
                if(pos3>=_AP_W2-1)
                    r=val!=0;
                else if (pos3>=0)
                r = (val<<(_AP_W2-1-pos3))!=0;
                carry = quantization_adjust(qb,r,neg_src);
            }
        } else {
            if (sh_amt < _AP_W) {
                V=val;
                V <<= sh_amt;
            }
        }

        if ((_AP_O!=AP_WRAP || _AP_N != 0) &&
                ((!_AP_S && _AP_S2) || _AP_I-_AP_S <
                 _AP_I2 - _AP_S2 + (QUAN_INC|| (_AP_S2 &&
                     _AP_O==AP_SAT_SYM)))) {
            bool deleted_zeros = _AP_S2?true:!carry,
                 deleted_ones = true;
            bool lD=(_AP_I2>_AP_I) && (_AP_W2-_AP_I2+_AP_I>=0) &&
                ap_private_ops::get<_AP_W2, _AP_S2, _AP_W2-_AP_I2+_AP_I>(val);
            enum { pos1=F2-_AP_F+_AP_W, pos2=F2-_AP_F+_AP_W+1};
            if (pos1 < _AP_W2) {
                bool Range1_all_ones= true;
                bool Range1_all_zeros= true;
                if (pos1 >= 0) {
                    enum { __W = (_AP_W2-pos1) > 0 ? (_AP_W2-pos1) : 1 };
                    const ap_private<__W, _AP_S2> Range1=ap_private<__W, _AP_S2>(val.lshr(pos1));
                    Range1_all_ones=Range1.isAllOnesValue();
                    Range1_all_zeros=Range1.isMinValue();
                } else {
                    Range1_all_ones=false;
                    Range1_all_zeros=val.isMinValue();
                }
                bool Range2_all_ones=true;
                if (pos2<_AP_W2 && pos2>=0) {
                    enum { __W = (_AP_W2-pos2)>0 ? (_AP_W2-pos2) : 1};
                    ap_private<__W, true> Range2=ap_private<__W, true>(val.lshr(pos2));
                    Range2_all_ones=Range2.isAllOnesValue();
                } else if(pos2<0)
                    Range2_all_ones=false;

                deleted_zeros=deleted_zeros && (carry?Range1_all_ones:Range1_all_zeros);
                deleted_ones=carry?Range2_all_ones&&(F2-_AP_F+_AP_W<0||!lD)
                    :Range1_all_ones;
                neg_src= neg_src&&!(carry && Range1_all_ones);
            } else
                neg_src = neg_src && V[_AP_W-1];

            bool neg_trg= V.isNegative();
            bool overflow=(neg_trg||!deleted_zeros) && !val.isNegative();
            bool underflow=(!neg_trg||!deleted_ones)&&neg_src;



            if(_AP_O==AP_SAT_SYM && _AP_S2 && _AP_S)
                underflow |= neg_src && (_AP_W>1?V.isMinSignedValue():true);
            overflow_adjust(underflow, overflow, lD, neg_src);
        }
        report();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const volatile ap_fixed_base<_AP_W2,_AP_I2,
                _AP_S2,_AP_Q2,_AP_O2, _AP_N2> &op) : V(op.V) {
        *this = const_cast<ap_fixed_base<_AP_W2,_AP_I2,
        _AP_S2,_AP_Q2,_AP_O2, _AP_N2>&>(op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_private<_AP_W2,_AP_S2>& op) {
        ap_fixed_base<_AP_W2,_AP_W2,_AP_S2> f_op;
        f_op.V=op;
        *this = f_op;
    }

    inline ap_fixed_base(bool b) {
        *this=(ap_private<1,false>)b;
        report();
    }

    inline ap_fixed_base(char b) {
        *this=(ap_private<8,false>)b;
        report();
    }

    inline ap_fixed_base(signed char b) {
        *this=(ap_private<8,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned char b) {
        *this=(ap_private<8,false>)b;
        report();
    }

    inline ap_fixed_base(signed short b) {
        *this=(ap_private<16,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned short b) {
        *this=(ap_private<16,false>)b;
        report();
    }

    inline ap_fixed_base(signed int b) {
        *this=(ap_private<32,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned int b) {
        *this=(ap_private<32,false>)b;
        report();
    }

    inline ap_fixed_base(signed long b) {
        *this=(ap_private<64,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned long b) {
        *this=(ap_private<64,false>)b;
        report();
    }
#1141 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    inline ap_fixed_base(ap_slong b) {
        *this=(ap_private<64,true>)b;
        report();
    }

    inline ap_fixed_base(ap_ulong b) {
        *this=(ap_private<64,false>)b;
        report();
    }





    inline ap_fixed_base(const char* val):V(0) {


        fromString(val);




    }

    inline ap_fixed_base(const char* val, signed char radix): V(0) {




        ap_private<_AP_W, _AP_S> Tmp(val, radix);
        V = Tmp;

    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        *this = ((bool)op);
        report();
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
        *this = ap_private<_AP_W2, _AP_S2>(op);
        report();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_fixed_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
        *this = ((const ap_private<_AP_W2 + _AP_W3, false>&)(op));
        report();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
         *this = (bool(op));
        report();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        *this = (ap_private<_AP_W2, false>(op));
        report();
    }

    inline ap_fixed_base(double d):V(0) {
        if(!d) return;
        const bool isneg=d<0;

        const uint64_t ireg=doubleToRawBits(isneg?-d:d);
        if((ireg&0x7fffffffffffffffULL)!=0) {
            const int32_t exp=(((ireg)>>52)&0x07ff)-((1ULL<<(11 -1))-1);
            ap_private<52 +2, true> man = ireg & 0x3fffffffffffffULL;

            if (exp == ((1ULL<<(11 -1))-1) + 1 &&
                man.range(52 - 1, 0) != 0) {

                fprintf(stderr, "[E] ap_%sfixed<%d, ...>: trying to "
                   "assign NaN to fixed point value.\n",
                            _AP_S?"":"u", _AP_W);
                exit(1);
            }
            man.clear(52 +1);
            man.set(52);
            if(isneg) {
                man.flip();
                man++;
            }

            enum {_AP_S2=true, _AP_W2=52 +2,_AP_F=_AP_W -_AP_I };
            const int _AP_I2=exp+2;
            const int F2=_AP_W2-_AP_I2;
            const bool QUAN_INC=F2>_AP_F && !(_AP_Q==AP_TRN || (_AP_Q==AP_TRN_ZERO &&
                    !_AP_S2));
            bool carry=false;

            const unsigned sh_amt=abs(F2-_AP_F);
            if (F2==_AP_F )
                V=man;
            else if (F2>_AP_F) {
                if(sh_amt >= 52 +2)
                    V=isneg?-1:0;
                else
                    V= ap_private<52 +2, true>((man>>sh_amt) |
                       ((man & 1ULL<<(52 +1))?
                        (0x3fffffffffffffULL>>(52 +2-sh_amt)
                        <<(52 +2-sh_amt)):0));

                if (_AP_Q!=AP_TRN && !(_AP_Q==AP_TRN_ZERO && !_AP_S2)) {
                    const bool qb=((F2-_AP_F > 52 +2) ? isneg : (man & (1ULL<<(F2-_AP_F-1))) != 0);
                    const int pos3=F2-_AP_F-2;
                    const bool r = (pos3>= 0) ? (man << ((0) > (_AP_W2-pos3-1) ? (0) : (_AP_W2-pos3-1))& 0x3fffffffffffffULL)!=0 : false;
                    carry = quantization_adjust(qb,r,isneg);
                }
            }
            else {

                if (sh_amt < _AP_W) {
                    V = man;
                    V <<= sh_amt;
                }
            }

            if((_AP_O != AP_WRAP || _AP_N != 0) &&
                    ((!_AP_S && _AP_S2) || _AP_I-_AP_S <
                     _AP_I2-_AP_S2+(QUAN_INC|| (_AP_S2 &&
                         _AP_O==AP_SAT_SYM)) )) {
                bool deleted_zeros = _AP_S2?true:!carry,
                     deleted_ones = true;
                bool neg_src;
                const bool lD=(_AP_I2>_AP_I) && (_AP_W2-_AP_I2+_AP_I>=0) &&
                    (man & (1ULL <<(52 +2-_AP_I2+_AP_I)));
                int pos1=F2+_AP_W-_AP_F;
                if (pos1 < _AP_W2) {
                    int pos2=pos1+1;
                    bool Range1_all_ones=true;
                    bool Range1_all_zeros=true;
                    if (pos1>=0) {
                        ap_private<52 +2,_AP_S> Range1=
                            ap_private<52 +2,_AP_S>((man >> pos1) | ((1ULL<<(52 +1)&man) ? (0x3fffffffffffffULL >> (52 +2-pos1) <<(52 +2-pos1)):0));
                        Range1_all_ones = Range1.isAllOnesValue();
                        Range1_all_zeros = Range1.isMinValue();
                    } else {
                        Range1_all_ones=false;
                        Range1_all_zeros = man==0;
                    }
                    bool Range2_all_ones=true;
                    if (pos2<_AP_W2 && pos2>=0) {
                        ap_private<52 +2, _AP_S> Range2=
                            ap_private<52 +2, _AP_S>((man >> pos2) | ((1ULL<<(52 +1)&man) ? (0x3fffffffffffffULL >> (52 +2-pos2) <<(52 +2-pos2)):0));
                        Range2_all_ones=Range2.isAllOnesValue();
                    } else if (pos2<0)
                        Range2_all_ones=false;
                    deleted_zeros=deleted_zeros && (carry?Range1_all_ones:Range1_all_zeros);
                    deleted_ones=carry?Range2_all_ones&&(F2-_AP_F+_AP_W<0||!lD) : Range1_all_ones;
                    neg_src=isneg&&!(carry&Range1_all_ones);
                } else
                    neg_src = isneg && V[_AP_W -1];

                const bool neg_trg=V.isNegative();
                const bool overflow=(neg_trg||!deleted_zeros) && !isneg;
                bool underflow=(!neg_trg||!deleted_ones)&&neg_src;




                if(_AP_O==AP_SAT_SYM && _AP_S2 && _AP_S)
                    underflow |= neg_src && (_AP_W>1?V.isMinSignedValue():true);
                overflow_adjust(underflow,overflow,lD, neg_src);
            }
        }
        report();
    }

    inline ap_fixed_base(float d):V(0) {
        *this = ap_fixed_base(double(d));
    }

    inline ap_fixed_base(half d):V(0) {
        *this = ap_fixed_base(double(d));
    }




    inline void operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        V = op.V;
    }

    inline ap_fixed_base& operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) {
        V = op.V;
        return *this;
    }

    inline void operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        V = op.V;
    }

    inline ap_fixed_base& operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) {
        V = op.V;
        return *this;
    }




    inline ap_fixed_base& setBits(unsigned long long bv) {
        V=bv;
        return *this;
    }



    static inline ap_fixed_base bitsToFixed(unsigned long long bv) {
        ap_fixed_base Tmp=bv;
        return Tmp;
    }



    inline ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S>
    to_ap_private(bool Cnative = true) const {
        ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ret = ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ((_AP_I >= 1) ? (_AP_S==true ? V.ashr(((0) > (_AP_W - _AP_I) ? (0) : (_AP_W - _AP_I))) : V.lshr(((0) > (_AP_W - _AP_I) ? (0) : (_AP_W - _AP_I)))) : ap_private<_AP_W, _AP_S>(0));

        if (Cnative) {
            bool r = false;
            if (_AP_I < _AP_W) {
                if (_AP_I > 0) r = !(V.getLoBits(_AP_W - _AP_I).isMinValue());
                else r = !(V.isMinValue());
            }
            if (r && V.isNegative()) {
                ++ret;
            }
        } else {

        }
        return ret;
    }

    template<int _AP_W2, bool _AP_S2>
    inline operator ap_private<_AP_W2,_AP_S2> () const {
        return (ap_private<_AP_W2,_AP_S2>)to_ap_private();
    }

    template<int _AP_W2, bool _AP_S2, int _AP_N2>
    inline operator ap_private<_AP_W2,_AP_S2,_AP_N2> () const {
        return (ap_private<_AP_W2,_AP_S2,_AP_N2>)to_ap_private();
    }


    inline int to_int() const {
        return to_ap_private().to_int();
    }

    inline int to_uint() const {
        return to_ap_private().to_uint();
    }

    inline ap_slong to_int64() const {
        return to_ap_private().to_int64();
    }

    inline ap_ulong to_uint64() const {
        return to_ap_private().to_uint64();
    }

    inline double to_double() const {
        if(!V)
            return 0;
        bool isneg = _AP_S && V[_AP_W-1];
        uint64_t res = isneg ? 0x8000000000000000ULL : 0;
        ap_private<_AP_W, false> tmp(V);
        if (isneg) tmp = ap_private<_AP_W, false>(-V);
        int i = _AP_W -1 - tmp.countLeadingZeros();
        int exp = _AP_I-(_AP_W-i);
        res|=((uint64_t)(exp+((1ULL<<(11 -1))-1)))<<52;
        if(i!=0) {
            tmp.clear(i);
            uint64_t man = ((i>52)?tmp.lshr(i-52):tmp).to_uint64() & 0x3fffffffffffffULL;
            res |= i<52 ? (man)<<(52 -i)& 0x3fffffffffffffULL : man;
        }
        double dp=rawBitsToDouble(res);
        return dp;
    }

    inline float to_float() const {
        if(!V)
            return 0;
        bool isneg = _AP_S && V[_AP_W-1];
        uint64_t res = isneg ? 0x80000000ULL : 0;
        ap_private<_AP_W, false> tmp = V;
        if (isneg) tmp = -tmp;
        int i = _AP_W -1 - tmp.countLeadingZeros();
        int exp = _AP_I-(_AP_W-i);
        res|=((uint64_t)(exp+((1ULL<<(8 -1))-1)))<<23;
        if(i!=0) {
            tmp.clear(i);
            uint32_t man = ((i>23) ? tmp.lshr(i-23) : tmp).to_uint() & 0x7fffff;
            res |= i<23 ? (man)<<(23 -i)& 0x7fffff : man;
        }
        float dp=rawBitsToFloat(res);
        return dp;
    }

    inline half to_half() const {
        if(!V)
            return 0;
        bool isneg = _AP_S && V[_AP_W-1];
        uint64_t res = isneg ? 0x8000ULL : 0;
        ap_private<_AP_W, false> tmp = V;
        if (isneg) tmp = -tmp;
        int i = _AP_W -1 - tmp.countLeadingZeros();
        int exp = _AP_I-(_AP_W-i);
        res|=((uint64_t)(exp+((1ULL<<(5 -1))-1)))<<10;
        if(i!=0) {
            tmp.clear(i);
            uint32_t man = ((i>10) ? tmp.lshr(i-10) : tmp).to_uint() & 0x3ff;
            res |= i<10 ? (man)<<(10 -i)& 0x3ff : man;
        }
        half dp=rawBitsToHalf(res);
        return dp;
    }

    inline operator long double () const {
        return to_double();
    }

    inline operator double () const {
        return to_double();
    }

    inline operator float () const {
           return to_float();
    }

    inline operator half () const {
           return to_half();
    }

    inline operator char () const {
        return (char) to_int();
    }

    inline operator signed char () const {
        return (signed char) to_int();
    }

    inline operator unsigned char () const {
        return (unsigned char) to_uint();
    }

    inline operator short () const {
        return (short) to_int();
    }

    inline operator unsigned short () const {
        return (unsigned short) to_uint();
    }

    inline operator int () const {
        return to_int();
    }

    inline operator unsigned int () const {
        return to_uint();
    }


    inline operator long () const {
        return (long)to_int64();
    }

    inline operator unsigned long () const {
        return (unsigned long) to_uint64();
    }
#1532 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    inline operator unsigned long long () const {
        return to_uint64();
    }

    inline operator long long () const {
        return to_int64();
    }


    inline std::string to_string(uint8_t radix=2, bool sign=_AP_S) const;

    inline ap_slong bits_to_int64() const {
      ap_private<((_AP_W) < (64) ? (_AP_W) : (64)), _AP_S> res(V);
        return (ap_slong) res;
    }

    inline ap_ulong bits_to_uint64() const {
      ap_private<((64) < (_AP_W) ? (64) : (_AP_W)), _AP_S> res(V);
      return (ap_ulong) res;
    }

    inline int length() const {return _AP_W;}




    inline int countLeadingZeros() {
        return V.countLeadingZeros();
    }



    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline typename RType<_AP_W2,_AP_I2,_AP_S2>::mult
    operator * (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        typename RType<_AP_W2,_AP_I2,_AP_S2>::mult r;
        r.V = V * op2.V;
        return r;
    }

    template<int _AP_W1, int _AP_I1, bool _AP_S1, int _AP_W2, int _AP_I2, bool _AP_S2>
    static inline ap_fixed_base multiply(const ap_fixed_base<_AP_W1,_AP_I1,_AP_S1>& op1, const
         ap_fixed_base<_AP_W2,_AP_I2,_AP_S2>& op2) {
        ap_private<_AP_W+_AP_W2, _AP_S> OP1=op1.V;
        ap_private<_AP_W2,_AP_S2> OP2=op2.V;
        return OP1*OP2;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline typename RType<_AP_W2,_AP_I2,_AP_S2>::div
    operator / (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {F2 = _AP_W2-_AP_I2,
              _W1=((_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) > (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)) ? (_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) : (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)))};
        ap_private<_W1, _AP_S||_AP_S2> dividend = (ap_private<_W1, _AP_S>(V)) << ((F2) > (0) ? (F2) : (0));
        ap_private<_W1, _AP_S||_AP_S2> divisior = ap_private<_W1, _AP_S2>(op2.V);
        typename RType<_AP_W2, _AP_I2, _AP_S2>::div r;
        r.V = ((_AP_S||_AP_S2) ? dividend.sdiv(divisior): dividend.udiv(divisior));
        return r;
    }
#1609 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::plus operator + (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { enum {_AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2}; typename RType<_AP_W2,_AP_I2,_AP_S2>::plus r, lhs(*this), rhs(op2); r.V = lhs.V.Add(rhs.V); return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::plus operator + (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::plus r; r.V = V + op2.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::minus operator - (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { enum {_AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2}; typename RType<_AP_W2,_AP_I2,_AP_S2>::minus r, lhs(*this), rhs(op2); r.V = lhs.V.Sub(rhs.V); return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::minus operator - (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::minus r; r.V = V - op2.V; return r; }
#1632 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator & (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V & rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator & (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V & op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator &(int op2) const { return V & (op2<<(_AP_W - _AP_I)); }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator | (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V | rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator | (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V | op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator |(int op2) const { return V | (op2<<(_AP_W - _AP_I)); }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator ^ (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V ^ rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator ^ (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V ^ op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator ^(int op2) const { return V ^ (op2<<(_AP_W - _AP_I)); }
#1646 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator += (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator + (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator -= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator - (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator &= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator & (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator |= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator | (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator ^= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator ^ (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator *= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator * (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator /= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator / (op2) ; return *this; }



    inline ap_fixed_base& operator ++() {
        operator+=(ap_fixed_base<1,1,false>(1));
        return *this;
    }

    inline ap_fixed_base& operator --() {
        operator-=(ap_fixed_base<1,1,false>(1));
        return *this;
    }



    inline const ap_fixed_base operator ++(int) {
        ap_fixed_base t(*this);
        operator++();
        return t;
    }

    inline const ap_fixed_base operator --(int) {
        ap_fixed_base t = *this;
        operator--();
        return t;
    }



    inline ap_fixed_base operator +() {return *this;}

    inline ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator -() const {
        ap_fixed_base<_AP_W + 1, _AP_I + 1, true> Tmp(*this);
        Tmp.V = - Tmp.V;
        return Tmp;
    }

    inline ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O, _AP_N> getNeg() {
        ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O, _AP_N> Tmp(*this);
        Tmp.V=-Tmp.V;
        return Tmp;
    }



    inline bool operator !() const {
        return !V;
    }



    inline ap_fixed_base<_AP_W, _AP_I, _AP_S>
         operator ~() const {
        ap_fixed_base<_AP_W, _AP_I, _AP_S> res(*this);
        res.V.flip();
        return res;
    }



    template<int _AP_SHIFT>
    inline ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift () const {
        ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
        r.V = V;
        return r;
    }

    template<int _AP_SHIFT>
    inline ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift () const {
        ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
        r.V = V;
        return r;
    }






    inline ap_fixed_base operator << (int sh) const {
        ap_fixed_base r;
        bool isNeg=(sh&0x80000000) != 0;
        sh=isNeg?-sh:sh;
        bool shiftoverflow = sh >= _AP_W;
        bool NegSrc = V.isNegative();
        if(isNeg) {
            if(shiftoverflow)
                NegSrc?r.V.set():r.V.clear();
            else
                r.V=_AP_S?V.ashr(sh):V.lshr(sh);
        } else {
            if(shiftoverflow)
                r.V.clear();
            else
                r.V=V<<sh;
        }
#1779 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator<<(const ap_private<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator << (sh);
    }

    inline ap_fixed_base operator << (unsigned int sh ) const {
        ap_fixed_base r;
        bool shiftoverflow = sh >= _AP_W;
        r.V = shiftoverflow ? ap_private<_AP_W, _AP_S >(0) : V << sh;
        if (sh == 0) return r;
#1814 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator << (const ap_private<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator << (sh);
    }

    inline ap_fixed_base operator >> (int sh) const {
        ap_fixed_base r;
        bool isNeg=(sh&0x80000000) != 0;
        bool NegSrc = V.isNegative();
        sh=isNeg?-sh:sh;
        bool shiftoverflow = sh >= _AP_W;
        if(isNeg && !shiftoverflow) r.V=V<<sh;
        else {
            if(shiftoverflow)
                NegSrc?r.V.set():r.V.clear();
            else
                r.V=_AP_S?V.ashr(sh):V.lshr(sh);
        }
#1866 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator >> (const ap_private<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator >> (sh);
    }

    inline ap_fixed_base operator >> (unsigned int sh) const {
        ap_fixed_base r;
        bool NegSrc = V.isNegative();
        bool shiftoverflow = sh >= _AP_W;
        if(shiftoverflow)
            NegSrc?r.V.set():r.V.clear();
        else
            r.V=_AP_S?V.ashr(sh):V.lshr(sh);
#1896 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator >> (const ap_private<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator >> (sh);
    }
#1915 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, bool _AP_S2> inline ap_fixed_base& operator <<=(const ap_private<_AP_W2,_AP_S2>& op2) { *this=operator << (op2); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_fixed_base& operator >>=(const ap_private<_AP_W2,_AP_S2>& op2) { *this=operator >> (op2); return *this; }
#1932 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base operator << (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { return operator << (op2.to_ap_private()); } template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator <<= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator << (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base operator >> (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { return operator >> (op2.to_ap_private()); } template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator >>= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator >> (op2); return *this; }

    inline ap_fixed_base& operator >>= (unsigned int sh) {
        *this = operator >> (sh);
        return *this;
    }

    inline ap_fixed_base& operator <<= (unsigned int sh) {
        *this = operator << (sh);
        return *this;
    }

    inline ap_fixed_base& operator >>= (int sh) {
        *this = operator >> (sh);
        return *this;
    }

    inline ap_fixed_base& operator <<= (int sh) {
        *this = operator << (sh);
        return *this;
    }



    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        return OP1 == OP2;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this==op2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator > (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        if(_AP_S||_AP_S2)
            return OP1.sgt(OP2);
        else
            return OP1.ugt(OP2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator <= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this>op2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator < (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        if(_AP_S||_AP_S2)
            return OP1.slt(OP2);
        else
            return OP1.ult(OP2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator >= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this<op2);
    }






    inline bool operator == (double d) const { return to_double() == d; }
    inline bool operator != (double d) const { return to_double() != d; }
    inline bool operator > (double d) const { return to_double() > d; }
    inline bool operator >= (double d) const { return to_double() >= d; }
    inline bool operator < (double d) const { return to_double() < d; }
    inline bool operator <= (double d) const { return to_double() <= d; }


    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> operator [] (unsigned int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index);
    }

    inline af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> bit(unsigned int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index);
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> bit (const ap_private<_AP_W2,_AP_S2>& index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index.to_int());
    }

    inline bool bit (unsigned int index) const {
        if (index >= _AP_W)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);

        return V[index];
    }

    inline bool operator [] (unsigned int index) const {
        if (index >= _AP_W)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);

        return V[index];
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool bit (const ap_private<_AP_W2, _AP_S2>& index) const {
        if (index >= _AP_W)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);

        return V[index.to_uint()];
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator [] (const ap_private<_AP_W2, _AP_S2>& index) const {
        if (index >= _AP_W)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);

        return V[index.to_uint()];
    }

    inline af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> get_bit(int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index + _AP_W - _AP_I);
    }

    template<int _AP_W2>
    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> get_bit (const ap_private<_AP_W2, true>& index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index.to_int() + _AP_W - _AP_I);
    }

    inline bool get_bit (int index) const {
        if (index < _AP_I - _AP_W )
     fprintf(stderr, "Warning! Index of bit vector  (%d) cannot be negative.\n", index);
        if (index >= _AP_I)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);


        return V[index + _AP_W - _AP_I];
    }

    template<int _AP_W2>
    inline bool get_bit (const ap_private<_AP_W2, true>& index) const {
        if (index < _AP_I - _AP_W )
     fprintf(stderr, "Warning! Index of bit vector  (%d) cannot be negative.\n", index.to_int());
        if (index >= _AP_I)
     fprintf(stderr, "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);


        return V[index.to_int() + _AP_W - _AP_I];
    }

    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) const {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<ap_fixed_base*>(this), Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_private<_AP_W2, _AP_S2> &HiIdx,
          const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
                 const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_private<_AP_W2, _AP_S2> &HiIdx,
          const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<
               ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>*>(this),
               Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
                 const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() {
        return this->range(_AP_W - 1, 0);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() const {
        return this->range(_AP_W - 1, 0);
    }

    inline bool is_zero () const {
        return V.isMinValue();
    }

    inline bool is_neg () const {
        if (V.isNegative())
            return true;
        return false;
    }

    inline int wl () const {
        return _AP_W;
    }

    inline int iwl () const {
        return _AP_I;
    }

    inline ap_q_mode q_mode () const {
        return _AP_Q;
    }

    inline ap_o_mode o_mode () const {
        return _AP_O;
    }

    inline int n_bits () const {
        return 0;
    }


public:
    ap_private<_AP_W, _AP_S> V;
    static const int width = _AP_W;
    static const int iwidth = _AP_I;
    static const ap_q_mode qmode = _AP_Q;
    static const ap_o_mode omode = _AP_O;

};






template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
std::string ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>::to_string(
                                            uint8_t radix, bool sign) const {
    std::string str;
    str.clear();
    char step = 0;
    bool isNeg = sign && V.isNegative();


    ap_fixed_base<_AP_W+1, _AP_I+1> tmp(*this);
    if (isNeg) {
        tmp = -tmp;
        str += '-';
    }
    std::string prefix;
    switch (radix) {
        case 2 : prefix = "0b"; step = 1; break;
        case 8 : prefix = "0o"; step = 3; break;
        case 16 : prefix = "0x"; step = 4; break;
        default : break;
    }

    if (_AP_I > 0) {




        ap_fixed_base<((_AP_I+1) > (1) ? (_AP_I+1) : (1)), ((_AP_I+1) > (1) ? (_AP_I+1) : (1)), false> int_part = tmp;
        str += int_part.to_ap_private().to_string(radix, false);
    } else {
        str += prefix;
        str += '0';
    }
    ap_fixed_base<((_AP_W - _AP_I) > (1) ? (_AP_W - _AP_I) : (1)), 0, false> frac_part = tmp;

    if (radix == 10) {
        if (frac_part != 0) {
            str += ".";
            while (frac_part != 0) {
                char digit = (char)(frac_part * radix).to_ap_private();
                str += static_cast<char>(digit + '0');
                frac_part *= radix;
            }
        }
    } else {
        if (frac_part != 0) {
            str += ".";
            for (signed i = _AP_W - _AP_I - 1; i >= 0; i -= step) {
                char digit = (char)(frac_part.range(i, ((0) > (i - step + 1) ? (0) : (i - step + 1))));


                int offset = ((0) < (i - step + 1) ? (0) : (i - step + 1));
                digit <<= -offset;
                str += digit < 10 ? static_cast<char>(digit + '0') :
                    static_cast<char>(digit - 10 + 'a');
            }
            if (radix == 16)
                str += "p0";
        }
    }
    return str;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_not(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = op.V;
    ret.V.flip();
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_and(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V & op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_or(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V | op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_xor(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V ^ op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    ap_fixed_base<_AP_W2+!_AP_S2, _AP_I2+!_AP_S2, true, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp.V = - op.V;
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = -op.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_W2 - _AP_I2 + ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp = op;
    Tmp.V <<= i;
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,
            int i) {
    ret.V = op.V << i;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_I2 + ((_AP_W - _AP_I) > (_AP_W2 - _AP_I2) ? (_AP_W - _AP_I) : (_AP_W2 - _AP_I2)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp = op;
    Tmp.V = _AP_S2 ? Tmp.V.ashr(i): Tmp.V.lshr(i);
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,
            int i) {
    ret.V = _AP_S ? op.V.ashr(i): op.V.lshr(i);
}
#2358 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
template<> inline ap_fixed_base<1,1,true,AP_TRN,AP_WRAP>::ap_fixed_base(bool i_op):V(i_op) { } template<> inline ap_fixed_base<1,1,false,AP_TRN,AP_WRAP>::ap_fixed_base(bool i_op):V(i_op) { }
template<> inline ap_fixed_base<8,8,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed char i_op):V(i_op) { } template<> inline ap_fixed_base<8,8,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed char i_op):V(i_op) { }
template<> inline ap_fixed_base<8,8,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned char i_op):V(i_op) { } template<> inline ap_fixed_base<8,8,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned char i_op):V(i_op) { }
template<> inline ap_fixed_base<16,16,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed short i_op):V(i_op) { } template<> inline ap_fixed_base<16,16,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed short i_op):V(i_op) { }
template<> inline ap_fixed_base<16,16,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned short i_op):V(i_op) { } template<> inline ap_fixed_base<16,16,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned short i_op):V(i_op) { }
template<> inline ap_fixed_base<32,32,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed int i_op):V(i_op) { } template<> inline ap_fixed_base<32,32,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed int i_op):V(i_op) { }
template<> inline ap_fixed_base<32,32,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned int i_op):V(i_op) { } template<> inline ap_fixed_base<32,32,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned int i_op):V(i_op) { }
template<> inline ap_fixed_base<64,64,true,AP_TRN,AP_WRAP>::ap_fixed_base(ap_slong i_op):V(i_op) { } template<> inline ap_fixed_base<64,64,false,AP_TRN,AP_WRAP>::ap_fixed_base(ap_slong i_op):V(i_op) { }
template<> inline ap_fixed_base<64,64,true,AP_TRN,AP_WRAP>::ap_fixed_base(ap_ulong i_op):V(i_op) { } template<> inline ap_fixed_base<64,64,false,AP_TRN,AP_WRAP>::ap_fixed_base(ap_ulong i_op):V(i_op) { }



inline std::string scientificFormat(std::string& input) {
    if (input.length() == 0)
        return input;

    size_t decPosition = input.find('.');
    if (decPosition == std::string::npos)
        decPosition = input.length();

    size_t firstNonZeroPos = 0;
    for (; input[firstNonZeroPos] > '9' ||
           input[firstNonZeroPos] < '1';
         firstNonZeroPos++);

    int exp;
    if (firstNonZeroPos > decPosition)
        exp = decPosition - firstNonZeroPos;
    else
        exp = decPosition - firstNonZeroPos - 1;
    std::string expString = "";
    if (exp == 0);
    else if (exp < 0) {
        expString += "e-";
        exp = -exp;
    } else
        expString += "e+";

    if (exp < 10 && exp > 0) {
        expString += '0';
        expString += (char)('0' + exp);
    } else if (exp != 0) {
        std::string tmp;

        std::ostringstream oss;
        oss<<exp;

        tmp=oss.str();
        expString += tmp;
    }

    int lastNonZeroPos = (int) (input.length() - 1);
    for (; lastNonZeroPos >= 0; --lastNonZeroPos)
        if (input[lastNonZeroPos] <= '9' && input[lastNonZeroPos] > '0')
            break;

    std::string ans = "";
    ans += input[firstNonZeroPos];
    if (firstNonZeroPos != (size_t)lastNonZeroPos) {
        ans += '.';
        for (int i=firstNonZeroPos+1; i <= lastNonZeroPos; i++)
            if (input[i] != '.')
                ans += input[i];
    }

    ans += expString;
    return ans;
}

inline std::string reduceToPrecision(std::string& input, int precision) {

    bool isZero = true;
    size_t inputLen = input.length();
    for (size_t i=0; i<inputLen && isZero; i++)
        if (input[i] != '.' && input[i] != '0')
            isZero = false;
    if (isZero)
        return "0";


    int FirstNonZeroPos = 0;
    int LastNonZeroPos = (int) inputLen - 1;
    int truncBitPosition = 0;
    size_t decPosition = input.find('.');
    for (; input[FirstNonZeroPos] < '1' || input[FirstNonZeroPos] > '9';
         FirstNonZeroPos++);

    for (; input[LastNonZeroPos] < '1' || input[LastNonZeroPos] > '9';
         LastNonZeroPos--);

    if (decPosition == std::string::npos)
        decPosition = inputLen;

    if ((int) decPosition > LastNonZeroPos) {
        if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision)
            return input;
        truncBitPosition = FirstNonZeroPos + precision;
    } else if ((int) decPosition < FirstNonZeroPos) {
        if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) {
            if (FirstNonZeroPos - decPosition - 1 < 4) {
                return input;
            } else {
                if (input[0] == '-') {
                    std::string tmp = input.substr(1, inputLen-1);
                    return std::string("-") +
                           scientificFormat(tmp);
                } else
                    return scientificFormat(input);
            }
        }
        truncBitPosition = FirstNonZeroPos + precision;
    } else {
        if (LastNonZeroPos - FirstNonZeroPos <= precision)
            return input;
        truncBitPosition = FirstNonZeroPos + precision + 1;
    }



    std::string ans = "";
    std::string dupInput = "0";
    if (input[0] == '-') {
        ans += '-';
        dupInput += input.substr(1, inputLen-1);
    } else {
        dupInput += input.substr(0, inputLen);
        ++truncBitPosition;
    }


    bool carry = dupInput[truncBitPosition] > '4';
    for (int i = truncBitPosition-1; i >=0 && carry; i--) {
        if (dupInput[i] == '.')
            continue;
        if (dupInput[i] == '9')
            dupInput[i] = '0';
        else {
            ++dupInput[i];
            carry = false;
        }
    }


    if (dupInput[0] == '1')
        FirstNonZeroPos = 0;
    else {
        FirstNonZeroPos = 0;
        while (dupInput[FirstNonZeroPos] < '1' ||
               dupInput[FirstNonZeroPos] > '9')
            ++FirstNonZeroPos;
    }

    unsigned it = FirstNonZeroPos;
    int NValidNumber = 0;
    while (it < dupInput.length()) {
        if (dupInput[it] == '.') {
            ++it;
            continue;
        }
        ++NValidNumber;
        if (NValidNumber > precision)
            dupInput[it] = '0';
        ++it;
    }


    decPosition = dupInput.find('.');
    if (decPosition == std::string::npos)
        truncBitPosition = (int) dupInput.length();
    else
        for (truncBitPosition = (int) (dupInput.length()-1);
             truncBitPosition >=0;
             --truncBitPosition) {
            if (dupInput[truncBitPosition] == '.')
                break;
            if (dupInput[truncBitPosition] != '0') {
                truncBitPosition++;
                break;
            }
        }

    if (dupInput[0] == '1')
        dupInput = dupInput.substr(0,
                                   truncBitPosition);
    else
        dupInput = dupInput.substr(1, truncBitPosition-1);

    decPosition = dupInput.find('.');
    if (decPosition != std::string::npos) {
        size_t it = 0;
        for (it = decPosition+1; dupInput[it]=='0'; it++);
        if (it - decPosition - 1 < 4) {
            ans += dupInput;
            return ans;
        } else {
            ans += scientificFormat(dupInput);
            return ans;
        }
    } else if ((int)(dupInput.length()) <= precision) {
        ans += dupInput;
        return ans;
    }

    ans += scientificFormat(dupInput);
    return ans;
}



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline std::ostream&
operator <<(std::ostream& out, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    unsigned width = out.width();
    unsigned precision = out.precision();
    char fill = out.fill();
    std::string str=x.to_string(10,_AP_S);
    str = reduceToPrecision(str, precision);
    if (width > str.length()) {
        char *padding = (char*)malloc((width - str.length() + 1)*sizeof(char));
        for (unsigned i=0; i<width - str.length(); ++i)
            padding[i] = fill;
        padding[width - str.length()] = 0;
        str = std::string(padding) + str;
        free(padding);
    }
    out<<str;
    return out;
}



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline std::istream&
operator >> (std::istream& os, ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
     double d;
     os >> d;
     x = ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(d);
     return os;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void print(const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    ap_private<_AP_W,_AP_S> data=x.V;
    if(_AP_I>0) {
        const ap_private<_AP_I,_AP_S> p1=data>>(_AP_W-_AP_I);
        print(p1);

    } else
        printf("0");
    printf(".");
    if(_AP_I<_AP_W) {
        const ap_private<_AP_W-_AP_I,false> p2=data;
        print(p2,false);
    }
}
#2745 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator + (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator - (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator * (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator / (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator & (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator | (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^ (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator == (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator != (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator > (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator < (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator += (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator -= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator *= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator /= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>= (ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<= (ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator &= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator |= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^= (ap_fixed_base<1,1,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator + (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator - (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator * (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator / (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator & (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator | (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^ (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator == (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator != (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator > (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator < (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator += (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>= (ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<= (ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^= (ap_fixed_base<8,8,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator + (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator - (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator * (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator / (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator & (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator | (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator ^ (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator == (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator != (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator > (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator < (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator += (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator -= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator *= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator /= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >>= (ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <<= (ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator &= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator |= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator ^= (ap_fixed_base<16,16,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator + (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator - (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator * (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator / (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator & (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator | (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^ (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator == (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator != (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator > (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator < (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator += (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>= (ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<= (ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^= (ap_fixed_base<16,16,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >>= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <<= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator + (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator - (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator * (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator / (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator & (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator | (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^ (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator == (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator != (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator > (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator < (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator += (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator -= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator *= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator /= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator &= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator |= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^= (ap_fixed_base<64,64,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator + (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator - (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator * (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator / (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator & (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator | (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^ (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator == (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator != (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator > (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator < (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator += (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^= (ap_fixed_base<64,64,false>(i_op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator + (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator - (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator * (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator / (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator & (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator | (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^ (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator == (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator != (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator > (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator < (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator += (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^= (ap_fixed_base<64,64,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator + (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator - (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator * (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator / (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator & (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator | (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^ (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator == (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator != (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator > (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator < (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator += (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^= (ap_fixed_base<64,64,false>(i_op)); }
#2795 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::plus operator + ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator + (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::minus operator - ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator - (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::mult operator * ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator * (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::div operator / ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator / (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator & ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator & (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator | ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator | (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator ^ ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator ^ (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator == ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator == (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator != ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator != (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator > ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator > (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator >= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator >= (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator < ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator < (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator <= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator <= (op); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator += (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator += ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator += (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator -= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator -= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator -= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator *= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator *= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator *= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator /= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator /= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator /= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator &= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator &= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator &= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator |= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator |= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator |= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator ^= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator ^= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator ^= (op.to_ap_private()); }
#2848 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#2888 "/opt/Xilinx/Vivado_HLS/2017.1/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_private<1,false>(op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator == ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator == (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator != ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator != (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator > ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator < (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator >= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator <= (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator < ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator > (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator <= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator >= (op1);
}
#77 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_int.h" 2


template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> class ap_fixed;
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> class ap_ufixed;
template<int _AP_W> class ap_int;
template<int _AP_W> class ap_uint;


template<int _AP_W>
class ap_int: public ap_private<_AP_W, true> {



public:
    typedef ap_private<_AP_W, true> Base;

    inline ap_int(): Base() {}
    template<int _AP_W2>
    inline ap_int(const volatile ap_int<_AP_W2> &op):Base((const ap_private<_AP_W2,true> &)(op)) {}

    template<int _AP_W2>
    inline ap_int(const ap_int<_AP_W2> &op):Base((const ap_private<_AP_W2,true> &)(op)) {}

    template<int _AP_W2>
    inline ap_int(const ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2,false> &)(op)) {}

    template<int _AP_W2>
    inline ap_int(const volatile ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2,false> &)(op)) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                 :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                  :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                 :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                  :Base(op.to_ap_private()) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.to_ap_private()) {}



    inline ap_int(bool v):Base(v) {}
    inline ap_int(signed char v):Base(v) {}
    inline ap_int(unsigned char v):Base(v) {}
    inline ap_int(short v):Base(v) {}
    inline ap_int(unsigned short v):Base(v) {}
    inline ap_int(int v):Base(v) {}
    inline ap_int(unsigned int v):Base(v) {}
    inline ap_int(long v):Base(v) {}
    inline ap_int(unsigned long v):Base(v) {}
    inline ap_int(unsigned long long v):Base(v) {}
    inline ap_int(long long v):Base(v) {}
    inline ap_int(half v):Base(v) {}
    inline ap_int(float v):Base(v) {}
    inline ap_int(double v):Base(v) {}
    inline ap_int(const char* v):Base(v) {}


    inline ap_int(const char* str, signed char rd):Base(str, rd) {}


    inline void operator = (const ap_int<_AP_W>& op2) volatile {
      const_cast<ap_int*>(this)->operator = (op2);
    }

    inline void operator = (const volatile ap_int<_AP_W>& op2) volatile {
      const_cast<Base*>(this)->operator = (op2);
    }

    inline ap_int<_AP_W>& operator = (const volatile ap_int<_AP_W>& op2) {
      Base::operator = (const_cast<ap_int<_AP_W>& >(op2));
        return *this;
    }

    inline ap_int<_AP_W>& operator = (const ap_int<_AP_W>& op2) {
      Base::operator = ((const ap_private<_AP_W, true>&)op2);
        return *this;
    }

};



template<int _AP_W>
class ap_uint: public ap_private<_AP_W, false> {



public:
    typedef ap_private<_AP_W, false> Base;

    inline ap_uint(): Base() {}
  inline ap_uint(const ap_uint<_AP_W>& op) :Base(dynamic_cast<const ap_private<_AP_W, false>&>(op)) {}
  inline ap_uint(const volatile ap_uint<_AP_W>& op):Base(dynamic_cast<const volatile ap_private<_AP_W, false>&>(op)){}
    template<int _AP_W2>
    inline ap_uint(const volatile ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2, false>&)(op)) {}

    template<int _AP_W2>
    inline ap_uint(const ap_uint<_AP_W2> &op) : Base((const ap_private<_AP_W2, false>&)(op)){}

    template<int _AP_W2>
    inline ap_uint(const ap_int<_AP_W2> &op) : Base((const ap_private<_AP_W2, true>&)(op)) {}

    template<int _AP_W2>
    inline ap_uint(const volatile ap_int<_AP_W2> &op) : Base((const ap_private<_AP_W2, false>&)(op)) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.to_ap_private()) {}



    inline ap_uint(bool v):Base(v) {}
    inline ap_uint(signed char v):Base(v) {}
    inline ap_uint(unsigned char v):Base(v) {}
    inline ap_uint(short v):Base(v) {}
    inline ap_uint(unsigned short v):Base(v) {}
    inline ap_uint(int v):Base(v) {}
    inline ap_uint(unsigned int v):Base(v) {}
    inline ap_uint(long v):Base(v) {}
    inline ap_uint(unsigned long v):Base(v) {}
    inline ap_uint(unsigned long long v):Base(v) {}
    inline ap_uint(long long v):Base(v) {}
    inline ap_uint(half v):Base(v) {}
    inline ap_uint(float v):Base(v) {}
    inline ap_uint(double v):Base(v) {}
    inline ap_uint(const char* v):Base(v) {}


    inline ap_uint(const char* str, signed char rd):Base(str, rd) {}


    inline void operator = (const ap_uint<_AP_W>& op2) volatile {
      Base::operator = (op2);
    }

    inline void operator = (const volatile ap_uint<_AP_W>& op2) volatile {
      Base::operator = (op2);
    }

    inline ap_uint<_AP_W>& operator = (const volatile ap_uint<_AP_W>& op2) {
      Base::operator = (op2);
        return *this;
    }

    inline ap_uint<_AP_W>& operator = (const ap_uint<_AP_W>& op2) {
      Base::operator = ((const ap_private<_AP_W, false>&)(op2));
        return *this;
    }

};






template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
         ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
class ap_fixed: public ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {



public:
    typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;

    inline ap_fixed():Base() {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(op) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const ap_int<_AP_W2>& op):
                   Base(ap_private<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const ap_uint<_AP_W2>& op):Base(ap_private<_AP_W2, false>(op)) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                    true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const volatile ap_int<_AP_W2>& op):
                   Base(ap_private<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const volatile ap_uint<_AP_W2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}



    inline ap_fixed(bool v):Base(v) {}
    inline ap_fixed(signed char v):Base(v) {}
    inline ap_fixed(unsigned char v):Base(v) {}
    inline ap_fixed(short v):Base(v) {}
    inline ap_fixed(unsigned short v):Base(v) {}
    inline ap_fixed(int v):Base(v) {}
    inline ap_fixed(unsigned int v):Base(v) {}
    inline ap_fixed(long v):Base(v) {}
    inline ap_fixed(unsigned long v):Base(v) {}
    inline ap_fixed(unsigned long long v):Base(v) {}
    inline ap_fixed(long long v):Base(v) {}
    inline ap_fixed(half v):Base(v) {}
    inline ap_fixed(float v):Base(v) {}
    inline ap_fixed(double v):Base(v) {}
    inline ap_fixed(const char* v):Base(v) {}


    inline ap_fixed(const char* str, signed char rd):Base(str, rd) {}


    inline ap_fixed& operator = (const ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
      Base::operator = (op);
        return *this;
    }

    inline ap_fixed& operator = (const volatile ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
        Base::operator = (op);
        return *this;
    }

    inline void operator = (const ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
      Base::operator = (op);
    }

    inline void operator = (const volatile ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::operator = (op);
    }

};


template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
         ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
class ap_ufixed: public ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {



public:
    typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;

    inline ap_ufixed():Base() {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op) : Base(ap_fixed_base<_AP_W2,
                     _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                      false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const ap_int<_AP_W2>& op):
      Base((const ap_private<_AP_W2, true>&)(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const ap_uint<_AP_W2>& op):
      Base((const ap_private<_AP_W2, false>&)(op)) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op) : Base(ap_fixed_base<_AP_W2,
                     _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                      false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const volatile ap_int<_AP_W2>& op):
                     Base(ap_private<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const volatile ap_uint<_AP_W2>& op):
                     Base(ap_private<_AP_W2, false>(op)) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                     _AP_O2, _AP_N2>& op):Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}




    inline ap_ufixed(bool v):Base(v) {}
    inline ap_ufixed(signed char v):Base(v) {}
    inline ap_ufixed(unsigned char v):Base(v) {}
    inline ap_ufixed(short v):Base(v) {}
    inline ap_ufixed(unsigned short v):Base(v) {}
    inline ap_ufixed(int v):Base(v) {}
    inline ap_ufixed(unsigned int v):Base(v) {}
    inline ap_ufixed(long v):Base(v) {}
    inline ap_ufixed(unsigned long v):Base(v) {}
    inline ap_ufixed(unsigned long long v):Base(v) {}
    inline ap_ufixed(long long v):Base(v) {}
    inline ap_ufixed(half v):Base(v) {}
    inline ap_ufixed(float v):Base(v) {}
    inline ap_ufixed(double v):Base(v) {}
    inline ap_ufixed(const char* v):Base(v) {}


    inline ap_ufixed(const char* str, signed char rd):Base(str, rd) {}



    inline ap_ufixed& operator = (const ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
      Base::operator = (op);
        return *this;
    }

    inline ap_ufixed& operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = const_cast<ap_ufixed&>(op);
        return *this;
    }

    inline void operator = (const ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
      Base::operator = (op);
    }

    inline void operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::V = const_cast<ap_ufixed&>(op);
    }

};
#87 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_axi_sdata.h" 2

template<int D,int U,int TI,int TD>
  struct ap_axis{
    ap_int<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<U> user;
    ap_uint<1> last;
    ap_uint<TI> id;
    ap_uint<TD> dest;
  };

template<int D,int U,int TI,int TD>
  struct ap_axiu{
    ap_uint<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<U> user;
    ap_uint<1> last;
    ap_uint<TI> id;
    ap_uint<TD> dest;
  };
#40 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 1 3
#41 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3

#42 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
#36 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_fixed.h" 1
#37 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h" 2
#70 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W, int I>
    ap_ufixed<W,I> abs(ap_ufixed<W,I> x) {
        return x;
    }

    template <int W, int I>
    ap_ufixed<W,I> abs(ap_fixed<W,I> x) {
        ap_ufixed<W,I> xw = x;
        ap_ufixed<W,I> xn = -x;
        return (x < 0) ? xn: xw;
    }

    template <int W>
    ap_uint<W> abs(ap_uint<W> x) {
        return x;
    }
    template <int W>
    ap_uint<W> abs(ap_int<W> x) {
        ap_int<W+1> xw = x;
        return (x < 0) ? -xw: xw;
    }
#173 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
    static
    int abs(int x) {
        return std::abs(x);
    }
    static
    long int abs(long int x) {
        return std::abs(x);
    }
}

static
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<class T>
T reg(T in)
{

#pragma HLS INLINE self off
#pragma HLS INTERFACE ap_none port=return register

    return in;
}
#227 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
static
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}







template<class _T>
void set_to_one(_T &a)
{
    a = 1.0f;
}





template<int _W, int _I>
void set_to_one(ap_fixed<_W,_I> &a)
{
    ap_int<_W> tmp_sat = pow((double)2,(double)(_W-_I))-1;
    a.range() = tmp_sat;
}
#270 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template<int _W, int _I>
void set_to_max(ap_fixed<_W,_I> &a)
{
    ap_int<_W> tmp_sat = pow((double)2,(double)_W)-1;
    a.range() = tmp_sat;
}
#284 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {


        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {


        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};

static
std::ostream &operator << (std::ostream &os, const fp_struct<float> &s)
{


    os << s.to_float();
    os << " (sign: " << s.sign << ", exp: " << s.exp << ", sig: ";
    os << s.sig.to_string(8);
    os << " " << s.sig.to_string(2);
    os << ")";


    return os;
}

static
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
#447 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
}







union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};

static
std::ostream &operator << (std::ostream &os, const fp_struct<double> &s)
{


    os << s.to_double() << " (sign: " << s.sign << ", exp: " << s.exp << ", sig: " << s.sig << " " << s.sig.to_string(2,true) << ")";


    return os;
}

static
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
#599 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
}
#615 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {





        ap_uint<16> data = (uint16_t)f.get_bits();

        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {





        half h;
        h.set_bits(detail::uint16(data().to_uint()));
        return h;

    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};

static
std::ostream &operator << (std::ostream &os, const fp_struct<half> &s)
{


    os << s.to_half() << " (sign: " << s.sign << ", exp: " << s.exp << ", sig: " << s.sig << " " << s.sig.to_string(2,true) << ")";


    return os;
}

static
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
#758 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
}
#773 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;
};
#795 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;
};
#817 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 0;
};
#838 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;
};
#893 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template < unsigned int _DIM, unsigned int _I=_DIM>
class LowerTri : public LowerTri<_DIM, _I-1>
{
public:
    static const int dummy;
    static const unsigned int Size = _I + LowerTri<_DIM,_I-1>::Size;
};

template < unsigned int _DIM>
class LowerTri<_DIM, 0>
{
public:
    static const int dummy;
    static const unsigned int Size = 0;
};

template <int _MAX, int _I>
class LowerTriApply
{
public:
    static int rowApply() {
        int max = _MAX;
        int i = _I;
        int index = 0;
        int row[max];
        int dim = (int)(sqrtf(0.25+2*max)-0.5);
        for(int ii=0; ii<dim; ii++) {
            for(int jj=0; jj<ii+1; jj++) {
                row[index] = ii;
                index++;
            }
        }
        return row[i];
    }

    static int colApply() {
        int max = _MAX;
        int i = _I;
        int index = 0;
        int col[max];
        int dim = (int)(sqrtf(0.25+2*max)-0.5);
        for(int ii=0; ii<dim; ii++) {
            for(int jj=0; jj<ii+1; jj++) {
                col[index] = jj;
                index++;
            }
        }
        return col[i];
    }

    static int sizeApply() {
        int max = _MAX;
        int i = _I;
        int size[max];
        size[0] = 0;
        for(int ii=1; ii<max; ii++) {
            size[ii] = size[ii-1]+ii;
            if(i == ii) { return size[i]; }
        }
        return size[i];
    }
};

template < int _DIM, int _Num=LowerTri<_DIM>::Size, int _I=_Num-1>
class LowerTriDim : public LowerTriDim<_DIM,_Num,_I-1>
{
public:
    static const int dummy;
    static const int dummy2;
    static const int dummy3;
};

template < int _DIM, int _Num>
class LowerTriDim<_DIM, _Num, 0>
{
public:
    static const int dummy;
    static const int dummy2;
    static const int dummy3;
    static int RowLookup[_Num];
    static int ColLookup[_Num];
    static int SizeLookup[_DIM];
};

template < int _DIM, int _Num, int _I>
const int LowerTriDim<_DIM, _Num, _I>::dummy =
    LowerTriDim<_DIM,_Num,0>::RowLookup[_I] = LowerTriApply<_Num,_I>::rowApply()
            + 0*LowerTriDim<_DIM,_Num,_I-1>::dummy;

template < int _DIM, int _Num>
const int LowerTriDim<_DIM, _Num, 0>::dummy =
    LowerTriDim<_DIM,_Num,0>::RowLookup[0] = LowerTriApply<_Num,0>::rowApply()
            + 0*LowerTriDim<_DIM,_Num,_Num>::dummy2;


template < int _DIM, int _Num, int _I>
const int LowerTriDim<_DIM, _Num, _I>::dummy2 =
    LowerTriDim<_DIM,_Num,0>::ColLookup[_I] = LowerTriApply<_Num,_I>::colApply()
            + 0*LowerTriDim<_DIM,_Num,_I-1>::dummy2;

template < int _DIM, int _Num>
const int LowerTriDim<_DIM, _Num, 0>::dummy2 =
    LowerTriDim<_DIM,_Num,0>::ColLookup[0] = LowerTriApply<_Num,0>::colApply()
            + 0*LowerTriDim<_DIM,_Num,_Num>::dummy3;

template < int _DIM, int _Num, int _I>
const int LowerTriDim<_DIM, _Num, _I>::dummy3 =
    LowerTriDim<_DIM,_Num,0>::SizeLookup[_I] = LowerTriApply<_Num,_I>::sizeApply()
            + 0*LowerTriDim<_DIM,_Num,_I-1>::dummy3;

template < int _DIM, int _Num>
const int LowerTriDim<_DIM, _Num, 0>::dummy3 =
    LowerTriDim<_DIM,_Num,0>::SizeLookup[0] = LowerTriApply<_Num,0>::sizeApply();

template<int _DIM, int _Num>
int LowerTriDim<_DIM, _Num, 0>::RowLookup[_Num];

template<int _DIM, int _Num>
int LowerTriDim<_DIM, _Num, 0>::ColLookup[_Num];

template<int _DIM, int _Num>
int LowerTriDim<_DIM, _Num, 0>::SizeLookup[_DIM];
#1029 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;

};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];
};
#1056 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);




template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];



template <class T>
struct is_fptype { static const bool value = false; };
template <> struct is_fptype<float> { static const bool value = true; };
template <> struct is_fptype<double> { static const bool value = true; };
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false; };
template <> struct is_integraltype<int> { static const bool value = true; };
template <> struct is_integraltype<unsigned int> { static const bool value = true; };
template <> struct is_integraltype<char> { static const bool value = true; };
template <> struct is_integraltype<signed char> { static const bool value = true; };
template <> struct is_integraltype<unsigned char> { static const bool value = true; };
template <> struct is_integraltype<short> { static const bool value = true; };
template <> struct is_integraltype<unsigned short> { static const bool value = true; };
template <> struct is_integraltype<long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long> { static const bool value = true; };
template <> struct is_integraltype<long long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long long> { static const bool value = true; };
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true; };
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true; };

template <class T>
struct is_fixedtype { static const bool value = false; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true; };

template<bool B, class T = void>
struct enable_if {};

template<class T>
struct enable_if<true, T> { typedef T type; };

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value; };

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value; };

template<typename T, T _v>
struct integral_constant
{
    static const T value = _v;
    typedef T value_type;
    typedef integral_constant<T,_v> type;
    operator value_type() { return value; }
};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template<typename T1, typename T2>
struct is_same;

template<typename T1, typename T2>
struct is_same : public false_type { };

template<typename T1>
struct is_same<T1,T1> : public true_type { };

template<typename T>
struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };

template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };
#41 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h" 2
#1 "/usr/include/assert.h" 1 3 4
#42 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h" 2

namespace hls {

template<int W, typename T>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, T& val) {
#pragma HLS inline
    ((start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("start >= 0 && start+w <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h", 48, __PRETTY_FUNCTION__));
    val = (T)pix(start+w-1, start);
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, float& val) {
#pragma HLS inline
    ((w == 32 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 32 && start >= 0 && start+w <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h", 55, __PRETTY_FUNCTION__));
    fp_struct<float> temp((ap_uint<32>)pix(start+w-1, start));
    val = temp.to_float();
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, double& val) {
#pragma HLS inline
    ((w == 64 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 64 && start >= 0 && start+w <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h", 63, __PRETTY_FUNCTION__));
    fp_struct<double> temp((ap_uint<64>)pix(start+w-1, start));
    val = temp.to_double();
}

template<int W, typename T>
void AXIGetBitFields(ap_axiu<W,1,1,1> axi, int start, int w, T& val) {
#pragma HLS inline
    AXIGetBitFields(axi.data, start, w, val);
}

template<int W, typename T>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, T val) {
#pragma HLS inline
    ((start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("start >= 0 && start+w <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h", 77, __PRETTY_FUNCTION__));
    pix(start+w-1, start) = val;
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, float val) {
#pragma HLS inline
    ((w == 32 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 32 && start >= 0 && start+w <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h", 84, __PRETTY_FUNCTION__));
    fp_struct<float> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, double val) {
#pragma HLS inline
    ((w == 64 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 64 && start >= 0 && start+w <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h", 92, __PRETTY_FUNCTION__));
    fp_struct<double> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W, typename T>
void AXISetBitFields(ap_axiu<W,1,1,1>& axi, int start, int w, T val) {
#pragma HLS inline
    AXISetBitFields(axi.data, start, w, val);
}

}
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 1
#45 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h"
#1 "/usr/include/assert.h" 1 3 4
#46 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2


#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_defines.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_defines.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_int.h" 1
#40 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_defines.h" 2
#105 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_defines.h"
template<int M, int E>
struct float_struct {
    ap_uint<M> mant;
    ap_uint<E> exp;
    ap_uint<1> sign;
};




template<int M, int E>
struct float_struct2 {
    ap_int<M> mant;
    ap_uint<E> exp;
};
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h" 1
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_traits.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_traits.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_fixed.h" 1
#36 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_traits.h" 2

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_utils.h" 1
#38 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_traits.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_defines.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_traits.h" 2

namespace hls
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
#65 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_traits.h"
};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(((I1) > (W1-I1) ? (I1) : (W1-I1))+1),(((I1) > (W1-I1) ? (I1) : (W1-I1))+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(((I1) > (W1-I1) ? (I1) : (W1-I1))+1),(((I1) > (W1-I1) ? (I1) : (W1-I1))+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<((W1) > (W2) ? (W1) : (W2)) + 1> ADD_T;
 typedef ap_int<((W1) > (W2) ? (W1) : (W2)) + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<((W1) > (W2+1) ? (W1) : (W2+1)) + 1> ADD_T;
 typedef ap_int<((W1) > (W2+1) ? (W1) : (W2+1)) + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<((W1+1) > (W2) ? (W1+1) : (W2)) + 1> ADD_T;
 typedef ap_int<((W1+1) > (W2) ? (W1+1) : (W2)) + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<((W1) > (W2) ? (W1) : (W2)) + 1> ADD_T;
 typedef ap_int<((W1) > (W2) ? (W1) : (W2)) + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}
#51 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2


namespace hls
{







#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_basic_math.h" 1
#44 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_basic_math.h"
template <typename T>
int generic_signbit(T x) {
    fp_struct<T> s(x);
    return s.__signbit();
}
static int __signbit(float x)
{
    return generic_signbit(x);
}

static int __signbit(double x)
{
    return generic_signbit(x);
}

static int __signbit(half x)
{
    return generic_signbit(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type signbit(T x)
{
    return x < 0 ? 1 : 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type signbit(T x)
{
    return __signbit(x);
}

template <typename T>
T generic_nan(const char *tagp) {
    fp_struct<T> nan;
    nan.sig = -1;
    nan.exp = -1;
    nan.sign = 0;
    return nan.to_ieee();
}
static double nan(const char *tagp) {
    return generic_nan<double>(tagp);
}

static float nanf(const char *tagp) {
    return generic_nan<double>(tagp);
}

static half half_nan(const char *tagp) {
    return generic_nan<half>(tagp);
}
#104 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_basic_math.h"
template <typename T>
int generic_isfinite(T x) {
    fp_struct<T> fs = x;
    int ret = (fs.exp == fp_struct<T>::EXP_INFNAN) ? 0 : 1;
    return ret;
}
static int __isfinite(float x)
{
    return generic_isfinite(x);
}

static int __isfinite(double x)
{
    return generic_isfinite(x);
}

static int __isfinite(half x)
{
    return generic_isfinite(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isfinite(T x)
{
    return 1;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isfinite(T x)
{
    return __isfinite(x);
}







template <typename T>
int generic_isinf(T x) {
    fp_struct<T> fs = x;
    int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig == 0x0)) ? 1 : 0;
    return ret;
}
static int __isinf(float x)
{
    return generic_isinf(x);
}

static int __isinf(double x)
{
    return generic_isinf(x);
}

static int __isinf(half x)
{
    return generic_isinf(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isinf(T x)
{
    return 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isinf(T x)
{
    return __isinf(x);
}







template <typename T>
int generic_isnan(T x) {
    fp_struct<T> fs = x;
    int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig != 0x0)) ? 1 : 0;
    return ret;
}
static int __isnan(float x)
{
    return generic_isnan(x);
}

static int __isnan(double x)
{
    return generic_isnan(x);
}

static int __isnan(half x)
{
    return generic_isnan(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isnan(T x)
{
    return 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isnan(T x)
{
 return __isnan(x);
}
#223 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_basic_math.h"
template <typename T>
int generic_isnormal(T x) {
    fp_struct<T> fs = x;
    int ret = ((fs.exp != fp_struct<T>::EXP_INFNAN) && (fs.exp != 0x0)) ? 1 : 0;
    return ret;
}
static int __isnormal(float x)
{
    return generic_isnormal(x);
}

static int __isnormal(double x)
{
    return generic_isnormal(x);
}

static int __isnormal(half x)
{
    return generic_isnormal(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isnormal(T x)
{
    return x != 0 ? 1 : 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isnormal(T x)
{
 return __isnormal(x);
}
#283 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_basic_math.h"
template <typename T>
int generic_fpclassify(T x) {
    fp_struct<T> fs = x;
    int ret;
    if(fs.exp == 0x0) {
        ret = (fs.sig == 0x0) ? 2 : 3;
    } else if(fs.exp == fp_struct<T>::EXP_INFNAN) {
        ret = (fs.sig == 0x0) ? 1 : 0;
    } else {
        ret = 4;
    }
    return ret;
}
static int __fpclassifyf(float x)
{
    return generic_fpclassify(x);
}

static int __fpclassify(double x)
{
    return generic_fpclassify(x);
}

static int __fpclassify(half x)
{
    return generic_fpclassify(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type fpclassify(T x)
{
    return x !=0 ? 4 : 2;
}

static int fpclassify(float x)
{
    return __fpclassifyf(x);
}

static int fpclassify(double x)
{
    return __fpclassify(x);
}

static int fpclassify(half x)
{
    return __fpclassify(x);
}

static
double copysign(double x, double y)
{
    fp_struct<double> xs(x), ys(y);
    xs.sign = ys.sign;
    return xs.to_ieee();
}

static
float copysignf(float x, float y)
{
    fp_struct<float> xs(x), ys(y);
    xs.sign = ys.sign;
    return xs.to_ieee();
}
static
half half_copysign(half x, half y)
{
    fp_struct<half> xs(x), ys(y);
    xs.sign = ys.sign;
    return xs.to_ieee();
}


static
float copysign(float x, float y)
{
    return copysignf(x, y);
}
static
half copysign(half x, half y)
{
    return ::hls::half_copysign(x, y);
}



template <typename T>
T generic_fabs(T x)
{
    return copysign(x, (T)0);
}

template <typename T>
T generic_fma(T x, T y, T z)
{
    return x*y+z;
}



template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isequal(T x, T y)
{
    return x == y;
}

static int isequal(double x, double y)
{
    return xil_fpo_equal_d(x,y);
}

static int isequal(float x, float y)
{
    return xil_fpo_equal_flt(x,y);
}

static int isequal(half x, half y)
{
    return x == y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isgreater(T x, T y)
{
    return x > y;
}

static int isgreater(double x, double y)
{
    return xil_fpo_greater_d(x,y);
}

static int isgreater(float x, float y)
{
    return xil_fpo_greater_flt(x,y);
}

static int isgreater(half x, half y)
{
    return x > y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isgreaterequal(T x, T y)
{
    return x >= y;
}

static int isgreaterequal(double x, double y)
{
    return xil_fpo_greaterequal_d(x,y);
}

static int isgreaterequal(float x, float y)
{
    return xil_fpo_greaterequal_flt(x,y);
}

static int isgreaterequal(half x, half y)
{
    return x >= y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isless(T x, T y)
{
    return x < y;
}

static int isless(double x, double y)
{
    return xil_fpo_less_d(x,y);
}

static int isless(float x, float y)
{
    return xil_fpo_less_flt(x,y);
}

static int isless(half x, half y)
{
    return x < y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type islessequal(T x, T y)
{
    return x <= y;
}

static int islessequal(double x, double y)
{
    return xil_fpo_lessequal_d(x,y);
}

static int islessequal(float x, float y)
{
    return xil_fpo_lessequal_flt(x,y);
}

static int islessequal(half x, half y)
{
    return x <= y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type islessgreater(T x, T y)
{
    return (x < y) || (x > y);
}

static int islessgreater(double x, double y)
{
    return xil_fpo_less_d(x,y) || xil_fpo_greater_d(x,y);
}

static int islessgreater(float x, float y)
{
    return xil_fpo_less_flt(x,y) || xil_fpo_greater_flt(x,y);
}

static int islessgreater(half x, half y)
{
    return (x < y) || (x > y);
}


template <typename T>
typename enable_if<is_arithmetic<T>::value, int>::type isnotequal(T x, T y)
{
    return x != y;
}

static int isnotequal(double x, double y)
{
    return xil_fpo_notequal_d(x,y);
}

static int isnotequal(float x, float y)
{
    return xil_fpo_notequal_flt(x,y);
}

static int isnotequal(half x, half y)
{
    return x != y;
}


template <typename T>
typename enable_if<is_arithmetic<T>::value, int>::type isordered(T x, T y)
{
    return (((!__isnan(x))&&(!__isnan(y))) ? 1 : 0);
}

template <typename T>
typename enable_if<is_arithmetic<T>::value, int>::type isunordered(T x, T y)
{
    return (( __isnan(x) || __isnan(y) ) ? 1 : 0);
}
#551 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_basic_math.h"
template <typename T>
T generic_fmax(T x, T y)
{
 fp_struct<T> x_fp(x);
 fp_struct<T> y_fp(y);
    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
 T res;
 if(x_fp.exp == 0 && x_fp.sig == 0 && y_fp.exp == 0 && y_fp.sig == 0) {
  res = y;
 } else if(__isnan(x)) {
  if(__isnan(y)) {
   x_fp.sig[fp_struct<T>::SIG_BITS-1] = 1;
   res = x_fp.to_ieee();
  } else {
   res = y;
  }
 } else if(__isnan(y)) {
  res = x;
 } else {

        bool ymaggreater = x_fp.to_int() < y_fp.to_int();
        if(y_fp.sign && x_fp.sign) ymaggreater = !ymaggreater;
        res = ymaggreater ? y : x;
 }
 return res;
}
#585 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_basic_math.h"
template<typename T>
T generic_fmin(T x, T y)
{
 fp_struct<T> x_fp(x);
 fp_struct<T> y_fp(y);
    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
 T res;
 if(x_fp.exp == 0 && x_fp.sig == 0 && y_fp.exp == 0 && y_fp.sig == 0) {
  res = y;
 } else if(__isnan(x)) {
  if(__isnan(y)) {
   x_fp.sig[fp_struct<T>::SIG_BITS-1] = 1;
   res = x_fp.to_ieee();
  } else {
   res = y;
  }
 } else if(__isnan(y)) {
  res = x;
 } else {

        bool ymaggreater = x_fp.to_int() < y_fp.to_int();
        if(y_fp.sign && x_fp.sign) ymaggreater = !ymaggreater;
        res = ymaggreater ? x : y;
    }
 return res;
}

template<typename T>
T generic_fdim(T x, T y)
{
 T res = 0;
 if (__isnan(x)) res = x;
 else if (__isnan(y)) res = y;
 else if (x>y) res = x-y;
 return res;
}

template<typename T>
T generic_maxmag(T x, T y)
{
        if (generic_fabs(y)>generic_fabs(x)) return y;
        else return x;
}

template<typename T>
T generic_minmag(T x, T y)
{
        if (generic_fabs(y)<generic_fabs(x)) return y;
        else return x;
}



template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type any(typename enable_if<is_integraltype<T>::value, T>::type x)
{
    return (x < 0);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type all(typename enable_if<is_integraltype<T>::value, T>::type x)
{
    return (x < 0);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, T>::type bitselect(T x, T y, T z)
{
    T r = (z & y) | (~z & x);
    return r;
}

template <typename T>
typename enable_if<is_fptype<T>::value, T>::type bitselect(T x, T y, T z)
{
    fp_struct<T> fp_x(x);
    fp_struct<T> fp_y(y);
    fp_struct<T> fp_z(z);
    ap_uint<Type_BitWidth<T>::Value> r;
    r = (fp_z.data() & fp_y.data()) | (~fp_z.data() & fp_x.data());
    fp_struct<T> fp_r(r);
    return fp_r.to_ieee();
}


template <typename T>
typename enable_if<is_arithmetic<T>::value, T>::type select(T x, T y, bool z)
{
    T r = z ? y : x;
    return r;
}

template <typename T>
T generic_frexp (T x, int* exp) {

    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
    fp_struct<T> xs = x;
    bool zero = (xs.exp == 0x0);
    bool nan = (xs.exp == max_exponent);
    *exp = (zero || nan) ? 0 : xs.expv()+1;
    if(zero) {

        return (T)0.0;
    } else if(nan) {

        return x;
    } else {
        xs.exp = fp_struct<T>::EXP_BIAS-1;
        return xs.to_ieee();
    }
}

template <typename T>
T generic_ldexp (T x, int exp) {

    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
    fp_struct<T> xs = x;
    exp += xs.exp;
    bool ininf = (xs.exp == max_exponent);
    bool zero = (xs.exp == 0) || (exp <= 0);
    bool inf = ininf || (exp >= max_exponent);
    if(__isnan(x)) {
        return x;
    } else if(zero && !ininf) {
        return ::hls::copysign((T)0.0,x);
    } else if(inf) {

        xs.sig = 0x0;
        xs.exp = max_exponent;
    } else {
        xs.exp = exp;
    }
    return xs.to_ieee();
}

template <typename T>
int generic_ilogb (T x) {
    fp_struct<T> xs(x);
    if ( xs.exp == 0 ) {
        if ( xs.sig == 0 ) return (-2147483647 - 1);
        unsigned int wf = fp_struct<T>::SIG_BITS;
        unsigned int zeros;
#pragma unroll
        for ( zeros = 0; zeros < wf; zeros++ )
            if ( xs.sig[wf-zeros-1] ) break;
        int ret = -127 - zeros;
        return ret;
    }
    return xs.expv();
}
#63 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2

static double fabs (double x) {
    return generic_fabs<double>(x);
}
static float fabs (float x) {
    return generic_fabs<float>(x);
}
static half fabs (half x) {
    return generic_fabs<half>(x);
}
static float fabsf (float x) {
    return generic_fabs<float>(x);
}
static half half_fabs (half x) {
    return generic_fabs<half>(x);
}


static double abs (double x) {
    return generic_fabs<double>(x);
}
static float abs (float x) {
    return generic_fabs<float>(x);
}
static half abs (half x) {
    return generic_fabs<half>(x);
}
static float absf (float x) {
    return generic_fabs<float>(x);
}
static half half_abs (half x) {
    return generic_fabs<half>(x);
}

static double fma (double x, double y, double z) {
    return generic_fma<double>(x,y,z);
}
static float fma (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half fma (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}
static float fmaf (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half half_fma (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}

static double mad (double x, double y, double z) {
    return generic_fma<double>(x,y,z);
}
static float mad (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half mad (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}
static float madf (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half half_mad (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}

static double frexp (double x, int* exp) {
    return generic_frexp<double>(x, exp);
}
static float frexp (float x, int* exp) {
    return generic_frexp<float>(x, exp);
}
static half frexp (half x, int* exp) {
    return generic_frexp<half>(x, exp);
}
static float frexpf (float x, int* exp) {
    return generic_frexp<float>(x, exp);
}
static half half_frexp (half x, int* exp) {
    return generic_frexp<half>(x, exp);
}

static double ldexp (double x, int exp) {
    return generic_ldexp<double>(x, exp);
}
static float ldexp (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half ldexp (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}
static float ldexpf (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half half_ldexp (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}

static double scalbn (double x, int exp) {
    return generic_ldexp<double>(x, exp);
}
static float scalbn (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half scalbn (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}
static float scalbnf (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half half_scalbn (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}

static double scalbln (double x, long int exp) {
    return generic_ldexp<double>(x, exp);
}
static float scalbln (float x, long int exp) {
    return generic_ldexp<float>(x, exp);
}
static half scalbln (half x, long int exp) {
    return generic_ldexp<half>(x, exp);
}
static float scalblnf (float x, long int exp) {
    return generic_ldexp<float>(x, exp);
}
static half half_scalbln (half x, long int exp) {
    return generic_ldexp<half>(x, exp);
}

static int ilogb (double x) {
    return generic_ilogb<double>(x);
}
static int ilogb (float x) {
    return generic_ilogb<float>(x);
}
static int ilogb (half x) {
    return generic_ilogb<half>(x);
}
static int ilogbf (float x) {
    return generic_ilogb<float>(x);
}
static int half_ilogb (half x) {
    return generic_ilogb<half>(x);
}

static double fmax(double x, double y) {
    return generic_fmax<double>(x,y);
}
static float fmax(float x, float y) {
    return generic_fmax(x,y);
}
static half fmax(half x, half y) {
    return generic_fmax<half>(x,y);
}
static float fmaxf(float x, float y) {
    return generic_fmax<float>(x,y);
}
static half half_fmax(half x, half y) {
    return generic_fmax<half>(x,y);
}

static double fmin(double x, double y) {
    return generic_fmin<double>(x,y);
}
static float fmin(float x, float y) {
    return generic_fmin(x,y);
}
static half fmin(half x, half y) {
    return generic_fmin<half>(x,y);
}
static float fminf(float x, float y) {
    return generic_fmin<float>(x,y);
}
static half half_fmin(half x, half y) {
    return generic_fmin<half>(x,y);
}

static double fdim(double x, double y) {
    return generic_fdim<double>(x,y);
}
static float fdim(float x, float y) {
    return generic_fdim(x,y);
}
static half fdim(half x, half y) {
    return generic_fdim<half>(x,y);
}
static float fdimf(float x, float y) {
    return generic_fdim<float>(x,y);
}
static half half_fdim(half x, half y) {
    return generic_fdim<half>(x,y);
}

static double maxmag(double x, double y) {
    return generic_maxmag<double>(x,y);
}
static float maxmag(float x, float y) {
    return generic_maxmag(x,y);
}
static half maxmag(half x, half y) {
    return generic_maxmag<half>(x,y);
}
static float maxmagf(float x, float y) {
    return generic_maxmag<float>(x,y);
}
static half half_maxmag(half x, half y) {
    return generic_maxmag<half>(x,y);
}

static double minmag(double x, double y) {
    return generic_minmag<double>(x,y);
}
static float minmag(float x, float y) {
    return generic_minmag(x,y);
}
static half minmag(half x, half y) {
    return generic_minmag<half>(x,y);
}
static float minmagf(float x, float y) {
    return generic_minmag<float>(x,y);
}
static half half_minmag(half x, half y) {
    return generic_minmag<half>(x,y);
}


#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h" 1
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h"
template <int W, int I, ap_q_mode Q, ap_o_mode O>
unsigned int clrsb(ap_fixed<W,I,Q,O> value) {
    ap_uint<W> x = value(W-1,0);
    if(value[W-1]) {
        x = ~x;
    }
    x = x << 1 | 0x1;
    (((int)x.countLeadingZeros() <= W) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h", 55, __PRETTY_FUNCTION__));
    (((int)x.countLeadingZeros() >= 0) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h", 56, __PRETTY_FUNCTION__));
    return x.countLeadingZeros();
}
#67 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h"
template <int W>
unsigned int clrsb(ap_int<W> value) {
    ap_uint<W> x = value(W-1,0);
    if(value[W-1]) {
        x = ~x;
    }
    x = x << 1 | 0x1;
    (((int)x.countLeadingZeros() <= W) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() <= W", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h", 74, __PRETTY_FUNCTION__));
    (((int)x.countLeadingZeros() >= 0) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h", 75, __PRETTY_FUNCTION__));
    return x.countLeadingZeros();
}
#86 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h"
static
unsigned int clrsb(int value)
{
#pragma HLS INLINE SELF
    return clrsb(ap_int<32>(value));
}

template<int Z, int W, int I>
unsigned int clz(ap_ufixed<W,I> x)
{
    ap_uint<Z+1> t;
    t(Z,1) = x(x.wl()-1,x.wl()-Z);
    t[0] = 1;

    return t.countLeadingZeros();
}

static
unsigned int clz(int value) {
    ap_int<32> x = value;
    return x.countLeadingZeros();
}

template <int W>
unsigned int clz(ap_int<W> value) {
    return value.countLeadingZeros();
}

template <int W>
unsigned int clz(ap_uint<W> value) {
    return value.countLeadingZeros();
}
#128 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h"
static
unsigned int find_normalization(int x)
{
    return clrsb(x);
}
#142 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_normalize.h"
static
unsigned int find_normalization(short x)
{


    int bits;
    if(x < 0) {
        bits = 0;
    } else {
        bits = 0xFFFF;
    }
    return clrsb(((int)x) << 16 | bits);
}
#291 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_round.h" 1
#37 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_round.h"
template <typename T>
void init_mask_table(typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS]) {


    const typename fp_struct<T>::inttype t = (1LL << fp_struct<T>::SIG_BITS)-1;
    for(unsigned int i = 0; i < fp_struct<T>::BITS-2; i++) {
        mask_table[i] = t >> (i+1);
    }
    mask_table[fp_struct<T>::BITS-2] = t;
    mask_table[fp_struct<T>::BITS-1] = t;
}

template <typename T>
void init_one_half_table(typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS]) {


    const typename fp_struct<T>::inttype t = 1LL << (fp_struct<T>::SIG_BITS-1);
    for(unsigned int i = 0; i < fp_struct<T>::BITS-2; i++) {
        mask_table[i] = t >> (i+1);
    }
    mask_table[fp_struct<T>::BITS-2] = t << 1;
    mask_table[fp_struct<T>::BITS-1] = t;
}

template <typename T>
void init_one_half_minus_one_table(typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS]) {


    const typename fp_struct<T>::inttype t = (1LL << (fp_struct<T>::SIG_BITS-1));
    for(unsigned int i = 0; i < fp_struct<T>::SIG_BITS-1; i++) {
        mask_table[i] = (t >> (i+1))-1;
    }
    for(unsigned int i = fp_struct<T>::SIG_BITS-1; i < fp_struct<T>::BITS-2; i++) {
        mask_table[i] = 0;
    }
    mask_table[fp_struct<T>::BITS-2] = (t << 1)-1;
    mask_table[fp_struct<T>::BITS-1] = t-1;
}

template <typename T>
T generic_floor(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);
    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        if(xs.__signbit() && !(xs.sig == 0 && xs.exp == 0)) {
            return T(-1.0);
        } else {
            return ::hls::copysign((T)0.0, x);
        }
    } else if((xs.exp > fp_struct<T>::EXP_BIAS + fp_struct<T>::SIG_BITS)) {

        return x;
    } else {
        typename fp_struct<T>::inttype mask;


        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];


        if(xs.__signbit()) {
            xs = typename fp_struct<T>::data_type(xs.data() + mask);
        }

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double floor(double x)
{
    return generic_floor<double>(x);
}

static
float floorf(float x)
{
    return generic_floor<float>(x);
}

static
half half_floor(half x)
{
    return generic_floor<half>(x);
}


static
float floor(float x)
{
    return floorf(x);
}
static
half floor(half x)
{
    return generic_floor<half>(x);
}


template <typename T>
T generic_ceil(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        if(!xs.__signbit() && !(xs.sig == 0 && xs.exp == 0)) {
            return T(1.0);
        } else {
            return ::hls::copysign((T)0.0, x);
        }
    } else if(xs.exp > (fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {

        return x;
    } else {
        typename fp_struct<T>::inttype mask;


        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value> index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];


        if(!xs.__signbit()) {
            xs = typename fp_struct<T>::data_type(xs.data() + mask);
        }

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double ceil(double x)
{
    return generic_ceil<double>(x);
}

static
float ceilf(float x)
{
    return generic_ceil<float>(x);
}

static
half half_ceil(half x)
{
    return generic_ceil<half>(x);
}

static
float ceil(float x)
{
    return ceilf(x);
}
static
half ceil(half x)
{
    return generic_ceil<half>(x);
}



template <typename T>
T generic_trunc(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        return ::hls::copysign((T)0.0, x);
    } else if((xs.exp > fp_struct<T>::EXP_BIAS + fp_struct<T>::SIG_BITS)) {

        return x;
    } else {
        typename fp_struct<T>::inttype mask;


        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];
        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double trunc(double x)
{
    return generic_trunc<double>(x);
}

static
float truncf(float x)
{
    return generic_trunc<float>(x);
}

static
half half_trunc(half x)
{
    return generic_trunc<half>(x);
}


static
float trunc(float x)
{
    return truncf(x);
}
static
half trunc(half x)
{
    return generic_trunc<half>(x);
}
#267 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_round.h"
template <typename T>
T generic_round(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    typename fp_struct<T>::inttype one_half_table[fp_struct<T>::BITS];
    init_one_half_table<T>(one_half_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS - 1) {

        return ::hls::copysign((T)0.0, x);
    } else if((xs.exp > fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {

        return x;
    } else {
        typename fp_struct<T>::inttype mask;
        typename fp_struct<T>::inttype one_half;


        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];
        one_half = one_half_table[index];

        xs = typename fp_struct<T>::data_type(xs.data() + one_half);

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double round(double x)
{
    return generic_round<double>(x);
}


static
float roundf(float x)
{
    return generic_round<float>(x);
}

static
half half_round(half x)
{
    return generic_round<half>(x);
}


static
float round(float x)
{
    return roundf(x);
}
static
half round(half x)
{
    return generic_round<half>(x);
}
#343 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_round.h"
template <typename T>
T generic_rint(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    typename fp_struct<T>::inttype one_half_minus_one_table[fp_struct<T>::BITS];
    init_one_half_minus_one_table<T>(one_half_minus_one_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS - 1 || (xs.exp == (fp_struct<T>::EXP_BIAS-1) && xs.sig == 0)) {

        return ::hls::copysign((T)0.0, x);
    } else if((xs.exp >= fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {

        return x;
    } else {
        typename fp_struct<T>::inttype mask;
        typename fp_struct<T>::inttype one_half;


        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];
        one_half = one_half_minus_one_table[index];

        int index_table[fp_struct<T>::BITS];
        for(unsigned int i = 0; i < fp_struct<T>::BITS-2; i++) {
            index_table[i] = int(fp_struct<T>::SIG_BITS - 1 - i);
        }
        index_table[fp_struct<T>::BITS-2] = int(fp_struct<T>::SIG_BITS)-2;





        index_table[fp_struct<T>::BITS-1] = int(fp_struct<T>::SIG_BITS);

        if(xs.data()[index_table[index]]) one_half += 1;
#389 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_round.h"
        xs = typename fp_struct<T>::data_type(xs.data() + one_half);

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double rint(double x)
{
    return generic_rint<double>(x);
}


static
float rintf(float x)
{
    return generic_rint<float>(x);
}

static
half half_rint(half x)
{
    return generic_rint<half>(x);
}

static
double nearbyint(double x)
{
    return generic_rint<double>(x);
}


static
float nearbyintf(float x)
{
    return generic_rint<float>(x);
}

static
half half_nearbyint(half x)
{
    return generic_rint<half>(x);
}

template <typename T, ap_q_mode ROUNDING, typename FP>
T cast_IEEE754(FP x, bool detect_overflow = false, typename enable_if<std::numeric_limits<T>::is_signed, bool>::type = true) {
    fp_struct<FP> xs(x);
    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> mantissa = xs.mantissa();

    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> smantissa = mantissa << xs.expv();

    ap_ufixed<1 , 8 * sizeof(T) , AP_TRN, AP_SAT> overflow_bits = smantissa;
    ap_ufixed<8 * sizeof(T)-1, 8 * sizeof(T)-1, ROUNDING> val = smantissa;

    bool overflow;
    if(fp_struct<FP>::SIG_BITS + 8 * sizeof(T) >= (fp_struct<FP>::EXP_INFNAN - fp_struct<FP>::EXP_BIAS)) {



        overflow = (xs.exp == fp_struct<FP>::EXP_INFNAN) || (overflow_bits != 0);
    } else {


        overflow = xs.expv() >= (signed)(fp_struct<FP>::SIG_BITS + 8 * sizeof(T)) || (overflow_bits != 0);
    }

    ap_int<8*sizeof(T)> minval = 0;
    minval[8*sizeof(T)-1] = 1;
    ap_int<8*sizeof(T)> maxval = -1;
    maxval[8*sizeof(T)-1] = 0;
    if(overflow && detect_overflow)
        return xs.__signbit() ? minval : maxval;
#472 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_round.h"
    ap_fixed<8 * sizeof(T),8 * sizeof(T)> result = val;
    if(xs.__signbit()) result = -val;

    return result;
}

template <typename T, ap_q_mode ROUNDING, typename FP>
T cast_IEEE754(FP x, bool detect_overflow = false, typename enable_if<!std::numeric_limits<T>::is_signed, bool>::type = true) {
    fp_struct<FP> xs(x);
    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> mantissa = xs.mantissa();

    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> smantissa = mantissa << xs.expv();

    ap_ufixed<1 , 8 * sizeof(T)+1, AP_TRN, AP_SAT> overflow_bits = smantissa;
    ap_ufixed<8 * sizeof(T) , 8 * sizeof(T) , ROUNDING> val = smantissa;


    bool overflow;
    if(fp_struct<FP>::SIG_BITS + 8 * sizeof(T) >= (fp_struct<FP>::EXP_INFNAN - fp_struct<FP>::EXP_BIAS)) {



        overflow = (xs.exp == fp_struct<FP>::EXP_INFNAN) || (overflow_bits != 0);
    } else {


        overflow = xs.expv() >= (signed)(fp_struct<FP>::SIG_BITS + 8 * sizeof(T)) || (overflow_bits != 0);
    }

    ap_uint<8*sizeof(T)> minval = 0;
    ap_uint<8*sizeof(T)> maxval = -1;
    if((overflow || xs.__signbit()) && detect_overflow)
        return xs.__signbit() ? minval : maxval;
#515 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_round.h"
    ap_fixed<8 * sizeof(T),8 * sizeof(T)> result = val;

    return result;
}


template <typename T, typename FP>
T cast_IEEE754(FP x, bool detect_overflow = false) {
    return cast_IEEE754<T, AP_TRN_ZERO>(x, detect_overflow);
}




static
long int lrint(double x) {

    return cast_IEEE754<long int, AP_RND_CONV>(x, true);
}

static
long long int llrint(double x) {
    return cast_IEEE754<long long int, AP_RND_CONV>(x, true);
}

static
long int lrintf(float x) {

    return cast_IEEE754<long int, AP_RND_CONV>(x, true);
}

static
long long int llrintf(float x) {
    return cast_IEEE754<long long int, AP_RND_CONV>(x, true);
}

static
long int half_lrint(half x) {

    return cast_IEEE754<long int, AP_RND_CONV>(x, true);
}

static
long long int half_llrint(half x) {
    return cast_IEEE754<long long int, AP_RND_CONV>(x, true);
}

static
long int lround(double x) {

    return cast_IEEE754<long int, AP_RND_INF>(x, true);
}

static
long long int llround(double x) {
    return cast_IEEE754<long long int, AP_RND_INF>(x, true);
}

static
long int lroundf(float x) {

    return cast_IEEE754<long int, AP_RND_INF>(x, true);
}

static
long long int llroundf(float x) {
    return cast_IEEE754<long long int, AP_RND_INF>(x, true);
}

static
long int half_lround(half x) {

    return cast_IEEE754<long int, AP_RND_INF>(x, true);
}

static
long long int half_llround(half x) {
    return cast_IEEE754<long long int, AP_RND_INF>(x, true);
}

template <typename T>
T generic_modf(T x, T *intpart)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        *intpart = ::hls::copysign((T)0.0, x);
        return x;
    } else if((xs.exp > fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {

        *intpart = x;
        if(::hls::__isnan(x)) {
            fp_struct<T> nan;
            nan.sig = -1;
            nan.exp = -1;
            nan.sign = 0;
            return nan.to_ieee();
        } else {
            return ::hls::copysign((T)0.0, x);
        }
    } else {
        typename fp_struct<T>::inttype mask;


        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];


        fp_struct<T> xf;
        xf.sig = xs.sig & mask;

        int zeros = xf.sig.countLeadingZeros();


        xf.exp = (xf.sig == 0) ? 0 : (unsigned short)(xs.exp-zeros-1);

        xf.sig = (xf.sig << 1) << zeros;
        xf.sign = xs.sign;


        xs.sig = xs.sig & (~mask);
        *intpart = xs.to_ieee();

        return xf.to_ieee();
    }
}

static
double modf(double x, double *intpart)
{
    return generic_modf<double>(x, intpart);
}

static
float modff(float x, float *intpart)
{
    return generic_modf<float>(x, intpart);
}

static
half half_modf(half x, half *intpart)
{
    return generic_modf<half>(x, intpart);
}


static
float modf(float x, float *intpart)
{
    return modff(x, intpart);
}
static
half modf(half x, half *intpart)
{
    return generic_modf<half>(x, intpart);
}


template <typename T>
T generic_fract(T x, T *intpart)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);


    fp_struct<T> special_case;
    special_case.sign = 0;
    special_case.exp = fp_struct<T>::EXP_BIAS-1;
    special_case.sig = -1;

    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        if(xs.__signbit() && !(xs.sig == 0 && xs.exp == 0)) {
            *intpart = (T)-1.0f;
            T f = (T)1.0 + x;
            fp_struct<T> xf(f);
            bool is_one = (xf.exp == fp_struct<T>::EXP_BIAS) && xf.sig == 0;
            if(is_one) {
                return special_case.to_ieee();
            } else {
                return xf.to_ieee();
            }
        } else {
            *intpart = ::hls::copysign((T)0.0, x);
            return x;
        }
    } else if(xs.exp == fp_struct<T>::EXP_INFNAN) {
        *intpart = x;
 if (xs.sig == 0)
     return ::hls::copysign((T)0.0, x);
        return x;
    } else if((xs.exp > fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {

        *intpart = x;
        return ::hls::copysign((T)0.0, x);
    } else {
        typename fp_struct<T>::inttype mask;


        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];


        fp_struct<T> xf;
        if(xs.__signbit())
            xf.sig = -xs.sig;
        else
            xf.sig = xs.sig;
        xf.sig = xf.sig & mask;

        int zeros = xf.sig.countLeadingZeros();;


        xf.exp = (xf.sig == 0) ? 0 : (unsigned short)(xs.exp-zeros-1);

        xf.sig = (xf.sig << 1) << zeros;
        xf.sign = 0;


        if(xs.__signbit()) {
            xs = typename fp_struct<T>::data_type(xs.data() + mask);
        }


        xs.sig = xs.sig & (~mask);
        *intpart = xs.to_ieee();

        return xf.to_ieee();
    }
}
static
double fract(double x, double *intpart)
{
    return generic_fract<double>(x, intpart);
}

static
float fractf(float x, float *intpart)
{
    return generic_fract<float>(x, intpart);
}
static
half half_fract(half x, half *intpart)
{
    return generic_fract<half>(x, intpart);
}
#292 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_.h" 1
#38 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_.h"
namespace log_reduce {

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_tables.h" 1
#32 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_tables.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_fixed.h" 1
#33 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_tables.h" 2
namespace {

template <typename T, int p, int alpha, int size> class log_lut_table {};





template <> class log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",
"0x0.03030549D3B2A18BB8123EEF5D29p0",
"0x0.04060E7B3F982465E5AE80179F4Ap0",
"0x0.050A1ED2A137CD8B76C303145D04p0",
"0x0.060F3868C0EF391853C966BD7471p0",
"0x0.07155D5CD81D53619307B8308EB9p0",
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",
"0x0.09A959A26D3862E752AF15528C0Fp0",
"0x0.0AB33774BD9E386027BF3B81173Fp0",
"0x0.0BBE2A841109EFBA651B04210A41p0",
"0x0.0CCA3514F685E5346E87B075E077p0",
"0x0.0DD759732434C1A6FD3C142C43A9p0",
"0x0.0EE599F19585A95D50A830135E93p0",
};


template <> class log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",
"0x0.03030549D3B2A18BB8123EEF5D29p0",
"0x0.04060E7B3F982465E5AE80179F4Ap0",
"0x0.050A1ED2A137CD8B76C303145D04p0",
"0x0.060F3868C0EF391853C966BD7471p0",
"0x0.07155D5CD81D53619307B8308EB9p0",
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",
"0x0.09A959A26D3862E752AF15528C0Fp0",
"0x0.0AB33774BD9E386027BF3B81173Fp0",
"0x0.0BBE2A841109EFBA651B04210A41p0",
"0x0.0CCA3514F685E5346E87B075E077p0",
"0x0.0DD759732434C1A6FD3C142C43A9p0",
"0x0.0EE599F19585A95D50A830135E93p0",
};


template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",
"0x0.03030549D3B2A18BB8123EEF5D29p0",
"0x0.04060E7B3F982465E5AE80179F4Ap0",
"0x0.050A1ED2A137CD8B76C303145D04p0",
"0x0.060F3868C0EF391853C966BD7471p0",
"0x0.07155D5CD81D53619307B8308EB9p0",
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",
"0x0.09A959A26D3862E752AF15528C0Fp0",
"0x0.0AB33774BD9E386027BF3B81173Fp0",
"0x0.0BBE2A841109EFBA651B04210A41p0",
"0x0.0CCA3514F685E5346E87B075E077p0",
"0x0.0DD759732434C1A6FD3C142C43A9p0",
"0x0.0EE599F19585A95D50A830135E93p0",
};





template <> class log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {

"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};


template <> class log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {

"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};


template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {

"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};





template <> class log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {

"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};


template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {

"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};





template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>::array [64] = {

"0x0",
"0x0.000002000001FF8002A9AACEA8ABp0",
"0x0.000004000007FF00155155D54557p0",
"0x0.000006000011FE8047F701A3CA09p0",
"0x0.00000800001FFE00AA9AAF2A2ACAp0",
"0x0.00000A000031FD814D3C5FB85BACp0",
"0x0.00000C000047FD023FDC14FE50CFp0",
"0x0.00000E000061FC839279D10BFE61p0",
"0x0.00001000007FFC055515965158A0p0",
"0x0.0000120000A1FB8797AF679E53E2p0",
"0x0.0000140000C7FB0A6A474822E493p0",
"0x0.0000160000F1FA8DDCDD3B6EFF3Cp0",
"0x0.00001800011FFA11FF7145729881p0",
"0x0.00001A000151F996E2036A7DA52Ap0",
"0x0.00001C000187F91C9493AF401A22p0",
"0x0.00001E0001C1F8A3272218C9EC79p0",
"0x0.0000200001FFF82AA9AEAC8B116Dp0",
"0x0.000022000241F7B32C3970537E65p0",
"0x0.000024000287F73CBEC26A5328FAp0",
"0x0.0000260002D1F6C77149A11A06F8p0",
"0x0.00002800031FF65353CF1B980E61p0",
"0x0.00002A000371F5E07652E11D3570p0",
"0x0.00002C0003C7F56EE8D4F959729Ap0",
"0x0.00002E000421F4FEBB556C5CBC97p0",
"0x0.00003000047FF48FFDD442970A5Dp0",
"0x0.0000320004E1F422C05184D8532Ap0",
"0x0.000034000547F3B712CD3C508E82p0",
"0x0.0000360005B1F34D0547728FB434p0",
"0x0.00003800061FF2E4A7C03185BC5Fp0",
"0x0.00003A000691F27E0A3783829F71p0",
"0x0.00003C000707F2193CAD7336562Dp0",
"0x0.00003E000781F1B64F220BB0D9ADp0",
"0x0.0000400007FFF155519558622364p0",
"0x0.000042000881F0F65407651A2D24p0",
"0x0.000044000907F09966783E08F11Cp0",
"0x0.000046000991F03E98E7EFBE69E0p0",
"0x0.000048000A1FEFE5FB56872A926Bp0",
"0x0.00004A000AB1EF8F9DC4119D661Ep0",
"0x0.00004C000B47EF3B90309CC6E0CAp0",
"0x0.00004E000BE1EEE9E29C36B6FEAAp0",
"0x0.000050000C7FEE9AA506EDDDBC70p0",
"0x0.000052000D21EE4DE770D10B1740p0",
"0x0.000054000DC7EE03B9D9EF6F0CB6p0",
"0x0.000056000E71EDBC2C4258999AEAp0",
"0x0.000058000F1FED774EAA1C7AC072p0",
"0x0.00005A000FD1ED3531114B627C64p0",
"0x0.00005C001087ECF5E377F600CE5Cp0",
"0x0.00005E001141ECB975DE2D65B67Bp0",
"0x0.0000600011FFEC7FF8440301356Dp0",
"0x0.0000620012C1EC497AA988A34C6Ap0",
"0x0.000064001387EC160D0ED07BFD3Cp0",
"0x0.000066001451EBE5BF73ED1B4A3Dp0",
"0x0.00006800151FEBB8A1D8F1713660p0",
"0x0.00006A0015F1EB8EC43DF0CDC52Fp0",
"0x0.00006C0016C7EB6836A2FEE0FAD1p0",
"0x0.00006E0017A1EB4509082FBADC0Cp0",
"0x0.00007000187FEB254B6D97CB6E48p0",
"0x0.000072001961EB090DD34BE2B790p0",
"0x0.000074001A47EAF060396130BE9Bp0",
"0x0.000076001B31EADB529FED458AC7p0",
"0x0.000078001C1FEAC9F50706112422p0",
"0x0.00007A001D11EABC576EC1E3936Cp0",
"0x0.00007C001E07EAB289D7376CE216p0",
"0x0.00007E001F01EAAC9C407DBD1A4Bp0",
};





template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>::array [64] = {

"0x0",
"0x0.000000100000007FFF0005554555p0",
"0x0.00000020000001FFFE002AAA6AAEp0",
"0x0.000000300000047FFD008FFF7014p0",
"0x0.00000040000007FFFC0155545595p0",
"0x0.0000005000000C7FFB029AA91B47p0",
"0x0.00000060000011FFFA047FFDC144p0",
"0x0.000000700000187FF907255247AEp0",
"0x0.0000008000001FFFF80AAAA6AEABp0",
"0x0.000000900000287FF70F2FFAF668p0",
"0x0.000000A0000031FFF614D54F1F19p0",
"0x0.000000B000003C7FF51BBAA328F7p0",
"0x0.000000C0000047FFF423FFF71440p0",
"0x0.000000D00000547FF32DC54AE13Ap0",
"0x0.000000E0000061FFF2392A9E902Fp0",
"0x0.000000F00000707FF1464FF22171p0",
"0x0.0000010000007FFFF05555459556p0",
"0x0.000001100000907FEF665A98EC3Bp0",
"0x0.000001200000A1FFEE797FEC2685p0",
"0x0.000001300000B47FED8EE53F449Ap0",
"0x0.000001400000C7FFECA6AA9246EBp0",
"0x0.000001500000DC7FEBC0EFE52DEDp0",
"0x0.000001600000F1FFEADDD537FA1Ap0",
"0x0.000001700001087FE9FD7A8AABF4p0",
"0x0.0000018000011FFFE91FFFDD4401p0",
"0x0.000001900001387FE845852FC2CEp0",
"0x0.000001A0000151FFE76E2A8228F0p0",
"0x0.000001B000016C7FE69A0FD476FDp0",
"0x0.000001C0000187FFE5C95526AD96p0",
"0x0.000001D00001A47FE4FC1A78CD60p0",
"0x0.000001E00001C1FFE4327FCAD705p0",
"0x0.000001F00001E07FE36CA51CCB37p0",
"0x0.000002000001FFFFE2AAAA6EAAACp0",
"0x0.000002100002207FE1ECAFC07621p0",
"0x0.00000220000241FFE132D5122E5Ap0",
"0x0.000002300002647FE07D3A63D420p0",
"0x0.00000240000287FFDFCBFFB56841p0",
"0x0.000002500002AC7FDF1F4506EB93p0",
"0x0.000002600002D1FFDE772A585EF0p0",
"0x0.000002700002F87FDDD3CFA9C339p0",
"0x0.0000028000031FFFDD3554FB1956p0",
"0x0.000002900003487FDC9BDA4C6234p0",
"0x0.000002A0000371FFDC077F9D9EC5p0",
"0x0.000002B000039C7FDB7864EED003p0",
"0x0.000002C00003C7FFDAEEAA3FF6ECp0",
"0x0.000002D00003F47FDA6A6F911485p0",
"0x0.000002E0000421FFD9EBD4E229DAp0",
"0x0.000002F00004507FD972FA3337FCp0",
"0x0.0000030000047FFFD8FFFF844001p0",
"0x0.000003100004B07FD89304D54307p0",
"0x0.000003200004E1FFD82C2A264230p0",
"0x0.000003300005147FD7CB8F773EA5p0",
"0x0.00000340000547FFD77154C83996p0",
"0x0.0000035000057C7FD71D9A193438p0",
"0x0.000003600005B1FFD6D07F6A2FC5p0",
"0x0.000003700005E87FD68A24BB2D7Ep0",
"0x0.0000038000061FFFD64AAA0C2EABp0",
"0x0.000003900006587FD6122F5D3499p0",
"0x0.000003A0000691FFD5E0D4AE409Ap0",
"0x0.000003B00006CC7FD5B6B9FF5408p0",
"0x0.000003C0000707FFD593FF507041p0",
"0x0.000003D00007447FD578C4A196AAp0",
"0x0.000003E0000781FFD56529F2C8AFp0",
"0x0.000003F00007C07FD5594F4407C1p0",
};





template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>::array [64] = {

"0x0",
"0x0.00000000800000001FFFFE000AAAp0",
"0x0.00000001000000007FFFFC005555p0",
"0x0.00000001800000011FFFFA011FFFp0",
"0x0.0000000200000001FFFFF802AAAAp0",
"0x0.00000002800000031FFFF6053555p0",
"0x0.00000003000000047FFFF408FFFFp0",
"0x0.00000003800000061FFFF20E4AAAp0",
"0x0.0000000400000007FFFFF0155555p0",
"0x0.000000048000000A1FFFEE1E5FFFp0",
"0x0.000000050000000C7FFFEC29AAAAp0",
"0x0.000000058000000F1FFFEA377554p0",
"0x0.0000000600000011FFFFE847FFFFp0",
"0x0.00000006800000151FFFE65B8AAAp0",
"0x0.00000007000000187FFFE4725554p0",
"0x0.000000078000001C1FFFE28C9FFFp0",
"0x0.000000080000001FFFFFE0AAAAA9p0",
"0x0.00000008800000241FFFDECCB554p0",
"0x0.00000009000000287FFFDCF2FFFEp0",
"0x0.000000098000002D1FFFDB1DCAA9p0",
"0x0.0000000A00000031FFFFD94D5553p0",
"0x0.0000000A800000371FFFD781DFFEp0",
"0x0.0000000B0000003C7FFFD5BBAAA8p0",
"0x0.0000000B800000421FFFD3FAF553p0",
"0x0.0000000C00000047FFFFD23FFFFDp0",
"0x0.0000000C8000004E1FFFD08B0AA8p0",
"0x0.0000000D000000547FFFCEDC5552p0",
"0x0.0000000D8000005B1FFFCD341FFDp0",
"0x0.0000000E00000061FFFFCB92AAA7p0",
"0x0.0000000E800000691FFFC9F83552p0",
"0x0.0000000F000000707FFFC864FFFCp0",
"0x0.0000000F800000781FFFC6D94AA7p0",
"0x0.000000100000007FFFFFC5555551p0",
"0x0.00000010800000881FFFC3D95FFCp0",
"0x0.00000011000000907FFFC265AAA6p0",
"0x0.00000011800000991FFFC0FA7550p0",
"0x0.00000012000000A1FFFFBF97FFFBp0",
"0x0.00000012800000AB1FFFBE3E8AA5p0",
"0x0.00000013000000B47FFFBCEE5550p0",
"0x0.00000013800000BE1FFFBBA79FFAp0",
"0x0.00000014000000C7FFFFBA6AAAA5p0",
"0x0.00000014800000D21FFFB937B54Fp0",
"0x0.00000015000000DC7FFFB80EFFF9p0",
"0x0.00000015800000E71FFFB6F0CAA4p0",
"0x0.00000016000000F1FFFFB5DD554Ep0",
"0x0.00000016800000FD1FFFB4D4DFF9p0",
"0x0.00000017000001087FFFB3D7AAA3p0",
"0x0.00000017800001141FFFB2E5F54Dp0",
"0x0.000000180000011FFFFFB1FFFFF8p0",
"0x0.000000188000012C1FFFB1260AA2p0",
"0x0.00000019000001387FFFB058554Dp0",
"0x0.00000019800001451FFFAF971FF7p0",
"0x0.0000001A00000151FFFFAEE2AAA1p0",
"0x0.0000001A8000015F1FFFAE3B354Cp0",
"0x0.0000001B0000016C7FFFADA0FFF6p0",
"0x0.0000001B8000017A1FFFAD144AA1p0",
"0x0.0000001C00000187FFFFAC95554Bp0",
"0x0.0000001C800001961FFFAC245FF5p0",
"0x0.0000001D000001A47FFFABC1AAA0p0",
"0x0.0000001D800001B31FFFAB6D754Ap0",
"0x0.0000001E000001C1FFFFAB27FFF5p0",
"0x0.0000001E800001D11FFFAAF18A9Fp0",
"0x0.0000001F000001E07FFFAACA5549p0",
"0x0.0000001F800001F01FFFAAB29FF4p0",
};





template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>::array [64] = {

"0x0",
"0x0.00000000040000000007FFFFFC00p0",
"0x0.0000000008000000001FFFFFF800p0",
"0x0.000000000C0000000047FFFFF402p0",
"0x0.0000000010000000007FFFFFF005p0",
"0x0.000000001400000000C7FFFFEC0Ap0",
"0x0.0000000018000000011FFFFFE811p0",
"0x0.000000001C0000000187FFFFE41Cp0",
"0x0.000000002000000001FFFFFFE02Ap0",
"0x0.00000000240000000287FFFFDC3Cp0",
"0x0.0000000028000000031FFFFFD853p0",
"0x0.000000002C00000003C7FFFFD46Ep0",
"0x0.0000000030000000047FFFFFD08Fp0",
"0x0.00000000340000000547FFFFCCB7p0",
"0x0.0000000038000000061FFFFFC8E4p0",
"0x0.000000003C0000000707FFFFC519p0",
"0x0.000000004000000007FFFFFFC155p0",
"0x0.00000000440000000907FFFFBD99p0",
"0x0.00000000480000000A1FFFFFB9E5p0",
"0x0.000000004C0000000B47FFFFB63Bp0",
"0x0.00000000500000000C7FFFFFB29Ap0",
"0x0.00000000540000000DC7FFFFAF03p0",
"0x0.00000000580000000F1FFFFFAB77p0",
"0x0.000000005C0000001087FFFFA7F5p0",
"0x0.000000006000000011FFFFFFA47Fp0",
"0x0.00000000640000001387FFFFA116p0",
"0x0.0000000068000000151FFFFF9DB8p0",
"0x0.000000006C00000016C7FFFF9A68p0",
"0x0.0000000070000000187FFFFF9725p0",
"0x0.00000000740000001A47FFFF93F0p0",
"0x0.00000000780000001C1FFFFF90C9p0",
"0x0.000000007C0000001E07FFFF8DB2p0",
"0x0.00000000800000001FFFFFFF8AAAp0",
"0x0.00000000840000002207FFFF87B2p0",
"0x0.0000000088000000241FFFFF84CBp0",
"0x0.000000008C0000002647FFFF81F4p0",
"0x0.0000000090000000287FFFFF7F2Fp0",
"0x0.00000000940000002AC7FFFF7C7Dp0",
"0x0.00000000980000002D1FFFFF79DCp0",
"0x0.000000009C0000002F87FFFF774Fp0",
"0x0.00000000A000000031FFFFFF74D5p0",
"0x0.00000000A40000003487FFFF726Fp0",
"0x0.00000000A8000000371FFFFF701Dp0",
"0x0.00000000AC00000039C7FFFF6DE1p0",
"0x0.00000000B00000003C7FFFFF6BBAp0",
"0x0.00000000B40000003F47FFFF69A9p0",
"0x0.00000000B8000000421FFFFF67AFp0",
"0x0.00000000BC0000004507FFFF65CBp0",
"0x0.00000000C000000047FFFFFF63FFp0",
"0x0.00000000C40000004B07FFFF624Cp0",
"0x0.00000000C80000004E1FFFFF60B0p0",
"0x0.00000000CC0000005147FFFF5F2Ep0",
"0x0.00000000D0000000547FFFFF5DC5p0",
"0x0.00000000D400000057C7FFFF5C76p0",
"0x0.00000000D80000005B1FFFFF5B41p0",
"0x0.00000000DC0000005E87FFFF5A28p0",
"0x0.00000000E000000061FFFFFF592Ap0",
"0x0.00000000E40000006587FFFF5848p0",
"0x0.00000000E8000000691FFFFF5783p0",
"0x0.00000000EC0000006CC7FFFF56DAp0",
"0x0.00000000F0000000707FFFFF564Fp0",
"0x0.00000000F40000007447FFFF55E3p0",
"0x0.00000000F8000000781FFFFF5594p0",
"0x0.00000000FC0000007C07FFFF5565p0",
};



template <typename T, typename T2, int p, int alpha, int size> class log0_lut_table {};
#821 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_tables.h"
template <> class log0_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64> { public:
log0_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>();
static const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>::array [64] = {
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"0x0.079CCEC24p0",
"0x0.079CCEC24p0",
"0x0.1001B8B2Fp0",
"0x0.1001B8B2Fp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.21AB3D01Ap0",
"0x0.21AB3D01Ap0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5F6808ECBp0",
"0x0.5F6808ECBp0",
"-0x0.4C276AEE2p0",
"-0x0.4C276AEE2p0",
"-0x0.462152B15p0",
"-0x0.462152B15p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.3328953C8p0",
"-0x0.3328953C8p0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
};



template <> class log0_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64> { public:
log0_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>::array [64] = {
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"0x0.079CCDC24CE109p0",
"0x0.079CCDC24CE109p0",
"0x0.1001B7B2F778EDp0",
"0x0.1001B7B2F778EDp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.21AB3C01A907DFp0",
"0x0.21AB3C01A907DFp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5F6807ECB99357p0",
"0x0.5F6807ECB99357p0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.462153B1555950p0",
"-0x0.462153B1555950p0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.3328963C8F6E81p0",
"-0x0.3328963C8F6E81p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
};



template <> class log0_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64> { public:
log0_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>::array [64] = {
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5F6807EC798353076AE126693CACp0",
"0x0.5F6807EC798353076AE126693CACp0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
};
#1065 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_tables.h"
template <int p, int alpha, int size> class log_inverse_lut_table {};
template <> class log_inverse_lut_table<0,5,64> { public:
log_inverse_lut_table<0,5,64>();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> log_inverse_lut_table<0,5,64>::array [64] = {
"0x1",
"0x1",
"0x1",
"0x0.F8p0",
"0x0.F8p0",
"0x0.F0p0",
"0x0.F0p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E0p0",
"0x0.E0p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B0p0",
"0x0.B0p0",
"0x1.58p0",
"0x1.58p0",
"0x1.50p0",
"0x1.50p0",
"0x1.48p0",
"0x1.48p0",
"0x1.48p0",
"0x1.40p0",
"0x1.40p0",
"0x1.40p0",
"0x1.38p0",
"0x1.38p0",
"0x1.30p0",
"0x1.30p0",
"0x1.30p0",
"0x1.28p0",
"0x1.28p0",
"0x1.28p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.18p0",
"0x1.18p0",
"0x1.18p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.08p0",
"0x1.08p0",
"0x1.08p0",
};

}
#41 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_.h" 2

template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{

    const int T1size = 1 << alpha;




    ap_ufixed<alpha, -p> a = zN;
    ap_ufixed<size-alpha, -p-alpha> b = zN;
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN;
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1;
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}




const int p0 = 0;
const int alpha0 = 5;
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2);
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template<typename T>
class log_traits {};

template <> class log_traits<half>
{
public:
    const static int we = fp_struct<half>::EXP_BITS;
    const static int wf = 15;
    const static int org_wf = fp_struct<half>::SIG_BITS;

    const static int gbits = 0;
    const static int MaxPrecision = p3+wf+1+gbits;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we> LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p3, -p3> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;
        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }
};
template <> class log_traits<float>
{
public:
    const static int we = fp_struct<float>::EXP_BITS;
    const static int wf = 31;
    const static int org_wf = fp_struct<float>::SIG_BITS;

    const static int gbits = 0;
    const static int MaxPrecision = p4+wf+1+gbits;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we> LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p4, -p4> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;
        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        return z4;
    }
};

template <> class log_traits<double>
{
public:
    const static int we = fp_struct<double>::EXP_BITS;
    const static int wf = 52;
    const static int org_wf = fp_struct<double>::SIG_BITS;

    const static int gbits = 0;
    const static int MaxPrecision = p8+wf+1+gbits;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we> LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p8, -p8> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < MaxPrecision-p8) ? w8 : (MaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }
};

template<typename T>
T log_generic(T base)
{
#pragma HLS pipeline

 fp_struct<T> bs(base);
        const static int we = log_traits<T>::we;
        const static int wf = log_traits<T>::wf;
        const static int org_wf = log_traits<T>::org_wf;

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();





    bool x_is_0 = 0;
    bool x_is_NaN = 0;
    bool x_is_neg = 0;
    bool x_is_inf = 0;


    if (bs.exp == 0)



                                x_is_0 = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;
    if (bs.sign[0]==1) x_is_neg = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    if ( x_is_0 ) {

        out.sign[0] = 1;

        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if ( x_is_NaN | x_is_neg ) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if ( x_is_inf ) {



        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }


        const static int bypass_threshold = wf/2;
        const static int MaxPrecision = log_traits<T>::MaxPrecision;
        typedef typename log_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;
 LOG_TYPE log_base;



    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
#281 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_.h"
    int FirstBit = nbs.sig[org_wf-1];


    b_frac[b_frac.wl()-b_frac.iwl()] = 1;
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));


    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }


    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692929317548838826088;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0);





 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];



        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;


        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_log_.h", 317, __PRETTY_FUNCTION__));

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1;

    ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
        zk = log_traits<T>::range_reduction(z1,log_sum);

    ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);


    log_base = Elog2 + log_sum + sum;





 out.sign[0] = log_base[log_base.wl()-1];
 if (log_base[log_base.wl()-1]) {
     log_base = - log_base;
 }

 int r_exp = 0;
 int pone;
#pragma unroll
 for (pone = we-1; pone > -MaxPrecision+1; pone--) {
     if ( log_base[pone+MaxPrecision] == 1 ) {
  r_exp = pone;
  break;
     }
 }

 if ( r_exp != pone ) {

     out.sign[0] = 0;

     out.exp = 0;
     return out.to_ieee();
 }

        ap_fixed<1 + MaxPrecision+org_wf, 1> delta = 0;
        delta[delta.wl()-1] = log_base[log_base.wl()-1];
        delta[delta.wl()-2] = 1;
        ap_fixed<1 + we + MaxPrecision+org_wf, 1 + we> log_base_l = log_base + (delta >> (org_wf-r_exp));

 if ( log_base_l[r_exp+1+MaxPrecision+org_wf] == 1 ) {
     r_exp++;
 }

        out.exp = fp_struct<T>::EXP_BIAS+r_exp;
 out.sig(org_wf-1,0) = log_base_l ( r_exp+MaxPrecision+org_wf-1 , r_exp+MaxPrecision );
 return out.to_ieee();

}

static half log(half base)
{
 return log_generic(base);
}
static float log(float base)
{
 return log_generic(base);
}
static double log(double base)
{
 return log_generic(base);
}

static float logf(float base)
{
 return log_generic(base);
}

static half half_log(half base)
{
 return log_generic(base);
}


static half log2(half base)
{
        return log_generic(base) * static_cast<half>(1.4426950408889634073599246810019);
}
static float log2(float base)
{
        return xil_fpo_mul_flt(log_generic(base),1.4426950408889634073599246810019f);
}
static double log2(double base)
{
        return xil_fpo_mul_d(log_generic(base),1.4426950408889634073599246810019);
}

static float log2f(float base)
{
        return xil_fpo_mul_flt(log_generic(base),1.4426950408889634073599246810019f);
}

static half half_log2(half base)
{
        return log_generic(base) * static_cast<half>(1.4426950408889634073599246810019);
}


static half log10(half base)
{
        return log_generic(base) * static_cast<half>(0.43429448190325182765112891891661);
}
static float log10(float base)
{
        return xil_fpo_mul_flt(log_generic(base),0.43429448190325182765112891891661f);
}
static double log10(double base)
{
        return xil_fpo_mul_d(log_generic(base),0.43429448190325182765112891891661);
}

static float log10f(float base)
{
        return xil_fpo_mul_flt(log_generic(base),0.43429448190325182765112891891661f);
}

static half half_log10(half base)
{
        return log_generic(base) * static_cast<half>(0.43429448190325182765112891891661);
}


static half logb(half base)
{
        return log_generic(fabs(base)) * static_cast<half>(1.4426950408889634073599246810019);
}
static float logb(float base)
{
        return xil_fpo_mul_flt(log_generic(fabs(base)),1.4426950408889634073599246810019f);
}
static double logb(double base)
{
        return xil_fpo_mul_d(log_generic(fabs(base)),1.4426950408889634073599246810019);
}

static float logbf(float base)
{
        return xil_fpo_mul_flt(log_generic(fabs(base)),1.4426950408889634073599246810019f);
}

static half half_logb(half base)
{
        return log_generic(fabs(base)) * static_cast<half>(1.4426950408889634073599246810019);
}


static double log1p(double x)
{
        fp_struct<double> xs(x);
 if ( xs.exp == 0 ) return 0;
 if ( xs.sign[0] & ::hls::__isinf(x) ) {
  xs.sig = -1;
  return xs.to_ieee();
 }
 if ( xs.exp == 2047 ) return x;
 ap_uint<2> xexp_h;
 xexp_h(1,0) = xs.exp(10,9);
 if ( xexp_h == 0 ) return x;
 fp_struct<double> ys;
 ys.sign[0] = 0;
 ap_uint<12> yexp = xs.exp;
 yexp <<= 1;
 ap_uint<2> yexp_h;
 yexp_h(1,0) = yexp(11,10);
 yexp_h--;
 yexp(11,10) = yexp_h(1,0);
 ys.exp(10,0) = yexp(10,0);
 ap_ufixed<53,1> xsig;
 xsig[52] = 1;
 xsig(51,0) = xs.sig(51,0);
 ap_ufixed<106,2> ysig = xsig*xsig;
 if ( ysig[105] ) {
  ys.exp++;
  ysig >>= 1;
 }
 ys.sig(51,0) = ysig(103,52);
 if ( xs.exp <= 998 ) return x-ys.to_ieee();
 double xd1p = x + 1;
 return log_generic(xd1p)-((xd1p-1)-x)/xd1p;
}
static float log1p(float x)
{
 fp_struct<float> xs(x);
 if ( xs.exp == 0 ) return 0;
        if ( xs.sign[0] & ::hls::__isinf(x) ) {
                xs.sig = -1;
                return xs.to_ieee();
        }
 if ( xs.exp == 255 ) return x;
 float xf1p = x + 1;
 return log_generic(xf1p)-((xf1p-1)-x)/xf1p;
}
static half log1p(half x)
{
        fp_struct<half> xs(x);
        if ( xs.exp == 0 ) return 0;
 if ( xs.sign[0] == 1 && xs.exp == 15 && xs.sig == 0 ) {
  xs.exp = 31;
  return xs.to_ieee();
 }
        if ( xs.sign[0] & ::hls::__isinf(x) ) {
                xs.sig = -1;
                return xs.to_ieee();
        }
        if ( xs.exp == 31 ) return x;
 float xf1p = x + 1;
        return log_generic(xf1p)-((xf1p-1)-x)/xf1p;
}

}
#293 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h" 1
#37 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
namespace pow_reduce {

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow_tables.h" 1
#32 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow_tables.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_fixed.h" 1
#33 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow_tables.h" 2
namespace {

template <typename T, int p, int alpha, int size> class log_lut_table {};





template <> class log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",
"0x0.03030549D3B2A18BB8123EEF5D29p0",
"0x0.04060E7B3F982465E5AE80179F4Ap0",
"0x0.050A1ED2A137CD8B76C303145D04p0",
"0x0.060F3868C0EF391853C966BD7471p0",
"0x0.07155D5CD81D53619307B8308EB9p0",
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",
"0x0.09A959A26D3862E752AF15528C0Fp0",
"0x0.0AB33774BD9E386027BF3B81173Fp0",
"0x0.0BBE2A841109EFBA651B04210A41p0",
"0x0.0CCA3514F685E5346E87B075E077p0",
"0x0.0DD759732434C1A6FD3C142C43A9p0",
"0x0.0EE599F19585A95D50A830135E93p0",
};


template <> class log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",
"0x0.03030549D3B2A18BB8123EEF5D29p0",
"0x0.04060E7B3F982465E5AE80179F4Ap0",
"0x0.050A1ED2A137CD8B76C303145D04p0",
"0x0.060F3868C0EF391853C966BD7471p0",
"0x0.07155D5CD81D53619307B8308EB9p0",
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",
"0x0.09A959A26D3862E752AF15528C0Fp0",
"0x0.0AB33774BD9E386027BF3B81173Fp0",
"0x0.0BBE2A841109EFBA651B04210A41p0",
"0x0.0CCA3514F685E5346E87B075E077p0",
"0x0.0DD759732434C1A6FD3C142C43A9p0",
"0x0.0EE599F19585A95D50A830135E93p0",
};


template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",
"0x0.03030549D3B2A18BB8123EEF5D29p0",
"0x0.04060E7B3F982465E5AE80179F4Ap0",
"0x0.050A1ED2A137CD8B76C303145D04p0",
"0x0.060F3868C0EF391853C966BD7471p0",
"0x0.07155D5CD81D53619307B8308EB9p0",
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",
"0x0.09A959A26D3862E752AF15528C0Fp0",
"0x0.0AB33774BD9E386027BF3B81173Fp0",
"0x0.0BBE2A841109EFBA651B04210A41p0",
"0x0.0CCA3514F685E5346E87B075E077p0",
"0x0.0DD759732434C1A6FD3C142C43A9p0",
"0x0.0EE599F19585A95D50A830135E93p0",
};





template <> class log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {

"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};


template <> class log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {

"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};


template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {

"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};





template <> class log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {

"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};


template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {

"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};





template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>::array [64] = {

"0x0",
"0x0.000002000001FF8002A9AACEA8ABp0",
"0x0.000004000007FF00155155D54557p0",
"0x0.000006000011FE8047F701A3CA09p0",
"0x0.00000800001FFE00AA9AAF2A2ACAp0",
"0x0.00000A000031FD814D3C5FB85BACp0",
"0x0.00000C000047FD023FDC14FE50CFp0",
"0x0.00000E000061FC839279D10BFE61p0",
"0x0.00001000007FFC055515965158A0p0",
"0x0.0000120000A1FB8797AF679E53E2p0",
"0x0.0000140000C7FB0A6A474822E493p0",
"0x0.0000160000F1FA8DDCDD3B6EFF3Cp0",
"0x0.00001800011FFA11FF7145729881p0",
"0x0.00001A000151F996E2036A7DA52Ap0",
"0x0.00001C000187F91C9493AF401A22p0",
"0x0.00001E0001C1F8A3272218C9EC79p0",
"0x0.0000200001FFF82AA9AEAC8B116Dp0",
"0x0.000022000241F7B32C3970537E65p0",
"0x0.000024000287F73CBEC26A5328FAp0",
"0x0.0000260002D1F6C77149A11A06F8p0",
"0x0.00002800031FF65353CF1B980E61p0",
"0x0.00002A000371F5E07652E11D3570p0",
"0x0.00002C0003C7F56EE8D4F959729Ap0",
"0x0.00002E000421F4FEBB556C5CBC97p0",
"0x0.00003000047FF48FFDD442970A5Dp0",
"0x0.0000320004E1F422C05184D8532Ap0",
"0x0.000034000547F3B712CD3C508E82p0",
"0x0.0000360005B1F34D0547728FB434p0",
"0x0.00003800061FF2E4A7C03185BC5Fp0",
"0x0.00003A000691F27E0A3783829F71p0",
"0x0.00003C000707F2193CAD7336562Dp0",
"0x0.00003E000781F1B64F220BB0D9ADp0",
"0x0.0000400007FFF155519558622364p0",
"0x0.000042000881F0F65407651A2D24p0",
"0x0.000044000907F09966783E08F11Cp0",
"0x0.000046000991F03E98E7EFBE69E0p0",
"0x0.000048000A1FEFE5FB56872A926Bp0",
"0x0.00004A000AB1EF8F9DC4119D661Ep0",
"0x0.00004C000B47EF3B90309CC6E0CAp0",
"0x0.00004E000BE1EEE9E29C36B6FEAAp0",
"0x0.000050000C7FEE9AA506EDDDBC70p0",
"0x0.000052000D21EE4DE770D10B1740p0",
"0x0.000054000DC7EE03B9D9EF6F0CB6p0",
"0x0.000056000E71EDBC2C4258999AEAp0",
"0x0.000058000F1FED774EAA1C7AC072p0",
"0x0.00005A000FD1ED3531114B627C64p0",
"0x0.00005C001087ECF5E377F600CE5Cp0",
"0x0.00005E001141ECB975DE2D65B67Bp0",
"0x0.0000600011FFEC7FF8440301356Dp0",
"0x0.0000620012C1EC497AA988A34C6Ap0",
"0x0.000064001387EC160D0ED07BFD3Cp0",
"0x0.000066001451EBE5BF73ED1B4A3Dp0",
"0x0.00006800151FEBB8A1D8F1713660p0",
"0x0.00006A0015F1EB8EC43DF0CDC52Fp0",
"0x0.00006C0016C7EB6836A2FEE0FAD1p0",
"0x0.00006E0017A1EB4509082FBADC0Cp0",
"0x0.00007000187FEB254B6D97CB6E48p0",
"0x0.000072001961EB090DD34BE2B790p0",
"0x0.000074001A47EAF060396130BE9Bp0",
"0x0.000076001B31EADB529FED458AC7p0",
"0x0.000078001C1FEAC9F50706112422p0",
"0x0.00007A001D11EABC576EC1E3936Cp0",
"0x0.00007C001E07EAB289D7376CE216p0",
"0x0.00007E001F01EAAC9C407DBD1A4Bp0",
};





template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>::array [64] = {

"0x0",
"0x0.000000100000007FFF0005554555p0",
"0x0.00000020000001FFFE002AAA6AAEp0",
"0x0.000000300000047FFD008FFF7014p0",
"0x0.00000040000007FFFC0155545595p0",
"0x0.0000005000000C7FFB029AA91B47p0",
"0x0.00000060000011FFFA047FFDC144p0",
"0x0.000000700000187FF907255247AEp0",
"0x0.0000008000001FFFF80AAAA6AEABp0",
"0x0.000000900000287FF70F2FFAF668p0",
"0x0.000000A0000031FFF614D54F1F19p0",
"0x0.000000B000003C7FF51BBAA328F7p0",
"0x0.000000C0000047FFF423FFF71440p0",
"0x0.000000D00000547FF32DC54AE13Ap0",
"0x0.000000E0000061FFF2392A9E902Fp0",
"0x0.000000F00000707FF1464FF22171p0",
"0x0.0000010000007FFFF05555459556p0",
"0x0.000001100000907FEF665A98EC3Bp0",
"0x0.000001200000A1FFEE797FEC2685p0",
"0x0.000001300000B47FED8EE53F449Ap0",
"0x0.000001400000C7FFECA6AA9246EBp0",
"0x0.000001500000DC7FEBC0EFE52DEDp0",
"0x0.000001600000F1FFEADDD537FA1Ap0",
"0x0.000001700001087FE9FD7A8AABF4p0",
"0x0.0000018000011FFFE91FFFDD4401p0",
"0x0.000001900001387FE845852FC2CEp0",
"0x0.000001A0000151FFE76E2A8228F0p0",
"0x0.000001B000016C7FE69A0FD476FDp0",
"0x0.000001C0000187FFE5C95526AD96p0",
"0x0.000001D00001A47FE4FC1A78CD60p0",
"0x0.000001E00001C1FFE4327FCAD705p0",
"0x0.000001F00001E07FE36CA51CCB37p0",
"0x0.000002000001FFFFE2AAAA6EAAACp0",
"0x0.000002100002207FE1ECAFC07621p0",
"0x0.00000220000241FFE132D5122E5Ap0",
"0x0.000002300002647FE07D3A63D420p0",
"0x0.00000240000287FFDFCBFFB56841p0",
"0x0.000002500002AC7FDF1F4506EB93p0",
"0x0.000002600002D1FFDE772A585EF0p0",
"0x0.000002700002F87FDDD3CFA9C339p0",
"0x0.0000028000031FFFDD3554FB1956p0",
"0x0.000002900003487FDC9BDA4C6234p0",
"0x0.000002A0000371FFDC077F9D9EC5p0",
"0x0.000002B000039C7FDB7864EED003p0",
"0x0.000002C00003C7FFDAEEAA3FF6ECp0",
"0x0.000002D00003F47FDA6A6F911485p0",
"0x0.000002E0000421FFD9EBD4E229DAp0",
"0x0.000002F00004507FD972FA3337FCp0",
"0x0.0000030000047FFFD8FFFF844001p0",
"0x0.000003100004B07FD89304D54307p0",
"0x0.000003200004E1FFD82C2A264230p0",
"0x0.000003300005147FD7CB8F773EA5p0",
"0x0.00000340000547FFD77154C83996p0",
"0x0.0000035000057C7FD71D9A193438p0",
"0x0.000003600005B1FFD6D07F6A2FC5p0",
"0x0.000003700005E87FD68A24BB2D7Ep0",
"0x0.0000038000061FFFD64AAA0C2EABp0",
"0x0.000003900006587FD6122F5D3499p0",
"0x0.000003A0000691FFD5E0D4AE409Ap0",
"0x0.000003B00006CC7FD5B6B9FF5408p0",
"0x0.000003C0000707FFD593FF507041p0",
"0x0.000003D00007447FD578C4A196AAp0",
"0x0.000003E0000781FFD56529F2C8AFp0",
"0x0.000003F00007C07FD5594F4407C1p0",
};





template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>::array [64] = {

"0x0",
"0x0.00000000800000001FFFFE000AAAp0",
"0x0.00000001000000007FFFFC005555p0",
"0x0.00000001800000011FFFFA011FFFp0",
"0x0.0000000200000001FFFFF802AAAAp0",
"0x0.00000002800000031FFFF6053555p0",
"0x0.00000003000000047FFFF408FFFFp0",
"0x0.00000003800000061FFFF20E4AAAp0",
"0x0.0000000400000007FFFFF0155555p0",
"0x0.000000048000000A1FFFEE1E5FFFp0",
"0x0.000000050000000C7FFFEC29AAAAp0",
"0x0.000000058000000F1FFFEA377554p0",
"0x0.0000000600000011FFFFE847FFFFp0",
"0x0.00000006800000151FFFE65B8AAAp0",
"0x0.00000007000000187FFFE4725554p0",
"0x0.000000078000001C1FFFE28C9FFFp0",
"0x0.000000080000001FFFFFE0AAAAA9p0",
"0x0.00000008800000241FFFDECCB554p0",
"0x0.00000009000000287FFFDCF2FFFEp0",
"0x0.000000098000002D1FFFDB1DCAA9p0",
"0x0.0000000A00000031FFFFD94D5553p0",
"0x0.0000000A800000371FFFD781DFFEp0",
"0x0.0000000B0000003C7FFFD5BBAAA8p0",
"0x0.0000000B800000421FFFD3FAF553p0",
"0x0.0000000C00000047FFFFD23FFFFDp0",
"0x0.0000000C8000004E1FFFD08B0AA8p0",
"0x0.0000000D000000547FFFCEDC5552p0",
"0x0.0000000D8000005B1FFFCD341FFDp0",
"0x0.0000000E00000061FFFFCB92AAA7p0",
"0x0.0000000E800000691FFFC9F83552p0",
"0x0.0000000F000000707FFFC864FFFCp0",
"0x0.0000000F800000781FFFC6D94AA7p0",
"0x0.000000100000007FFFFFC5555551p0",
"0x0.00000010800000881FFFC3D95FFCp0",
"0x0.00000011000000907FFFC265AAA6p0",
"0x0.00000011800000991FFFC0FA7550p0",
"0x0.00000012000000A1FFFFBF97FFFBp0",
"0x0.00000012800000AB1FFFBE3E8AA5p0",
"0x0.00000013000000B47FFFBCEE5550p0",
"0x0.00000013800000BE1FFFBBA79FFAp0",
"0x0.00000014000000C7FFFFBA6AAAA5p0",
"0x0.00000014800000D21FFFB937B54Fp0",
"0x0.00000015000000DC7FFFB80EFFF9p0",
"0x0.00000015800000E71FFFB6F0CAA4p0",
"0x0.00000016000000F1FFFFB5DD554Ep0",
"0x0.00000016800000FD1FFFB4D4DFF9p0",
"0x0.00000017000001087FFFB3D7AAA3p0",
"0x0.00000017800001141FFFB2E5F54Dp0",
"0x0.000000180000011FFFFFB1FFFFF8p0",
"0x0.000000188000012C1FFFB1260AA2p0",
"0x0.00000019000001387FFFB058554Dp0",
"0x0.00000019800001451FFFAF971FF7p0",
"0x0.0000001A00000151FFFFAEE2AAA1p0",
"0x0.0000001A8000015F1FFFAE3B354Cp0",
"0x0.0000001B0000016C7FFFADA0FFF6p0",
"0x0.0000001B8000017A1FFFAD144AA1p0",
"0x0.0000001C00000187FFFFAC95554Bp0",
"0x0.0000001C800001961FFFAC245FF5p0",
"0x0.0000001D000001A47FFFABC1AAA0p0",
"0x0.0000001D800001B31FFFAB6D754Ap0",
"0x0.0000001E000001C1FFFFAB27FFF5p0",
"0x0.0000001E800001D11FFFAAF18A9Fp0",
"0x0.0000001F000001E07FFFAACA5549p0",
"0x0.0000001F800001F01FFFAAB29FF4p0",
};





template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>::array [64] = {

"0x0",
"0x0.00000000040000000007FFFFFC00p0",
"0x0.0000000008000000001FFFFFF800p0",
"0x0.000000000C0000000047FFFFF402p0",
"0x0.0000000010000000007FFFFFF005p0",
"0x0.000000001400000000C7FFFFEC0Ap0",
"0x0.0000000018000000011FFFFFE811p0",
"0x0.000000001C0000000187FFFFE41Cp0",
"0x0.000000002000000001FFFFFFE02Ap0",
"0x0.00000000240000000287FFFFDC3Cp0",
"0x0.0000000028000000031FFFFFD853p0",
"0x0.000000002C00000003C7FFFFD46Ep0",
"0x0.0000000030000000047FFFFFD08Fp0",
"0x0.00000000340000000547FFFFCCB7p0",
"0x0.0000000038000000061FFFFFC8E4p0",
"0x0.000000003C0000000707FFFFC519p0",
"0x0.000000004000000007FFFFFFC155p0",
"0x0.00000000440000000907FFFFBD99p0",
"0x0.00000000480000000A1FFFFFB9E5p0",
"0x0.000000004C0000000B47FFFFB63Bp0",
"0x0.00000000500000000C7FFFFFB29Ap0",
"0x0.00000000540000000DC7FFFFAF03p0",
"0x0.00000000580000000F1FFFFFAB77p0",
"0x0.000000005C0000001087FFFFA7F5p0",
"0x0.000000006000000011FFFFFFA47Fp0",
"0x0.00000000640000001387FFFFA116p0",
"0x0.0000000068000000151FFFFF9DB8p0",
"0x0.000000006C00000016C7FFFF9A68p0",
"0x0.0000000070000000187FFFFF9725p0",
"0x0.00000000740000001A47FFFF93F0p0",
"0x0.00000000780000001C1FFFFF90C9p0",
"0x0.000000007C0000001E07FFFF8DB2p0",
"0x0.00000000800000001FFFFFFF8AAAp0",
"0x0.00000000840000002207FFFF87B2p0",
"0x0.0000000088000000241FFFFF84CBp0",
"0x0.000000008C0000002647FFFF81F4p0",
"0x0.0000000090000000287FFFFF7F2Fp0",
"0x0.00000000940000002AC7FFFF7C7Dp0",
"0x0.00000000980000002D1FFFFF79DCp0",
"0x0.000000009C0000002F87FFFF774Fp0",
"0x0.00000000A000000031FFFFFF74D5p0",
"0x0.00000000A40000003487FFFF726Fp0",
"0x0.00000000A8000000371FFFFF701Dp0",
"0x0.00000000AC00000039C7FFFF6DE1p0",
"0x0.00000000B00000003C7FFFFF6BBAp0",
"0x0.00000000B40000003F47FFFF69A9p0",
"0x0.00000000B8000000421FFFFF67AFp0",
"0x0.00000000BC0000004507FFFF65CBp0",
"0x0.00000000C000000047FFFFFF63FFp0",
"0x0.00000000C40000004B07FFFF624Cp0",
"0x0.00000000C80000004E1FFFFF60B0p0",
"0x0.00000000CC0000005147FFFF5F2Ep0",
"0x0.00000000D0000000547FFFFF5DC5p0",
"0x0.00000000D400000057C7FFFF5C76p0",
"0x0.00000000D80000005B1FFFFF5B41p0",
"0x0.00000000DC0000005E87FFFF5A28p0",
"0x0.00000000E000000061FFFFFF592Ap0",
"0x0.00000000E40000006587FFFF5848p0",
"0x0.00000000E8000000691FFFFF5783p0",
"0x0.00000000EC0000006CC7FFFF56DAp0",
"0x0.00000000F0000000707FFFFF564Fp0",
"0x0.00000000F40000007447FFFF55E3p0",
"0x0.00000000F8000000781FFFFF5594p0",
"0x0.00000000FC0000007C07FFFF5565p0",
};



template <typename T, typename T2, int p, int alpha, int size> class log0_lut_table {};
#821 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow_tables.h"
template <> class log0_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64> { public:
log0_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>();
static const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>::array [64] = {
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"0x0.079CCEC24p0",
"0x0.079CCEC24p0",
"0x0.1001B8B2Fp0",
"0x0.1001B8B2Fp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.21AB3D01Ap0",
"0x0.21AB3D01Ap0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5F6808ECBp0",
"0x0.5F6808ECBp0",
"-0x0.4C276AEE2p0",
"-0x0.4C276AEE2p0",
"-0x0.462152B15p0",
"-0x0.462152B15p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.3328953C8p0",
"-0x0.3328953C8p0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
};



template <> class log0_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64> { public:
log0_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>::array [64] = {
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"0x0.079CCDC24CE109p0",
"0x0.079CCDC24CE109p0",
"0x0.1001B7B2F778EDp0",
"0x0.1001B7B2F778EDp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.21AB3C01A907DFp0",
"0x0.21AB3C01A907DFp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5F6807ECB99357p0",
"0x0.5F6807ECB99357p0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.462153B1555950p0",
"-0x0.462153B1555950p0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.3328963C8F6E81p0",
"-0x0.3328963C8F6E81p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
};



template <> class log0_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64> { public:
log0_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>::array [64] = {
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5F6807EC798353076AE126693CACp0",
"0x0.5F6807EC798353076AE126693CACp0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
};
#1065 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow_tables.h"
template <int p, int alpha, int size> class log_inverse_lut_table_pow {};
template <> class log_inverse_lut_table_pow<0,5,64> { public:
log_inverse_lut_table_pow<0,5,64>();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> log_inverse_lut_table_pow<0,5,64>::array [64] = {
"0x1",
"0x1",
"0x1",
"0x0.F8p0",
"0x0.F8p0",
"0x0.F0p0",
"0x0.F0p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E0p0",
"0x0.E0p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B0p0",
"0x0.B0p0",
"0x1.58p0",
"0x1.58p0",
"0x1.50p0",
"0x1.50p0",
"0x1.48p0",
"0x1.48p0",
"0x1.48p0",
"0x1.40p0",
"0x1.40p0",
"0x1.40p0",
"0x1.38p0",
"0x1.38p0",
"0x1.30p0",
"0x1.30p0",
"0x1.30p0",
"0x1.28p0",
"0x1.28p0",
"0x1.28p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.18p0",
"0x1.18p0",
"0x1.18p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.08p0",
"0x1.08p0",
"0x1.08p0",
};


template <typename T> class table_exp_Z1 {};


template <> class table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};


template <> class table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};


template <> class table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x1.000000000000000p0",
"0x1.0100802AB55777Dp0",
"0x1.0202015600445B0p0",
"0x1.0304848362076A0p0",
"0x1.04080AB55DE3917p0",
"0x1.050C94EF7A206DCp0",
"0x1.06122436410DD14p0",
"0x1.0718B98F42084EFp0",
"0x1.08205601127EC98p0",
"0x1.0928FA934EF9093p0",
"0x1.0A32A84E9C1F581p0",
"0x1.0B3D603CA7C3273p0",
"0x1.0C49236829E8BC2p0",
"0x1.0D55F2DCE5D1E96p0",
"0x1.0E63CFA7AB09D17p0",
"0x1.0F72BAD65671B69p0",
"0x1.1082B577D34ED7Dp0",
"0x1.1193C09C1C595C4p0",
"0x1.12A5DD543CCC4DDp0",
"0x1.13B90CB25176A4Cp0",
"0x1.14CD4FC989CD645p0",
"0x1.15E2A7AE28FECA6p0",
"0x1.16F91575870692Fp0",
"0x1.18109A3611C34FBp0",
"0x1.192937074E0CD68p0",
"0x1.1A42ED01D8CBC61p0",
"0x1.1B5DBD3F6812230p0",
"0x1.1C79A8DACC350DEp0",
"0x1.1D96B0EFF0E793Dp0",
"0x1.1EB4D69BDE569A3p0",
"0x1.1FD41AFCBA45E6Ep0",
"0x1.20F47F31C92E464p0",
"0x1.2216045B6F5CCF9p0",
"0x1.2338AB9B3213497p0",
"0x1.245C7613B8A9AF2p0",
"0x1.258164E8CDB0D82p0",
"0x1.26A7793F601642Bp0",
"0x1.27CEB43D844902Fp0",
"0x1.28F7170A755FD75p0",
"0x1.2A20A2CE964063Dp0",
"0x1.2B4B58B372C7950p0",
"0x1.2C7739E3C0F32BDp0",
"0x1.2DA4478B620C73Ep0",
"0x1.2ED282D763D424Dp0",
"0x1.3001ECF601AF700p0",
"0x1.31328716A5D63C2p0",
"0x1.32645269EA828F9p0",
"0x1.339750219B212A8p0",
"0x1.34CB8170B58352Dp0",
"0x1.3600E78B6B11D19p0",
"0x1.373783A7220124Fp0",
"0x1.386F56FA7686E62p0",
"0x1.39A862BD3C1065Fp0",
"0x1.3AE2A8287E7A804p0",
"0x1.3C1E2876834AA7Fp0",
"0x1.3D5AE4E2CAE92C8p0",
"0x1.3E98DEAA11DCBAAp0",
"0x1.3FD8170A520718Bp0",
"0x1.41188F42C3E320Fp0",
"0x1.425A4893DFC3F9Ep0",
"0x1.439D443F5F158EEp0",
"0x1.44E183883D9E498p0",
"0x1.462707B2BAC20DBp0",
"0x1.476DD2045AC678Dp0",
"0x1.48B5E3C3E818667p0",
"0x1.49FF3E397492BACp0",
"0x1.4B49E2AE5AC6746p0",
"0x1.4C95D26D3F44074p0",
"0x1.4DE30EC211E6013p0",
"0x1.4F3198FA0F1CF9Ep0",
"0x1.50817263C13CCF5p0",
"0x1.51D29C4F01CB308p0",
"0x1.5325180CFACF76Cp0",
"0x1.5478E6F02823D02p0",
"0x1.55CE0A4C58C7BB2p0",
"0x1.57248376B033D61p0",
"0x1.587C53C5A7AF027p0",
"0x1.59D57C910FA4DE7p0",
"0x1.5B2FFF3210FD957p0",
"0x1.5C8BDD032E7708Fp0",
"0x1.5DE9176045FF53Bp0",
"0x1.5F47AFA69210A75p0",
"0x1.60A7A734AB0E875p0",
"0x1.6208FF6A88A4614p0",
"0x1.636BB9A9832584Dp0",
"0x1.64CFD75454EE7BFp0",
"0x1.663559CF1BC7C5Ap0",
"0x1.679C427F5A49F39p0",
"0x1.690492CBF9432CFp0",
"0x1.6A6E4C1D491E179p0",
"0x1.6BD96FDD034A27Fp0",
"0x1.6D45FF764BA55B5p0",
"0x1.6EB3FC55B1E75B4p0",
"0x1.702367E9330E0DDp0",
"0x1.719443A03ACB928p0",
"0x1.730690EBA4F5ADFp0",
"0x1.747A513DBEF6A62p0",
"0x1.75EF860A493F8FBp0",
"0x1.776630C678BC0EDp0",
"0x1.78DE52E8F8478BBp0",
"0x1.7A57EDE9EA23DE3p0",
"0x1.7BD30342E9716FBp0",
"0x1.7D4F946F0BA8D6Ap0",
"0x1.7ECDA2EAE215EBFp0",
"0x1.804D30347B545CBp0",
"0x1.81CE3DCB64CDB88p0",
"0x1.8350CD30AC38FF6p0",
"0x1.84D4DFE6E11BAF5p0",
"0x1.865A7772164C541p0",
"0x1.87E19557E3769A2p0",
"0x1.896A3B1F66A0E69p0",
"0x1.8AF46A5145B3750p0",
"0x1.8C802477B000FDCp0",
"0x1.8E0D6B1E5FD0E54p0",
"0x1.8F9C3FD29BEAF6Bp0",
"0x1.912CA4233924AA7p0",
"0x1.92BE99A09BEFFB7p0",
"0x1.945221DCB9EBCBAp0",
"0x1.95E73E6B1B75D9Bp0",
"0x1.977DF0E0DD3E499p0",
"0x1.99163AD4B1DCC13p0",
"0x1.9AB01DDEE3671B6p0",
"0x1.9C4B9B995509B1Fp0",
"0x1.9DE8B59F84A1410p0",
"0x1.9F876D8E8C56650p0",
"0x1.A127C505243AB4Fp0",
"0x1.A2C9BDA3A3E77AAp0",
"0x1.A46D590C041E0A9p0",
"0x0.9B4597E37CB04FFp0",
"0x0.9BE12B381386EBAp0",
"0x0.9C7D5A6DE293099p0",
"0x0.9D1A262119177CBp0",
"0x0.9DB78EEE82D48C8p0",
"0x0.9E55957388A4C0Ep0",
"0x0.9EF43A4E311A4ACp0",
"0x0.9F937E1D211D0B1p0",
"0x0.A033617F9C89377p0",
"0x0.A0D3E51586CE9E3p0",
"0x0.A175097F63908A0p0",
"0x0.A216CF5E5746455p0",
"0x0.A2B9375427DC3EFp0",
"0x0.A35C42033D55D02p0",
"0x0.A3FFF00EA26FA4Ap0",
"0x0.A4A4421A0542C56p0",
"0x0.A54938C9B7E846Bp0",
"0x0.A5EED4C2B11D9A6p0",
"0x0.A69516AA8CE986Cp0",
"0x0.A73BFF278D41C26p0",
"0x0.A7E38EE09AB1365p0",
"0x0.A88BC67D44FEE6Bp0",
"0x0.A934A6A5C3D5825p0",
"0x0.A9DE3002F76B9AEp0",
"0x0.AA88633E692C84Ap0",
"0x0.AB3341024C61E05p0",
"0x0.ABDEC9F97EDDCE4p0",
"0x0.AC8AFECF89A5CC7p0",
"0x0.AD37E030A19E3F4p0",
"0x0.ADE56EC9A836A6Ep0",
"0x0.AE93AB482C16806p0",
"0x0.AF42965A69CAD4Cp0",
"0x0.AFF230AF4C74755p0",
"0x0.B0A27AF66E76E6Dp0",
"0x0.B15375E01A27FC3p0",
"0x0.B205221D4A8020Cp0",
"0x0.B2B7805FABCB532p0",
"0x0.B36A91599C5AD1Dp0",
"0x0.B41E55BE2D37798p0",
"0x0.B4D2CE4122D4D60p0",
"0x0.B587FB96F5C4E71p0",
"0x0.B63DDE74D36C98Bp0",
"0x0.B6F477909EB8F0Cp0",
"0x0.B7ABC7A0F0D4F20p0",
"0x0.B863CF5D19E0354p0",
"0x0.B91C8F7D21A6399p0",
"0x0.B9D608B9C8566BFp0",
"0x0.BA903BCC873CE7Ep0",
"0x0.BB4B296F917BF09p0",
"0x0.BC06D25DD4C6241p0",
"0x0.BCC33752FA19691p0",
"0x0.BD80590B667A97Fp0",
"0x0.BE3E38443BB1DFEp0",
"0x0.BEFCD5BB5907E8Dp0",
"0x0.BFBC322F5C03B26p0",
"0x0.C07C4E5FA129321p0",
"0x0.C13D2B0C44B8AF4p0",
"0x0.C1FEC8F6236EE00p0",
"0x0.C2C128DEDB45C57p0",
"0x0.C3844B88CC364A2p0",
"0x0.C44831B718FAA1Dp0",
"0x0.C50CDC2DA7D16C9p0",
"0x0.C5D24BB123419CAp0",
"0x0.C6988106FADF218p0",
"0x0.C75F7CF56410574p0",
"0x0.C82740435AD43C0p0",
"0x0.C8EFCBB8A2896C2p0",
"0x0.C9B9201DC6B5E5Bp0",
"0x0.CA833E3C1BCF93Ep0",
"0x0.CB4E26DDC005A3Ap0",
"0x0.CC19DACD9C0AA1Dp0",
"0x0.CCE65AD763DF644p0",
"0x0.CDB3A7C7979EBD5p0",
"0x0.CE81C26B8449FC9p0",
"0x0.CF50AB9144963B9p0",
"0x0.D0206407C1BA78Bp0",
"0x0.D0F0EC9EB43E807p0",
"0x0.D1C24626A4CAA61p0",
"0x0.D2947170ECF84C4p0",
"0x0.D3676F4FB8233EDp0",
"0x0.D43B4096043BDE0p0",
"0x0.D50FE617A29A1CBp0",
"0x0.D5E560A938D151Dp0",
"0x0.D6BBB1204184DDBp0",
"0x0.D792D8530D3DA53p0",
"0x0.D86AD718C34061Dp0",
"0x0.D943AE496264C99p0",
"0x0.DA1D5EBDC1ED8D8p0",
"0x0.DAF7E94F9261313p0",
"0x0.DBD34ED95E63BB6p0",
"0x0.DCAF90368B91406p0",
"0x0.DD8CAE435B59485p0",
"0x0.DE6AA9DCEBDB100p0",
"0x0.DF4983E138C2A7Bp0",
"0x0.E0293D2F1C26EE7p0",
"0x0.E109D6A64F686C6p0",
"0x0.E1EB51276C110C3p0",
"0x0.E2CDAD93ECB4B4Ep0",
"0x0.E3B0ECCE2DD2C3Fp0",
"0x0.E4950FB96EB86A9p0",
"0x0.E57A1739D263EC9p0",
"0x0.E66004346068C38p0",
"0x0.E746D78F05D4A68p0",
"0x0.E82E92309615774p0",
"0x0.E9173500CBE0159p0",
"0x0.EA00C0E84A181A3p0",
"0x0.EAEB36D09CB879Ap0",
"0x0.EBD697A439BD105p0",
"0x0.ECC2E44E820D18Cp0",
"0x0.EDB01DBBC2668C3p0",
"0x0.EE9E44D9344A6FEp0",
"0x0.EF8D5A94FEEA0E4p0",
"0x0.F07D5FDE38151E7p0",
"0x0.F16E55A4E528DA0p0",
"0x0.F2603CD9FC00028p0",
"0x0.F353166F63E3D78p0",
"0x0.F446E357F67DFD8p0",
"0x0.F53BA48780CB586p0",
"0x0.F6315AF2C40FD7Bp0",
"0x0.F728078F76CB38Cp0",
"0x0.F81FAB5445AEBC8p0",
"0x0.F9184738D493D4Fp0",
"0x0.FA11DC35BF73C89p0",
"0x0.FB0C6B449B604ECp0",
"0x0.FC07F55FF77D249p0",
"0x0.FD047B835DFA9C5p0",
"0x0.FE01FEAB551127Cp0",
"0x0.FF007FD55FFDDE3p0",
};



template <typename T> class table_f_Z2 {};


template <> class table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [32];};
const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [32] = {
"0x0",
"0x0.0000000p0",
"0x0.0000002p0",
"0x0.0000004p0",
"0x0.0000008p0",
"0x0.000000Cp0",
"0x0.0000012p0",
"0x0.0000018p0",
"0x0.0000020p0",
"0x0.0000028p0",
"0x0.0000032p0",
"0x0.000003Cp0",
"0x0.0000048p0",
"0x0.0000054p0",
"0x0.0000062p0",
"0x0.0000070p0",
"0x0.0000080p0",
"0x0.0000090p0",
"0x0.00000A2p0",
"0x0.00000B4p0",
"0x0.00000C8p0",
"0x0.00000DCp0",
"0x0.00000F2p0",
"0x0.0000108p0",
"0x0.0000120p0",
"0x0.0000138p0",
"0x0.0000152p0",
"0x0.000016Cp0",
"0x0.0000188p0",
"0x0.00001A4p0",
"0x0.00001C2p0",
"0x0.00001E0p0",
};


template <> class table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.0000000080002AAp0",
"0x0.000000020001555p0",
"0x0.000000048004800p0",
"0x0.00000008000AAABp0",
"0x0.0000000C8014D56p0",
"0x0.000000120024003p0",
"0x0.0000001880392B0p0",
"0x0.000000200055560p0",
"0x0.000000288079811p0",
"0x0.0000003200A6AC4p0",
"0x0.0000003C80DDD7Bp0",
"0x0.000000480120036p0",
"0x0.00000054816E2F5p0",
"0x0.0000006201C95B9p0",
"0x0.000000708232883p0",
"0x0.0000008002AAB55p0",
"0x0.000000908332E2Ep0",
"0x0.000000A203CC111p0",
"0x0.000000B484773FEp0",
"0x0.000000C805356F6p0",
"0x0.000000DC86079FAp0",
"0x0.000000F206EED0Cp0",
"0x0.0000010887EC02Ep0",
"0x0.000001200900360p0",
"0x0.000001388A2C6A3p0",
"0x0.000001520B719FBp0",
"0x0.0000016C8CD0D68p0",
"0x0.000001880E4B0EBp0",
"0x0.000001A48FE1487p0",
"0x0.000001C2119483Dp0",
"0x0.000001E09365C0Fp0",
"0x0.000002001556000p0",
"0x0.000002209766410p0",
"0x0.000002421997843p0",
"0x0.000002649BEAC99p0",
"0x0.000002881E61116p0",
"0x0.000002ACA0FB5BBp0",
"0x0.000002D223BAA8Cp0",
"0x0.000002F8A69FF89p0",
"0x0.0000032029AC4B6p0",
"0x0.00000348ACE0A15p0",
"0x0.00000372303DFA8p0",
"0x0.0000039CB3C5572p0",
"0x0.000003C83777B77p0",
"0x0.000003F4BB561B8p0",
"0x0.000004223F61838p0",
"0x0.00000450C39AEFAp0",
"0x0.000004804803602p0",
"0x0.000004B0CC9BD51p0",
"0x0.000004E251654EBp0",
"0x0.00000514D660CD4p0",
"0x0.000005485B8F50Ep0",
"0x0.0000057CE0F1D9Cp0",
"0x0.000005B26689683p0",
"0x0.000005E8EC56FC4p0",
"0x0.00000620725B964p0",
"0x0.00000658F898366p0",
"0x0.000006927F0DDCDp0",
"0x0.000006CD05BD89Ep0",
"0x0.000007088CA83DCp0",
"0x0.0000074513CEF8Ap0",
"0x0.000007829B32BACp0",
"0x0.000007C122D4847p0",
"0x0.00000800AAB555Dp0",
"0x0.0000084132D62F4p0",
"0x0.00000882BB3810Fp0",
"0x0.000008C543DBFB2p0",
"0x0.00000908CCC2EE1p0",
"0x0.0000094D55EDEA1p0",
"0x0.00000992DF5DEF6p0",
"0x0.000009D96913FE3p0",
"0x0.00000A20F31116Fp0",
"0x0.00000A697D5639Cp0",
"0x0.00000AB307E4671p0",
"0x0.00000AFD92BC9F0p0",
"0x0.00000B491DDFE1Fp0",
"0x0.00000B95A94F303p0",
"0x0.00000BE3350B8A0p0",
"0x0.00000C31C115EFBp0",
"0x0.00000C814D6F61Ap0",
"0x0.00000CD1DA18E00p0",
"0x0.00000D2367136B4p0",
"0x0.00000D75F46003Ap0",
"0x0.00000DC981FFA97p0",
"0x0.00000E1E0FF35D1p0",
"0x0.00000E739E3C1ECp0",
"0x0.00000ECA2CDAEEFp0",
"0x0.00000F21BBD0CDFp0",
"0x0.00000F7A4B1EBC0p0",
"0x0.00000FD3DAC5B9Ap0",
"0x0.0000102E6AC6C70p0",
"0x0.00001089FB22E4Ap0",
"0x0.000010E68BDB12Cp0",
"0x0.000011441CF051Dp0",
"0x0.000011A2AE63A21p0",
"0x0.000012024036040p0",
"0x0.00001262D26877Fp0",
"0x0.000012C464FBFE5p0",
"0x0.00001326F7F1976p0",
"0x0.0000138A8B4A43Ap0",
"0x0.000013EF1F07037p0",
"0x0.00001454B328D73p0",
"0x0.000014BB47B0BF4p0",
"0x0.00001522DC9FBC0p0",
"0x0.0000158B71F6CDFp0",
"0x0.000015F507B6F57p0",
"0x0.0000165F9DE132Dp0",
"0x0.000016CB347686Ap0",
"0x0.00001737CB77F14p0",
"0x0.000017A562E6731p0",
"0x0.00001813FAC30C8p0",
"0x0.00001883930EBE1p0",
"0x0.000018F42BCA882p0",
"0x0.00001965C4F76B2p0",
"0x0.000019D85E96678p0",
"0x0.00001A4BF8A87DCp0",
"0x0.00001AC0932EAE5p0",
"0x0.00001B362E29F9Ap0",
"0x0.00001BACC99B602p0",
"0x0.00001C246583E25p0",
"0x0.00001C9D01E480Bp0",
"0x0.00001D169EBE3BAp0",
"0x0.00001D913C1213Ap0",
"0x0.00001E0CD9E1094p0",
"0x0.00001E89782C1CEp0",
"0x0.00001F0716F44F1p0",
"0x0.00001F85B63AA05p0",
"0x0.000020055600111p0",
"0x0.00002085F645A1Dp0",
"0x0.00002107970C531p0",
"0x0.0000218A3855256p0",
"0x0.0000220DDA21194p0",
"0x0.000022927C712F3p0",
"0x0.000023181F4667Ap0",
"0x0.0000239EC2A1C34p0",
"0x0.000024266684427p0",
"0x0.000024AF0AEEE5Cp0",
"0x0.00002538AFE2ADDp0",
"0x0.000025C355609B1p0",
"0x0.0000264EFB69AE1p0",
"0x0.000026DBA1FEE76p0",
"0x0.000027694921479p0",
"0x0.000027F7F0D1CF3p0",
"0x0.0000288799117ECp0",
"0x0.0000291841E156Dp0",
"0x0.000029A9EB42580p0",
"0x0.00002A3C953582Ep0",
"0x0.00002AD03FBBD7Fp0",
"0x0.00002B64EAD657Ep0",
"0x0.00002BFA9686033p0",
"0x0.00002C9142CBDA7p0",
"0x0.00002D28EFA8DE5p0",
"0x0.00002DC19D1E0F5p0",
"0x0.00002E5B4B2C6E1p0",
"0x0.00002EF5F9D4FB3p0",
"0x0.00002F91A918B74p0",
"0x0.0000302E58F8A2Ep0",
"0x0.000030CC0975BECp0",
"0x0.0000316ABA910B6p0",
"0x0.0000320A6C4B897p0",
"0x0.000032AB1EA6398p0",
"0x0.0000334CD1A21C4p0",
"0x0.000033EF8540325p0",
"0x0.0000349339817C5p0",
"0x0.00003537EE66FAEp0",
"0x0.000035DDA3F1AEAp0",
"0x0.000036845A22985p0",
"0x0.0000372C10FAB88p0",
"0x0.000037D4C87B0FDp0",
"0x0.0000387E80A49F0p0",
"0x0.00003929397866Ap0",
"0x0.000039D4F2F7678p0",
"0x0.00003A81AD22A22p0",
"0x0.00003B2F67FB175p0",
"0x0.00003BDE2381C7Bp0",
"0x0.00003C8DDFB7B3Ep0",
"0x0.00003D3E9C9DDCBp0",
"0x0.00003DF05A3542Bp0",
"0x0.00003EA3187EE6Ap0",
"0x0.00003F56D77BC94p0",
"0x0.0000400B972CEB3p0",
"0x0.000040C157934D3p0",
"0x0.0000417818AFEFEp0",
"0x0.0000422FDA83D42p0",
"0x0.000042E89D0FFA8p0",
"0x0.000043A2605563Dp0",
"0x0.0000445D245510Cp0",
"0x0.00004518E910021p0",
"0x0.000045D5AE87387p0",
"0x0.0000469374BBB4Bp0",
"0x0.000047523BAE778p0",
"0x0.00004812036081Ap0",
"0x0.000048D2CBD2D3Dp0",
"0x0.0000499495066EEp0",
"0x0.00004A575EFC538p0",
"0x0.00004B1B29B5827p0",
"0x0.00004BDFF532FC8p0",
"0x0.00004CA5C175C27p0",
"0x0.00004D6C8E7ED50p0",
"0x0.00004E345C4F350p0",
"0x0.00004EFD2AE7E33p0",
"0x0.00004FC6FA49E06p0",
"0x0.00005091CA762D6p0",
"0x0.0000515D9B6DCAFp0",
"0x0.0000522A6D31B9Dp0",
"0x0.000052F83FC2FAFp0",
"0x0.000053C713228EFp0",
"0x0.00005496E75176Dp0",
"0x0.00005567BC50B33p0",
"0x0.000056399221450p0",
"0x0.0000570C68C42D1p0",
"0x0.000057E0403A6C3p0",
"0x0.000058B51885032p0",
"0x0.0000598AF1A4F2Dp0",
"0x0.00005A61CB9B3C1p0",
"0x0.00005B39A668DFAp0",
"0x0.00005C12820EDE8p0",
"0x0.00005CEC5E8E396p0",
"0x0.00005DC73BE7F13p0",
"0x0.00005EA31A1D06Dp0",
"0x0.00005F7FF92E7B1p0",
"0x0.0000605DD91D4EDp0",
"0x0.0000613CB9EA82Ep0",
"0x0.0000621C9B97184p0",
"0x0.000062FD7E240FBp0",
"0x0.000063DF61926A2p0",
"0x0.000064C245E3288p0",
"0x0.000065A62B174B9p0",
"0x0.0000668B112FD45p0",
"0x0.00006770F82DC39p0",
"0x0.00006857E0121A4p0",
"0x0.0000693FC8DDD95p0",
"0x0.00006A28B29201Ap0",
"0x0.00006B129D2F942p0",
"0x0.00006BFD88B791Bp0",
"0x0.00006CE9752AFB3p0",
"0x0.00006DD6628AD1Ap0",
"0x0.00006EC450D815Fp0",
"0x0.00006FB34013C8Fp0",
"0x0.000070A3303EEBBp0",
"0x0.00007194215A7F2p0",
"0x0.000072861367841p0",
"0x0.000073790666FB9p0",
"0x0.0000746CFA59E68p0",
"0x0.00007561EF4145Fp0",
"0x0.00007657E51E1ABp0",
"0x0.0000774EDBF165Dp0",
"0x0.00007846D3BC284p0",
"0x0.0000793FCC7F62Fp0",
"0x0.00007A39C63C16Ep0",
"0x0.00007B34C0F3451p0",
"0x0.00007C30BCA5EE7p0",
"0x0.00007D2DB955140p0",
"0x0.00007E2BB701B6Cp0",
"0x0.00007F2AB5ACD7Bp0",
};



template <typename T> class table_f_Z3 {};


template <> class table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.000000000000800p0",
"0x0.000000000002000p0",
"0x0.000000000004800p0",
"0x0.000000000008000p0",
"0x0.00000000000C800p0",
"0x0.000000000012000p0",
"0x0.000000000018800p0",
"0x0.000000000020000p0",
"0x0.000000000028800p0",
"0x0.000000000032000p0",
"0x0.00000000003C800p0",
"0x0.000000000048000p0",
"0x0.000000000054800p0",
"0x0.000000000062000p0",
"0x0.000000000070800p0",
"0x0.000000000080000p0",
"0x0.000000000090800p0",
"0x0.0000000000A2000p0",
"0x0.0000000000B4800p0",
"0x0.0000000000C8000p0",
"0x0.0000000000DC800p0",
"0x0.0000000000F2000p0",
"0x0.000000000108800p0",
"0x0.000000000120000p0",
"0x0.000000000138800p0",
"0x0.000000000152000p0",
"0x0.00000000016C800p0",
"0x0.000000000188000p0",
"0x0.0000000001A4800p0",
"0x0.0000000001C2001p0",
"0x0.0000000001E0801p0",
"0x0.000000000200001p0",
"0x0.000000000220801p0",
"0x0.000000000242001p0",
"0x0.000000000264801p0",
"0x0.000000000288001p0",
"0x0.0000000002AC802p0",
"0x0.0000000002D2002p0",
"0x0.0000000002F8802p0",
"0x0.000000000320002p0",
"0x0.000000000348802p0",
"0x0.000000000372003p0",
"0x0.00000000039C803p0",
"0x0.0000000003C8003p0",
"0x0.0000000003F4803p0",
"0x0.000000000422003p0",
"0x0.000000000450804p0",
"0x0.000000000480004p0",
"0x0.0000000004B0804p0",
"0x0.0000000004E2005p0",
"0x0.000000000514805p0",
"0x0.000000000548005p0",
"0x0.00000000057C806p0",
"0x0.0000000005B2006p0",
"0x0.0000000005E8806p0",
"0x0.000000000620007p0",
"0x0.000000000658807p0",
"0x0.000000000692007p0",
"0x0.0000000006CC808p0",
"0x0.000000000708008p0",
"0x0.000000000744809p0",
"0x0.000000000782009p0",
"0x0.0000000007C080Ap0",
"0x0.00000000080000Ap0",
"0x0.00000000084080Bp0",
"0x0.00000000088200Bp0",
"0x0.0000000008C480Cp0",
"0x0.00000000090800Cp0",
"0x0.00000000094C80Dp0",
"0x0.00000000099200Dp0",
"0x0.0000000009D880Ep0",
"0x0.000000000A2000Fp0",
"0x0.000000000A6880Fp0",
"0x0.000000000AB2010p0",
"0x0.000000000AFC811p0",
"0x0.000000000B48011p0",
"0x0.000000000B94812p0",
"0x0.000000000BE2013p0",
"0x0.000000000C30814p0",
"0x0.000000000C80014p0",
"0x0.000000000CD0815p0",
"0x0.000000000D22016p0",
"0x0.000000000D74817p0",
"0x0.000000000DC8018p0",
"0x0.000000000E1C818p0",
"0x0.000000000E72019p0",
"0x0.000000000EC881Ap0",
"0x0.000000000F2001Bp0",
"0x0.000000000F7881Cp0",
"0x0.000000000FD201Dp0",
"0x0.00000000102C81Ep0",
"0x0.00000000108801Fp0",
"0x0.0000000010E4820p0",
"0x0.000000001142021p0",
"0x0.0000000011A0822p0",
"0x0.000000001200024p0",
"0x0.000000001260825p0",
"0x0.0000000012C2026p0",
"0x0.000000001324827p0",
"0x0.000000001388028p0",
"0x0.0000000013EC829p0",
"0x0.00000000145202Bp0",
"0x0.0000000014B882Cp0",
"0x0.00000000152002Dp0",
"0x0.00000000158882Fp0",
"0x0.0000000015F2030p0",
"0x0.00000000165C831p0",
"0x0.0000000016C8033p0",
"0x0.000000001734834p0",
"0x0.0000000017A2036p0",
"0x0.000000001810837p0",
"0x0.000000001880039p0",
"0x0.0000000018F083Ap0",
"0x0.00000000196203Cp0",
"0x0.0000000019D483Dp0",
"0x0.000000001A4803Fp0",
"0x0.000000001ABC841p0",
"0x0.000000001B32042p0",
"0x0.000000001BA8844p0",
"0x0.000000001C20046p0",
"0x0.000000001C98848p0",
"0x0.000000001D12049p0",
"0x0.000000001D8C84Bp0",
"0x0.000000001E0804Dp0",
"0x0.000000001E8484Fp0",
"0x0.000000001F02051p0",
"0x0.000000001F80853p0",
"0x0.000000002000055p0",
"0x0.000000002080857p0",
"0x0.000000002102059p0",
"0x0.00000000218485Bp0",
"0x0.00000000220805Dp0",
"0x0.00000000228C85Fp0",
"0x0.000000002312061p0",
"0x0.000000002398864p0",
"0x0.000000002420066p0",
"0x0.0000000024A8868p0",
"0x0.00000000253206Ap0",
"0x0.0000000025BC86Dp0",
"0x0.00000000264806Fp0",
"0x0.0000000026D4872p0",
"0x0.000000002762074p0",
"0x0.0000000027F0876p0",
"0x0.000000002880079p0",
"0x0.00000000291087Cp0",
"0x0.0000000029A207Ep0",
"0x0.000000002A34881p0",
"0x0.000000002AC8083p0",
"0x0.000000002B5C886p0",
"0x0.000000002BF2089p0",
"0x0.000000002C8888Cp0",
"0x0.000000002D2008Ep0",
"0x0.000000002DB8891p0",
"0x0.000000002E52094p0",
"0x0.000000002EEC897p0",
"0x0.000000002F8809Ap0",
"0x0.00000000302489Dp0",
"0x0.0000000030C20A0p0",
"0x0.0000000031608A3p0",
"0x0.0000000032000A6p0",
"0x0.0000000032A08A9p0",
"0x0.0000000033420ACp0",
"0x0.0000000033E48B0p0",
"0x0.0000000034880B3p0",
"0x0.00000000352C8B6p0",
"0x0.0000000035D20BAp0",
"0x0.0000000036788BDp0",
"0x0.0000000037200C0p0",
"0x0.0000000037C88C4p0",
"0x0.0000000038720C7p0",
"0x0.00000000391C8CBp0",
"0x0.0000000039C80CFp0",
"0x0.000000003A748D2p0",
"0x0.000000003B220D6p0",
"0x0.000000003BD08DAp0",
"0x0.000000003C800DDp0",
"0x0.000000003D308E1p0",
"0x0.000000003DE20E5p0",
"0x0.000000003E948E9p0",
"0x0.000000003F480EDp0",
"0x0.000000003FFC8F1p0",
"0x0.0000000040B20F5p0",
"0x0.0000000041688F9p0",
"0x0.0000000042200FDp0",
"0x0.0000000042D8901p0",
"0x0.000000004392105p0",
"0x0.00000000444C90Ap0",
"0x0.00000000450810Ep0",
"0x0.0000000045C4912p0",
"0x0.000000004682117p0",
"0x0.00000000474091Bp0",
"0x0.000000004800120p0",
"0x0.0000000048C0924p0",
"0x0.000000004982129p0",
"0x0.000000004A4492Dp0",
"0x0.000000004B08132p0",
"0x0.000000004BCC937p0",
"0x0.000000004C9213Bp0",
"0x0.000000004D58940p0",
"0x0.000000004E20145p0",
"0x0.000000004EE894Ap0",
"0x0.000000004FB214Fp0",
"0x0.00000000507C954p0",
"0x0.000000005148159p0",
"0x0.00000000521495Ep0",
"0x0.0000000052E2163p0",
"0x0.0000000053B0968p0",
"0x0.00000000548016Ep0",
"0x0.000000005550973p0",
"0x0.000000005622178p0",
"0x0.0000000056F497Ep0",
"0x0.0000000057C8183p0",
"0x0.00000000589C989p0",
"0x0.00000000597218Ep0",
"0x0.000000005A48994p0",
"0x0.000000005B2019Ap0",
"0x0.000000005BF899Fp0",
"0x0.000000005CD21A5p0",
"0x0.000000005DAC9ABp0",
"0x0.000000005E881B1p0",
"0x0.000000005F649B7p0",
"0x0.0000000060421BDp0",
"0x0.0000000061209C3p0",
"0x0.0000000062001C9p0",
"0x0.0000000062E09CFp0",
"0x0.0000000063C21D5p0",
"0x0.0000000064A49DBp0",
"0x0.0000000065881E2p0",
"0x0.00000000666C9E8p0",
"0x0.0000000067521EFp0",
"0x0.0000000068389F5p0",
"0x0.0000000069201FCp0",
"0x0.000000006A08A02p0",
"0x0.000000006AF2209p0",
"0x0.000000006BDCA10p0",
"0x0.000000006CC8216p0",
"0x0.000000006DB4A1Dp0",
"0x0.000000006EA2224p0",
"0x0.000000006F90A2Bp0",
"0x0.000000007080232p0",
"0x0.000000007170A39p0",
"0x0.000000007262240p0",
"0x0.000000007354A47p0",
"0x0.00000000744824Fp0",
"0x0.00000000753CA56p0",
"0x0.00000000763225Dp0",
"0x0.000000007728A65p0",
"0x0.00000000782026Cp0",
"0x0.000000007918A74p0",
"0x0.000000007A1227Bp0",
"0x0.000000007B0CA83p0",
"0x0.000000007C0828Bp0",
"0x0.000000007D04A92p0",
"0x0.000000007E0229Ap0",
"0x0.000000007F00AA2p0",
};

}
#40 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h" 2

template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void log_range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{

    const int T1size = 1 << alpha;




    ap_ufixed<alpha, -p> a = zN;
    ap_ufixed<size-alpha, -p-alpha> b = zN;
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN;
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1;
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}




const int p0 = 0;
const int alpha0 = 5;
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2);
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template<typename T>
class pow_traits {};

template <> class pow_traits<half>
{
public:
    const static int we = fp_struct<half>::EXP_BITS;
    const static int wf = 18;
    const static int org_wf = fp_struct<half>::SIG_BITS;

    const static int log_gbits = 4;
    const static int LogMaxPrecision = p3+wf+1+log_gbits;
    typedef ap_fixed<1 + we + LogMaxPrecision, 1 + we> LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<LogMaxPrecision-p3, -p3> log_range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < LogMaxPrecision-p2) ? w2 : (LogMaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < LogMaxPrecision-p3) ? w3 : (LogMaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;
        log_range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }

    const static int exp_gbits = 3;
    const static int exp_gbits_Z2 = 3;
    const static int w_Z1 = 9;



    static ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<org_wf+exp_gbits-w_Z1,-w_Z1> Z1P ) {
        ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> Z1P_l = Z1P;
        return Z1P_l;
    }
};
template <> class pow_traits<float>
{
public:
    const static int we = fp_struct<float>::EXP_BITS;
    const static int wf = 34;
    const static int org_wf = fp_struct<float>::SIG_BITS;

    const static int log_gbits = 4;
    const static int LogMaxPrecision = p4+wf+1+log_gbits;
    typedef ap_fixed<1 + we + LogMaxPrecision, 1 + we> LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<LogMaxPrecision-p4, -p4> log_range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < LogMaxPrecision-p2) ? w2 : (LogMaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < LogMaxPrecision-p3) ? w3 : (LogMaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < LogMaxPrecision-p4) ? w4 : (LogMaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;
        log_range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;

        log_range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;

        log_range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;

        return z4;
    }

    const static int exp_gbits = 4;
    const static int exp_gbits_Z2 = 3;
    const static int w_Z1 = 9;






    static ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<org_wf+exp_gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2_ind = 5;
        ap_uint<w_Z2_ind> Z2_ind = Z1P ( Z1P.wl()-1 , Z1P.wl()-w_Z2_ind );
        ap_ufixed<org_wf+exp_gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z2_ind ];
        ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = Z1P + f_Z2;
        return exp_Z1P_m_1;
    }
};

template <> class pow_traits<double>
{
public:
    const static int we = fp_struct<double>::EXP_BITS;
    const static int wf = 66;
    const static int org_wf = fp_struct<double>::SIG_BITS;

    const static int log_gbits = 5 ;
    const static int LogMaxPrecision = p8+wf+1+log_gbits;
    typedef ap_fixed<1 + we + LogMaxPrecision, 1 + we> LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<LogMaxPrecision-p8, -p8> log_range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < LogMaxPrecision-p2) ? w2 : (LogMaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < LogMaxPrecision-p3) ? w3 : (LogMaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < LogMaxPrecision-p4) ? w4 : (LogMaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < LogMaxPrecision-p5) ? w5 : (LogMaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < LogMaxPrecision-p6) ? w6 : (LogMaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < LogMaxPrecision-p7) ? w7 : (LogMaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < LogMaxPrecision-p8) ? w8 : (LogMaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        log_range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }





    const static int exp_gbits = 7;
    const static int exp_gbits_Z2 = 5;
    const static int w_Z1 = 8;




    static ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<org_wf+exp_gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2 = 8;
 const static int w_Z2P = 43;
        const static int w_Z3 = 8;
        const static int w_Z4 = 35;

 ap_ufixed < w_Z2 , -w_Z1 > Z2 = Z1P;
 ap_ufixed < w_Z2P , -w_Z1-w_Z2 > Z2P = Z1P;
 ap_ufixed < w_Z3 , -w_Z1-w_Z2 > Z3 = Z1P;
 ap_ufixed < w_Z4 , -w_Z1-w_Z2-w_Z3 > Z4 = Z1P;
#259 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
        const static int w_Z4_ind = w_Z3;
 ap_uint<w_Z4_ind> Z4_ind = Z4 ( Z4.wl()-1 , Z4.wl()-w_Z4_ind );
 ap_ufixed<org_wf+exp_gbits-2*(w_Z1+w_Z2+w_Z3)-1,-2*(w_Z1+w_Z2+w_Z3)-1> f_Z4 = table_f_Z3< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z4_ind ] >> ( 2*w_Z3 );
 ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2-w_Z3+1,-w_Z1-w_Z2-w_Z3+1> exp_Z4_m_1 = Z4 + f_Z4;


 ap_uint<w_Z3> Z3_ind = Z3 ( Z3.wl()-1, 0 );
        ap_ufixed<org_wf+exp_gbits-2*(w_Z1+w_Z2)-1,-2*(w_Z1+w_Z2)-1> f_Z3 = table_f_Z3< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z3_ind ];
        ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z3_m_1 = Z3 + f_Z3;


 ap_ufixed<org_wf+exp_gbits-2*(w_Z1+w_Z2)-w_Z3+2,-2*(w_Z1+w_Z2)-w_Z3+2> exp_Z2P_m_1_lo = exp_Z3_m_1 * exp_Z4_m_1;


 ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2+2,-w_Z1-w_Z2+2> exp_Z2P_m_1_l = exp_Z3_m_1 + exp_Z4_m_1 + exp_Z2P_m_1_lo;
 ((exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 274, __PRETTY_FUNCTION__));
 ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z2P_m_1 = exp_Z2P_m_1_l;






        ap_uint<w_Z2> Z2_ind = Z2 ( Z2.wl()-1, 0 );
        ap_ufixed<org_wf+exp_gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z2_ind ];
 ap_ufixed<org_wf+exp_gbits-w_Z1+1 -2,-w_Z1+1> exp_Z2_m_1 = Z2 + f_Z2;


 ap_ufixed<org_wf+exp_gbits-2*w_Z1-w_Z2+2,-2*w_Z1-w_Z2+2> exp_Z1P_m_1_lo = exp_Z2_m_1 * exp_Z2P_m_1;


        ap_ufixed<org_wf+exp_gbits-w_Z1+2,-w_Z1+2> exp_Z1P_m_1_l = exp_Z2_m_1 + exp_Z2P_m_1 + exp_Z1P_m_1_lo;
        ((exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 291, __PRETTY_FUNCTION__));
        ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1,-w_Z1+1> exp_Z1P_m_1 = exp_Z1P_m_1_l;

 return exp_Z1P_m_1;
    }
};

template<typename T>
T pow_generic(T base, T exp)
{
#pragma HLS pipeline

 fp_struct<T> bs(base);
 fp_struct<T> es(exp);
        const static int we = pow_traits<T>::we;
        const static int wf = pow_traits<T>::wf;
        const static int org_wf = pow_traits<T>::org_wf;

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();
    int m_exp = es.expv();
#329 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    bool y_is_0 = 0;
    bool x_is_1 = 0;
    bool x_is_p1 = 0;
    bool x_is_n1 = 0;
    bool y_is_inf = 0;
    bool y_is_NaN = 0;
    bool x_is_NaN = 0;
    bool x_is_0 = 0;
    bool x_is_inf = 0;
    bool x_is_neg = 0;
    bool y_is_int = 0;


    if (es.exp == 0)



 y_is_0 = 1;

    if (b_exp == 0 && bs.sig == 0) x_is_1 = 1;
    x_is_p1 = x_is_1 & ~bs.sign[0];
    x_is_n1 = x_is_1 & bs.sign[0];

    if ( ::hls::__isinf(exp) ) y_is_inf = 1;

    if ( ::hls::__isnan(exp) ) y_is_NaN = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;


    if (bs.exp == 0)



                                x_is_0 = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    if (bs.sign[0]==1 && x_is_0 == 0 && x_is_inf == 0) x_is_neg = 1;

    fp_struct<T> nes = es;
#380 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    if ( m_exp >= org_wf ) y_is_int = ~y_is_inf & ~y_is_NaN;
    else if ( m_exp >= 0 && nes.sig(org_wf-1-m_exp,0)==0 ) y_is_int = 1;




    if ( y_is_0 | x_is_p1 | (x_is_n1 & y_is_inf) ) {



        out.exp = fp_struct<T>::EXP_BIAS;
        return out.to_ieee();
    }

    if ( y_is_NaN | x_is_NaN | (x_is_neg & ~y_is_inf & ~y_is_int) ) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
#414 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    bool y_is_pinf = 0;
    bool y_is_ninf = 0;
    bool x_abs_greater_1;
    bool y_is_pos = 0;
    bool y_is_odd = 0;
    bool r_sign = 0;

    y_is_pinf = y_is_inf & ~es.sign[0];
    y_is_ninf = y_is_inf & es.sign[0];

    if (b_exp >= 0) x_abs_greater_1 = 1; else x_abs_greater_1 = 0;

    if (es.sign[0]==0) y_is_pos = 1;


    if (m_exp == 0) y_is_odd = 1;
    else if (m_exp > 0 && m_exp <= org_wf) y_is_odd = nes.sig[org_wf-m_exp];

    r_sign = x_is_neg & y_is_odd;
    out.sign[0] = r_sign;

    if ( x_is_n1 ) {
        out.exp = fp_struct<T>::EXP_BIAS;
        return out.to_ieee();
    }
    if ( (y_is_pinf & x_abs_greater_1) | (y_is_ninf & ~x_abs_greater_1) | (x_is_0 & ~y_is_pos) | (x_is_inf & y_is_pos) ) {



 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if ( (y_is_pinf & ~x_abs_greater_1) | (y_is_ninf & x_abs_greater_1) | (x_is_0 & y_is_pos) | (x_is_inf & ~y_is_pos) ) {



        out.exp = 0;
        return out.to_ieee();
    }



        const static int log_bypass_threshold = wf/2;
        const static int LogMaxPrecision = pow_traits<T>::LogMaxPrecision;
        typedef typename pow_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;




    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
#483 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    int FirstBit = nbs.sig[org_wf-1];


    b_frac[b_frac.wl()-b_frac.iwl()] = 1;
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));


    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }


    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692930952011528220776;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0);





 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table_pow<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];



        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;


        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 519, __PRETTY_FUNCTION__));

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1;

    ap_fixed<1-log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk;
        zk = pow_traits<T>::log_range_reduction(z1,log_sum);

    ap_fixed<1-2*log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);


    ap_fixed<1 + we + wf, 1 + we> log_base = Elog2 + log_sum + sum;






    ap_fixed<1 + 1 + org_wf, 1 + 1> e_frac = 0;


    e_frac[e_frac.wl()-e_frac.iwl()] = 1;
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(org_wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    ap_fixed<1 + we+1 + wf+org_wf, 1 + we+1> m_frac_l = log_base * e_frac;





    ap_fixed<1 + we + wf+org_wf, 1 + we> m_fix_l = m_frac_l << m_exp;
    ap_fixed<1 + we + wf+org_wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    const static int exp_gbits = pow_traits<T>::exp_gbits;
    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix;


    if ( m_exp >= 0 ) m_fix = m_frac_l << m_exp;
    else m_fix = m_frac_l >> -m_exp;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<org_wf+exp_gbits+we+1, 0> LOG2_s = LOG2;


    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix_a = r_exp * LOG2_s;

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 576, __PRETTY_FUNCTION__));
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 577, __PRETTY_FUNCTION__));
    ap_fixed<1 -1 + org_wf+exp_gbits, 1 -1> m_diff = m_fix - m_fix_a;
#607 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    const static int w_Z1 = pow_traits<T>::w_Z1;

    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );

    ap_ufixed<org_wf+exp_gbits-w_Z1, -w_Z1> m_diff_lo = m_diff;


    const static int exp_gbits_Z2 = pow_traits<T>::exp_gbits_Z2;
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = pow_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + org_wf+exp_gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -org_wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + org_wf+exp_gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 621, __PRETTY_FUNCTION__));
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }


    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {



            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {



            out.exp = 0;
            return out.to_ieee();
 }
    }


    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {



        out.exp = 0;
        return out.to_ieee();
    }




    out.sig(org_wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-org_wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;

    return out.to_ieee();

}

static half pow(half base, half exp)
{
 return pow_generic(base,exp);
}
static float pow(float base, float exp)
{
 return pow_generic(base,exp);
}
static double pow(double base, double exp)
{
 return pow_generic(base,exp);
}

static float powf(float base, float exp)
{
 return pow_generic(base,exp);
}

static half half_pow(half base, half exp)
{
 return pow_generic(base,exp);
}

template<typename T>
T powr_generic(T base, T exp)
{
#pragma HLS pipeline

 fp_struct<T> bs(base);
 fp_struct<T> es(exp);

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();
#726 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    bool y_is_0 = 0;
    bool x_is_0 = 0;
    bool x_is_n0 = 0;
    bool x_is_1 = 0;
    bool y_is_inf = 0;
    bool x_is_inf = 0;
    bool y_is_NaN = 0;
    bool x_is_NaN = 0;
    bool x_is_neg = 0;


    if (es.exp == 0)



        y_is_0 = 1;


    if (bs.exp == 0)



                                x_is_0 = 1;
    x_is_n0 = x_is_0 & bs.sign[0];

    if (b_exp == 0 && bs.sig == 0) x_is_1 = 1;

    if ( ::hls::__isinf(exp) ) y_is_inf = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    if ( ::hls::__isnan(exp) ) y_is_NaN = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;

    if (bs.sign[0]==1 && x_is_0 == 0) x_is_neg = 1;

    if ( y_is_NaN | x_is_NaN | x_is_neg | ( ( x_is_0 | x_is_inf ) & y_is_0 ) | ( x_is_1 & y_is_inf ) ) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }

    if ( x_is_n0 ) {
 base = -base;
    }

    return pow_generic(base,exp);

}

static half powr(half base, half exp)
{
        return powr_generic(base,exp);
}
static float powr(float base, float exp)
{
        return powr_generic(base,exp);
}
static double powr(double base, double exp)
{
        return powr_generic(base,exp);
}

static float powrf(float base, float exp)
{
        return powr_generic(base,exp);
}

static half half_powr(half base, half exp)
{
        return powr_generic(base,exp);
}

template<typename T>
T pown_generic(T base, int exp)
{
#pragma HLS pipeline

        fp_struct<T> bs(base);
 ap_fixed<1 + 31, 1 + 31> es = exp;
        const static int we = pow_traits<T>::we;
        const static int wf = pow_traits<T>::wf;
        const static int org_wf = pow_traits<T>::org_wf;

        fp_struct<T> out;
        out.sign[0] = 0;
        out.sig = 0;

    int b_exp = bs.expv();
#826 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    bool y_is_0 = 0;
    bool x_is_NaN = 0;

    if ( exp == 0 ) y_is_0 = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;

    if ( y_is_0 ) {



        out.exp = fp_struct<T>::EXP_BIAS;
        return out.to_ieee();
    }
    if ( x_is_NaN ) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
#854 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    bool x_is_0 = 0;
    bool x_is_inf = 0;
    bool y_is_pos = ~es[31];
    bool y_is_odd = es[0];
    bool x_is_neg = bs.sign[0];
    bool r_sign = 0;


    if (bs.exp == 0)



                                x_is_0 = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    r_sign = x_is_neg & y_is_odd;
    out.sign[0] = r_sign;

    if ( (x_is_0 & ~y_is_pos) | (x_is_inf & y_is_pos) ) {



        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if ( (x_is_0 & y_is_pos) | (x_is_inf & ~y_is_pos) ) {



        out.exp = 0;
        return out.to_ieee();
    }



        const static int log_bypass_threshold = wf/2;
        const static int LogMaxPrecision = pow_traits<T>::LogMaxPrecision;
        typedef typename pow_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;




    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
#916 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    int FirstBit = nbs.sig[org_wf-1];


    b_frac[b_frac.wl()-b_frac.iwl()] = 1;
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));


    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }


    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692930952011528220776;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0);





 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table_pow<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];



        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;


        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 952, __PRETTY_FUNCTION__));

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1;

    ap_fixed<1-log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk;
        zk = pow_traits<T>::log_range_reduction(z1,log_sum);

    ap_fixed<1-2*log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);


    ap_fixed<1 + we + wf, 1 + we> log_base = Elog2 + log_sum + sum;





    ap_fixed<1 + we+31 + wf, 1 + we+31> m_frac_l = log_base * es;



    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_frac_l;

    const static int exp_gbits = pow_traits<T>::exp_gbits;
    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix = m_frac_l;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<org_wf+exp_gbits+we+1, 0> LOG2_s = LOG2;


    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix_a = r_exp * LOG2_s;

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 994, __PRETTY_FUNCTION__));
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 995, __PRETTY_FUNCTION__));
    ap_fixed<1 -1 + org_wf+exp_gbits, 1 -1> m_diff = m_fix - m_fix_a;
#1025 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    const static int w_Z1 = pow_traits<T>::w_Z1;

    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );

    ap_ufixed<org_wf+exp_gbits-w_Z1, -w_Z1> m_diff_lo = m_diff;


    const static int exp_gbits_Z2 = pow_traits<T>::exp_gbits_Z2;
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = pow_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + org_wf+exp_gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -org_wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + org_wf+exp_gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 1039, __PRETTY_FUNCTION__));
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }


    if ( ( m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {



            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {



            out.exp = 0;
            return out.to_ieee();
 }
    }


    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {



        out.exp = 0;
        return out.to_ieee();
    }




    out.sig(org_wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-org_wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;

    return out.to_ieee();

}

static half pown(half base, int exp)
{
        return pown_generic(base,exp);
}
static float pown(float base, int exp)
{
        return pown_generic(base,exp);
}
static double pown(double base, int exp)
{
        return pown_generic(base,exp);
}

static float pownf(float base, int exp)
{
        return pown_generic(base,exp);
}

static half half_pown(half base, int exp)
{
        return pown_generic(base,exp);
}

template<typename T>
T rootn_generic(T base, int exp)
{
#pragma HLS pipeline

 fp_struct<T> bs(base);
 ap_fixed<1 + 31, 1 + 31> es = exp;
        const static int we = pow_traits<T>::we;
        const static int wf = pow_traits<T>::wf;
        const static int org_wf = pow_traits<T>::org_wf;

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();
#1135 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    bool x_is_NaN = 0;
    bool x_is_neg = 0;
    bool x_is_0 = 0;

    if ( ::hls::__isnan(base) ) x_is_NaN = 1;
    if (bs.sign[0]==1) x_is_neg = 1;

    if (bs.exp == 0)



                                x_is_0 = 1;

    if ( (es==0) | x_is_NaN | (x_is_neg & ~x_is_0 & (es!=1) & (es!=-1)) ) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }

    bool x_is_inf = 0;
    bool r_sign = 0;

    if ( ::hls::__isinf(base) ) x_is_inf = 1;
    ap_int<2> exp1 = exp;
    r_sign = x_is_neg & ( ~x_is_0 | ( x_is_0 & exp1[0] ) );
    out.sign[0] = r_sign;

    if ( ( x_is_0 & (es<0) ) | ( x_is_inf & (es>0) ) ) {



 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if ( ( x_is_0 & (es>0) ) | ( x_is_inf & (es<0) ) ) {



        out.exp = 0;
        return out.to_ieee();
    }



        const static int log_bypass_threshold = wf/2;
        const static int LogMaxPrecision = pow_traits<T>::LogMaxPrecision;
        typedef typename pow_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;




    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
#1208 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    int FirstBit = nbs.sig[org_wf-1];


    b_frac[b_frac.wl()-b_frac.iwl()] = 1;
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));


    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }


    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692930952011528220776;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0);





 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table_pow<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];



        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;


        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 1244, __PRETTY_FUNCTION__));

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1;

    ap_fixed<1-log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk;
        zk = pow_traits<T>::log_range_reduction(z1,log_sum);

    ap_fixed<1-2*log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);


    ap_fixed<1 + we + wf, 1 + we> log_base = Elog2 + log_sum + sum;





    ap_fixed<1 + we + wf+org_wf, 1 + we> m_frac_l = log_base / es;



    ap_fixed<1 + we + wf+org_wf, 1 + we> m_fix_back = m_frac_l;

    const static int exp_gbits = pow_traits<T>::exp_gbits;
    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix = m_frac_l;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<org_wf+exp_gbits+we+1, 0> LOG2_s = LOG2;


    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix_a = r_exp * LOG2_s;

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 1286, __PRETTY_FUNCTION__));
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 1287, __PRETTY_FUNCTION__));
    ap_fixed<1 -1 + org_wf+exp_gbits, 1 -1> m_diff = m_fix - m_fix_a;
#1317 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h"
    const static int w_Z1 = pow_traits<T>::w_Z1;

    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );

    ap_ufixed<org_wf+exp_gbits-w_Z1, -w_Z1> m_diff_lo = m_diff;


    const static int exp_gbits_Z2 = pow_traits<T>::exp_gbits_Z2;
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = pow_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + org_wf+exp_gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -org_wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + org_wf+exp_gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_pow.h", 1331, __PRETTY_FUNCTION__));
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }


    if ( r_exp > fp_struct<T>::EXP_BIAS ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {



            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {



            out.exp = 0;
            return out.to_ieee();
 }
    }


    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {



        out.exp = 0;
        return out.to_ieee();
    }




    out.sig(org_wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-org_wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;

    return out.to_ieee();

}

static half rootn(half base, int exp)
{
 return rootn_generic(base,exp);
}
static float rootn(float base, int exp)
{
 return rootn_generic(base,exp);
}
static double rootn(double base, int exp)
{
 return rootn_generic(base,exp);
}

static float rootnf(float base, int exp)
{
 return rootn_generic(base,exp);
}

static half half_rootn(half base, int exp)
{
 return rootn_generic(base,exp);
}

}
#295 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_fmod_rem_quo.h" 1
#38 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_fmod_rem_quo.h"
namespace fmdrmd{




template <int N,int S>
ap_uint<S+1> rcp_sub(ap_uint<N> d)
{
 ap_uint<N+S+1> b2 = 1;
 b2 <<=(N+S);
 ap_uint<S+1> rst = b2/d;
 return b2/d;
}
template <int N, int S, int E>
ap_uint<N> mod_sub(ap_uint<N> x, ap_uint<N> y, ap_int<E+2> n)
{
 ap_uint <N+1> rem(0);
 ap_uint <N> ret(0);
 ap_int <E+2> i(0);
 ap_uint <E+1> loop(0);
 const int LOOPEND = ((1<<E)-2+N-2);
 rem=x;
 i = n;
 for (loop =0; loop < LOOPEND; loop++){
  if(i==0)
   continue;
  i--;
  if(rem >= y)
   rem -=y;
  rem <<=1;
 }
 if(rem >= y)
  rem -=y;
 ret = rem;
 return ret;
}
template <int N, int S, int E>
ap_uint<N> mod_sub_nr2(ap_uint<N> x, ap_uint<N> y, ap_int<E+2> n)
{
 ap_uint <N> ret(0);
 ap_int <E+2> i(0);
 ap_uint <E+1> loop(0);
 ap_int <N+1> rem(0);
 ap_uint <N+1> rem2(0);
 ap_uint <1> s;
 i = n;
 rem(N-1,0) = x;
 rem2(N-1,0)= x;
 const int LOOPEND = ((1<<E)-2+N-2);
 for (loop =0; loop < LOOPEND; loop++){
  if(i==0)
   continue;
  i--;
  rem = rem2-y;
  s = rem(N,N);
  if(s==0)
   rem2 = rem;
  rem2 <<=1;
 }
 if(rem2 >= y)
  rem2 -=y;
 ret = rem2;
 return ret;
}
template <int N, int S, int E>
ap_uint<N> mod_rcp_mult(ap_uint<N> r_sh, ap_uint<N> d, ap_int<E+2> n)
{
 const int LOOPEND = ((1<<E)-2+N-2+S-1)/S;
 ap_uint <S+1> rcp;
 ap_uint <6> shift(0);
 ap_uint <N+1> d2d(0);
 ap_int <E+2> i(0);
 ap_uint <E+1> loop(0);
 ap_uint <N+S+1> quo(0);
 ap_uint <S+1> quoN(0);
 ap_uint <N+S> prdct(0);
 ap_uint <N+S> r_shN(0);
 ap_uint <N+1> rem(0);

 i = n;
 d2d(N,1) = d;
 rcp = rcp_sub<N,S>(d);


 for (loop =0; loop < LOOPEND; loop++){
  if(i > S)
    shift = S;
  else
    shift = i;
     quo = rcp * r_sh;
     quoN = quo>>(N+S - shift);
     prdct = quoN * d;
     r_shN = r_sh;
     r_shN = r_shN << shift;
     rem = r_shN - prdct;
     if(rem>=d2d)
      rem -= d2d;
     if(rem>=d)
      rem -= d;
     r_sh(N-1,0) = rem (N-1,0);
     i -=shift;
 }
 return r_sh;
}

template <class T>
T generic_fmod_mult(T x, T y)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 const int S = N+12;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
 ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
 ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_e = fy.exp > fx.exp?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;

 if( (isZ_m_y&& isZ_e_y) ||
    ((isF_e_x)) ||
    ((isF_e_y) && (!isZ_m_y)) ){
    fz.exp = FF_E;
    fz.sig = FF_M;
    return fz.to_ieee();
  }
  if(isyBx_e){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    return fz.to_ieee();
  }else if ((isxEy_e )&&(isyBx_m) ){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    return fz.to_ieee();
  }else if ((isxEy_e)&&(isxEy_m) ){
    fz.exp = 0;
    fz.sig = 0;
    return fz.to_ieee();
  }
  if( isZ_e_x){
    LZ = fx.sig.countLeadingZeros();
    ix = -fx.EXP_BIAS+1 - LZ -1;
    ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
    ap_mx(LZ,0) = 0;
  }else{
    ix = fx.exp - fx.EXP_BIAS;
    ap_mx(M-1,0) = fx.sig;
    ap_mx[M] = 1;
  }
  if( isZ_e_y){
    LZ = fy.sig.countLeadingZeros();
    iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
    ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
    ap_my(LZ,0) = 0;
  }else{
    iy = fy.exp - fy.EXP_BIAS;
    ap_my(M-1,0) = fy.sig;
    ap_my[M] = 1;
  }

  n = ix - iy;
 ap_uint<N> d = ap_my(N-1,0);
 ap_uint<N+0> r_sh(0);
 r_sh(N-1,0) = ap_mx(N-1,0);
 ap_uint <N> res(0);

 res = mod_rcp_mult<N,S,E>(ap_mx,d,n);

 r_sh = res;
 ap_uint<N+1> ap_mx_2(0);
 ap_mx_2(N-1,0) = (r_sh(N-1,0));

 if(ap_mx_2==0){
   fz.exp = 0;
   fz.sig = 0;
   return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);
 if(iy>= 1-fy.EXP_BIAS){
  fz.exp = iy+fy.EXP_BIAS;
  fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}
template <class T>
T generic_fmod(T x, T y)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
  ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
  ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_e = fy.exp > fx.exp?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;
 if( (isZ_m_y&& isZ_e_y) ||
  ((isF_e_x)) ||
  ((isF_e_y) && (!isZ_m_y)) ){
  fz.exp = FF_E;
  fz.sig = FF_M;
  return fz.to_ieee();
 }
 if(isyBx_e){
  fz.exp = fx.exp;
  fz.sig = fx.sig;
  return fz.to_ieee();
 }else if ((isxEy_e )&&(isyBx_m) ){
  fz.exp = fx.exp;
  fz.sig = fx.sig;
  return fz.to_ieee();
 }else if ((isxEy_e)&&(isxEy_m) ){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 if( isZ_e_x){
  LZ = fx.sig.countLeadingZeros();
  ix = -fx.EXP_BIAS+1 - LZ -1;
  ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
  ap_mx(LZ,0) = 0;
 }else{
  ix = fx.exp - fx.EXP_BIAS;
  ap_mx(M-1,0) = fx.sig;
  ap_mx[M] = 1;
 }
 if( isZ_e_y){
  LZ = fy.sig.countLeadingZeros();
  iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
  ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
  ap_my(LZ,0) = 0;
 }else{
  iy = fy.exp - fy.EXP_BIAS;
  ap_my(M-1,0) = fy.sig;
  ap_my[M] = 1;
 }
 n = ix - iy;
        ap_uint<N> d = ap_my(N-1,0);
        ap_uint<N+1> r_sh(0);
        ap_int<E+2> i;
        r_sh(N-1,0) = ap_mx(N-1,0);
        i = n;

        const int LOOPEND = ((1<<E)-2+M);
        ap_uint<E+1> loop(0);



        for (loop =0; loop < LOOPEND; loop++){
                if(r_sh >= d)
                        r_sh = r_sh -d;
                if( i >0 ){
                        r_sh <<=1;
                        i--;
                };
        }


  ap_uint<N+1> ap_mx_2(r_sh(N,0));
 if(ap_mx_2==0){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);
 if(iy>= 1-fy.EXP_BIAS){
     fz.exp = iy+fy.EXP_BIAS;
     fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}

template <class T>
T generic_remainder(T x, T y)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
 ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
 ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_1e = (fy.exp-fx.exp)==1?1:0;
 ap_uint<1> isyBx_2e = (fy.exp-fx.exp)>1?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 ap_uint<M+1> sigx_2 ;
 sigx_2(M,1) =fx.sig(M-1,0);
 ap_uint<1> isyBE2x_m = fy.sig >= (sigx_2) ?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;
 if( (isZ_m_y&& isZ_e_y) ||
  ((isF_e_x)) ||
  ((isF_e_y) && (!isZ_m_y)) ){
  fz.exp = FF_E;
  fz.sig = FF_M;
  return fz.to_ieee();
 }
 if((isF_e_y)&&(isZ_m_y)){
  fz = fx;
  return fz.to_ieee();
 }
 if ((isxEy_e)&&(isxEy_m) ){
  fz.exp = 0;
  fz.sig = 0;
  fz.sign = fx.sign;
  return fz.to_ieee();

 }else if(isyBx_2e){

  fz.exp = fx.exp;
  fz.sig = fx.sig;
  fz.sign = fx.sign;
  return fz.to_ieee();

 }else if(isyBx_1e){
  if(isZ_e_x)
  {
   if(sigx_2(M-1,0)<= fy.sig){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    return fz.to_ieee();
   }
  }else if(isyBx_m ){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    return fz.to_ieee();
  }else if(isxEy_m){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    return fz.to_ieee();
  }
 }else if(isxEy_e && isZ_e_y){
  if (isyBE2x_m){
   fz.exp = fx.exp;
   fz.sig = fx.sig;
   fz.sign = fx.sign;
   return fz.to_ieee();

  }

 }

 if( isZ_e_x){
  LZ = fx.sig.countLeadingZeros();
  ix = -fx.EXP_BIAS+1 - LZ -1;
  ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
  ap_mx(LZ,0) = 0;
 }else{
  ix = fx.exp - fx.EXP_BIAS;
  ap_mx(M-1,0) = fx.sig;
  ap_mx[M] = 1;
 }
 if( isZ_e_y){
  LZ = fy.sig.countLeadingZeros();
  iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
  ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
  ap_my(LZ,0) = 0;
 }else{
  iy = fy.exp - fy.EXP_BIAS;
  ap_my(M-1,0) = fy.sig;
  ap_my[M] = 1;
 }

 n = ix - iy;
 ap_uint<N> d = ap_my(N-1,0);
 ap_uint<N+1> d2d(0);
 ap_uint<N+1> r_sh(0);
 ap_uint<1> s_r(fx.sign);
 ap_int<E+2> i;
 ap_uint<1> even(1);
 d2d(N,1) = d(N-1,0);
 const int LOOPEND = ((1<<E)-2+M);
 ap_uint<E+1> loop(0);
 r_sh(N-1,0) = ap_mx(N-1,0);
 i = n;



 for (loop =0; loop < LOOPEND; loop++){
  if(i>0){
   i--;
   if(r_sh >= d)
    r_sh = (r_sh -d)<<1;
   else
    r_sh = r_sh<<1;
  }
 }
 if(i==0 && r_sh>=d){
  r_sh -=d;
  even =0;
 }

 ap_uint<N+2> r_sh2 = (r_sh<<1);
 if(n<-1)
 {
  fz = fx;
  return fz.to_ieee();
 }
 if(r_sh2<d){
  ;
 }else if(r_sh2==d){
  if(even==0)
   s_r = 1-s_r;
 }else if(r_sh<d){
  r_sh = d - r_sh;
  s_r = 1-s_r;
 }else if(r_sh>d){
  r_sh = d2d - r_sh;
  s_r = 1-s_r;
 }

 fz.sign = s_r;
 ap_uint<N+1> ap_mx_2(r_sh(N,0));
 if(ap_mx_2==0){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 iy += i;
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);

 if(iy>= 1-fy.EXP_BIAS){
     fz.exp = iy+fy.EXP_BIAS ;
     fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy ;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}

template <class T>
T generic_remquo(T x, T y, int* quo)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
 ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
 ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_1e = (fy.exp-fx.exp)==1?1:0;
 ap_uint<1> isyBx_2e = (fy.exp-fx.exp)>1?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 ap_uint<1> isE_s = fy.sign == fx.sign?1:0;
 ap_uint<M+1> sigx_2 ;
 sigx_2(M,1) =fx.sig(M-1,0);
 ap_uint<1> isyBE2x_m = fy.sig >= (sigx_2) ?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;
 if( (isZ_m_y&& isZ_e_y) ||
  ((isF_e_x)) ||
  ((isF_e_y) && (!isZ_m_y)) ){
  fz.exp = FF_E;
  fz.sig = FF_M;
  *quo = isE_s? 0 : -0;
  return fz.to_ieee();
 }
 if((isF_e_y)&&(isZ_m_y)){
  fz = fx;
  *quo = isE_s? 0 : -0;
  return fz.to_ieee();
 }
 if ((isxEy_e)&&(isxEy_m) ){
  fz.exp = 0;
  fz.sig = 0;
  fz.sign = fx.sign;
  *quo = isE_s? 1 : -1;
  return fz.to_ieee();

 }else if(isyBx_2e){

  fz.exp = fx.exp;
  fz.sig = fx.sig;
  fz.sign = fx.sign;
  *quo = isE_s? 0 : -0;
  return fz.to_ieee();

 }else if(isyBx_1e){
  if(isZ_e_x)
  {
   if(sigx_2(M-1,0)<= fy.sig){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    *quo = isE_s? 0 : -0;
    return fz.to_ieee();
   }
  }else if(isyBx_m ){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    *quo = isE_s? 0 : -0;
    return fz.to_ieee();
  }else if(isxEy_m){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    *quo = isE_s? 0 : -0 ;
    return fz.to_ieee();
  }
 }else if(isxEy_e && isZ_e_y){
  if (isyBE2x_m){
   fz.exp = fx.exp;
   fz.sig = fx.sig;
   fz.sign = fx.sign;
   *quo = isE_s? 0 : -0;
   return fz.to_ieee();
  }
 }

 if( isZ_e_x){
  LZ = fx.sig.countLeadingZeros();
  ix = -fx.EXP_BIAS+1 - LZ -1;
  ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
  ap_mx(LZ,0) = 0;
 }else{
  ix = fx.exp - fx.EXP_BIAS;
  ap_mx(M-1,0) = fx.sig;
  ap_mx[M] = 1;
 }
 if( isZ_e_y){
  LZ = fy.sig.countLeadingZeros();
  iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
  ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
  ap_my(LZ,0) = 0;
 }else{
  iy = fy.exp - fy.EXP_BIAS;
  ap_my(M-1,0) = fy.sig;
  ap_my[M] = 1;
 }
 n = ix - iy;
 ap_uint<N> d = ap_my(N-1,0);
        ap_uint<N+2> d2d(0);
        ap_uint<N+2> r_sh(0);
        ap_uint<1> s_r(fx.sign);
        ap_int<E+2> i;
        ap_uint<1> even(1);
        ap_uint<3> apq(0);
        ap_uint<E+1> loop(0);
        d2d(N,1) = d(N-1,0);
        r_sh(N-1,0) = ap_mx(N-1,0);
        i = n;
 const int LOOPEND = ((1<<E)-2+M);



 for (loop =0; loop < LOOPEND; loop++){
  if(i>0){
   i--;
   if(r_sh >= d){
    r_sh = (r_sh -d)<<1;
    apq[0] = 1;
    apq <<= 1;
   }
   else{
    r_sh = r_sh<<1;
    apq <<=1;
   }
  }
 }
 if(i==0 && r_sh>=d){
  r_sh -=d;
  even =0;
  apq[0] = 1;
 }

 ap_uint<N+2> r_sh2 = (r_sh<<1);
 if(n<-1)
 {
  fz = fx;
  return fz.to_ieee();
 }
 if(r_sh2<d){
  ;
 }else if(r_sh2==d){
  if(even==0){
   s_r = 1-s_r;
   apq+=1;
  }
 }else if(r_sh<d){
  r_sh = d - r_sh;
  s_r = 1-s_r;
  apq+=1;
 }else if(r_sh>d){
  r_sh = d2d - r_sh;
  s_r = 1-s_r;
  apq+=1;
 }
 if(isE_s)
  *quo = apq;
 else
  *quo = 0-apq;

 fz.sign = s_r;
 ap_uint<N+1> ap_mx_2(r_sh(N,0));
 if(ap_mx_2==0){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 iy += i;
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);

 if(iy>= 1-fy.EXP_BIAS){
     fz.exp = iy+fy.EXP_BIAS ;
     fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy ;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}
}

static double fmod(double x, double y){
 return fmdrmd::generic_fmod<double>(x,y);
}
static float fmodf(float x, float y){
 return fmdrmd::generic_fmod_mult<float>(x,y);
}
static half half_fmod(half x, half y){
 return fmdrmd::generic_fmod<half>(x,y);
}
static float fmod(float x, float y){
 return hls::fmodf(x,y);
}
static half fmod(half x, half y){
 return hls::half_fmod(x,y);
}

static double remainder(double x, double y){
 return fmdrmd::generic_remainder<double>(x,y);
}
static float remainderf(float x, float y){
 return fmdrmd::generic_remainder<float>(x,y);
}
static half half_remainder(half x, half y){
 return fmdrmd::generic_remainder<half>(x,y);
}
static float remainder(float x, float y){
 return hls::remainderf(x,y);
}
static half remainder(half x, half y){
 return hls::half_remainder(x,y);
}

static double remquo(double x, double y, int* quo){
 return fmdrmd::generic_remquo<double>(x,y, quo);
}
static float remquof(float x, float y, int* quo){
 return fmdrmd::generic_remquo<float>(x,y, quo);
}
static half half_remquo(half x, half y, int* quo){
 return fmdrmd::generic_remquo<half>(x,y, quo);
}
static float remquo(float x, float y, int* quo){
 return hls::remquof(x,y, quo);
}
static half remquo(half x, half y, int* quo){
 return hls::half_remquo(x,y, quo);
}

template <class T>
T generic_divide(T x, T y){
        T z;
        z = x/y;
        return z;
}

static
double divide(double x, double y){
        return generic_divide<double>(x,y);
}

static
float dividef(float x, float y){
        return generic_divide<float>(x,y);
}

static
half half_divide(half x, half y){
        return generic_divide<half>(x,y);
}


static
float divide(float x, float y){
        return dividef(x,y);
}
static
half divide(half x, half y){
       return generic_divide<half>(x,y);
}


;
#296 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_nextafter.h" 1
#38 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_nextafter.h"
template <class T>
T generic_nextafter(T x, T y)
{
  fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 const int E = fp_struct<T>::EXP_BITS;
 const int W = fp_struct<T>::BITS;

 ap_uint<W-1> INF = ((1LL<<E)-1) << (W-1-E);
 ap_uint<1> ap_sx (fx.sign);
 ap_uint<W-1> ap_hx (fx.data()(W-2,0));
 ap_uint<1> ap_sy (fy.sign);
 ap_uint<W-1> ap_hy (fy.data()(W-2,0));
 ap_uint<1> ap_sz (0);
 ap_uint<W-1> ap_hz (0);
 ap_uint<1> sxEsy (ap_sx == ap_sy);
 ap_uint<1> hxEhy (ap_hx == ap_hy);
 ap_uint<1> hxLhy (ap_hx < ap_hy);;
 ap_uint<1> hxBinf(ap_hx > INF);
 ap_uint<1> hyBinf(ap_hy > INF);
 ap_uint<1> hxE0 (ap_hx == 0);
 ap_uint<W-1> ap_hy_p1(ap_hx+1);
 ap_uint<W-1> ap_hy_m1(ap_hx-1);


 ap_sz = hyBinf ? ap_sy :
   hxBinf ? ap_sx :
   hxEhy & sxEsy ? ap_sy :
          hxE0 ? ap_sy :
                       ap_sx ;

 ap_hz = hyBinf ? ap_hy :
  hxBinf ? ap_hx :
  hxEhy && sxEsy ? ap_hy :
  hxEhy && (!sxEsy) && hxE0 ? ap_hy :
  (!sxEsy) && (!hxE0) ? ap_hy_m1 :
  (!hxEhy) && hxE0 ? ap_hy_p1 :
  (!hxEhy) && sxEsy && hxLhy ? ap_hy_p1 :
          ap_hy_m1 ;

   fp_struct<T> fz;
   ap_int<W> out;
   fz.sign = ap_sz;
   fz.exp = ap_hz(W-2,W-E-1);
   fz.sig = ap_hz(W-E-2,0);
   return fz.to_ieee();
};

static
double nextafter(double x, double y)
{
 return generic_nextafter<double>(x,y);
}

static
float nextafterf(float x, float y)
{
 return generic_nextafter<float>(x,y);
}

static
half half_nextafter(half x, half y)
{
 return generic_nextafter<half>(x,y);
}


static
float nextafter(float x, float y)
{
 return generic_nextafter<float>(x,y);
}
static
half nextafter(half x, half y)
{
 return generic_nextafter<half>(x,y);
}

;
#297 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2


#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h" 1
#43 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_big_mult.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_big_mult.h"
template<int W1, int W2>
void
big_mult_v1(ap_uint<W1> a, ap_uint<W2> b, ap_uint<W1+W2> &c)
{
    c = a * b;
}

template<int M>
void
aca(
    ap_uint<M> a0,
    ap_uint<M> a1,
    ap_uint<M> b0,
    ap_uint<M> b1,
    ap_uint<2*M> c,
    ap_uint<1> cin,
    ap_uint<2*M> &p,
    ap_uint<2> &out)
{
    ap_uint<2*M> p0;
    ap_uint<2*M> p1;
    ap_uint<(2*M)+2> pp0;
    ap_uint<(2*M)+2> pp1;

    p0 = a0 * b0;
    pp0 = p0 + c + cin;
    p1 = a1 * b1;
    pp1 = pp0 + p1;
    p = pp1((2*M)-1,0);
    out = pp1(((2*M)+1),(2*M));
}

template<int M>
void
acb(
    ap_uint<2> x,
    ap_uint<M> y,
    ap_uint<M> &r)
{
    r = x + y;
}

template<int M>
void
cr(
    ap_uint<M> din,
    ap_uint<M> &dout)
{
    dout = din;
}


template<int W, int M>
void
big_mult_v2(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    const int N = (W/M)-1;



    ap_uint<2*M> z[N+1][N+1];




    ap_uint<2> ci[N][N+1];

    for(int i=0; i<N+1; i++) {
        z[0][i] = a(M*(i+1)-1,M*i) * b(M*(i+1)-1,M*i);
#121 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_big_mult.h"
    }


    for(int i=0; i<N; i++) {
        ci[i][0] = 0;

        ap_uint<M> a0, a1, b0, b1;
        ap_uint<2*M> c, p;
        ap_uint<1> cin;
        ap_uint<2> out;

        for(int j=0; j<N; j++) {
            if(j>=i) {
                a0 = a(M*(j-i+1)-1,M*(j-i));
                b0 = b(M*(j+2)-1,M*(j+1));
                a1 = a(M*(j+2)-1,M*(j+1));
                b1 = b(M*(j-i+1)-1,M*(j-i));
                c = (ap_uint<W>(z[i][j-i+1](M-1,0)),
                         ap_uint<M>(z[i][j-i]((2*M)-1,M)));

                cin = ci[i][j-i][0];
                aca<M>(a0,a1,b0,b1,c,cin,p,out);
                ci[i][j-i+1] = out;
                z[i+1][j-i] = p;
#161 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_big_mult.h"
            }
        }


        if(i == N-1) {


            m(M*(N+2)-1,M*(N)) = p;






        }


        ap_uint<2> x;
        ap_uint<M> y, r;
        x = ci[i][N-i];
        y = z[i][N-i]((2*M)-1,M);




        acb<M>(x,y,r);
        m((M*((2*N)+2-i))-1,M*((2*N)+1-i)) = r;







        ap_uint<M> din, dout;
        din = z[i][0];

        cr<M>(din,dout);

        m((M*(i+1))-1,M*i) = dout;



    }
}

template<int W, int M>
void
big_mult_v3(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    const int N = (W+M-1)/M;

    ap_uint<2*M> pp[N][N];
    int i, j;
    for (i = 0; i < N; ++i)
        for (j = 0; j < N; ++j) {
            unsigned Ui = (i == N-1) ? W-1 : M*(i+1)-1;
            unsigned Uj = (j == N-1) ? W-1 : M*(j+1)-1;
            pp[i][j] = a(Ui,M*i) * b(Uj,M*j);
        }


    ap_uint<48> pps[2*N];
    pps[0] = pp[0][0];

    for (i = 1; i < 2*N; ++i) {
        pps[i] = pps[i-1] >> M;
        for (j = 0; j < N; ++j)
            if ((j <= i) && (i-j < N)) {
                pps[i] += pp[j][i-j];
            }
    }


    for (i = 0; i < 2*N; ++i) {
        unsigned Li = M*i;
        if (Li < 2*W) {
            unsigned Ui = M*(i+1)-1;
            if (Ui >= 2*W) { Ui = 2*W-1; }
            m(Ui,Li) = pps[i](M-1, 0);
        }
    }
}


template<int W, int W2, int M>
void
big_mult_v3small(
    ap_uint<W> a,
    ap_uint<W2> b,
    ap_uint<W+W2> &m)
{
    const int N = (W+M-1)/M;

    ap_uint<M+W2> pp[N];
    int i;
    for (i = 0; i < N; ++i) {
        unsigned Ui = (i == N-1) ? W-1 : M*(i+1)-1;
        pp[i] = a(Ui,M*i) * b;
    }


    ap_uint<M+W2> pps[N];
    pps[0] = pp[0];

    for (i = 1; i < N; ++i) {
        pps[i] = pps[i-1] >> M;
        pps[i] += pp[i];
    }


    for (i = 0; i < N-1; ++i) {
        unsigned Li = M*i;
        if (Li < W+W2) {
            unsigned Ui = M*(i+1)-1;
            if (Ui >= W+W2) { Ui = W+W2-1; }
            m(Ui,Li) = pps[i](M-1, 0);
        }
    }
    unsigned Li = M*i;
    if (Li < W+W2) {

        unsigned Ui = W+W2-1;
        m(Ui,Li) = pps[i];
    }
}

template<int SELECT, int W, int M>
void
big_mult(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    switch(SELECT) {
        case 1:
            big_mult_v1(a,b,m);
            break;
        case 2:
            big_mult_v2<W,M>(a,b,m);
            break;
        default:
            big_mult_v3<W,M>(a,b,m);
            break;
    };
}

template<int W, int M>
void
big_mult(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    big_mult<3,W,M>(a,b,m);
}


template<int W1, int W2>
void
big_mult(
    ap_uint<W1> a,
    ap_uint<W2> b,
    ap_uint<W1+W2> &m)
{
    if(W2 <= 64) {

        big_mult_v3small<W1,W2,17>(a,b,m);
    } else {





        ap_uint<(17*(((W1 > W2) ? W1 : W2)+ 16)/17)> a_m = a;
        ap_uint<(17*(((W1 > W2) ? W1 : W2)+ 16)/17)> b_m = b;
        ap_uint<2*(17*(((W1 > W2) ? W1 : W2)+ 16)/17)> m_m;
        big_mult<(17*(((W1 > W2) ? W1 : W2)+ 16)/17),17>(a_m,b_m,m_m);

        m = m_m;
    }
}

template <int W1, int I1, int W2, int I2>
void
big_mult(
    ap_ufixed<W1,I1> a,
    ap_ufixed<W2,I2> b,
    ap_ufixed<W1+W2,I1+I2> &m)
{
    ap_uint<W1> ai;
    ap_uint<W2> bi;
    ap_uint<W1+W2> mi;
    ai(W1-1, 0) = a(W1-1, 0);
    bi(W2-1, 0) = b(W2-1, 0);
    big_mult(ai,bi,mi);
    m(W1+W2-1,0) = mi(W1+W2-1,0);
}
#44 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h"
static const ap_uint<100> ref_cordic("9b74eda8435e5a67f5f9092c6",16);


static const ap_uint<512> ref_4oPi_512("000000000000000000000000000028BE60DB9391054A7F09D5F47D4D377036D8A5664F10E4107F9458EAF7AEF1586DC91B8E909374B801924BBA827464873FBF",16);
#62 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h"
static const ap_uint<256> ref_4oPi_table_256[10] = {
    "0x0000000000000000000000000000000028be60db9391054a7f09d5f47d4d3770",
    "0x28be60db9391054a7f09d5f47d4d377036d8a5664f10e4107f9458eaf7aef158",
    "0x36d8a5664f10e4107f9458eaf7aef1586dc91b8e909374b801924bba82746487",
    "0x6dc91b8e909374b801924bba827464873f877ac72c4a69cfba208d7d4baed121",
    "0x3f877ac72c4a69cfba208d7d4baed1213a671c09ad17df904e64758e60d4ce7d",
    "0x3a671c09ad17df904e64758e60d4ce7d272117e2ef7e4a0ec7fe25fff7816603",
    "0x272117e2ef7e4a0ec7fe25fff7816603fbcbc462d6829b47db4d9fb3c9f2c26d",
    "0xfbcbc462d6829b47db4d9fb3c9f2c26dd3d18fd9a797fa8b5d49eeb1faf97c5e",
    "0xd3d18fd9a797fa8b5d49eeb1faf97c5ecf41ce7de294a4ba9afed7ec47e35742",
    "0xcf41ce7de294a4ba9afed7ec47e357421580cc11bf1edaeafc33ef0826bd0d87",
};

static const ap_uint<100> ref_4oPi_table_100[13] = {
    "0x000000000000000000000028B",
    "0x00000000000000000028BE60D",
    "0x0000000000000028BE60DB939",
    "0x000000000028BE60DB9391054",
    "0x00000028BE60DB9391054A7F0",
    "0x0028BE60DB9391054A7F09D5F",
    "0xBE60DB9391054A7F09D5F47D4",
    "0xDB9391054A7F09D5F47D4D377",
    "0x91054A7F09D5F47D4D377036D",
    "0x4A7F09D5F47D4D377036D8A56",
    "0x09D5F47D4D377036D8A5664F1",
    "0xF47D4D377036D8A5664F10E41",
    "0x4D377036D8A5664F10E417F94",
};

static const ap_uint<80> ref_4oPi_table_80[9] = {
    "0x00000028BE60DB939105",
    "0x0028BE60DB9391054A7F",
    "0xBE60DB9391054A7F09D5",
    "0xDB9391054A7F09D5F47D",
    "0x91054A7F09D5F47D4D37",
    "0x4A7F09D5F47D4D377036",
    "0x09D5F47D4D377036D8A5",
    "0xF47D4D377036D8A5664F",
    "0x4D377036D8A5664F10E4",
};



static const ap_uint<400> ref_Pio4_400("3243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89452821E638D01377BE5466CF34E90C6CC0A",16);

static const ap_uint<256> ref_Pio4_table[10] = {
    "0x000000000000000000000000000000003243f6a8885a308d313198a2e0370734",
    "0x3243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e6c8",
    "0x4a4093822299f31d0082efa98ec4e6c89452821e638d01377be5466cf34e90c6",
    "0x9452821e638d01377be5466cf34e90c6cc0ac29b7c97c50dd3f84d5b5b547091",
    "0xcc0ac29b7c97c50dd3f84d5b5b54709179216d5d98979fb1bd1310ba698dfb5a",
    "0x79216d5d98979fb1bd1310ba698dfb5ac2ffd72dbd01adfb7b8e1afed6a267e9",
    "0xc2ffd72dbd01adfb7b8e1afed6a267e96ba7c9045f12c7f9924a19947b3916cf",
    "0x6ba7c9045f12c7f9924a19947b3916cf70801f2e2858efc16636920d871574e6",
    "0x70801f2e2858efc16636920d871574e69a458fea3f4933d7e0d95748f728eb65",
    "0x9a458fea3f4933d7e0d95748f728eb658718bcd5882154aee7b54a41dc25a59b",
};


template <int W, int I>
void scaled_fixed2ieee(ap_fixed<W, I> in, half &result, int prescale)
{

    fp_struct<half> out;
    out.sign[0] = in[in.wl()-1];



    ap_ufixed<W,I> ain = in;
    if(out.__signbit()) {
        ain = -in;
    }


    int shift = ain.countLeadingZeros();
    ap_ufixed<W, I> in_shift = ain << shift;


    ap_ufixed<W,1> result_mantissa;

    int newexp = (int)fp_struct<half>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<half>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<half>::EXP_INFNAN", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 153, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 154, __PRETTY_FUNCTION__));
    }


    out.set_mantissa(result_mantissa);
    out.exp = newexp;

    result = out.to_ieee();
}

template <int W, int I>
void scaled_fixed2ieee(ap_ufixed<W, I> in, half &result, int prescale)
{

    fp_struct<half> out;
    out.sign[0] = 0;

    ap_ufixed<W,I> ain = in;


    int shift = ain.countLeadingZeros();
    ap_ufixed<W, I> in_shift = ain << shift;


    ap_ufixed<W,1> result_mantissa;

    int newexp = (int)fp_struct<half>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<half>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<half>::EXP_INFNAN", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 191, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 192, __PRETTY_FUNCTION__));
    }


    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}



template <int W, int I>
void scaled_fixed2ieee(ap_fixed<W, I> in, float &result, int prescale)
{

    fp_struct<float> out;
    out.sign[0] = in[in.wl()-1];



    ap_ufixed<W,I> ain = in;

    if(out.__signbit()) {
        ain = -in;
    }



    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("__hls_rem > 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 220, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("__hls_rem <= 16", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 221, __PRETTY_FUNCTION__));


    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;


    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_ufixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];




        if(c[i] != 16) {
            break;
        }
    }


    ap_ufixed<W,1> result_mantissa;

    int newexp = ((int)fp_struct<float>::EXP_BIAS+in_shift.iwl()-1-prescale-shift);





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<float>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<float>::EXP_INFNAN", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 269, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 270, __PRETTY_FUNCTION__));
    }


    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}


template <int W, int I>
void scaled_fixed2ieee(ap_ufixed<W, I> in, float &result, int prescale)
{


    fp_struct<float> out;
    out.sign[0] = 0;
    ap_ufixed<W,I> ain = in;

    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("__hls_rem > 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 289, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("__hls_rem <= 16", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 290, __PRETTY_FUNCTION__));


    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;


    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_ufixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];
        if(c[i] != 16) {
            break;
        }
    }


    ap_ufixed<W,1> result_mantissa;

    int newexp = (int)fp_struct<float>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<float>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<float>::EXP_INFNAN", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 334, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 335, __PRETTY_FUNCTION__));
    }


    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}

template <int W, int I>
void scaled_fixed2ieee(ap_fixed<W, I> in, double &result, int prescale)
{

    fp_struct<double> out;
    out.sign[0] = in[in.wl()-1];



    ap_ufixed<W,I> ain = in;

    if(out.__signbit()) {
        ain = -in;
    }

    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("__hls_rem > 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 359, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("__hls_rem <= 16", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 360, __PRETTY_FUNCTION__));


    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;


    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_ufixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];
        if(c[i] != 16) {
            break;
        }
    }


    ap_ufixed<W,1> result_mantissa;

    int newexp = (int)fp_struct<double>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;
    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<double>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<double>::EXP_INFNAN", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 399, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 400, __PRETTY_FUNCTION__));
    }


    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}

template <int W, int I>
void scaled_fixed2ieee(ap_ufixed<W, I> in, double &result, int prescale)
{

    fp_struct<double> out;
    out.sign[0] = 0;
    ap_ufixed<W,I> ain = in;

    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("__hls_rem > 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 417, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("__hls_rem <= 16", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 418, __PRETTY_FUNCTION__));


    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;


    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_fixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];
        if(c[i] != 16) {
            break;
        }
    }


    ap_ufixed<W,1> result_mantissa;

    int newexp = (int)fp_struct<double>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;
    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<double>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<double>::EXP_INFNAN", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 457, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_float_utils.h", 458, __PRETTY_FUNCTION__));
    }


    out.set_mantissa(result_mantissa);
    out.exp = newexp;

    result = out.to_ieee();
}
#36 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h" 2
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int W>
float
convToFloat(
    ap_uint<W> din)
{
    ap_ufixed<W,1> d;
    d(W-1,0) = din(W-1,0);
    int prescale = 0;
    fp_struct<float> out;
    out.sign[0] = 0;

    ap_ufixed<W,1> ain = d;

    ap_uint<32> out_bits_1 = 0, out_bits_2 = 0, out_bits_3 = 0;
    out_bits_1(31, 16) = ain(ain.wl()-1,ain.wl()-16); out_bits_1[15] = 1;
    out_bits_2(31, 16) = ain(ain.wl()-16-1,ain.wl()-32); out_bits_2[15] = 1;
    if(ain.wl() > 48) {
        out_bits_3(31, 16) = ain(ain.wl()-32-1,ain.wl()-48);
    } else {
        out_bits_3(31, 16) = 0xFFFF;
    }
    out_bits_3[15] = 1;

    int c1 = clz(out_bits_1.to_uint());
    int c2 = clz(out_bits_2.to_uint());
    int c3 = clz(out_bits_3.to_uint());
    int shift = c1;

    ap_ufixed<W,1> in_shift = ain << c1;
    if(c1 == 16) {
        shift += c2;
        in_shift = in_shift << c2;
        if(c2 == 16) {

            shift += c3;
            in_shift = in_shift << c3;
        }
    }
    out.sig(fp_struct<float>::SIG_BITS-1,0) =
        in_shift(in_shift.wl()-1-1,
                 in_shift.wl()-fp_struct<float>::SIG_BITS-1);
    out.exp = (din == 0) ? 0 : (fp_struct<float>::EXP_BIAS+in_shift.iwl())-prescale-shift-1;

    return out.to_ieee();
}
#101 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int W, int I>
float
convToFloat(
 ap_ufixed<W,I> din)
{
    ap_ufixed<W,1> d;
 d = din;
 ap_uint<W> di;
 di(W-1,0) = d(W-1,0);
 return convToFloat<W>(di);
}
#120 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int W>
ap_uint<W>
convToInt(
    float din)
{
    fp_struct<float> fps(din);

    ap_uint<W> dout = ((ap_uint<W>)0x1 << 23) | fps.sig;
    dout = dout << (W-24);
    dout = dout >> (-1-fps.expv());






    return dout;
}
#146 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int W>
double
convToDouble(
    ap_uint<W> din)
{
    ap_ufixed<W,1> d;
    d(W-1,0) = din(W-1,0);
    int prescale = 0;
    fp_struct<double> out;
    out.sign[0] = 0;

    ap_ufixed<W,1> ain = d;

    ap_uint<32> out_bits_1 = 0, out_bits_2 = 0, out_bits_3 = 0, out_bits_4 = 0;
    out_bits_1(31, 16) = ain(ain.wl()-1,ain.wl()-16); out_bits_1[15] = 1;
    out_bits_2(31, 16) = ain(ain.wl()-16-1,ain.wl()-32); out_bits_2[15] = 1;
    out_bits_3(31, 16) = ain(ain.wl()-32-1,ain.wl()-48); out_bits_3[15] = 1;
    out_bits_4(31, 16) = ain(ain.wl()-48-1,ain.wl()-64); out_bits_4[15] = 1;

    int c1 = clz(out_bits_1.to_uint());
    int c2 = clz(out_bits_2.to_uint());
    int c3 = clz(out_bits_3.to_uint());
    int c4 = clz(out_bits_4.to_uint());
    int shift = c1;

    ap_ufixed<W,1> in_shift = ain << c1;
    if(c1 == 16) {
        shift += c2;
        in_shift = in_shift << c2;
        if(c2 == 16) {

            shift += c3;
            in_shift = in_shift << c3;
            if(c3 == 16) {
                shift += c4;
                in_shift = in_shift << c4;
            }
        }
    }
    out.sig(fp_struct<double>::SIG_BITS-1,0) =
        in_shift(in_shift.wl()-1-1,
                 in_shift.wl()-fp_struct<double>::SIG_BITS-1);
    out.exp = (din == 0) ? 0 : (fp_struct<double>::EXP_BIAS+in_shift.iwl())-prescale-shift-1;

    return out.to_ieee();
}
#201 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int W, int I>
double
convToDouble(
 ap_ufixed<W,I> din)
{
    ap_ufixed<W,1> d;
 d = din;
 ap_uint<W> di;
 di(W-1,0) = d(W-1,0);
 return convToDouble<W>(di);
}
#220 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int W>
ap_uint<W>
convToInt(
    double din)
{
    fp_struct<double> fps(din);

    ap_uint<W> dout = ((ap_uint<W>)0x1 << 52) | fps.sig;
    dout = dout << (W-53);
    dout = dout >> (-1-fps.expv());






    return dout;
}
#248 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi(int exp, half dummy)
{
#pragma HLS RESOURCE variable=ref_4oPi_table_80 core=ROM_1P_LUTRAM
    ap_int<9> addr = exp+14;
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h", 254, __PRETTY_FUNCTION__));
    ap_uint<80> table_80 = ref_4oPi_table_80[addr >> 4];
    return (table_80 << (ap_uint<4>)(addr(3,0)))(79,80-((2*(SB+1)+p1+3)));
}
#269 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi(int exp, float dummy)
{
#pragma HLS RESOURCE variable=ref_4oPi_table_100 core=ROM_1P_LUTRAM
    ap_int<9> addr = exp+(1+4*16);
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h", 275, __PRETTY_FUNCTION__));
    ap_uint<100> table_100 = ref_4oPi_table_100[addr >> 4];
    return (table_100 << (ap_uint<4>)(addr(3,0)))(99,100-((2*(SB+1)+p1+3)));
}
#289 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi(int exp, double dummy)
{
    ap_uint<2*(SB+1)+p1+3> ret;
    ap_int<12> addr = exp+76;
    ap_uint<256> table_256 = ref_4oPi_table_256[addr(10,7)];
    ret = (table_256 << (ap_uint<7>)(addr(6,0)))(255,256-((2*(SB+1))+p1+3));
    if(addr < 0) {
        ret = 0;
    }
    return ret;
}
#314 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int p1, int CW, class T>
void
range_redux_payne_hanek(
    T din,
    ap_uint<3> &k,
    ap_uint<CW> &dout)
{
    const int EB = fp_struct<T>::EXP_BIAS;
    const int SB = fp_struct<T>::SIG_BITS;

    fp_struct<T> fps1(din);
    int exp = fps1.exp - EB;




    if(exp > -1) {
        ap_uint<CW> Pio4_i1;
        ap_uint<CW+1> Pio4_i2;
        ap_uint<SB+1> X;
        ap_uint<2*(SB+1)+p1+3> Med;
        ap_uint<3*(SB+1)+p1+3> h;
        ap_uint<(SB+1)+3> h_int;
        ap_uint<CW> h_fract;
        ap_uint<2*CW> prod;
        ap_uint<CW+1> prod_adj;

        Pio4_i1 = ref_Pio4_400(400-1-2,400-1-2-CW+1);
        Pio4_i2 = ref_Pio4_400(400-1-2,400-1-2-(CW+1)+1);

        X = ((ap_uint<SB+1>)0x1 << SB) | (fps1.sig);
        Med = table_lookup_4oPi<SB,p1>(exp,din);

        big_mult(Med, X, h);

        h_int = h >> (2*(SB+1)+p1);
        h_fract = h(2*(SB+1)+p1-1,2*(SB+1)+p1-CW);
        k = h_int(2,0);

        big_mult(h_fract, Pio4_i1, prod);

  prod_adj = prod((2*CW)-1,CW-1);
  prod_adj = (k[0] == 1) ? (ap_uint<CW+1>)(Pio4_i2 - prod_adj) : prod_adj;

  dout = prod_adj(CW,1);
    } else {
        k = 0;
        dout = convToInt<CW>(din);
    }
}
#374 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi_hotbm(int exp, half dummy)
{
#pragma HLS RESOURCE variable=ref_4oPi_table_80 core=ROM_1P_LUTRAM
    ap_int<9> addr = exp+14;
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h", 380, __PRETTY_FUNCTION__));
    ap_uint<80> table_80 = ref_4oPi_table_80[addr >> 4];
    return (table_80 << (ap_uint<4>)(addr(3,0)))(79,80-((2*(SB+1)+p1+3)));
}
#395 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi_hotbm(int exp, float dummy)
{
#pragma HLS RESOURCE variable=ref_4oPi_table_100 core=ROM_1P_LUTRAM
    ap_int<9> addr = exp+(1+4*16);
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h", 401, __PRETTY_FUNCTION__));
    ap_uint<100> table_100 = ref_4oPi_table_100[addr >> 4];
    return (table_100 << (ap_uint<4>)(addr(3,0)))(99,100-((2*(SB+1)+p1+3)));
}
#415 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi_hotbm(int exp, double dummy)
{
    ap_uint<2*(SB+1)+p1+3> ret;
    ap_int<12> addr = exp+76;
    ap_uint<256> table_256 = ref_4oPi_table_256[addr(10,7)];
    ret = (table_256 << (ap_uint<7>)(addr(6,0)))(255,256-((2*(SB+1))+p1+3));
    if(addr < 0) {
        ret = 0;
    }
    return ret;
}
#453 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int p1, class T, int W_dout, int W_Mx>
void
range_redux_payne_hanek_hotbm(
    T din,
    ap_uint<3> &k,
    ap_ufixed<W_dout, 0> &dout,
    ap_ufixed<W_Mx, 0> &Mx,
    ap_int<fp_struct<T>::EXP_BITS> &Ex)
{
    const int SB = fp_struct<T>::SIG_BITS;

    fp_struct<T> fps1(din);
    int expv = fps1.expv();







    ap_ufixed<3*(SB+1)+p1+3,SB+1+3> h_fixed;

    bool closepath = ((fps1.exp) < fp_struct<T>::EXP_BIAS-1);

    if(closepath) {
        Ex = expv+2;
        expv = -2;
    } else {
        Ex = 0;
    }

    {
        ap_uint<SB+1> X;
        ap_uint<2*(SB+1)+p1+3> Med;
        ap_uint<3*(SB+1)+p1+3> h;

        X(fp_struct<T>::SIG_BITS-1,0) = fps1.sig(fp_struct<T>::SIG_BITS-1,0);
        X[fp_struct<T>::SIG_BITS] = 1;
        Med = table_lookup_4oPi_hotbm<SB,p1>(expv,din);
        h = Med * X;


        h_fixed(h_fixed.wl()-1, 0) = h(h_fixed.wl()-1, 0);
#504 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
    }


    ap_ufixed<W_Mx+p1, 0> Mx_bits = h_fixed;
    if(closepath) {
        k = 0;
    } else {
        k = h_fixed;
    }


    if(k[0] == 1) {
        Mx_bits = 1-Mx_bits;
    }

    ap_uint<BitWidth<p1>::Value> Mx_zeros = clz<p1>(Mx_bits);
#528 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
    Mx = ap_ufixed<W_Mx, 0>(Mx_bits << Mx_zeros);
    Ex -= Mx_zeros;
    dout = ap_ufixed<W_dout, 0>(Mx << Ex);
#539 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
}
#565 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
template<int p1, class T, int W_dout, int W_Mx>
void
range_redux_payne_hanek_hotbm_pi(
    T din,
    ap_uint<3> &k,
    ap_ufixed<W_dout, 0> &dout,
    ap_ufixed<W_Mx, 0> &Mx,
    ap_int<fp_struct<T>::EXP_BITS> &Ex,
    int &exactly_pi_over_2)
{
    const int SB = fp_struct<T>::SIG_BITS;

    fp_struct<T> fps1(din);
    int expv = fps1.expv();





    ap_ufixed<3*(SB+1)+p1+3,SB+1+3> h_fixed;

    bool closepath = ((fps1.exp) < fp_struct<T>::EXP_BIAS-3);

    if(closepath) {
        Ex = expv+4;
        expv = -4;
    } else {
        Ex = 0;
    }

    {
        ap_uint<SB+1> X;
        ap_uint<2*(SB+1)+p1+3> Med;
        ap_uint<3*(SB+1)+p1+3> h;

        X(fp_struct<T>::SIG_BITS-1,0) = fps1.sig(fp_struct<T>::SIG_BITS-1,0);
        X[fp_struct<T>::SIG_BITS] = 1;

        h = X;
        h <<= SB+p1+2;
        h <<= 2;
        h <<= expv;


        h_fixed(h_fixed.wl()-1, 0) = h(h_fixed.wl()-1, 0);
#618 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
    }

    ap_ufixed<W_Mx+p1, 1> Mx_bits_extended = h_fixed;
    exactly_pi_over_2 = (Mx_bits_extended == 1);

    ap_ufixed<W_Mx+p1, 0> Mx_bits = h_fixed;

    if(closepath) {
        k = 0;
    } else {
        k = h_fixed;
    }


    if(k[0] == 1) {
        Mx_bits = 1-Mx_bits;
    }

    ap_uint<BitWidth<p1>::Value> Mx_zeros = clz<p1>(Mx_bits);
#645 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
    Mx = ap_ufixed<W_Mx, 0>(Mx_bits << Mx_zeros);
    Ex -= Mx_zeros;
    dout = ap_ufixed<W_dout, 0>(Mx << Ex);
#656 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_range_redux.h"
}
#45 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic_tables.h" 1
#37 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic_tables.h"
static const ap_uint<128> cordic_ctab_table_int_128[128] = {
    "0x3243F6A8885A308D313198A2E0370734",
    "0x1DAC670561BB4F68ADFC88BD978751A0",
    "0xFADBAFC96406EB156DC79EF5F7A217E",
    "0x7F56EA6AB0BDB719644BCC4F9F44477",
    "0x3FEAB76E59FBD38DB2C9E4B7038B835",
    "0x1FFD55BBA97624A84EF3AEEDBB518C4",
    "0xFFFAAADDDB94D5BBE78C564015F760",
    "0x7FFF5556EEEA5CB40311A8FDDF3057",
    "0x3FFFEAAAB7776E52EC4ABEDADB53DF",
    "0x1FFFFD5555BBBBA9729AB7AAC08947",
    "0xFFFFFAAAAADDDDDB94B968067EF3A",
    "0x7FFFFF555556EEEEEA5CA5D895892",
    "0x3FFFFFEAAAAAB777776E52E5356F5",
    "0x1FFFFFFD555555BBBBBBA972972D0",
    "0xFFFFFFFAAAAAAADDDDDDDB94B94B",
    "0x7FFFFFFF55555556EEEEEEEA5CA5",
    "0x3FFFFFFFEAAAAAAAB77777776E52",
    "0x1FFFFFFFFD55555555BBBBBBBBA9",
    "0xFFFFFFFFFAAAAAAAAADDDDDDDDD",
    "0x7FFFFFFFFF5555555556EEEEEEE",
    "0x3FFFFFFFFFEAAAAAAAAAB777777",
    "0x1FFFFFFFFFFD5555555555BBBBB",
    "0xFFFFFFFFFFFAAAAAAAAAAADDDD",
    "0x7FFFFFFFFFFF555555555556EE",
    "0x3FFFFFFFFFFFEAAAAAAAAAAAB7",
    "0x1FFFFFFFFFFFFD555555555555",
    "0xFFFFFFFFFFFFFAAAAAAAAAAAA",
    "0x7FFFFFFFFFFFFF55555555555",
    "0x3FFFFFFFFFFFFFEAAAAAAAAAA",
    "0x1FFFFFFFFFFFFFFD555555555",
    "0xFFFFFFFFFFFFFFFAAAAAAAAA",
    "0x7FFFFFFFFFFFFFFF55555555",
    "0x3FFFFFFFFFFFFFFFEAAAAAAA",
    "0x1FFFFFFFFFFFFFFFFD555555",
    "0xFFFFFFFFFFFFFFFFFAAAAAA",
    "0x7FFFFFFFFFFFFFFFFF55555",
    "0x3FFFFFFFFFFFFFFFFFEAAAA",
    "0x1FFFFFFFFFFFFFFFFFFD555",
    "0xFFFFFFFFFFFFFFFFFFFAAA",
    "0x7FFFFFFFFFFFFFFFFFFF55",
    "0x3FFFFFFFFFFFFFFFFFFFEA",
    "0x1FFFFFFFFFFFFFFFFFFFFD",
    "0xFFFFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFF",
    "0x3FFFFFFFFFFFF",
    "0x1FFFFFFFFFFFF",
    "0xFFFFFFFFFFFF",
    "0x7FFFFFFFFFFF",
    "0x3FFFFFFFFFFF",
    "0x1FFFFFFFFFFF",
    "0xFFFFFFFFFFF",
    "0x7FFFFFFFFFF",
    "0x3FFFFFFFFFF",
    "0x1FFFFFFFFFF",
    "0xFFFFFFFFFF",
    "0x7FFFFFFFFF",
    "0x3FFFFFFFFF",
    "0x1FFFFFFFFF",
    "0xFFFFFFFFF",
    "0x7FFFFFFFF",
    "0x3FFFFFFFF",
    "0x1FFFFFFFF",
    "0xFFFFFFFF",
    "0x7FFFFFFF",
    "0x3FFFFFFF",
    "0x1FFFFFFF",
    "0xFFFFFFF",
    "0x7FFFFFF",
    "0x3FFFFFF",
    "0x1FFFFFF",
    "0xFFFFFF",
    "0x7FFFFF",
    "0x3FFFFF",
    "0x1FFFFF",
    "0xFFFFF",
    "0x7FFFF",
    "0x3FFFF",
    "0x1FFFF",
    "0xFFFF",
    "0x7FFF",
    "0x3FFF",
    "0x1FFF",
    "0xFFF",
    "0x7FF",
    "0x3FF",
    "0x1FF",
    "0xFF",
    "0x7F",
    "0x3F",
    "0x1F",
    "0xF",
    "0x7",
    "0x3",
    "0x1",
    "0x0",
    "0x0",
};

static const ap_ufixed<128,2> cordic_ctab_table_128[128] = {
    "0x0.C90FDAA22168C234C4C6628B80DC1CD0",
    "0x0.76B19C1586ED3DA2B7F222F65E1D4680",
    "0x0.3EB6EBF25901BAC55B71E7BD7DE885F8",
    "0x0.1FD5BA9AAC2F6DC65912F313E7D111DC",
    "0x0.0FFAADDB967EF4E36CB2792DC0E2E0D4",
    "0x0.07FF556EEA5D892A13BCEBBB6ED46310",
    "0x0.03FFEAAB776E5356EF9E31590057DD80",
    "0x0.01FFFD555BBBA972D00C46A3F77CC15C",
    "0x0.00FFFFAAAADDDDB94BB12AFB6B6D4F7C",
    "0x0.007FFFF55556EEEEA5CA6ADEAB02251C",
    "0x0.003FFFFEAAAAB77776E52E5A019FBCE8",
    "0x0.001FFFFFD55555BBBBBA972976256248",
    "0x0.000FFFFFFAAAAAADDDDDDB94B94D5BD4",
    "0x0.0007FFFFFF5555556EEEEEEA5CA5CB40",
    "0x0.0003FFFFFFEAAAAAAB7777776E52E52C",
    "0x0.0001FFFFFFFD5555555BBBBBBBA97294",
    "0x0.0000FFFFFFFFAAAAAAAADDDDDDDDB948",
    "0x0.00007FFFFFFFF555555556EEEEEEEEA4",
    "0x0.00003FFFFFFFFEAAAAAAAAB777777774",
    "0x0.00001FFFFFFFFFD555555555BBBBBBB8",
    "0x0.00000FFFFFFFFFFAAAAAAAAAADDDDDDC",
    "0x0.000007FFFFFFFFFF55555555556EEEEC",
    "0x0.000003FFFFFFFFFFEAAAAAAAAAAB7774",
    "0x0.000001FFFFFFFFFFFD55555555555BB8",
    "0x0.000000FFFFFFFFFFFFAAAAAAAAAAAADC",
    "0x0.0000007FFFFFFFFFFFF5555555555554",
    "0x0.0000003FFFFFFFFFFFFEAAAAAAAAAAA8",
    "0x0.0000001FFFFFFFFFFFFFD55555555554",
    "0x0.0000000FFFFFFFFFFFFFFAAAAAAAAAA8",
    "0x0.00000007FFFFFFFFFFFFFF5555555554",
    "0x0.00000003FFFFFFFFFFFFFFEAAAAAAAA8",
    "0x0.00000001FFFFFFFFFFFFFFFD55555554",
    "0x0.00000000FFFFFFFFFFFFFFFFAAAAAAA8",
    "0x0.000000007FFFFFFFFFFFFFFFF5555554",
    "0x0.000000003FFFFFFFFFFFFFFFFEAAAAA8",
    "0x0.000000001FFFFFFFFFFFFFFFFFD55554",
    "0x0.000000000FFFFFFFFFFFFFFFFFFAAAA8",
    "0x0.0000000007FFFFFFFFFFFFFFFFFF5554",
    "0x0.0000000003FFFFFFFFFFFFFFFFFFEAA8",
    "0x0.0000000001FFFFFFFFFFFFFFFFFFFD54",
    "0x0.0000000000FFFFFFFFFFFFFFFFFFFFA8",
    "0x0.00000000007FFFFFFFFFFFFFFFFFFFF4",
    "0x0.00000000003FFFFFFFFFFFFFFFFFFFFC",
    "0x0.00000000001FFFFFFFFFFFFFFFFFFFFC",
    "0x0.00000000000FFFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000007FFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000003FFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000001FFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000000FFFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000007FFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000003FFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000001FFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000000FFFFFFFFFFFFFFFFFFC",
    "0x0.00000000000007FFFFFFFFFFFFFFFFFC",
    "0x0.00000000000003FFFFFFFFFFFFFFFFFC",
    "0x0.00000000000001FFFFFFFFFFFFFFFFFC",
    "0x0.00000000000000FFFFFFFFFFFFFFFFFC",
    "0x0.000000000000007FFFFFFFFFFFFFFFFC",
    "0x0.000000000000003FFFFFFFFFFFFFFFFC",
    "0x0.000000000000001FFFFFFFFFFFFFFFFC",
    "0x0.000000000000000FFFFFFFFFFFFFFFFC",
    "0x0.0000000000000007FFFFFFFFFFFFFFFC",
    "0x0.0000000000000003FFFFFFFFFFFFFFFC",
    "0x0.0000000000000001FFFFFFFFFFFFFFFC",
    "0x0.0000000000000000FFFFFFFFFFFFFFFC",
    "0x0.00000000000000007FFFFFFFFFFFFFFC",
    "0x0.00000000000000003FFFFFFFFFFFFFFC",
    "0x0.00000000000000001FFFFFFFFFFFFFFC",
    "0x0.00000000000000000FFFFFFFFFFFFFFC",
    "0x0.000000000000000007FFFFFFFFFFFFFC",
    "0x0.000000000000000003FFFFFFFFFFFFFC",
    "0x0.000000000000000001FFFFFFFFFFFFFC",
    "0x0.000000000000000000FFFFFFFFFFFFFC",
    "0x0.0000000000000000007FFFFFFFFFFFFC",
    "0x0.0000000000000000003FFFFFFFFFFFFC",
    "0x0.0000000000000000001FFFFFFFFFFFFC",
    "0x0.0000000000000000000FFFFFFFFFFFFC",
    "0x0.00000000000000000007FFFFFFFFFFFC",
    "0x0.00000000000000000003FFFFFFFFFFFC",
    "0x0.00000000000000000001FFFFFFFFFFFC",
    "0x0.00000000000000000000FFFFFFFFFFFC",
    "0x0.000000000000000000007FFFFFFFFFFC",
    "0x0.000000000000000000003FFFFFFFFFFC",
    "0x0.000000000000000000001FFFFFFFFFFC",
    "0x0.000000000000000000000FFFFFFFFFFC",
    "0x0.0000000000000000000007FFFFFFFFFC",
    "0x0.0000000000000000000003FFFFFFFFFC",
    "0x0.0000000000000000000001FFFFFFFFFC",
    "0x0.0000000000000000000000FFFFFFFFFC",
    "0x0.00000000000000000000007FFFFFFFFC",
    "0x0.00000000000000000000003FFFFFFFFC",
    "0x0.00000000000000000000001FFFFFFFFC",
    "0x0.00000000000000000000000FFFFFFFFC",
    "0x0.000000000000000000000007FFFFFFFC",
    "0x0.000000000000000000000003FFFFFFFC",
    "0x0.000000000000000000000001FFFFFFFC",
    "0x0.000000000000000000000000FFFFFFFC",
    "0x0.0000000000000000000000007FFFFFFC",
    "0x0.0000000000000000000000003FFFFFFC",
    "0x0.0000000000000000000000001FFFFFFC",
    "0x0.0000000000000000000000000FFFFFFC",
    "0x0.00000000000000000000000007FFFFFC",
    "0x0.00000000000000000000000003FFFFFC",
    "0x0.00000000000000000000000001FFFFFC",
    "0x0.00000000000000000000000000FFFFFC",
    "0x0.000000000000000000000000007FFFFC",
    "0x0.000000000000000000000000003FFFFC",
    "0x0.000000000000000000000000001FFFFC",
    "0x0.000000000000000000000000000FFFFC",
    "0x0.0000000000000000000000000007FFFC",
    "0x0.0000000000000000000000000003FFFC",
    "0x0.0000000000000000000000000001FFFC",
    "0x0.0000000000000000000000000000FFFC",
    "0x0.00000000000000000000000000007FFC",
    "0x0.00000000000000000000000000003FFC",
    "0x0.00000000000000000000000000001FFC",
    "0x0.00000000000000000000000000000FFC",
    "0x0.000000000000000000000000000007FC",
    "0x0.000000000000000000000000000003FC",
    "0x0.000000000000000000000000000001FC",
    "0x0.000000000000000000000000000000FC",
    "0x0.0000000000000000000000000000007C",
    "0x0.0000000000000000000000000000003C",
    "0x0.0000000000000000000000000000001C",
    "0x0.0000000000000000000000000000000C",
    "0x0.00000000000000000000000000000004",
    "0x0.00000000000000000000000000000000",
    "0x0.00000000000000000000000000000000",
};


static const float cordic_ctab_table_floatdouble_128[128] = {
7.853982e-01,
4.636476e-01,
2.449787e-01,
1.243550e-01,
6.241881e-02,
3.123983e-02,
1.562373e-02,
7.812341e-03,
3.906230e-03,
1.953123e-03,
9.765622e-04,
4.882812e-04,
2.441406e-04,
1.220703e-04,
6.103516e-05,
3.051758e-05,
1.525879e-05,
7.629395e-06,
3.814697e-06,
1.907349e-06,
9.536743e-07,
4.768372e-07,
2.384186e-07,
1.192093e-07,
5.960464e-08,
2.980232e-08,
1.490116e-08,
7.450581e-09,
3.725290e-09,
1.862645e-09,
9.313226e-10,
4.656613e-10,
2.328306e-10,
1.164153e-10,
5.820766e-11,
2.910383e-11,
1.455192e-11,
7.275958e-12,
3.637979e-12,
1.818989e-12,
9.094947e-13,
4.547474e-13,
2.273737e-13,
1.136868e-13,
5.684342e-14,
2.842171e-14,
1.421085e-14,
7.105427e-15,
3.552714e-15,
1.776357e-15,
8.881784e-16,
4.440892e-16,
2.220446e-16,
1.110223e-16,
5.551115e-17,
2.775558e-17,
1.387779e-17,
6.938894e-18,
3.469447e-18,
1.734723e-18,
8.673617e-19,
4.336809e-19,
2.168404e-19,
1.084202e-19,
5.421011e-20,
2.710505e-20,
1.355253e-20,
6.776264e-21,
3.388132e-21,
1.694066e-21,
8.470329e-22,
4.235165e-22,
2.117582e-22,
1.058791e-22,
5.293956e-23,
2.646978e-23,
1.323489e-23,
6.617445e-24,
3.308722e-24,
1.654361e-24,
8.271806e-25,
4.135903e-25,
2.067952e-25,
1.033976e-25,
5.169879e-26,
2.584939e-26,
1.292470e-26,
6.462349e-27,
3.231174e-27,
1.615587e-27,
8.077936e-28,
4.038968e-28,
2.019484e-28,
1.009742e-28,
5.048710e-29,
2.524355e-29,
1.262177e-29,
6.310887e-30,
3.155444e-30,
1.577722e-30,
7.888609e-31,
3.944305e-31,
1.972152e-31,
9.860761e-32,
4.930381e-32,
2.465190e-32,
1.232595e-32,
6.162976e-33,
3.081488e-33,
1.540744e-33,
7.703720e-34,
3.851860e-34,
1.925930e-34,
9.629650e-35,
4.814825e-35,
2.407412e-35,
1.203706e-35,
6.018531e-36,
3.009266e-36,
1.504633e-36,
7.523164e-37,
3.761582e-37,
1.880791e-37,
9.403955e-38,
4.701977e-38,
2.350989e-38,
1.175494e-38,
5.877472e-39,
};

static const float cordic_hyperb_table_floatdouble_128[128] = {
5.493061e-01,
2.554128e-01,
1.256572e-01,
6.258157e-02,
3.126018e-02,
1.562627e-02,
7.812659e-03,
3.906270e-03,
1.953127e-03,
9.765628e-04,
4.882813e-04,
2.441406e-04,
1.220703e-04,
6.103516e-05,
3.051758e-05,
1.525879e-05,
7.629395e-06,
3.814697e-06,
1.907349e-06,
9.536743e-07,
4.768372e-07,
2.384186e-07,
1.192093e-07,
5.960464e-08,
2.980232e-08,
1.490116e-08,
7.450581e-09,
3.725290e-09,
1.862645e-09,
9.313226e-10,
4.656613e-10,
2.328306e-10,
1.164153e-10,
5.820766e-11,
2.910383e-11,
1.455192e-11,
7.275958e-12,
3.637979e-12,
1.818989e-12,
9.094947e-13,
4.547474e-13,
2.273737e-13,
1.136868e-13,
5.684342e-14,
2.842171e-14,
1.421085e-14,
7.105427e-15,
3.552714e-15,
1.776357e-15,
8.881784e-16,
4.440892e-16,
2.220446e-16,
1.110223e-16,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
};


static const ap_ufixed<128,4> cordic_hyperb_table_128[128] = {
"0x0.8c9f53d5681854bb520cc6aa829dbe5",
"0x0.4162bbea0451469c9daf0be0810eda9",
"0x0.202b12393d5deed328cf41ed722d8c9",
"0x0.1005588ad375acdcb1312a563c68525",
"0x0.0800aac448d77125a4ee9fee2db3774",
"0x0.04001556222b47263834e958ab3b4ca",
"0x0.020002aab111235a6e87a29f88bb425",
"0x0.01000055558888ad1aee1ef93404079",
"0x0.0080000aaaac44448d68e4c64f4d811",
"0x0.004000015555622222b46b4dd0dd6ae",
"0x0.002000002aaaab11111235a35dc3dc4",
"0x0.001000000555555888888ad1ad1c98c",
"0x0.0008000000aaaaaac4444448d68d69b",
"0x0.0004000000155555562222222b46b46",
"0x0.000200000002aaaaaab1111111235a3",
"0x0.0001000000005555555588888888ad1",
"0x0.0000800000000aaaaaaaac444444448",
"0x0.0000400000000155555555622222222",
"0x0.000020000000002aaaaaaaab1111111",
"0x0.0000100000000005555555555888888",
"0x0.0000080000000000aaaaaaaaaac4444",
"0x0.0000040000000000155555555556222",
"0x0.000002000000000002aaaaaaaaaab11",
"0x0.0000010000000000005555555555558",
"0x0.0000008000000000000aaaaaaaaaaaa",
"0x0.0000004000000000000155555555555",
"0x0.000000200000000000002aaaaaaaaaa",
"0x0.0000001000000000000005555555555",
"0x0.0000000800000000000000aaaaaaaaa",
"0x0.0000000400000000000000155555555",
"0x0.000000020000000000000002aaaaaaa",
"0x0.0000000100000000000000005555555",
"0x0.0000000080000000000000000aaaaaa",
"0x0.0000000040000000000000000155555",
"0x0.000000002000000000000000002aaaa",
"0x0.0000000010000000000000000005555",
"0x0.0000000008000000000000000000aaa",
"0x0.0000000004000000000000000000155",
"0x0.000000000200000000000000000002a",
"0x0.0000000001000000000000000000005",
"0x0.0000000000800000000000000000000",
"0x0.0000000000400000000000000000000",
"0x0.00000000001ffffffffffffffffffff",
"0x0.00000000000ffffffffffffffffffff",
"0x0.000000000007fffffffffffffffffff",
"0x0.000000000003fffffffffffffffffff",
"0x0.000000000001fffffffffffffffffff",
"0x0.000000000000fffffffffffffffffff",
"0x0.0000000000007ffffffffffffffffff",
"0x0.0000000000003ffffffffffffffffff",
"0x0.0000000000001ffffffffffffffffff",
"0x0.0000000000000ffffffffffffffffff",
"0x0.00000000000007fffffffffffffffff",
"0x0.00000000000003fffffffffffffffff",
"0x0.00000000000001fffffffffffffffff",
"0x0.00000000000000fffffffffffffffff",
"0x0.000000000000007ffffffffffffffff",
"0x0.000000000000003ffffffffffffffff",
"0x0.000000000000001ffffffffffffffff",
"0x0.000000000000000ffffffffffffffff",
"0x0.0000000000000007fffffffffffffff",
"0x0.0000000000000003fffffffffffffff",
"0x0.0000000000000001fffffffffffffff",
"0x0.0000000000000000fffffffffffffff",
"0x0.00000000000000007ffffffffffffff",
"0x0.00000000000000003ffffffffffffff",
"0x0.00000000000000001ffffffffffffff",
"0x0.00000000000000000ffffffffffffff",
"0x0.000000000000000007fffffffffffff",
"0x0.000000000000000003fffffffffffff",
"0x0.000000000000000001fffffffffffff",
"0x0.000000000000000000fffffffffffff",
"0x0.0000000000000000007ffffffffffff",
"0x0.0000000000000000003ffffffffffff",
"0x0.0000000000000000001ffffffffffff",
"0x0.0000000000000000000ffffffffffff",
"0x0.00000000000000000007fffffffffff",
"0x0.00000000000000000003fffffffffff",
"0x0.00000000000000000001fffffffffff",
"0x0.00000000000000000000fffffffffff",
"0x0.000000000000000000007ffffffffff",
"0x0.000000000000000000003ffffffffff",
"0x0.000000000000000000001ffffffffff",
"0x0.000000000000000000000ffffffffff",
"0x0.0000000000000000000007fffffffff",
"0x0.0000000000000000000003fffffffff",
"0x0.0000000000000000000001fffffffff",
"0x0.0000000000000000000000fffffffff",
"0x0.00000000000000000000007ffffffff",
"0x0.00000000000000000000003ffffffff",
"0x0.00000000000000000000001ffffffff",
"0x0.00000000000000000000000ffffffff",
"0x0.000000000000000000000007fffffff",
"0x0.000000000000000000000003fffffff",
"0x0.000000000000000000000001fffffff",
"0x0.000000000000000000000000fffffff",
"0x0.0000000000000000000000007ffffff",
"0x0.0000000000000000000000003ffffff",
"0x0.0000000000000000000000001ffffff",
"0x0.0000000000000000000000000ffffff",
"0x0.00000000000000000000000007fffff",
"0x0.00000000000000000000000003fffff",
"0x0.00000000000000000000000001fffff",
"0x0.00000000000000000000000000fffff",
"0x0.000000000000000000000000007ffff",
"0x0.000000000000000000000000003ffff",
"0x0.000000000000000000000000001ffff",
"0x0.000000000000000000000000000ffff",
"0x0.0000000000000000000000000007fff",
"0x0.0000000000000000000000000003fff",
"0x0.0000000000000000000000000001fff",
"0x0.0000000000000000000000000000fff",
"0x0.00000000000000000000000000007ff",
"0x0.00000000000000000000000000003ff",
"0x0.00000000000000000000000000001ff",
"0x0.00000000000000000000000000000ff",
"0x0.000000000000000000000000000007f",
"0x0.000000000000000000000000000003f",
"0x0.000000000000000000000000000001f",
"0x0.000000000000000000000000000000f",
"0x0.0000000000000000000000000000007",
"0x0.0000000000000000000000000000003",
"0x0.0000000000000000000000000000001",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
};


static const ap_ufixed<128,4> cordic_hyperb_table_128_160[170] = {
"0x0.8c9f53d5681854bb520cc6aa829dbe5",
"0x0.4162bbea0451469c9daf0be0810eda9",
"0x0.202b12393d5deed328cf41ed722d8c9",
"0x0.1005588ad375acdcb1312a563c68525",
"0x0.1005588ad375acdcb1312a563c68525",
"0x0.0800aac448d77125a4ee9fee2db3774",
"0x0.04001556222b47263834e958ab3b4ca",
"0x0.020002aab111235a6e87a29f88bb425",
"0x0.020002aab111235a6e87a29f88bb425",
"0x0.01000055558888ad1aee1ef93404079",
"0x0.0080000aaaac44448d68e4c64f4d811",
"0x0.004000015555622222b46b4dd0dd6ae",
"0x0.004000015555622222b46b4dd0dd6ae",
"0x0.002000002aaaab11111235a35dc3dc4",
"0x0.001000000555555888888ad1ad1c98c",
"0x0.0008000000aaaaaac4444448d68d69b",
"0x0.0008000000aaaaaac4444448d68d69b",
"0x0.0004000000155555562222222b46b46",
"0x0.000200000002aaaaaab1111111235a3",
"0x0.0001000000005555555588888888ad1",
"0x0.0001000000005555555588888888ad1",
"0x0.0000800000000aaaaaaaac444444448",
"0x0.0000400000000155555555622222222",
"0x0.000020000000002aaaaaaaab1111111",
"0x0.000020000000002aaaaaaaab1111111",
"0x0.0000100000000005555555555888888",
"0x0.0000080000000000aaaaaaaaaac4444",
"0x0.0000040000000000155555555556222",
"0x0.0000040000000000155555555556222",
"0x0.000002000000000002aaaaaaaaaab11",
"0x0.0000010000000000005555555555558",
"0x0.0000008000000000000aaaaaaaaaaaa",
"0x0.0000008000000000000aaaaaaaaaaaa",
"0x0.0000004000000000000155555555555",
"0x0.000000200000000000002aaaaaaaaaa",
"0x0.0000001000000000000005555555555",
"0x0.0000001000000000000005555555555",
"0x0.0000000800000000000000aaaaaaaaa",
"0x0.0000000400000000000000155555555",
"0x0.000000020000000000000002aaaaaaa",
"0x0.000000020000000000000002aaaaaaa",
"0x0.0000000100000000000000005555555",
"0x0.0000000080000000000000000aaaaaa",
"0x0.0000000040000000000000000155555",
"0x0.0000000040000000000000000155555",
"0x0.000000002000000000000000002aaaa",
"0x0.0000000010000000000000000005555",
"0x0.0000000008000000000000000000aaa",
"0x0.0000000008000000000000000000aaa",
"0x0.0000000004000000000000000000155",
"0x0.000000000200000000000000000002a",
"0x0.0000000001000000000000000000005",
"0x0.0000000001000000000000000000005",
"0x0.0000000000800000000000000000000",
"0x0.0000000000400000000000000000000",
"0x0.00000000001ffffffffffffffffffff",
"0x0.00000000001ffffffffffffffffffff",
"0x0.00000000000ffffffffffffffffffff",
"0x0.000000000007fffffffffffffffffff",
"0x0.000000000003fffffffffffffffffff",
"0x0.000000000003fffffffffffffffffff",
"0x0.000000000001fffffffffffffffffff",
"0x0.000000000000fffffffffffffffffff",
"0x0.0000000000007ffffffffffffffffff",
"0x0.0000000000007ffffffffffffffffff",
"0x0.0000000000003ffffffffffffffffff",
"0x0.0000000000001ffffffffffffffffff",
"0x0.0000000000000ffffffffffffffffff",
"0x0.0000000000000ffffffffffffffffff",
"0x0.00000000000007fffffffffffffffff",
"0x0.00000000000003fffffffffffffffff",
"0x0.00000000000001fffffffffffffffff",
"0x0.00000000000001fffffffffffffffff",
"0x0.00000000000000fffffffffffffffff",
"0x0.000000000000007ffffffffffffffff",
"0x0.000000000000003ffffffffffffffff",
"0x0.000000000000003ffffffffffffffff",
"0x0.000000000000001ffffffffffffffff",
"0x0.000000000000000ffffffffffffffff",
"0x0.0000000000000007fffffffffffffff",
"0x0.0000000000000007fffffffffffffff",
"0x0.0000000000000003fffffffffffffff",
"0x0.0000000000000001fffffffffffffff",
"0x0.0000000000000000fffffffffffffff",
"0x0.0000000000000000fffffffffffffff",
"0x0.00000000000000007ffffffffffffff",
"0x0.00000000000000003ffffffffffffff",
"0x0.00000000000000001ffffffffffffff",
"0x0.00000000000000001ffffffffffffff",
"0x0.00000000000000000ffffffffffffff",
"0x0.000000000000000007fffffffffffff",
"0x0.000000000000000003fffffffffffff",
"0x0.000000000000000003fffffffffffff",
"0x0.000000000000000001fffffffffffff",
"0x0.000000000000000000fffffffffffff",
"0x0.0000000000000000007ffffffffffff",
"0x0.0000000000000000007ffffffffffff",
"0x0.0000000000000000003ffffffffffff",
"0x0.0000000000000000001ffffffffffff",
"0x0.0000000000000000000ffffffffffff",
"0x0.0000000000000000000ffffffffffff",
"0x0.00000000000000000007fffffffffff",
"0x0.00000000000000000003fffffffffff",
"0x0.00000000000000000001fffffffffff",
"0x0.00000000000000000001fffffffffff",
"0x0.00000000000000000000fffffffffff",
"0x0.000000000000000000007ffffffffff",
"0x0.000000000000000000003ffffffffff",
"0x0.000000000000000000003ffffffffff",
"0x0.000000000000000000001ffffffffff",
"0x0.000000000000000000000ffffffffff",
"0x0.0000000000000000000007fffffffff",
"0x0.0000000000000000000007fffffffff",
"0x0.0000000000000000000003fffffffff",
"0x0.0000000000000000000001fffffffff",
"0x0.0000000000000000000000fffffffff",
"0x0.0000000000000000000000fffffffff",
"0x0.00000000000000000000007ffffffff",
"0x0.00000000000000000000003ffffffff",
"0x0.00000000000000000000001ffffffff",
"0x0.00000000000000000000001ffffffff",
"0x0.00000000000000000000000ffffffff",
"0x0.000000000000000000000007fffffff",
"0x0.000000000000000000000003fffffff",
"0x0.000000000000000000000003fffffff",
"0x0.000000000000000000000001fffffff",
"0x0.000000000000000000000000fffffff",
"0x0.0000000000000000000000007ffffff",
"0x0.0000000000000000000000007ffffff",
"0x0.0000000000000000000000003ffffff",
"0x0.0000000000000000000000001ffffff",
"0x0.0000000000000000000000000ffffff",
"0x0.0000000000000000000000000ffffff",
"0x0.00000000000000000000000007fffff",
"0x0.00000000000000000000000003fffff",
"0x0.00000000000000000000000001fffff",
"0x0.00000000000000000000000001fffff",
"0x0.00000000000000000000000000fffff",
"0x0.000000000000000000000000007ffff",
"0x0.000000000000000000000000003ffff",
"0x0.000000000000000000000000003ffff",
"0x0.000000000000000000000000001ffff",
"0x0.000000000000000000000000000ffff",
"0x0.0000000000000000000000000007fff",
"0x0.0000000000000000000000000007fff",
"0x0.0000000000000000000000000003fff",
"0x0.0000000000000000000000000001fff",
"0x0.0000000000000000000000000000fff",
"0x0.0000000000000000000000000000fff",
"0x0.00000000000000000000000000007ff",
"0x0.00000000000000000000000000003ff",
"0x0.00000000000000000000000000001ff",
"0x0.00000000000000000000000000001ff",
"0x0.00000000000000000000000000000ff",
"0x0.000000000000000000000000000007f",
"0x0.000000000000000000000000000003f",
"0x0.000000000000000000000000000003f",
"0x0.000000000000000000000000000001f",
"0x0.000000000000000000000000000000f",
"0x0.0000000000000000000000000000007",
"0x0.0000000000000000000000000000007",
"0x0.0000000000000000000000000000003",
"0x0.0000000000000000000000000000001",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
};
#46 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h" 2
#57 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
namespace cordic
{

template <typename T>
class _const
{
};
template <>
class _const<half>
{
public:
    static const uint16_t zero = 0x0000;
    static const uint16_t pi_4 = 0x3a48;
    static const uint16_t pi_2 = 0x3e48;
    static const uint16_t _3pi_4 = 0x40b6;
    static const uint16_t pi = 0x4248;
};
template <>
class _const<float>
{
public:
    static const uint32_t zero = 0x00000000;
    static const uint32_t pi_4 = 0x3F490FDB;
    static const uint32_t pi_2 = 0x3FC90FDB;
    static const uint32_t _3pi_4 = 0x4016CBE4;
    static const uint32_t pi = 0x40490FDB;
};

template <>
class _const<double>
{
public:
    static const uint64_t zero = 0x0000000000000000;
    static const uint64_t pi_4 = 0x3FE921FB54442D18;
    static const uint64_t pi_2 = 0x3FF921FB54442D18;
    static const uint64_t _3pi_4 = 0x4002D97C7F3321D2;
    static const uint64_t pi = 0x400921FB54442D18;
};
#105 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
template<int II1, int LAT1, class T2, class T3, class T4>
typename x_traits<T2,T3>::ADD_T addsub(
    T2 a,
    T3 b,
    T4 add)
{
    if(II1 == 0) {
        if(LAT1 == 1) {
#pragma HLS INTERFACE ap_none port=return register
        }
    }
#pragma HLS LATENCY MAX=LAT1

    typename x_traits<T2,T3>::ADD_T tmp;
    if(add) {
        tmp = a + b;
    } else {
        tmp = a - b;
    }
    return tmp;
}







template<int N, int MODE, int II1, int LAT1, int W, int I, int W2, int I2>
void cordic_circ_v1(
 ap_fixed<W,I> &x,
 ap_fixed<W,I> &y,
 ap_fixed<W2,I2> &z)
{
#pragma HLS INLINE SELF






    typedef ap_fixed<W,I> T;

    const int n = (N>W) ? W : N;
    const int LAT2 = LAT1/N;

 int k;
 T tx, ty;
    ap_fixed<W2,I2> tz;
 ap_uint<1> d;

 for (k=0; k<n; ++k) {



  if(MODE == 1) {
   d = ~y[W-1];






  } else {
   d = z[W-1];






  }
  T y_s = y >> k;
  tx = addsub<II1,LAT2>(x, y_s, d);
  T x_s = x >> k;
  ty = addsub<II1,LAT2>(y, x_s, !d);
  ap_fixed<W2,I2,AP_RND> z_s; z_s = cordic_ctab_table_128[k];
  tz = addsub<II1,LAT2>(z, z_s, d);
  x = tx; y = ty; z = tz;
 }





}







template<int W, int N, int MODE, int II1, int LAT1, class T, class T2>
void cordic_hyperb_v1(
 T &x,
 T &y,
 T2 &z)
{
#pragma HLS INLINE SELF






 const int n = (N>W) ? W : N;
 const int n1 = n + n/4;
 const int LAT2 = LAT1/N;

 int k1;
 T tx, ty;
    T2 tz;
 ap_uint<1> d;

 for (k1=0; k1<n1; ++k1) {
  int k = k1 - (k1/4) + 1;



  if(MODE == 1) {
   d = ~y[n-1];






  } else {
   d = z[n-1];







  }
  T y_s = y >> k;
  tx = addsub<II1,LAT2>(x, y_s, !d);
  T x_s = x >> k;
  ty = addsub<II1,LAT2>(y, x_s, !d);
  T z_s = cordic_hyperb_table_128[k-1];
  tz = addsub<II1,LAT2>(z, z_s, d);
  x = tx; y = ty; z = tz;
    }





}


template<typename T>
struct cordic_sincos_traits {};

template <>
struct cordic_sincos_traits<double> {
    typedef double T;
    static const int p1 = 61;
    static const int g = 5;
    static const int SMALL_ANGLE_THRESHOLD_BITS = 27;


    static const int CW = fp_struct<T>::SIG_BITS+SMALL_ANGLE_THRESHOLD_BITS+g;
};

template <>
struct cordic_sincos_traits<float> {
    typedef float T;
    static const int p1 = 29;
    static const int g = 5;
    static const int SMALL_ANGLE_THRESHOLD_BITS = 12;


    static const int CW = fp_struct<T>::SIG_BITS+SMALL_ANGLE_THRESHOLD_BITS+g;
};

template <>
struct cordic_sincos_traits<half> {
    typedef half T;
    static const int p1 = 12;
    static const int g = 5;
    static const int SMALL_ANGLE_THRESHOLD_BITS = 5;


    static const int CW = fp_struct<T>::SIG_BITS+SMALL_ANGLE_THRESHOLD_BITS+g;
};





template <typename T>
void cordic_sincos_generic(T t_in,
                           T &s_out,
                           T &c_out) {
    const int p1 = cordic_sincos_traits<T>::p1;
    const int bits = cordic_sincos_traits<T>::SMALL_ANGLE_THRESHOLD_BITS;


    const int CW = cordic_sincos_traits<T>::CW;

    fp_struct<T> din(t_in);

 if(din.exp == fp_struct<T>::EXP_INFNAN) {
        s_out = hls::nan("");
        c_out = hls::nan("");
        return;
    } else if(din.exp < (fp_struct<T>::EXP_BIAS-bits)) {

        c_out = (T)1.0;
        s_out = t_in;
        return;
    }

    ap_uint<3> k;
    ap_ufixed<CW, 0> fout;




    ap_ufixed<CW, 0> Mx;
    ap_int<fp_struct<T>::EXP_BITS> Ex, yprescale;
    range_redux_payne_hanek_hotbm<p1>(t_in,k,fout,Mx,Ex);
    ap_ufixed<CW,0> piover4("0.78539816339744830961566084581987572104929234984377");

    ap_fixed<CW+3,3> x, y, z;
    if(Ex < -bits) {
        x = (T)1.0;
        y = Mx * piover4;
        yprescale = -Ex;



    } else {






        x = ap_fixed<CW+3,3,AP_RND>("0.6072529350088812561694467525116341097505455558743");
        y = 0;


        z = fout * piover4;
        cordic_circ_v1<CW+3,0,0,0>(x,y,z);
        yprescale = 0;
    }
#364 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
    T tmp_s_out, tmp_c_out;
    scaled_fixed2ieee(y, tmp_s_out, yprescale);
    scaled_fixed2ieee(x, tmp_c_out, 0);
#378 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
    int sel = (din.__signbit()) ? 7 - k.to_uint() : k.to_uint();
    switch(sel) {
    case 0:
        s_out = tmp_s_out;
        c_out = tmp_c_out;
        break;
    case 1:
        s_out = tmp_c_out;
        c_out = tmp_s_out;
        break;
    case 2:
        s_out = tmp_c_out;
        c_out = -tmp_s_out;
        break;
    case 3:
        s_out = tmp_s_out;
        c_out = -tmp_c_out;
        break;
    case 4:
        s_out = -tmp_s_out;
        c_out = -tmp_c_out;
        break;
    case 5:
        s_out = -tmp_c_out;
        c_out = -tmp_s_out;
        break;
    case 6:
        s_out = -tmp_c_out;
        c_out = tmp_s_out;
        break;
    case 7:
        s_out = -tmp_s_out;
        c_out = tmp_c_out;
        break;
    default:
        s_out = tmp_s_out;
        c_out = tmp_c_out;
 }
}
#528 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
static void sincos(double t_in,
                   double *s,
                   double *c) {
    double s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    *s = s_out;
    *c = c_out;
}
static double sin(double t_in) {
    double s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return s_out;
}
static double cos(double t_in) {
    double s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return c_out;
}

static void sincosf( float t_in,
                     float *s,
                     float *c) {
    float s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    *s = s_out;
    *c = c_out;
}

static float sinf(float t_in) {
    float s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return s_out;
}

static float cosf(float t_in) {
    float s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return c_out;
}

static void half_sincos(half t_in,
                   half *s,
                   half *c) {
    half s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    *s = s_out;
    *c = c_out;
}
static half half_sin(half t_in) {
    half s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return s_out;
}
static half half_cos(half t_in) {
    half s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return c_out;
}






template <typename T> struct atan_traits {
};

template <> struct atan_traits<half> {
    static const int SMALL_ANGLE_THRESHOLD_BITS=7;

    static const int GUARD_BITS=4;
    static half div(half y, half x) {
        return y/x;
    }
};
template <> struct atan_traits<float> {
    static const int SMALL_ANGLE_THRESHOLD_BITS=11;

    static const int GUARD_BITS=4;
    static float div(float y, float x) {
        return xil_fpo_div_flt(y,x);
    }
};
template <> struct atan_traits<double> {
    static const int SMALL_ANGLE_THRESHOLD_BITS=27;

    static const int GUARD_BITS=5;
    static double div(double y, double x) {
        return xil_fpo_div_d(y,x);
    }
};





template <typename T>
T atan_generic(T t_in) {
 fp_struct<T> fps1(t_in);

    if(fps1.exp < fp_struct<T>::EXP_BIAS - atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS) {




        return t_in;
    }
#643 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
    const int CW =
        atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS + 1 +
        fp_struct<T>::SIG_BITS +
        atan_traits<T>::GUARD_BITS;




 ap_fixed<CW+3,3> x, y;
    ap_fixed<CW+1, 1> z;

 int exp = fps1.expv();
    ap_ufixed<CW+1,1> X = fps1.mantissa();

 X = X << exp;






 x = 1;
 y = X;
 z = 0;

 cordic_circ_v1<CW+3,1,0,0>(x,y,z);

 return z;
}




template <typename T>
T atan_cordic(T x) {
 fp_struct<T> xs(x);
 ap_uint<1> neg = xs.sign;
 xs.sign = 0;
 T absx = xs.to_ieee();

    const T pi_over_2 = fp_struct<T>(_const<T>::pi_2).to_ieee();
    const T pi_over_4 = fp_struct<T>(_const<T>::pi_4).to_ieee();
 T res;
    if(xs.exp == fp_struct<T>::EXP_INFNAN) {
  if(xs.sig == 0) {
            res = pi_over_2;
  } else {
   res = hls::nan("");
  }
 } else if(absx == (T)1.0) {

        res = pi_over_4;
    } else {

        bool octant1 = xs.exp >= fp_struct<T>::EXP_BIAS;

        T one_over_x = (T)1.0/absx;
        T din = octant1 ? one_over_x : absx;
        res = atan_generic(din);
        if(octant1) {




            res = pi_over_2 - res;
        } else {



        }
    }

    fp_struct<T> tmpout(res);
 tmpout.sign = neg;
 return tmpout.to_ieee();;
}

static half half_atan(half t_in) {
 return atan_cordic(t_in);
}
static float atanf(float t_in) {
 return atan_cordic(t_in);
}
static double atan(double t_in) {
 return atan_cordic(t_in);
}






template <typename T>
T atan2_generic(T y_in, T x_in) {

    fp_struct<T> fps_x(x_in);
    fp_struct<T> fps_y(y_in);



    if ( fps_y.exp + atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS < fps_x.exp) {




        return atan_traits<T>::div(y_in,x_in);
    }
    if ( fps_y.exp == 0 ) {
        return (T)0;
    }
#761 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
    const int CW =
        atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS + 1 +
        fp_struct<T>::SIG_BITS +
        atan_traits<T>::GUARD_BITS;




    ap_fixed<CW+4, 4> x, y;
    ap_fixed<CW+1, 1> z;





    int d_exp = fps_x.exp - fps_y.exp;


    x=fps_x.mantissa();
    y=fps_y.mantissa();


    y >>= d_exp;
    z = 0;



    cordic_circ_v1<CW+3,1,0,0>(x,y,z);

    return z;
}






template<class T>
static T atan2_cordic_Q1(T y_in, T x_in) {

    fp_struct<T> fpsx(x_in);
    fp_struct<T> fpsy(y_in);
    if (fpsx.data() == fpsy.data())
        return fp_struct<T>(_const<T>::pi_4).to_ieee();
    else if (y_in > x_in)
        return fp_struct<T>(_const<T>::pi_2).to_ieee() - atan2_generic(x_in, y_in);
    else
        return atan2_generic(y_in, x_in);
}


template<class T>
static T atan2_cordic(T y_in, T x_in) {
    fp_struct<T> fpsx(x_in);
    fp_struct<T> fpsy(y_in);
    if ( hls::__isnan(y_in) || hls::__isnan(x_in) ) {
        return hls::nan("");
    }


    if(fpsy.exp == 0 && fpsy.sig == 0 && fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::pi).to_ieee(), y_in);
    if(fpsy.exp == 0 && fpsy.sig == 0 && ~fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::zero).to_ieee(), y_in);
    if(fpsx.exp == 0 && fpsx.sig == 0 )
        return hls::copysign(fp_struct<T>(_const<T>::pi_2).to_ieee(), y_in);


    if(fpsx.exp == 0) { fpsx.sig = 0; }
    if(fpsy.exp == 0) { fpsy.sig = 0; }
    if(fpsy.exp == 0 && fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::pi).to_ieee(), y_in);
    if(fpsy.exp == 0 && ~fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::zero).to_ieee(), y_in);
    if(fpsx.exp == 0)
        return hls::copysign(fp_struct<T>(_const<T>::pi_2).to_ieee(), y_in);

    int m = ( (fpsx.sign.to_int() << 1) | fpsy.sign.to_int() );
#853 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
    if ( hls::__isinf(x_in) && hls::__isinf(y_in) ) {
        switch(m) {
            case 0: return fp_struct<T>(_const<T>::pi_4).to_ieee();
            case 1: return -fp_struct<T>(_const<T>::pi_4).to_ieee();
            case 2: return fp_struct<T>(_const<T>::_3pi_4).to_ieee();
            case 3: return -fp_struct<T>(_const<T>::_3pi_4).to_ieee();
        }
    } else if ( hls::__isinf(x_in) ) {
        switch(m) {
            case 0: return fp_struct<T>(_const<T>::zero).to_ieee();
            case 1: return -fp_struct<T>(_const<T>::zero).to_ieee();
            case 2: return fp_struct<T>(_const<T>::pi).to_ieee();
            case 3: return -fp_struct<T>(_const<T>::pi).to_ieee();
        }
    } else if ( hls::__isinf(y_in) ) {
        switch(m&1) {
            case 0: return fp_struct<T>(_const<T>::pi_2).to_ieee();
            case 1: return -fp_struct<T>(_const<T>::pi_2).to_ieee();
        }
    } else {
        T a = hls::abs(y_in);
        T b = hls::abs(x_in);
        T c = atan2_cordic_Q1(a,b);
        T d = fp_struct<T>(_const<T>::pi).to_ieee() - c;
        switch(m) {
            case 0:
                return c;
            case 1:
                return -c;
            case 2:
                return d;
            case 3:
                return -d;
        }
    }
    return 0;
}

static half
half_atan2(half y_in, half x_in) {
    return atan2_cordic(y_in, x_in);
}

static float
atan2f(float y_in, float x_in) {
    return atan2_cordic(y_in, x_in);
}

static double
atan2(double y_in, double x_in) {
    return atan2_cordic(y_in, x_in);
}


template <typename T> struct hyperbolic_traits {






};

template <> struct hyperbolic_traits<half> {

    static const typename fp_struct<half>::inttype H_MAX_INPUT = 0x49e4;
    static const int H_INT_MAX = 4;
    static const int H_DEC_MIN = 5;
    static const int N = fp_struct<half>::SIG_BITS + H_DEC_MIN + 2;
};
template <> struct hyperbolic_traits<float> {
    static const typename fp_struct<float>::inttype H_MAX_INPUT = 0x42b2d4fc;
    static const int H_INT_MAX = 7;
    static const int H_DEC_MIN = 12;
    static const int N = fp_struct<float>::SIG_BITS + H_DEC_MIN + 4;
};
template <> struct hyperbolic_traits<double> {
    static const typename fp_struct<double>::inttype H_MAX_INPUT = 0x408633ce8fb9f87d;
    static const int H_INT_MAX = 9;
    static const int H_DEC_MIN = 28;
    static const int N = fp_struct<double>::SIG_BITS + H_DEC_MIN + 5;
};
#957 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
template<typename T>
void hyperb_range_redux(
 T t,
 ap_uint<hyperbolic_traits<T>::H_INT_MAX+1> &k,
 ap_ufixed<hyperbolic_traits<T>::N,0> &t_out)
{
 fp_struct<T> ts(t);

    const int F1 = hyperbolic_traits<T>::N;
 const int I1 = hyperbolic_traits<T>::H_INT_MAX;
 const int W1 = I1 + F1;

 ap_ufixed<W1,I1> t_f = ts.mantissa();

 t_f <<= ts.expv();

 ap_ufixed<F1,1> inv_ln2("0x1.71547652b82fe1777d0ffda0d23a7d11d6aef551cp0");
 ap_ufixed<F1,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");

 ap_ufixed<W1+F1,I1+1> prod;
 big_mult(t_f, inv_ln2, prod);


    k = prod;
 ap_ufixed<F1,0> prod_dec = prod;

 ap_ufixed<2*(F1),0> tmp_t_out;
 big_mult(prod_dec, ln2, tmp_t_out);
 t_out = tmp_t_out;
#1002 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
}


template <typename T>
void sinh_cosh_range_redux_cordic(
 T d,
 T &s_out,
 T &c_out)
{
    fp_struct<T> ds(d);

    bool sign = ds.sign;
    ds.sign = 0;

    if(ds.to_ieee() > fp_struct<T>(hyperbolic_traits<T>::H_MAX_INPUT).to_ieee()) {

        ds.exp = fp_struct<T>::EXP_INFNAN;
        ds.sig = 0;
        ds.sign = sign;
        s_out = ds.to_ieee();
        ds.sign = 0;
        c_out = ds.to_ieee();
        return;
    } else if(ds.exp == fp_struct<T>::EXP_INFNAN) {

        ds.sign = sign;
        s_out = ds.to_ieee();
        ds.sign = 0;
        c_out = ds.to_ieee();
        return;
 } else if(ds.exp < (fp_struct<T>::EXP_BIAS - hyperbolic_traits<T>::H_DEC_MIN)) {

        s_out = d;
  c_out = (T)1.0;
        return;
    }

 ap_uint<hyperbolic_traits<T>::H_INT_MAX+1> k;
 ap_ufixed<hyperbolic_traits<T>::N,0> r;
 hyperb_range_redux(d, k, r);

 const int N = hyperbolic_traits<T>::N;

 ap_fixed<N,2> tmp_x(1.0/8.28133692173427360395e-01);
 ap_fixed<N,2> tmp_y(0);
 ap_fixed<N,2> tmp_z(r);
 cordic_hyperb_v1<N,N,0,0,0>(tmp_x,tmp_y,tmp_z);
 T x = tmp_x;
 T y = tmp_y;
#1068 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
 T two_p_plus_k, two_p_minus_k;


 unsigned int pos_exp = (int)(k+fp_struct<T>::EXP_BIAS-1);
 unsigned int neg_exp = (k >= fp_struct<T>::EXP_BIAS) ? 0 : (int)(-k+fp_struct<T>::EXP_BIAS-1);
    fp_struct<T> two_p_plus_s((typename fp_struct<T>::inttype)0);
    fp_struct<T> two_p_minus_s((typename fp_struct<T>::inttype)0);
    two_p_plus_s.exp = pos_exp;
    two_p_minus_s.exp = neg_exp;
 two_p_plus_k = two_p_plus_s.to_ieee();
 two_p_minus_k = two_p_minus_s.to_ieee();

 T sinhkln2 = two_p_plus_k - two_p_minus_k;
 T coshkln2 = two_p_plus_k + two_p_minus_k;


 T s_out_tmp = coshkln2*y + sinhkln2*x;
 T c_out_tmp = coshkln2*x + sinhkln2*y;
#1111 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_cordic.h"
    fp_struct<T> s_fp(s_out_tmp);
    fp_struct<T> c_fp(c_out_tmp);
 s_fp.sign = sign;
 c_fp.sign = 0;

 s_out = s_fp.to_ieee();
 c_out = c_fp.to_ieee();

}



static half half_sinh(half t_in) {
 half s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return s_out;
}

static half half_cosh(half t_in) {
 half s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return c_out;
}

static float sinhf(float t_in) {
 float s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return s_out;
}

static float coshf(float t_in) {
 float s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return c_out;
}

static double sinh(double t_in) {
 double s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return s_out;
}

static double cosh(double t_in) {
 double s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return c_out;
}


}
#300 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h" 1
#46 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/utils/x_hls_defines.h" 1
#47 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h" 2




namespace hotbm
{

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm_tables.h" 1
#32 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm_tables.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_fixed.h" 1
#33 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm_tables.h" 2

namespace second_order_float {


static const ap_fixed< 29 , 0 > cos_K0 [ 128 ] = {
"0", "0x1.3bdp-16", "0x4.ef48p-16", "0xb.1a6p-16", "0x1.3bcf8p-12", "0x1.ed71p-12", "0x2.c688p-12", "0x3.c7128p-12",
"0x4.ef0ep-12", "0x6.3e78p-12", "0x7.b54dp-12", "0x9.53898p-12", "0xb.19298p-12", "0xd.06288p-12", "0xf.1a818p-12", "0x1.1563p-8",
"0x1.3b92ep-8", "0x1.64376p-8", "0x1.8f501p-8", "0x1.bcdc98p-8", "0x1.ecdc78p-8", "0x2.1f4f4p-8", "0x2.54347p-8", "0x2.8b8b9p-8",
"0x2.c55408p-8", "0x3.018d5p-8", "0x3.4036d8p-8", "0x3.815p-8", "0x3.c4d828p-8", "0x4.0acebp-8", "0x4.5332ep-8", "0x4.9e041p-8",
"0x4.eb418p-8", "0x5.3aea7p-8", "0x5.8cfe28p-8", "0x5.e17bdp-8", "0x6.386298p-8", "0x6.91b1b8p-8", "0x6.ed684p-8", "0x7.4b856p-8",
"0x7.ac082p-8", "0x8.0eefap-8", "0x8.743aep-8", "0x8.dbe8e8p-8", "0x9.45f8cp-8", "0x9.b2696p-8", "0xa.2139b8p-8", "0xa.9268b8p-8",
"0xb.05f548p-8", "0xb.7bde5p-8", "0xb.f422a8p-8", "0xc.6ec12p-8", "0xc.ebb8ap-8", "0xd.6b07d8p-8", "0xd.ecada8p-8", "0xe.70a8b8p-8",
"0xe.f6f7d8p-8", "0xf.7f99bp-8", "0x1.00a8cfp-4", "0x1.097d04p-4", "0x1.1276248p-4", "0x1.1b941a8p-4", "0x1.24d6cfp-4", "0x1.2e3e2bp-4",
"0x1.37ca188p-4", "0x1.417a7e8p-4", "0x1.4b4f46p-4", "0x1.5548568p-4", "0x1.5f6597p-4", "0x1.69a6ef8p-4", "0x1.740c458p-4", "0x1.7e95808p-4",
"0x1.8942858p-4", "0x1.94133bp-4", "0x1.9f0786p-4", "0x1.aa1f4bp-4", "0x1.b55a6f8p-4", "0x1.c0b8d7p-4", "0x1.cc3a658p-4", "0x1.d7deff8p-4",
"0x1.e3a687p-4", "0x1.ef90ep-4", "0x1.fb9dec8p-4", "0x2.07cd8fp-4", "0x2.141fa98p-4", "0x2.20941d8p-4", "0x2.2d2accp-4", "0x2.39e3968p-4",
"0x2.46be5d8p-4", "0x2.53bb008p-4", "0x2.60d9608p-4", "0x2.6e195c8p-4", "0x2.7b7ad4p-4", "0x2.88fda58p-4", "0x2.96a1b1p-4", "0x2.a466d38p-4",
"0x2.b24ceb8p-4", "0x2.c053d68p-4", "0x2.ce7b728p-4", "0x2.dcc39cp-4", "0x2.eb2c2f8p-4", "0x2.f9b50a8p-4", "0x3.085e08p-4", "0x3.172705p-4",
"0x3.260fdcp-4", "0x3.3518688p-4", "0x3.4440858p-4", "0x3.53880d8p-4", "0x3.62eedbp-4", "0x3.7274c8p-4", "0x3.8219aep-4", "0x3.91dd668p-4",
"0x3.a1bfca8p-4", "0x3.b1c0b28p-4", "0x3.c1dff8p-4", "0x3.d21d728p-4", "0x3.e278fap-4", "0x3.f2f266p-4", "0x4.03898ep-4", "0x4.143e498p-4",
"0x4.25106e8p-4", "0x4.35ffd4p-4", "0x4.470c508p-4", "0x4.5835b9p-4", "0x4.697be4p-4", "0x4.7adea6p-4", "0x4.8c5dd58p-4", "0x4.9df946p-4",
};

static const ap_fixed< 23 , 1 > cos_K1 [ 128 ] = {
"0x4.p-24", "0x1.3bdcp-8", "0x2.77a8p-8", "0x3.b36cp-8", "0x4.ef38p-8", "0x6.2ae4p-8", "0x7.668cp-8", "0x8.a21cp-8",
"0x9.dda8p-8", "0xb.190cp-8", "0xc.5454p-8", "0xd.8f7cp-8", "0xe.ca84p-8", "0x1.00568p-4", "0x1.1402cp-4", "0x1.27acp-4",
"0x1.3b524p-4", "0x1.4ef54p-4", "0x1.62964p-4", "0x1.76328p-4", "0x1.89cbcp-4", "0x1.9d614p-4", "0x1.b0f28p-4", "0x1.c47f4p-4",
"0x1.d8084p-4", "0x1.eb8ccp-4", "0x1.ff0c4p-4", "0x2.1286cp-4", "0x2.25fc8p-4", "0x2.396c8p-4", "0x2.4cd74p-4", "0x2.603cp-4",
"0x2.739bp-4", "0x2.86f4cp-4", "0x2.9a47p-4", "0x2.ad934p-4", "0x2.c0d9cp-4", "0x2.d4184p-4", "0x2.e751p-4", "0x2.fa81p-4",
"0x3.0dab4p-4", "0x3.20cdp-4", "0x3.33e74p-4", "0x3.46fap-4", "0x3.5a048p-4", "0x3.6d064p-4", "0x3.7fffcp-4", "0x3.92f0cp-4",
"0x3.a5d8cp-4", "0x3.b8b78p-4", "0x3.cb8d4p-4", "0x3.de5acp-4", "0x3.f11ccp-4", "0x4.03d7p-4", "0x4.1685cp-4", "0x4.292cp-4",
"0x4.3bc64p-4", "0x4.4e56cp-4", "0x4.60ddp-4", "0x4.73588p-4", "0x4.85c88p-4", "0x4.982dp-4", "0x4.aa86cp-4", "0x4.bcd5cp-4",
"0x4.cf174p-4", "0x4.e14ecp-4", "0x4.f3794p-4", "0x5.05974p-4", "0x5.17aap-4", "0x5.29aecp-4", "0x5.3ba84p-4", "0x5.4d938p-4",
"0x5.5f728p-4", "0x5.7143cp-4", "0x5.83074p-4", "0x5.94bep-4", "0x5.a6664p-4", "0x5.b800cp-4", "0x5.c98ep-4", "0x5.db0bcp-4",
"0x5.ec7cp-4", "0x5.fddd4p-4", "0x6.0f3p-4", "0x6.20738p-4", "0x6.31a7cp-4", "0x6.42cccp-4", "0x6.53e2cp-4", "0x6.64e8cp-4",
"0x6.75de4p-4", "0x6.86c54p-4", "0x6.979bp-4", "0x6.a861p-4", "0x6.b9164p-4", "0x6.c9bcp-4", "0x6.da4f8p-4", "0x6.ead2cp-4",
"0x6.fb44cp-4", "0x7.0ba68p-4", "0x7.1bf5cp-4", "0x7.2c338p-4", "0x7.3c608p-4", "0x7.4c7acp-4", "0x7.5c84p-4", "0x7.6c798p-4",
"0x7.7c5d4p-4", "0x7.8c2ecp-4", "0x7.9beep-4", "0x7.ab9a4p-4", "0x7.bb338p-4", "0x7.cab94p-4", "0x7.da2c8p-4", "0x7.e98bcp-4",
"0x7.f8d7cp-4", "0x8.0810cp-4", "0x8.1734cp-4", "0x8.26458p-4", "0x8.3541cp-4", "0x8.442a4p-4", "0x8.52fe4p-4", "0x8.61bd4p-4",
"0x8.70684p-4", "0x8.7efe4p-4", "0x8.8d7e4p-4", "0x8.9beap-4", "0x8.aa40cp-4", "0x8.b882cp-4", "0x8.c6adp-4", "0x8.d4c34p-4",
};

static const ap_fixed< 15 , 0 > cos_K2 [ 128 ] = {
"0x4.ef2p-4", "0x4.efp-4", "0x4.ef2p-4", "0x4.efp-4", "0x4.eeap-4", "0x4.eeap-4", "0x4.ee4p-4", "0x4.ee2p-4",
"0x4.ed4p-4", "0x4.ecep-4", "0x4.ec8p-4", "0x4.ec2p-4", "0x4.ebap-4", "0x4.ebp-4", "0x4.ea4p-4", "0x4.e98p-4",
"0x4.e8ep-4", "0x4.e84p-4", "0x4.e7p-4", "0x4.e64p-4", "0x4.e54p-4", "0x4.e42p-4", "0x4.e34p-4", "0x4.e24p-4",
"0x4.e1p-4", "0x4.dfcp-4", "0x4.de8p-4", "0x4.dd6p-4", "0x4.dbep-4", "0x4.da8p-4", "0x4.d92p-4", "0x4.d7cp-4",
"0x4.d66p-4", "0x4.d48p-4", "0x4.d32p-4", "0x4.d1ap-4", "0x4.cfap-4", "0x4.ce2p-4", "0x4.ccp-4", "0x4.caap-4",
"0x4.c86p-4", "0x4.c68p-4", "0x4.c4ap-4", "0x4.c28p-4", "0x4.c04p-4", "0x4.be4p-4", "0x4.bc2p-4", "0x4.b9ep-4",
"0x4.b7cp-4", "0x4.b5ap-4", "0x4.b36p-4", "0x4.b0ap-4", "0x4.aeap-4", "0x4.abcp-4", "0x4.a98p-4", "0x4.a68p-4",
"0x4.a44p-4", "0x4.a1ap-4", "0x4.9ecp-4", "0x4.9bep-4", "0x4.994p-4", "0x4.96ap-4", "0x4.93cp-4", "0x4.908p-4",
"0x4.8ep-4", "0x4.8a8p-4", "0x4.878p-4", "0x4.84ap-4", "0x4.812p-4", "0x4.7e4p-4", "0x4.7aap-4", "0x4.77ap-4",
"0x4.744p-4", "0x4.70ep-4", "0x4.6dcp-4", "0x4.6a2p-4", "0x4.66cp-4", "0x4.636p-4", "0x4.5f8p-4", "0x4.5c2p-4",
"0x4.586p-4", "0x4.54ap-4", "0x4.50cp-4", "0x4.4dp-4", "0x4.494p-4", "0x4.456p-4", "0x4.416p-4", "0x4.3d6p-4",
"0x4.39cp-4", "0x4.356p-4", "0x4.318p-4", "0x4.2d6p-4", "0x4.296p-4", "0x4.24ep-4", "0x4.20ep-4", "0x4.1cap-4",
"0x4.188p-4", "0x4.13cp-4", "0x4.0f8p-4", "0x4.0b4p-4", "0x4.06ap-4", "0x4.022p-4", "0x3.fd4p-4", "0x3.f9p-4",
"0x3.f4ap-4", "0x3.fp-4", "0x3.eb2p-4", "0x3.e66p-4", "0x3.e1ap-4", "0x3.ddp-4", "0x3.d7ep-4", "0x3.d32p-4",
"0x3.ce4p-4", "0x3.c92p-4", "0x3.c46p-4", "0x3.bf2p-4", "0x3.ba4p-4", "0x3.b5p-4", "0x3.afep-4", "0x3.aacp-4",
"0x3.a56p-4", "0x3.ap-4", "0x3.9b2p-4", "0x3.95ep-4", "0x3.904p-4", "0x3.8a8p-4", "0x3.85cp-4", "0x3.802p-4",
};



static const ap_fixed< 30 , 1 > sin_K0 [ 128 ] = {
"0xc.90fdaap-4", "0xc.90f87fp-4", "0xc.90e8fe8p-4", "0xc.90cf28p-4", "0xc.90aafcp-4", "0xc.907c7a8p-4", "0xc.9043a4p-4", "0xc.9000788p-4",
"0xc.8fb2f88p-4", "0xc.8f5b25p-4", "0xc.8ef8fd8p-4", "0xc.8e8c838p-4", "0xc.8e15b7p-4", "0xc.8d94998p-4", "0xc.8d092a8p-4", "0xc.8c736cp-4",
"0xc.8bd35ep-4", "0xc.8b2902p-4", "0xc.8a74588p-4", "0xc.89b563p-4", "0xc.88ec228p-4", "0xc.881898p-4", "0xc.873ac5p-4", "0xc.8652aa8p-4",
"0xc.8560498p-4", "0xc.8463a48p-4", "0xc.835cbcp-4", "0xc.824b918p-4", "0xc.813027p-4", "0xc.800a7e8p-4", "0xc.7eda988p-4", "0xc.7da078p-4",
"0xc.7c5c1ep-4", "0xc.7b0d8dp-4", "0xc.79b4c68p-4", "0xc.7851cc8p-4", "0xc.76e4a1p-4", "0xc.756d468p-4", "0xc.73ebbfp-4", "0xc.72600c8p-4",
"0xc.70ca318p-4", "0xc.6f2a3p-4", "0xc.6d800bp-4", "0xc.6bcbc48p-4", "0xc.6a0d5fp-4", "0xc.6844dd8p-4", "0xc.6672428p-4", "0xc.64959p-4",
"0xc.62aecap-4", "0xc.60bdf2p-4", "0xc.5ec30cp-4", "0xc.5cbe1a8p-4", "0xc.5aaf2p-4", "0xc.58962p-4", "0xc.56731ep-4", "0xc.54461c8p-4",
"0xc.520f1e8p-4", "0xc.4fce28p-4", "0xc.4d833c8p-4", "0xc.4b2e5e8p-4", "0xc.48cf918p-4", "0xc.4666dap-4", "0xc.43f43a8p-4", "0xc.4177b7p-4",
"0xc.3ef1538p-4", "0xc.3c6113p-4", "0xc.39c6fap-4", "0xc.37230cp-4", "0xc.34754dp-4", "0xc.31bdc1p-4", "0xc.2efc6b8p-4", "0xc.2c31518p-4",
"0xc.295c76p-4", "0xc.267dde8p-4", "0xc.23958ep-4", "0xc.20a389p-4", "0xc.1da7d48p-4", "0xc.1aa275p-4", "0xc.17936ep-4", "0xc.147ac48p-4",
"0xc.11587dp-4", "0xc.0e2c9cp-4", "0xc.0af7268p-4", "0xc.07b8218p-4", "0xc.046f91p-4", "0xc.011d7ap-4", "0xb.fdc1e18p-4", "0xb.fa5ccdp-4",
"0xb.f6ee41p-4", "0xb.f376428p-4", "0xb.eff4d68p-4", "0xb.ec6a028p-4", "0xb.e8d5cbp-4", "0xb.e538368p-4", "0xb.e191498p-4", "0xb.dde1098p-4",
"0xb.da277cp-4", "0xb.d664a6p-4", "0xb.d2988ep-4", "0xb.cec3388p-4", "0xb.cae4acp-4", "0xb.c6fceep-4", "0xb.c30c04p-4", "0xb.bf11f38p-4",
"0xb.bb0ec3p-4", "0xb.b70278p-4", "0xb.b2ed19p-4", "0xb.aeceabp-4", "0xb.aaa735p-4", "0xb.a676bc8p-4", "0xb.a23d48p-4", "0xb.9dfaddp-4",
"0xb.99af83p-4", "0xb.955b3fp-4", "0xb.90fe188p-4", "0xb.8c9815p-4", "0xb.88293b8p-4", "0xb.83b1928p-4", "0xb.7f312p-4", "0xb.7aa7ebp-4",
"0xb.7615fap-4", "0xb.717b54p-4", "0xb.6cd7ffp-4", "0xb.682c03p-4", "0xb.637766p-4", "0xb.5eba2e8p-4", "0xb.59f4648p-4", "0xb.55260e8p-4",
};

static const ap_fixed< 21 , -1 > sin_K1 [ 128 ] = {
"0x8.p-24", "-0x5.2a8p-12", "-0xa.56p-12", "-0xf.81p-12", "-0x1.4acp-8", "-0x1.9d64p-8", "-0x1.f014p-8", "-0x2.42b4p-8",
"-0x2.955p-8", "-0x2.e7f4p-8", "-0x3.3a84p-8", "-0x3.8d18p-8", "-0x3.dfa8p-8", "-0x4.3238p-8", "-0x4.84b4p-8", "-0x4.d734p-8",
"-0x5.29a8p-8", "-0x5.7c14p-8", "-0x5.ce74p-8", "-0x6.20dp-8", "-0x6.7328p-8", "-0x6.c574p-8", "-0x7.17bcp-8", "-0x7.69fp-8",
"-0x7.bc18p-8", "-0x8.0e4p-8", "-0x8.6054p-8", "-0x8.b254p-8", "-0x9.044cp-8", "-0x9.564p-8", "-0x9.a814p-8", "-0x9.f9e8p-8",
"-0xa.4ba8p-8", "-0xa.9d64p-8", "-0xa.ef08p-8", "-0xb.4098p-8", "-0xb.9218p-8", "-0xb.e39p-8", "-0xc.34f4p-8", "-0xc.8644p-8",
"-0xc.d78p-8", "-0xd.28a4p-8", "-0xd.79bcp-8", "-0xd.cab8p-8", "-0xe.1bap-8", "-0xe.6c7cp-8", "-0xe.bd4p-8", "-0xf.0de4p-8",
"-0xf.5e7cp-8", "-0xf.aef4p-8", "-0xf.ff64p-8", "-0x1.04fb8p-4", "-0x1.09fecp-4", "-0x1.0f00cp-4", "-0x1.1401cp-4", "-0x1.19008p-4",
"-0x1.1dfdp-4", "-0x1.22f88p-4", "-0x1.27f38p-4", "-0x1.2ceb8p-4", "-0x1.31e14p-4", "-0x1.36d6cp-4", "-0x1.3bc94p-4", "-0x1.40ba4p-4",
"-0x1.45a9cp-4", "-0x1.4a968p-4", "-0x1.4f82p-4", "-0x1.546b8p-4", "-0x1.59538p-4", "-0x1.5e39p-4", "-0x1.631c4p-4", "-0x1.67fep-4",
"-0x1.6cdccp-4", "-0x1.71bb4p-4", "-0x1.7696p-4", "-0x1.7b6e4p-4", "-0x1.8045p-4", "-0x1.851bp-4", "-0x1.89ed4p-4", "-0x1.8ebd8p-4",
"-0x1.938bp-4", "-0x1.9856p-4", "-0x1.9d1fp-4", "-0x1.a1e6cp-4", "-0x1.a6abp-4", "-0x1.ab6c4p-4", "-0x1.b02b8p-4", "-0x1.b4e9p-4",
"-0x1.b9a38p-4", "-0x1.be5cp-4", "-0x1.c310cp-4", "-0x1.c7c3cp-4", "-0x1.cc734p-4", "-0x1.d1214p-4", "-0x1.d5cc4p-4", "-0x1.da748p-4",
"-0x1.df19cp-4", "-0x1.e3bc4p-4", "-0x1.e85c4p-4", "-0x1.ecf8cp-4", "-0x1.f1938p-4", "-0x1.f62acp-4", "-0x1.fabfcp-4", "-0x1.ff51p-4",
"-0x2.03df8p-4", "-0x2.086bp-4", "-0x2.0cf48p-4", "-0x2.117ap-4", "-0x2.15fdp-4", "-0x2.1a7c4p-4", "-0x2.1ef9p-4", "-0x2.2371cp-4",
"-0x2.27e84p-4", "-0x2.2c5bp-4", "-0x2.30cb4p-4", "-0x2.3537cp-4", "-0x2.39a14p-4", "-0x2.3e088p-4", "-0x2.426b4p-4", "-0x2.46cacp-4",
"-0x2.4b268p-4", "-0x2.4f7fcp-4", "-0x2.53d5p-4", "-0x2.58274p-4", "-0x2.5c764p-4", "-0x2.60c0cp-4", "-0x2.6509p-4", "-0x2.694d4p-4",
};

static const ap_fixed< 13 , -2 > sin_K2 [ 128 ] = {
"-0x1.4bp-4", "-0x1.4aep-4", "-0x1.4aap-4", "-0x1.4a8p-4", "-0x1.4a6p-4", "-0x1.4aap-4", "-0x1.4a4p-4", "-0x1.4a6p-4",
"-0x1.4a6p-4", "-0x1.4a4p-4", "-0x1.4a6p-4", "-0x1.4a6p-4", "-0x1.4a2p-4", "-0x1.4ap-4", "-0x1.4ap-4", "-0x1.49ep-4",
"-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49ap-4", "-0x1.496p-4", "-0x1.492p-4", "-0x1.48cp-4", "-0x1.48cp-4",
"-0x1.488p-4", "-0x1.482p-4", "-0x1.48p-4", "-0x1.48p-4", "-0x1.47cp-4", "-0x1.478p-4", "-0x1.478p-4", "-0x1.474p-4",
"-0x1.47p-4", "-0x1.468p-4", "-0x1.464p-4", "-0x1.462p-4", "-0x1.45ep-4", "-0x1.456p-4", "-0x1.45p-4", "-0x1.44ap-4",
"-0x1.446p-4", "-0x1.442p-4", "-0x1.43cp-4", "-0x1.43ap-4", "-0x1.436p-4", "-0x1.42ep-4", "-0x1.42ap-4", "-0x1.426p-4",
"-0x1.422p-4", "-0x1.41ep-4", "-0x1.414p-4", "-0x1.40ep-4", "-0x1.40ap-4", "-0x1.402p-4", "-0x1.3f8p-4", "-0x1.3f4p-4",
"-0x1.3f2p-4", "-0x1.3ecp-4", "-0x1.3dcp-4", "-0x1.3d8p-4", "-0x1.3d6p-4", "-0x1.3c8p-4", "-0x1.3c4p-4", "-0x1.3bcp-4",
"-0x1.3b4p-4", "-0x1.3bp-4", "-0x1.3a8p-4", "-0x1.3ap-4", "-0x1.394p-4", "-0x1.38ep-4", "-0x1.386p-4", "-0x1.37ep-4",
"-0x1.37ap-4", "-0x1.368p-4", "-0x1.364p-4", "-0x1.36p-4", "-0x1.358p-4", "-0x1.344p-4", "-0x1.33cp-4", "-0x1.332p-4",
"-0x1.32cp-4", "-0x1.326p-4", "-0x1.31ep-4", "-0x1.30cp-4", "-0x1.304p-4", "-0x1.3p-4", "-0x1.2f6p-4", "-0x1.2e8p-4",
"-0x1.2ep-4", "-0x1.2dp-4", "-0x1.2ccp-4", "-0x1.2cp-4", "-0x1.2b8p-4", "-0x1.2aap-4", "-0x1.29ep-4", "-0x1.292p-4",
"-0x1.28ap-4", "-0x1.27ep-4", "-0x1.274p-4", "-0x1.26cp-4", "-0x1.25cp-4", "-0x1.254p-4", "-0x1.244p-4", "-0x1.23ap-4",
"-0x1.23p-4", "-0x1.226p-4", "-0x1.214p-4", "-0x1.208p-4", "-0x1.1fap-4", "-0x1.1f2p-4", "-0x1.1e4p-4", "-0x1.1dap-4",
"-0x1.1cep-4", "-0x1.1c2p-4", "-0x1.1b4p-4", "-0x1.1a8p-4", "-0x1.19cp-4", "-0x1.186p-4", "-0x1.17ap-4", "-0x1.16ep-4",
"-0x1.166p-4", "-0x1.156p-4", "-0x1.148p-4", "-0x1.13cp-4", "-0x1.12cp-4", "-0x1.122p-4", "-0x1.11p-4", "-0x1.104p-4",
};





static const ap_ufixed< 30 , 1 > sin_cos_K0 [ 256 ] = {
"0x1.p0", "0xf.ffec43p-4", "0xf.ffb10b8p-4", "0xf.ff4e5ap-4", "0xf.fec4308p-4", "0xf.fe128fp-4", "0xf.fd3978p-4", "0xf.fc38ed8p-4",
"0xf.fb10f2p-4", "0xf.f9c188p-4", "0xf.f84ab3p-4", "0xf.f6ac768p-4", "0xf.f4e6d68p-4", "0xf.f2f9d78p-4", "0xf.f0e57e8p-4", "0xf.eea9dp-4",
"0xf.ec46d2p-4", "0xf.e9bc8ap-4", "0xf.e70affp-4", "0xf.e432368p-4", "0xf.e132388p-4", "0xf.de0b0cp-4", "0xf.dabcb9p-4", "0xf.d74747p-4",
"0xf.d3aabf8p-4", "0xf.cfe72bp-4", "0xf.cbfc928p-4", "0xf.c7ebp-4", "0xf.c3b27d8p-4", "0xf.bf5315p-4", "0xf.baccd2p-4", "0xf.b61fbfp-4",
"0xf.b14be8p-4", "0xf.ac5159p-4", "0xf.a7301d8p-4", "0xf.a1e843p-4", "0xf.9c79d68p-4", "0xf.96e4e48p-4", "0xf.91297cp-4", "0xf.8b47aap-4",
"0xf.853f7ep-4", "0xf.7f1106p-4", "0xf.78bc52p-4", "0xf.7241718p-4", "0xf.6ba074p-4", "0xf.64d96ap-4", "0xf.5dec648p-4", "0xf.56d9748p-4",
"0xf.4fa0ab8p-4", "0xf.48421bp-4", "0xf.40bdd58p-4", "0xf.3913eep-4", "0xf.314476p-4", "0xf.294f828p-4", "0xf.2135258p-4", "0xf.18f5748p-4",
"0xf.1090828p-4", "0xf.080665p-4", "0xe.ff5731p-4", "0xe.f682fcp-4", "0xe.ed89db8p-4", "0xe.e46be58p-4", "0xe.db2931p-4", "0xe.d1c1d5p-4",
"0xe.c835e78p-4", "0xe.be85818p-4", "0xe.b4b0bap-4", "0xe.aab7a98p-4", "0xe.a09a69p-4", "0xe.9659108p-4", "0xe.8bf3ba8p-4", "0xe.816a7f8p-4",
"0xe.76bd7a8p-4", "0xe.6becc5p-4", "0xe.60f87ap-4", "0xe.55e0b5p-4", "0xe.4aa5908p-4", "0xe.3f4729p-4", "0xe.33c59a8p-4", "0xe.2821008p-4",
"0xe.1c5979p-4", "0xe.106f2p-4", "0xe.0462138p-4", "0xd.f83271p-4", "0xd.ebe0568p-4", "0xd.df6be28p-4", "0xd.d2d534p-4", "0xd.c61c698p-4",
"0xd.b941a28p-4", "0xd.ac44ff8p-4", "0xd.9f269f8p-4", "0xd.91e6a38p-4", "0xd.84852cp-4", "0xd.77025a8p-4", "0xd.695e4fp-4", "0xd.5b992c8p-4",
"0xd.4db3148p-4", "0xd.3fac298p-4", "0xd.31848d8p-4", "0xd.233c64p-4", "0xd.14d3d08p-4", "0xd.064af58p-4", "0xc.f7a1f8p-4", "0xc.e8d8fbp-4",
"0xc.d9f024p-4", "0xc.cae7978p-4", "0xc.bbbf7a8p-4", "0xc.ac77f28p-4", "0xc.9d1125p-4", "0xc.8d8b38p-4", "0xc.7de652p-4", "0xc.6e22998p-4",
"0xc.5e40358p-4", "0xc.4e3f4d8p-4", "0xc.3e2008p-4", "0xc.2de28d8p-4", "0xc.1d8706p-4", "0xc.0d0d9ap-4", "0xb.fc7672p-4", "0xb.ebc1b68p-4",
"0xb.daef918p-4", "0xb.ca002cp-4", "0xb.b8f3af8p-4", "0xb.a7ca47p-4", "0xb.96841cp-4", "0xb.85215ap-4", "0xb.73a22a8p-4", "0xb.6206bap-4",

"0xc.90fdaap-4", "0xc.90f87fp-4", "0xc.90e8fe8p-4", "0xc.90cf28p-4", "0xc.90aafcp-4", "0xc.907c7a8p-4", "0xc.9043a4p-4", "0xc.9000788p-4",
"0xc.8fb2f88p-4", "0xc.8f5b25p-4", "0xc.8ef8fd8p-4", "0xc.8e8c838p-4", "0xc.8e15b7p-4", "0xc.8d94998p-4", "0xc.8d092a8p-4", "0xc.8c736cp-4",
"0xc.8bd35ep-4", "0xc.8b2902p-4", "0xc.8a74588p-4", "0xc.89b563p-4", "0xc.88ec228p-4", "0xc.881898p-4", "0xc.873ac5p-4", "0xc.8652aa8p-4",
"0xc.8560498p-4", "0xc.8463a48p-4", "0xc.835cbcp-4", "0xc.824b918p-4", "0xc.813027p-4", "0xc.800a7e8p-4", "0xc.7eda988p-4", "0xc.7da078p-4",
"0xc.7c5c1ep-4", "0xc.7b0d8dp-4", "0xc.79b4c68p-4", "0xc.7851cc8p-4", "0xc.76e4a1p-4", "0xc.756d468p-4", "0xc.73ebbfp-4", "0xc.72600c8p-4",
"0xc.70ca318p-4", "0xc.6f2a3p-4", "0xc.6d800bp-4", "0xc.6bcbc48p-4", "0xc.6a0d5fp-4", "0xc.6844dd8p-4", "0xc.6672428p-4", "0xc.64959p-4",
"0xc.62aecap-4", "0xc.60bdf2p-4", "0xc.5ec30cp-4", "0xc.5cbe1a8p-4", "0xc.5aaf2p-4", "0xc.58962p-4", "0xc.56731ep-4", "0xc.54461c8p-4",
"0xc.520f1e8p-4", "0xc.4fce28p-4", "0xc.4d833c8p-4", "0xc.4b2e5e8p-4", "0xc.48cf918p-4", "0xc.4666dap-4", "0xc.43f43a8p-4", "0xc.4177b7p-4",
"0xc.3ef1538p-4", "0xc.3c6113p-4", "0xc.39c6fap-4", "0xc.37230cp-4", "0xc.34754dp-4", "0xc.31bdc1p-4", "0xc.2efc6b8p-4", "0xc.2c31518p-4",
"0xc.295c76p-4", "0xc.267dde8p-4", "0xc.23958ep-4", "0xc.20a389p-4", "0xc.1da7d48p-4", "0xc.1aa275p-4", "0xc.17936ep-4", "0xc.147ac48p-4",
"0xc.11587dp-4", "0xc.0e2c9cp-4", "0xc.0af7268p-4", "0xc.07b8218p-4", "0xc.046f91p-4", "0xc.011d7ap-4", "0xb.fdc1e18p-4", "0xb.fa5ccdp-4",
"0xb.f6ee41p-4", "0xb.f376428p-4", "0xb.eff4d68p-4", "0xb.ec6a028p-4", "0xb.e8d5cbp-4", "0xb.e538368p-4", "0xb.e191498p-4", "0xb.dde1098p-4",
"0xb.da277cp-4", "0xb.d664a6p-4", "0xb.d2988ep-4", "0xb.cec3388p-4", "0xb.cae4acp-4", "0xb.c6fceep-4", "0xb.c30c04p-4", "0xb.bf11f38p-4",
"0xb.bb0ec3p-4", "0xb.b70278p-4", "0xb.b2ed19p-4", "0xb.aeceabp-4", "0xb.aaa735p-4", "0xb.a676bc8p-4", "0xb.a23d48p-4", "0xb.9dfaddp-4",
"0xb.99af83p-4", "0xb.955b3fp-4", "0xb.90fe188p-4", "0xb.8c9815p-4", "0xb.88293b8p-4", "0xb.83b1928p-4", "0xb.7f312p-4", "0xb.7aa7ebp-4",
"0xb.7615fap-4", "0xb.717b54p-4", "0xb.6cd7ffp-4", "0xb.682c03p-4", "0xb.637766p-4", "0xb.5eba2e8p-4", "0xb.59f4648p-4", "0xb.55260e8p-4",
};

static const ap_fixed< 23 , 1 > sin_cos_K1 [ 256 ] = {
"-0x4.p-24", "-0x1.3bdcp-8", "-0x2.77a8p-8", "-0x3.b36cp-8", "-0x4.ef38p-8", "-0x6.2ae4p-8", "-0x7.668cp-8", "-0x8.a21cp-8",
"-0x9.dda8p-8", "-0xb.190cp-8", "-0xc.5454p-8", "-0xd.8f7cp-8", "-0xe.ca84p-8", "-0x1.00568p-4", "-0x1.1402cp-4", "-0x1.27acp-4",
"-0x1.3b524p-4", "-0x1.4ef54p-4", "-0x1.62964p-4", "-0x1.76328p-4", "-0x1.89cbcp-4", "-0x1.9d614p-4", "-0x1.b0f28p-4", "-0x1.c47f4p-4",
"-0x1.d8084p-4", "-0x1.eb8ccp-4", "-0x1.ff0c4p-4", "-0x2.1286cp-4", "-0x2.25fc8p-4", "-0x2.396c8p-4", "-0x2.4cd74p-4", "-0x2.603cp-4",
"-0x2.739bp-4", "-0x2.86f4cp-4", "-0x2.9a47p-4", "-0x2.ad934p-4", "-0x2.c0d9cp-4", "-0x2.d4184p-4", "-0x2.e751p-4", "-0x2.fa81p-4",
"-0x3.0dab4p-4", "-0x3.20cdp-4", "-0x3.33e74p-4", "-0x3.46fap-4", "-0x3.5a048p-4", "-0x3.6d064p-4", "-0x3.7fffcp-4", "-0x3.92f0cp-4",
"-0x3.a5d8cp-4", "-0x3.b8b78p-4", "-0x3.cb8d4p-4", "-0x3.de5acp-4", "-0x3.f11ccp-4", "-0x4.03d7p-4", "-0x4.1685cp-4", "-0x4.292cp-4",
"-0x4.3bc64p-4", "-0x4.4e56cp-4", "-0x4.60ddp-4", "-0x4.73588p-4", "-0x4.85c88p-4", "-0x4.982dp-4", "-0x4.aa86cp-4", "-0x4.bcd5cp-4",
"-0x4.cf174p-4", "-0x4.e14ecp-4", "-0x4.f3794p-4", "-0x5.05974p-4", "-0x5.17aap-4", "-0x5.29aecp-4", "-0x5.3ba84p-4", "-0x5.4d938p-4",
"-0x5.5f728p-4", "-0x5.7143cp-4", "-0x5.83074p-4", "-0x5.94bep-4", "-0x5.a6664p-4", "-0x5.b800cp-4", "-0x5.c98ep-4", "-0x5.db0bcp-4",
"-0x5.ec7cp-4", "-0x5.fddd4p-4", "-0x6.0f3p-4", "-0x6.20738p-4", "-0x6.31a7cp-4", "-0x6.42cccp-4", "-0x6.53e2cp-4", "-0x6.64e8cp-4",
"-0x6.75de4p-4", "-0x6.86c54p-4", "-0x6.979bp-4", "-0x6.a861p-4", "-0x6.b9164p-4", "-0x6.c9bcp-4", "-0x6.da4f8p-4", "-0x6.ead2cp-4",
"-0x6.fb44cp-4", "-0x7.0ba68p-4", "-0x7.1bf5cp-4", "-0x7.2c338p-4", "-0x7.3c608p-4", "-0x7.4c7acp-4", "-0x7.5c84p-4", "-0x7.6c798p-4",
"-0x7.7c5d4p-4", "-0x7.8c2fp-4", "-0x7.9beep-4", "-0x7.ab9a4p-4", "-0x7.bb338p-4", "-0x7.cab94p-4", "-0x7.da2c8p-4", "-0x7.e98cp-4",
"-0x7.f8d7cp-4", "-0x8.0810cp-4", "-0x8.1734cp-4", "-0x8.26458p-4", "-0x8.3541cp-4", "-0x8.442a4p-4", "-0x8.52fe4p-4", "-0x8.61bd4p-4",
"-0x8.70684p-4", "-0x8.7efe4p-4", "-0x8.8d7e4p-4", "-0x8.9beap-4", "-0x8.aa40cp-4", "-0x8.b882cp-4", "-0x8.c6adp-4", "-0x8.d4c34p-4",

"0x8.p-24", "-0x5.2a8p-12", "-0xa.56p-12", "-0xf.81p-12", "-0x1.4acp-8", "-0x1.9d64p-8", "-0x1.f014p-8", "-0x2.42b4p-8",
"-0x2.955p-8", "-0x2.e7f4p-8", "-0x3.3a84p-8", "-0x3.8d18p-8", "-0x3.dfa8p-8", "-0x4.3238p-8", "-0x4.84b4p-8", "-0x4.d734p-8",
"-0x5.29a8p-8", "-0x5.7c14p-8", "-0x5.ce74p-8", "-0x6.20dp-8", "-0x6.7328p-8", "-0x6.c574p-8", "-0x7.17bcp-8", "-0x7.69fp-8",
"-0x7.bc18p-8", "-0x8.0e4p-8", "-0x8.6054p-8", "-0x8.b254p-8", "-0x9.044cp-8", "-0x9.564p-8", "-0x9.a814p-8", "-0x9.f9e8p-8",
"-0xa.4ba8p-8", "-0xa.9d64p-8", "-0xa.ef08p-8", "-0xb.4098p-8", "-0xb.9218p-8", "-0xb.e39p-8", "-0xc.34f4p-8", "-0xc.8644p-8",
"-0xc.d78p-8", "-0xd.28a4p-8", "-0xd.79bcp-8", "-0xd.cab8p-8", "-0xe.1bap-8", "-0xe.6c7cp-8", "-0xe.bd4p-8", "-0xf.0de4p-8",
"-0xf.5e7cp-8", "-0xf.aef4p-8", "-0xf.ff64p-8", "-0x1.04fb8p-4", "-0x1.09fecp-4", "-0x1.0f00cp-4", "-0x1.1401cp-4", "-0x1.19008p-4",
"-0x1.1dfdp-4", "-0x1.22f88p-4", "-0x1.27f38p-4", "-0x1.2ceb8p-4", "-0x1.31e14p-4", "-0x1.36d6cp-4", "-0x1.3bc94p-4", "-0x1.40ba4p-4",
"-0x1.45a9cp-4", "-0x1.4a968p-4", "-0x1.4f82p-4", "-0x1.546b8p-4", "-0x1.59538p-4", "-0x1.5e39p-4", "-0x1.631c4p-4", "-0x1.67fep-4",
"-0x1.6cdccp-4", "-0x1.71bb4p-4", "-0x1.7696p-4", "-0x1.7b6e4p-4", "-0x1.8045p-4", "-0x1.851bp-4", "-0x1.89ed4p-4", "-0x1.8ebd8p-4",
"-0x1.938bp-4", "-0x1.9856p-4", "-0x1.9d1fp-4", "-0x1.a1e6cp-4", "-0x1.a6abp-4", "-0x1.ab6c4p-4", "-0x1.b02b8p-4", "-0x1.b4e9p-4",
"-0x1.b9a38p-4", "-0x1.be5cp-4", "-0x1.c310cp-4", "-0x1.c7c3cp-4", "-0x1.cc734p-4", "-0x1.d1214p-4", "-0x1.d5cc4p-4", "-0x1.da748p-4",
"-0x1.df19cp-4", "-0x1.e3bc4p-4", "-0x1.e85c4p-4", "-0x1.ecf8cp-4", "-0x1.f1938p-4", "-0x1.f62acp-4", "-0x1.fabfcp-4", "-0x1.ff51p-4",
"-0x2.03df8p-4", "-0x2.086bp-4", "-0x2.0cf48p-4", "-0x2.117ap-4", "-0x2.15fdp-4", "-0x2.1a7c4p-4", "-0x2.1ef9p-4", "-0x2.2371cp-4",
"-0x2.27e84p-4", "-0x2.2c5bp-4", "-0x2.30cb4p-4", "-0x2.3537cp-4", "-0x2.39a14p-4", "-0x2.3e088p-4", "-0x2.426b4p-4", "-0x2.46cacp-4",
"-0x2.4b268p-4", "-0x2.4f7fcp-4", "-0x2.53d5p-4", "-0x2.58274p-4", "-0x2.5c764p-4", "-0x2.60c0cp-4", "-0x2.6509p-4", "-0x2.694d4p-4",
};

static const ap_fixed< 15 , 0 > sin_cos_K2 [ 256 ] = {
"-0x4.ef2p-4", "-0x4.efp-4", "-0x4.ef2p-4", "-0x4.efp-4", "-0x4.eeap-4", "-0x4.eeap-4", "-0x4.ee4p-4", "-0x4.ee2p-4",
"-0x4.ed4p-4", "-0x4.ecep-4", "-0x4.ec8p-4", "-0x4.ec2p-4", "-0x4.ebap-4", "-0x4.ebp-4", "-0x4.ea4p-4", "-0x4.e98p-4",
"-0x4.e8ep-4", "-0x4.e84p-4", "-0x4.e7p-4", "-0x4.e64p-4", "-0x4.e54p-4", "-0x4.e42p-4", "-0x4.e34p-4", "-0x4.e24p-4",
"-0x4.e1p-4", "-0x4.dfcp-4", "-0x4.de8p-4", "-0x4.dd6p-4", "-0x4.dbep-4", "-0x4.da8p-4", "-0x4.d92p-4", "-0x4.d7cp-4",
"-0x4.d66p-4", "-0x4.d48p-4", "-0x4.d32p-4", "-0x4.d1ap-4", "-0x4.cfap-4", "-0x4.ce2p-4", "-0x4.ccp-4", "-0x4.caap-4",
"-0x4.c86p-4", "-0x4.c68p-4", "-0x4.c4ap-4", "-0x4.c28p-4", "-0x4.c04p-4", "-0x4.be4p-4", "-0x4.bc2p-4", "-0x4.b9ep-4",
"-0x4.b7cp-4", "-0x4.b5ap-4", "-0x4.b36p-4", "-0x4.b0ap-4", "-0x4.aeap-4", "-0x4.abcp-4", "-0x4.a98p-4", "-0x4.a68p-4",
"-0x4.a44p-4", "-0x4.a1ap-4", "-0x4.9ecp-4", "-0x4.9bep-4", "-0x4.994p-4", "-0x4.96ap-4", "-0x4.93cp-4", "-0x4.908p-4",
"-0x4.8ep-4", "-0x4.8a8p-4", "-0x4.878p-4", "-0x4.84ap-4", "-0x4.812p-4", "-0x4.7e4p-4", "-0x4.7aap-4", "-0x4.77ap-4",
"-0x4.744p-4", "-0x4.70ep-4", "-0x4.6dcp-4", "-0x4.6a2p-4", "-0x4.66cp-4", "-0x4.636p-4", "-0x4.5f8p-4", "-0x4.5c2p-4",
"-0x4.586p-4", "-0x4.54ap-4", "-0x4.50cp-4", "-0x4.4dp-4", "-0x4.494p-4", "-0x4.456p-4", "-0x4.416p-4", "-0x4.3d6p-4",
"-0x4.39cp-4", "-0x4.356p-4", "-0x4.318p-4", "-0x4.2d6p-4", "-0x4.296p-4", "-0x4.24ep-4", "-0x4.20ep-4", "-0x4.1cap-4",
"-0x4.188p-4", "-0x4.13cp-4", "-0x4.0f8p-4", "-0x4.0b4p-4", "-0x4.06ap-4", "-0x4.022p-4", "-0x3.fd4p-4", "-0x3.f9p-4",
"-0x3.f4ap-4", "-0x3.efep-4", "-0x3.eb2p-4", "-0x3.e66p-4", "-0x3.e1ap-4", "-0x3.ddp-4", "-0x3.d7ep-4", "-0x3.d3p-4",
"-0x3.ce4p-4", "-0x3.c92p-4", "-0x3.c46p-4", "-0x3.bf2p-4", "-0x3.ba4p-4", "-0x3.b5p-4", "-0x3.afep-4", "-0x3.aacp-4",
"-0x3.a56p-4", "-0x3.ap-4", "-0x3.9b2p-4", "-0x3.95ep-4", "-0x3.904p-4", "-0x3.8a8p-4", "-0x3.85cp-4", "-0x3.802p-4",

"-0x1.4bp-4", "-0x1.4aep-4", "-0x1.4aap-4", "-0x1.4a8p-4", "-0x1.4a6p-4", "-0x1.4aap-4", "-0x1.4a4p-4", "-0x1.4a6p-4",
"-0x1.4a6p-4", "-0x1.4a4p-4", "-0x1.4a6p-4", "-0x1.4a6p-4", "-0x1.4a2p-4", "-0x1.4ap-4", "-0x1.4ap-4", "-0x1.49ep-4",
"-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49ap-4", "-0x1.496p-4", "-0x1.492p-4", "-0x1.48cp-4", "-0x1.48cp-4",
"-0x1.488p-4", "-0x1.482p-4", "-0x1.48p-4", "-0x1.48p-4", "-0x1.47cp-4", "-0x1.478p-4", "-0x1.478p-4", "-0x1.474p-4",
"-0x1.47p-4", "-0x1.468p-4", "-0x1.464p-4", "-0x1.462p-4", "-0x1.45ep-4", "-0x1.456p-4", "-0x1.45p-4", "-0x1.44ap-4",
"-0x1.446p-4", "-0x1.442p-4", "-0x1.43cp-4", "-0x1.43ap-4", "-0x1.436p-4", "-0x1.42ep-4", "-0x1.42ap-4", "-0x1.426p-4",
"-0x1.422p-4", "-0x1.41ep-4", "-0x1.414p-4", "-0x1.40ep-4", "-0x1.40ap-4", "-0x1.402p-4", "-0x1.3f8p-4", "-0x1.3f4p-4",
"-0x1.3f2p-4", "-0x1.3ecp-4", "-0x1.3dcp-4", "-0x1.3d8p-4", "-0x1.3d6p-4", "-0x1.3c8p-4", "-0x1.3c4p-4", "-0x1.3bcp-4",
"-0x1.3b4p-4", "-0x1.3bp-4", "-0x1.3a8p-4", "-0x1.3ap-4", "-0x1.394p-4", "-0x1.38ep-4", "-0x1.386p-4", "-0x1.37ep-4",
"-0x1.37ap-4", "-0x1.368p-4", "-0x1.364p-4", "-0x1.36p-4", "-0x1.358p-4", "-0x1.344p-4", "-0x1.33cp-4", "-0x1.332p-4",
"-0x1.32cp-4", "-0x1.326p-4", "-0x1.31ep-4", "-0x1.30cp-4", "-0x1.304p-4", "-0x1.3p-4", "-0x1.2f6p-4", "-0x1.2e8p-4",
"-0x1.2ep-4", "-0x1.2dp-4", "-0x1.2ccp-4", "-0x1.2cp-4", "-0x1.2b8p-4", "-0x1.2aap-4", "-0x1.29ep-4", "-0x1.292p-4",
"-0x1.28ap-4", "-0x1.27ep-4", "-0x1.274p-4", "-0x1.26cp-4", "-0x1.25cp-4", "-0x1.254p-4", "-0x1.244p-4", "-0x1.23ap-4",
"-0x1.23p-4", "-0x1.226p-4", "-0x1.214p-4", "-0x1.208p-4", "-0x1.1fap-4", "-0x1.1f2p-4", "-0x1.1e4p-4", "-0x1.1dap-4",
"-0x1.1cep-4", "-0x1.1c2p-4", "-0x1.1b4p-4", "-0x1.1a8p-4", "-0x1.19cp-4", "-0x1.186p-4", "-0x1.17ap-4", "-0x1.16ep-4",
"-0x1.166p-4", "-0x1.156p-4", "-0x1.148p-4", "-0x1.13cp-4", "-0x1.12cp-4", "-0x1.122p-4", "-0x1.11p-4", "-0x1.104p-4",
};
};

namespace first_order_half {


static const ap_fixed< 15 , 0 > cos_K0 [ 256 ] = {
"0", "0", "0", "0x4.p-16", "0x4.p-16", "0x8.p-16", "0xc.p-16", "0x1.p-12",
"0x1.4p-12", "0x1.8p-12", "0x2.p-12", "0x2.4p-12", "0x2.cp-12", "0x3.4p-12", "0x3.cp-12", "0x4.4p-12",
"0x5.p-12", "0x5.8p-12", "0x6.4p-12", "0x7.p-12", "0x7.cp-12", "0x8.8p-12", "0x9.4p-12", "0xa.4p-12",
"0xb.p-12", "0xc.p-12", "0xd.p-12", "0xe.p-12", "0xf.p-12", "0x1.04p-8", "0x1.14p-8", "0x1.28p-8",
"0x1.3cp-8", "0x1.5p-8", "0x1.64p-8", "0x1.78p-8", "0x1.9p-8", "0x1.a4p-8", "0x1.bcp-8", "0x1.d4p-8",
"0x1.ecp-8", "0x2.04p-8", "0x2.2p-8", "0x2.38p-8", "0x2.54p-8", "0x2.7p-8", "0x2.8cp-8", "0x2.a8p-8",
"0x2.c4p-8", "0x2.e4p-8", "0x3.p-8", "0x3.2p-8", "0x3.4p-8", "0x3.6p-8", "0x3.8p-8", "0x3.a4p-8",
"0x3.c4p-8", "0x3.e8p-8", "0x4.0cp-8", "0x4.3p-8", "0x4.54p-8", "0x4.78p-8", "0x4.9cp-8", "0x4.c4p-8",
"0x4.ecp-8", "0x5.14p-8", "0x5.3cp-8", "0x5.64p-8", "0x5.8cp-8", "0x5.b8p-8", "0x5.ep-8", "0x6.0cp-8",
"0x6.38p-8", "0x6.64p-8", "0x6.9p-8", "0x6.cp-8", "0x6.ecp-8", "0x7.1cp-8", "0x7.4cp-8", "0x7.7cp-8",
"0x7.acp-8", "0x7.dcp-8", "0x8.1p-8", "0x8.4p-8", "0x8.74p-8", "0x8.a8p-8", "0x8.dcp-8", "0x9.1p-8",
"0x9.44p-8", "0x9.7cp-8", "0x9.b4p-8", "0x9.e8p-8", "0xa.2p-8", "0xa.58p-8", "0xa.94p-8", "0xa.ccp-8",
"0xb.04p-8", "0xb.4p-8", "0xb.7cp-8", "0xb.b8p-8", "0xb.f4p-8", "0xc.3p-8", "0xc.7p-8", "0xc.acp-8",
"0xc.ecp-8", "0xd.2cp-8", "0xd.6cp-8", "0xd.acp-8", "0xd.ecp-8", "0xe.3p-8", "0xe.7p-8", "0xe.b4p-8",
"0xe.f8p-8", "0xf.3cp-8", "0xf.8p-8", "0xf.c4p-8", "0x1.00cp-4", "0x1.05p-4", "0x1.098p-4", "0x1.0ep-4",
"0x1.128p-4", "0x1.17p-4", "0x1.1b8p-4", "0x1.204p-4", "0x1.24cp-4", "0x1.298p-4", "0x1.2e4p-4", "0x1.33p-4",
"0x1.37cp-4", "0x1.3c8p-4", "0x1.418p-4", "0x1.464p-4", "0x1.4b4p-4", "0x1.504p-4", "0x1.554p-4", "0x1.5a4p-4",
"0x1.5f8p-4", "0x1.648p-4", "0x1.69cp-4", "0x1.6ecp-4", "0x1.74p-4", "0x1.794p-4", "0x1.7e8p-4", "0x1.84p-4",
"0x1.894p-4", "0x1.8ecp-4", "0x1.94p-4", "0x1.998p-4", "0x1.9fp-4", "0x1.a48p-4", "0x1.aap-4", "0x1.afcp-4",
"0x1.b54p-4", "0x1.bbp-4", "0x1.c0cp-4", "0x1.c68p-4", "0x1.cc4p-4", "0x1.d2p-4", "0x1.d7cp-4", "0x1.ddcp-4",
"0x1.e3cp-4", "0x1.e98p-4", "0x1.ef8p-4", "0x1.f58p-4", "0x1.fb8p-4", "0x2.01cp-4", "0x2.07cp-4", "0x2.0ep-4",
"0x2.14p-4", "0x2.1a4p-4", "0x2.208p-4", "0x2.26cp-4", "0x2.2d4p-4", "0x2.338p-4", "0x2.3ap-4", "0x2.404p-4",
"0x2.46cp-4", "0x2.4d4p-4", "0x2.53cp-4", "0x2.5a4p-4", "0x2.60cp-4", "0x2.678p-4", "0x2.6ep-4", "0x2.74cp-4",
"0x2.7b8p-4", "0x2.824p-4", "0x2.89p-4", "0x2.8fcp-4", "0x2.96cp-4", "0x2.9d8p-4", "0x2.a48p-4", "0x2.ab4p-4",
"0x2.b24p-4", "0x2.b94p-4", "0x2.c04p-4", "0x2.c78p-4", "0x2.ce8p-4", "0x2.d58p-4", "0x2.dccp-4", "0x2.e4p-4",
"0x2.eb4p-4", "0x2.f28p-4", "0x2.f9cp-4", "0x3.01p-4", "0x3.084p-4", "0x3.0fcp-4", "0x3.174p-4", "0x3.1e8p-4",
"0x3.26p-4", "0x3.2d8p-4", "0x3.35p-4", "0x3.3ccp-4", "0x3.444p-4", "0x3.4bcp-4", "0x3.538p-4", "0x3.5b4p-4",
"0x3.63p-4", "0x3.6acp-4", "0x3.728p-4", "0x3.7a4p-4", "0x3.82p-4", "0x3.8ap-4", "0x3.91cp-4", "0x3.99cp-4",
"0x3.a1cp-4", "0x3.a9cp-4", "0x3.b1cp-4", "0x3.b9cp-4", "0x3.c1cp-4", "0x3.cap-4", "0x3.d2p-4", "0x3.da4p-4",
"0x3.e28p-4", "0x3.eacp-4", "0x3.f3p-4", "0x3.fb4p-4", "0x4.038p-4", "0x4.0bcp-4", "0x4.144p-4", "0x4.1ccp-4",
"0x4.25p-4", "0x4.2d8p-4", "0x4.36p-4", "0x4.3e8p-4", "0x4.47p-4", "0x4.4f8p-4", "0x4.584p-4", "0x4.60cp-4",
"0x4.698p-4", "0x4.724p-4", "0x4.7acp-4", "0x4.838p-4", "0x4.8c4p-4", "0x4.954p-4", "0x4.9ep-4", "0x4.a6cp-4",
};

static const ap_fixed< 7 , 1 > cos_K1 [ 256 ] = {
"0", "0", "0x4.p-8", "0", "0x4.p-8", "0x4.p-8", "0x4.p-8", "0x4.p-8",
"0x4.p-8", "0x8.p-8", "0x4.p-8", "0x8.p-8", "0x8.p-8", "0x8.p-8", "0x8.p-8", "0xc.p-8",
"0x8.p-8", "0xc.p-8", "0xc.p-8", "0xc.p-8", "0xc.p-8", "0xc.p-8", "0x1.p-4", "0xc.p-8",
"0x1.p-4", "0x1.p-4", "0x1.p-4", "0x1.p-4", "0x1.4p-4", "0x1.p-4", "0x1.4p-4", "0x1.4p-4",
"0x1.4p-4", "0x1.4p-4", "0x1.4p-4", "0x1.8p-4", "0x1.4p-4", "0x1.8p-4", "0x1.8p-4", "0x1.8p-4",
"0x1.cp-4", "0x1.cp-4", "0x1.8p-4", "0x1.cp-4", "0x1.cp-4", "0x1.cp-4", "0x1.cp-4", "0x1.cp-4",
"0x2.p-4", "0x1.cp-4", "0x2.p-4", "0x2.p-4", "0x2.p-4", "0x2.p-4", "0x2.4p-4", "0x2.p-4",
"0x2.4p-4", "0x2.4p-4", "0x2.4p-4", "0x2.4p-4", "0x2.4p-4", "0x2.8p-4", "0x2.8p-4", "0x2.8p-4",
"0x2.8p-4", "0x2.8p-4", "0x2.8p-4", "0x2.8p-4", "0x2.cp-4", "0x2.8p-4", "0x2.cp-4", "0x2.cp-4",
"0x2.cp-4", "0x2.cp-4", "0x3.p-4", "0x2.cp-4", "0x3.p-4", "0x3.p-4", "0x3.p-4", "0x3.p-4",
"0x3.p-4", "0x3.4p-4", "0x3.p-4", "0x3.4p-4", "0x3.4p-4", "0x3.4p-4", "0x3.4p-4", "0x3.8p-4",
"0x3.8p-4", "0x3.8p-4", "0x3.4p-4", "0x3.8p-4", "0x3.8p-4", "0x3.cp-4", "0x3.8p-4", "0x3.8p-4",
"0x3.cp-4", "0x3.cp-4", "0x3.cp-4", "0x3.cp-4", "0x3.cp-4", "0x4.p-4", "0x3.cp-4", "0x4.p-4",
"0x4.p-4", "0x4.p-4", "0x4.p-4", "0x4.p-4", "0x4.4p-4", "0x4.p-4", "0x4.4p-4", "0x4.4p-4",
"0x4.4p-4", "0x4.4p-4", "0x4.4p-4", "0x4.8p-4", "0x4.4p-4", "0x4.8p-4", "0x4.8p-4", "0x4.8p-4",
"0x4.8p-4", "0x4.8p-4", "0x4.cp-4", "0x4.8p-4", "0x4.cp-4", "0x4.cp-4", "0x4.cp-4", "0x4.cp-4",
"0x5.p-4", "0x5.p-4", "0x4.cp-4", "0x5.p-4", "0x5.p-4", "0x5.p-4", "0x5.p-4", "0x5.4p-4",
"0x5.p-4", "0x5.4p-4", "0x5.p-4", "0x5.4p-4", "0x5.4p-4", "0x5.4p-4", "0x5.8p-4", "0x5.4p-4",
"0x5.8p-4", "0x5.4p-4", "0x5.8p-4", "0x5.8p-4", "0x5.8p-4", "0x5.cp-4", "0x5.cp-4", "0x5.8p-4",
"0x5.cp-4", "0x5.cp-4", "0x5.cp-4", "0x5.cp-4", "0x5.cp-4", "0x6.p-4", "0x6.p-4", "0x6.p-4",
"0x5.cp-4", "0x6.p-4", "0x6.p-4", "0x6.4p-4", "0x6.4p-4", "0x6.p-4", "0x6.4p-4", "0x6.p-4",
"0x6.4p-4", "0x6.4p-4", "0x6.8p-4", "0x6.8p-4", "0x6.4p-4", "0x6.8p-4", "0x6.4p-4", "0x6.8p-4",
"0x6.8p-4", "0x6.8p-4", "0x6.8p-4", "0x6.8p-4", "0x6.cp-4", "0x6.8p-4", "0x6.cp-4", "0x6.cp-4",
"0x6.cp-4", "0x6.cp-4", "0x6.cp-4", "0x7.p-4", "0x6.cp-4", "0x7.p-4", "0x6.cp-4", "0x7.p-4",
"0x7.p-4", "0x7.p-4", "0x7.4p-4", "0x7.p-4", "0x7.p-4", "0x7.4p-4", "0x7.4p-4", "0x7.4p-4",
"0x7.4p-4", "0x7.4p-4", "0x7.4p-4", "0x7.4p-4", "0x7.8p-4", "0x7.8p-4", "0x7.4p-4", "0x7.8p-4",
"0x7.8p-4", "0x7.8p-4", "0x7.cp-4", "0x7.8p-4", "0x7.8p-4", "0x7.cp-4", "0x7.cp-4", "0x7.cp-4",
"0x7.cp-4", "0x7.cp-4", "0x7.cp-4", "0x7.cp-4", "0x8.p-4", "0x7.cp-4", "0x8.p-4", "0x8.p-4",
"0x8.p-4", "0x8.p-4", "0x8.p-4", "0x8.4p-4", "0x8.4p-4", "0x8.p-4", "0x8.4p-4", "0x8.4p-4",
"0x8.4p-4", "0x8.4p-4", "0x8.4p-4", "0x8.4p-4", "0x8.8p-4", "0x8.8p-4", "0x8.8p-4", "0x8.4p-4",
"0x8.8p-4", "0x8.8p-4", "0x8.8p-4", "0x8.8p-4", "0x8.cp-4", "0x8.cp-4", "0x8.8p-4", "0x8.cp-4",
"0x8.cp-4", "0x8.8p-4", "0x9.p-4", "0x9.p-4", "0x9.p-4", "0x8.cp-4", "0x8.cp-4", "0x9.p-4",
};



static const ap_fixed< 16 , 1 > sin_K0 [ 256 ] = {
"0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.90cp-4", "0xc.90cp-4", "0xc.90cp-4",
"0xc.90cp-4", "0xc.908p-4", "0xc.908p-4", "0xc.908p-4", "0xc.904p-4", "0xc.904p-4", "0xc.9p-4", "0xc.8fcp-4",
"0xc.8fcp-4", "0xc.8f8p-4", "0xc.8f4p-4", "0xc.8f4p-4", "0xc.8fp-4", "0xc.8ecp-4", "0xc.8e8p-4", "0xc.8e4p-4",
"0xc.8ep-4", "0xc.8dcp-4", "0xc.8d8p-4", "0xc.8d4p-4", "0xc.8dp-4", "0xc.8ccp-4", "0xc.8c8p-4", "0xc.8c4p-4",
"0xc.8bcp-4", "0xc.8b8p-4", "0xc.8b4p-4", "0xc.8acp-4", "0xc.8a8p-4", "0xc.8ap-4", "0xc.89cp-4", "0xc.894p-4",
"0xc.89p-4", "0xc.888p-4", "0xc.88p-4", "0xc.87cp-4", "0xc.874p-4", "0xc.86cp-4", "0xc.864p-4", "0xc.85cp-4",
"0xc.858p-4", "0xc.85p-4", "0xc.848p-4", "0xc.84p-4", "0xc.834p-4", "0xc.82cp-4", "0xc.824p-4", "0xc.81cp-4",
"0xc.814p-4", "0xc.808p-4", "0xc.8p-4", "0xc.7f8p-4", "0xc.7ecp-4", "0xc.7e4p-4", "0xc.7dcp-4", "0xc.7dp-4",
"0xc.7c4p-4", "0xc.7bcp-4", "0xc.7bp-4", "0xc.7a8p-4", "0xc.79cp-4", "0xc.79p-4", "0xc.784p-4", "0xc.778p-4",
"0xc.77p-4", "0xc.764p-4", "0xc.758p-4", "0xc.74cp-4", "0xc.74p-4", "0xc.734p-4", "0xc.728p-4", "0xc.718p-4",
"0xc.70cp-4", "0xc.7p-4", "0xc.6f4p-4", "0xc.6e4p-4", "0xc.6d8p-4", "0xc.6ccp-4", "0xc.6bcp-4", "0xc.6bp-4",
"0xc.6ap-4", "0xc.694p-4", "0xc.684p-4", "0xc.674p-4", "0xc.668p-4", "0xc.658p-4", "0xc.648p-4", "0xc.63cp-4",
"0xc.62cp-4", "0xc.61cp-4", "0xc.60cp-4", "0xc.5fcp-4", "0xc.5ecp-4", "0xc.5dcp-4", "0xc.5ccp-4", "0xc.5bcp-4",
"0xc.5acp-4", "0xc.59cp-4", "0xc.588p-4", "0xc.578p-4", "0xc.568p-4", "0xc.554p-4", "0xc.544p-4", "0xc.534p-4",
"0xc.52p-4", "0xc.51p-4", "0xc.4fcp-4", "0xc.4ecp-4", "0xc.4d8p-4", "0xc.4c4p-4", "0xc.4b4p-4", "0xc.4ap-4",
"0xc.48cp-4", "0xc.478p-4", "0xc.468p-4", "0xc.454p-4", "0xc.44p-4", "0xc.42cp-4", "0xc.418p-4", "0xc.404p-4",
"0xc.3fp-4", "0xc.3dcp-4", "0xc.3c8p-4", "0xc.3bp-4", "0xc.39cp-4", "0xc.388p-4", "0xc.374p-4", "0xc.35cp-4",
"0xc.348p-4", "0xc.33p-4", "0xc.31cp-4", "0xc.304p-4", "0xc.2fp-4", "0xc.2d8p-4", "0xc.2c4p-4", "0xc.2acp-4",
"0xc.294p-4", "0xc.28p-4", "0xc.268p-4", "0xc.25p-4", "0xc.238p-4", "0xc.22p-4", "0xc.20cp-4", "0xc.1f4p-4",
"0xc.1dcp-4", "0xc.1c4p-4", "0xc.1acp-4", "0xc.19p-4", "0xc.178p-4", "0xc.16p-4", "0xc.148p-4", "0xc.13p-4",
"0xc.114p-4", "0xc.0fcp-4", "0xc.0e4p-4", "0xc.0c8p-4", "0xc.0bp-4", "0xc.094p-4", "0xc.07cp-4", "0xc.06p-4",
"0xc.048p-4", "0xc.02cp-4", "0xc.01p-4", "0xb.ff8p-4", "0xb.fdcp-4", "0xb.fcp-4", "0xb.fa4p-4", "0xb.f8cp-4",
"0xb.f7p-4", "0xb.f54p-4", "0xb.f38p-4", "0xb.f1cp-4", "0xb.fp-4", "0xb.ee4p-4", "0xb.ec8p-4", "0xb.eacp-4",
"0xb.e8cp-4", "0xb.e7p-4", "0xb.e54p-4", "0xb.e38p-4", "0xb.e18p-4", "0xb.dfcp-4", "0xb.dep-4", "0xb.dcp-4",
"0xb.da4p-4", "0xb.d84p-4", "0xb.d68p-4", "0xb.d48p-4", "0xb.d28p-4", "0xb.d0cp-4", "0xb.cecp-4", "0xb.cccp-4",
"0xb.cbp-4", "0xb.c9p-4", "0xb.c7p-4", "0xb.c5p-4", "0xb.c3p-4", "0xb.c1p-4", "0xb.bfp-4", "0xb.bdp-4",
"0xb.bbp-4", "0xb.b9p-4", "0xb.b7p-4", "0xb.b5p-4", "0xb.b3p-4", "0xb.b0cp-4", "0xb.aecp-4", "0xb.accp-4",
"0xb.aacp-4", "0xb.a88p-4", "0xb.a68p-4", "0xb.a44p-4", "0xb.a24p-4", "0xb.ap-4", "0xb.9ep-4", "0xb.9bcp-4",
"0xb.99cp-4", "0xb.978p-4", "0xb.954p-4", "0xb.934p-4", "0xb.91p-4", "0xb.8ecp-4", "0xb.8c8p-4", "0xb.8a8p-4",
"0xb.884p-4", "0xb.86p-4", "0xb.83cp-4", "0xb.818p-4", "0xb.7f4p-4", "0xb.7dp-4", "0xb.7acp-4", "0xb.788p-4",
"0xb.76p-4", "0xb.73cp-4", "0xb.718p-4", "0xb.6f4p-4", "0xb.6ccp-4", "0xb.6a8p-4", "0xb.684p-4", "0xb.65cp-4",
"0xb.638p-4", "0xb.61p-4", "0xb.5ecp-4", "0xb.5c4p-4", "0xb.5ap-4", "0xb.578p-4", "0xb.554p-4", "0xb.52cp-4",
};

static const ap_fixed< 6 , -1 > sin_K1 [ 256 ] = {
"0", "0", "0", "0", "-0x4.p-8", "0", "0", "0",
"-0x4.p-8", "0", "0", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "0",
"-0x4.p-8", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x8.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8",
"-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x4.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8",
"-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8",
"-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4",
"-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4",
"-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.cp-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4",
"-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4",
"-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",
};

static const ap_fixed< 15 , 1 > sin_cos_K0 [ 512 ] = {
"0x1.p0", "0x1.p0", "0x1.p0", "0xf.ffcp-4", "0xf.ffcp-4", "0xf.ff8p-4", "0xf.ff4p-4", "0xf.ffp-4",
"0xf.fecp-4", "0xf.fe8p-4", "0xf.fep-4", "0xf.fdcp-4", "0xf.fd4p-4", "0xf.fccp-4", "0xf.fc4p-4", "0xf.fbcp-4",
"0xf.fbp-4", "0xf.fa8p-4", "0xf.f9cp-4", "0xf.f9p-4", "0xf.f84p-4", "0xf.f78p-4", "0xf.f6cp-4", "0xf.f5cp-4",
"0xf.f5p-4", "0xf.f4p-4", "0xf.f3p-4", "0xf.f2p-4", "0xf.f1p-4", "0xf.efcp-4", "0xf.eecp-4", "0xf.ed8p-4",
"0xf.ec4p-4", "0xf.ebp-4", "0xf.e9cp-4", "0xf.e88p-4", "0xf.e7p-4", "0xf.e5cp-4", "0xf.e44p-4", "0xf.e2cp-4",
"0xf.e14p-4", "0xf.dfcp-4", "0xf.dep-4", "0xf.dc8p-4", "0xf.dacp-4", "0xf.d9p-4", "0xf.d74p-4", "0xf.d58p-4",
"0xf.d3cp-4", "0xf.d1cp-4", "0xf.dp-4", "0xf.cep-4", "0xf.ccp-4", "0xf.cap-4", "0xf.c8p-4", "0xf.c5cp-4",
"0xf.c3cp-4", "0xf.c18p-4", "0xf.bf4p-4", "0xf.bdp-4", "0xf.bacp-4", "0xf.b88p-4", "0xf.b64p-4", "0xf.b3cp-4",
"0xf.b14p-4", "0xf.aecp-4", "0xf.ac4p-4", "0xf.a9cp-4", "0xf.a74p-4", "0xf.a48p-4", "0xf.a2p-4", "0xf.9f4p-4",
"0xf.9c8p-4", "0xf.99cp-4", "0xf.97p-4", "0xf.94p-4", "0xf.914p-4", "0xf.8e4p-4", "0xf.8b4p-4", "0xf.884p-4",
"0xf.854p-4", "0xf.824p-4", "0xf.7fp-4", "0xf.7cp-4", "0xf.78cp-4", "0xf.758p-4", "0xf.724p-4", "0xf.6fp-4",
"0xf.6bcp-4", "0xf.684p-4", "0xf.64cp-4", "0xf.618p-4", "0xf.5ep-4", "0xf.5a8p-4", "0xf.56cp-4", "0xf.534p-4",
"0xf.4fcp-4", "0xf.4cp-4", "0xf.484p-4", "0xf.448p-4", "0xf.40cp-4", "0xf.3dp-4", "0xf.39p-4", "0xf.354p-4",
"0xf.314p-4", "0xf.2d4p-4", "0xf.294p-4", "0xf.254p-4", "0xf.214p-4", "0xf.1dp-4", "0xf.19p-4", "0xf.14cp-4",
"0xf.108p-4", "0xf.0c4p-4", "0xf.08p-4", "0xf.03cp-4", "0xe.ff4p-4", "0xe.fbp-4", "0xe.f68p-4", "0xe.f2p-4",
"0xe.ed8p-4", "0xe.e9p-4", "0xe.e48p-4", "0xe.dfcp-4", "0xe.db4p-4", "0xe.d68p-4", "0xe.d1cp-4", "0xe.cdp-4",
"0xe.c84p-4", "0xe.c38p-4", "0xe.be8p-4", "0xe.b9cp-4", "0xe.b4cp-4", "0xe.afcp-4", "0xe.aacp-4", "0xe.a5cp-4",
"0xe.a08p-4", "0xe.9b8p-4", "0xe.964p-4", "0xe.914p-4", "0xe.8cp-4", "0xe.86cp-4", "0xe.818p-4", "0xe.7cp-4",
"0xe.76cp-4", "0xe.714p-4", "0xe.6cp-4", "0xe.668p-4", "0xe.61p-4", "0xe.5b8p-4", "0xe.56p-4", "0xe.504p-4",
"0xe.4acp-4", "0xe.45p-4", "0xe.3f4p-4", "0xe.398p-4", "0xe.33cp-4", "0xe.2ep-4", "0xe.284p-4", "0xe.224p-4",
"0xe.1c4p-4", "0xe.168p-4", "0xe.108p-4", "0xe.0a8p-4", "0xe.048p-4", "0xd.fe4p-4", "0xd.f84p-4", "0xd.f2p-4",
"0xd.ecp-4", "0xd.e5cp-4", "0xd.df8p-4", "0xd.d94p-4", "0xd.d2cp-4", "0xd.cc8p-4", "0xd.c6p-4", "0xd.bfcp-4",
"0xd.b94p-4", "0xd.b2cp-4", "0xd.ac4p-4", "0xd.a5cp-4", "0xd.9f4p-4", "0xd.988p-4", "0xd.92p-4", "0xd.8b4p-4",
"0xd.848p-4", "0xd.7dcp-4", "0xd.77p-4", "0xd.704p-4", "0xd.694p-4", "0xd.628p-4", "0xd.5b8p-4", "0xd.54cp-4",
"0xd.4dcp-4", "0xd.46cp-4", "0xd.3fcp-4", "0xd.388p-4", "0xd.318p-4", "0xd.2a8p-4", "0xd.234p-4", "0xd.1cp-4",
"0xd.14cp-4", "0xd.0d8p-4", "0xd.064p-4", "0xc.ffp-4", "0xc.f7cp-4", "0xc.f04p-4", "0xc.e8cp-4", "0xc.e18p-4",
"0xc.dap-4", "0xc.d28p-4", "0xc.cbp-4", "0xc.c34p-4", "0xc.bbcp-4", "0xc.b44p-4", "0xc.ac8p-4", "0xc.a4cp-4",
"0xc.9dp-4", "0xc.954p-4", "0xc.8d8p-4", "0xc.85cp-4", "0xc.7ep-4", "0xc.76p-4", "0xc.6e4p-4", "0xc.664p-4",
"0xc.5e4p-4", "0xc.564p-4", "0xc.4e4p-4", "0xc.464p-4", "0xc.3e4p-4", "0xc.36p-4", "0xc.2ep-4", "0xc.25cp-4",
"0xc.1d8p-4", "0xc.154p-4", "0xc.0dp-4", "0xc.04cp-4", "0xb.fc8p-4", "0xb.f44p-4", "0xb.ebcp-4", "0xb.e34p-4",
"0xb.dbp-4", "0xb.d28p-4", "0xb.cap-4", "0xb.c18p-4", "0xb.b9p-4", "0xb.b08p-4", "0xb.a7cp-4", "0xb.9f4p-4",
"0xb.968p-4", "0xb.8dcp-4", "0xb.854p-4", "0xb.7c8p-4", "0xb.73cp-4", "0xb.6acp-4", "0xb.62p-4", "0xb.594p-4",

"0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.90cp-4", "0xc.90cp-4", "0xc.90cp-4",
"0xc.90cp-4", "0xc.908p-4", "0xc.908p-4", "0xc.908p-4", "0xc.904p-4", "0xc.904p-4", "0xc.9p-4", "0xc.8fcp-4",
"0xc.8fcp-4", "0xc.8f8p-4", "0xc.8f4p-4", "0xc.8f4p-4", "0xc.8fp-4", "0xc.8ecp-4", "0xc.8e8p-4", "0xc.8e4p-4",
"0xc.8ep-4", "0xc.8dcp-4", "0xc.8d8p-4", "0xc.8d4p-4", "0xc.8dp-4", "0xc.8ccp-4", "0xc.8c8p-4", "0xc.8c4p-4",
"0xc.8bcp-4", "0xc.8b8p-4", "0xc.8b4p-4", "0xc.8acp-4", "0xc.8a8p-4", "0xc.8ap-4", "0xc.89cp-4", "0xc.894p-4",
"0xc.89p-4", "0xc.888p-4", "0xc.88p-4", "0xc.87cp-4", "0xc.874p-4", "0xc.86cp-4", "0xc.864p-4", "0xc.85cp-4",
"0xc.858p-4", "0xc.85p-4", "0xc.848p-4", "0xc.84p-4", "0xc.834p-4", "0xc.82cp-4", "0xc.824p-4", "0xc.81cp-4",
"0xc.814p-4", "0xc.808p-4", "0xc.8p-4", "0xc.7f8p-4", "0xc.7ecp-4", "0xc.7e4p-4", "0xc.7dcp-4", "0xc.7dp-4",
"0xc.7c4p-4", "0xc.7bcp-4", "0xc.7bp-4", "0xc.7a8p-4", "0xc.79cp-4", "0xc.79p-4", "0xc.784p-4", "0xc.778p-4",
"0xc.77p-4", "0xc.764p-4", "0xc.758p-4", "0xc.74cp-4", "0xc.74p-4", "0xc.734p-4", "0xc.728p-4", "0xc.718p-4",
"0xc.70cp-4", "0xc.7p-4", "0xc.6f4p-4", "0xc.6e4p-4", "0xc.6d8p-4", "0xc.6ccp-4", "0xc.6bcp-4", "0xc.6bp-4",
"0xc.6ap-4", "0xc.694p-4", "0xc.684p-4", "0xc.674p-4", "0xc.668p-4", "0xc.658p-4", "0xc.648p-4", "0xc.63cp-4",
"0xc.62cp-4", "0xc.61cp-4", "0xc.60cp-4", "0xc.5fcp-4", "0xc.5ecp-4", "0xc.5dcp-4", "0xc.5ccp-4", "0xc.5bcp-4",
"0xc.5acp-4", "0xc.59cp-4", "0xc.588p-4", "0xc.578p-4", "0xc.568p-4", "0xc.554p-4", "0xc.544p-4", "0xc.534p-4",
"0xc.52p-4", "0xc.51p-4", "0xc.4fcp-4", "0xc.4ecp-4", "0xc.4d8p-4", "0xc.4c4p-4", "0xc.4b4p-4", "0xc.4ap-4",
"0xc.48cp-4", "0xc.478p-4", "0xc.468p-4", "0xc.454p-4", "0xc.44p-4", "0xc.42cp-4", "0xc.418p-4", "0xc.404p-4",
"0xc.3fp-4", "0xc.3dcp-4", "0xc.3c8p-4", "0xc.3bp-4", "0xc.39cp-4", "0xc.388p-4", "0xc.374p-4", "0xc.35cp-4",
"0xc.348p-4", "0xc.33p-4", "0xc.31cp-4", "0xc.304p-4", "0xc.2fp-4", "0xc.2d8p-4", "0xc.2c4p-4", "0xc.2acp-4",
"0xc.294p-4", "0xc.28p-4", "0xc.268p-4", "0xc.25p-4", "0xc.238p-4", "0xc.22p-4", "0xc.20cp-4", "0xc.1f4p-4",
"0xc.1dcp-4", "0xc.1c4p-4", "0xc.1acp-4", "0xc.19p-4", "0xc.178p-4", "0xc.16p-4", "0xc.148p-4", "0xc.13p-4",
"0xc.114p-4", "0xc.0fcp-4", "0xc.0e4p-4", "0xc.0c8p-4", "0xc.0bp-4", "0xc.094p-4", "0xc.07cp-4", "0xc.06p-4",
"0xc.048p-4", "0xc.02cp-4", "0xc.01p-4", "0xb.ff8p-4", "0xb.fdcp-4", "0xb.fcp-4", "0xb.fa4p-4", "0xb.f8cp-4",
"0xb.f7p-4", "0xb.f54p-4", "0xb.f38p-4", "0xb.f1cp-4", "0xb.fp-4", "0xb.ee4p-4", "0xb.ec8p-4", "0xb.eacp-4",
"0xb.e8cp-4", "0xb.e7p-4", "0xb.e54p-4", "0xb.e38p-4", "0xb.e18p-4", "0xb.dfcp-4", "0xb.dep-4", "0xb.dcp-4",
"0xb.da4p-4", "0xb.d84p-4", "0xb.d68p-4", "0xb.d48p-4", "0xb.d28p-4", "0xb.d0cp-4", "0xb.cecp-4", "0xb.cccp-4",
"0xb.cbp-4", "0xb.c9p-4", "0xb.c7p-4", "0xb.c5p-4", "0xb.c3p-4", "0xb.c1p-4", "0xb.bfp-4", "0xb.bdp-4",
"0xb.bbp-4", "0xb.b9p-4", "0xb.b7p-4", "0xb.b5p-4", "0xb.b3p-4", "0xb.b0cp-4", "0xb.aecp-4", "0xb.accp-4",
"0xb.aacp-4", "0xb.a88p-4", "0xb.a68p-4", "0xb.a44p-4", "0xb.a24p-4", "0xb.ap-4", "0xb.9ep-4", "0xb.9bcp-4",
"0xb.99cp-4", "0xb.978p-4", "0xb.954p-4", "0xb.934p-4", "0xb.91p-4", "0xb.8ecp-4", "0xb.8c8p-4", "0xb.8a8p-4",
"0xb.884p-4", "0xb.86p-4", "0xb.83cp-4", "0xb.818p-4", "0xb.7f4p-4", "0xb.7dp-4", "0xb.7acp-4", "0xb.788p-4",
"0xb.76p-4", "0xb.73cp-4", "0xb.718p-4", "0xb.6f4p-4", "0xb.6ccp-4", "0xb.6a8p-4", "0xb.684p-4", "0xb.65cp-4",
"0xb.638p-4", "0xb.61p-4", "0xb.5ecp-4", "0xb.5c4p-4", "0xb.5ap-4", "0xb.578p-4", "0xb.554p-4", "0xb.52cp-4",
};

static const ap_fixed< 7 , 1 > sin_cos_K1 [ 512 ] = {
"0", "0", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8",
"-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8",
"-0x8.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8",
"-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4",
"-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4", "-0x2.8p-4",
"-0x2.8p-4", "-0x2.8p-4", "-0x2.8p-4", "-0x2.8p-4", "-0x2.cp-4", "-0x2.8p-4", "-0x2.cp-4", "-0x2.cp-4",
"-0x2.cp-4", "-0x2.cp-4", "-0x3.p-4", "-0x2.cp-4", "-0x3.p-4", "-0x3.p-4", "-0x3.p-4", "-0x3.p-4",
"-0x3.p-4", "-0x3.4p-4", "-0x3.p-4", "-0x3.4p-4", "-0x3.4p-4", "-0x3.4p-4", "-0x3.4p-4", "-0x3.8p-4",
"-0x3.8p-4", "-0x3.8p-4", "-0x3.4p-4", "-0x3.8p-4", "-0x3.8p-4", "-0x3.cp-4", "-0x3.8p-4", "-0x3.8p-4",
"-0x3.cp-4", "-0x3.cp-4", "-0x3.cp-4", "-0x3.cp-4", "-0x3.cp-4", "-0x4.p-4", "-0x3.cp-4", "-0x4.p-4",
"-0x4.p-4", "-0x4.p-4", "-0x4.p-4", "-0x4.p-4", "-0x4.4p-4", "-0x4.p-4", "-0x4.4p-4", "-0x4.4p-4",
"-0x4.4p-4", "-0x4.4p-4", "-0x4.4p-4", "-0x4.8p-4", "-0x4.4p-4", "-0x4.8p-4", "-0x4.8p-4", "-0x4.8p-4",
"-0x4.8p-4", "-0x4.8p-4", "-0x4.cp-4", "-0x4.8p-4", "-0x4.cp-4", "-0x4.cp-4", "-0x4.cp-4", "-0x4.cp-4",
"-0x5.p-4", "-0x5.p-4", "-0x4.cp-4", "-0x5.p-4", "-0x5.p-4", "-0x5.p-4", "-0x5.p-4", "-0x5.4p-4",
"-0x5.p-4", "-0x5.4p-4", "-0x5.p-4", "-0x5.4p-4", "-0x5.4p-4", "-0x5.4p-4", "-0x5.8p-4", "-0x5.4p-4",
"-0x5.8p-4", "-0x5.4p-4", "-0x5.8p-4", "-0x5.8p-4", "-0x5.8p-4", "-0x5.cp-4", "-0x5.cp-4", "-0x5.8p-4",
"-0x5.cp-4", "-0x5.cp-4", "-0x5.cp-4", "-0x5.cp-4", "-0x5.cp-4", "-0x6.p-4", "-0x6.p-4", "-0x6.p-4",
"-0x5.cp-4", "-0x6.p-4", "-0x6.p-4", "-0x6.4p-4", "-0x6.4p-4", "-0x6.p-4", "-0x6.4p-4", "-0x6.p-4",
"-0x6.4p-4", "-0x6.4p-4", "-0x6.8p-4", "-0x6.8p-4", "-0x6.4p-4", "-0x6.8p-4", "-0x6.4p-4", "-0x6.8p-4",
"-0x6.8p-4", "-0x6.8p-4", "-0x6.8p-4", "-0x6.8p-4", "-0x6.cp-4", "-0x6.8p-4", "-0x6.cp-4", "-0x6.cp-4",
"-0x6.cp-4", "-0x6.cp-4", "-0x6.cp-4", "-0x7.p-4", "-0x6.cp-4", "-0x7.p-4", "-0x6.cp-4", "-0x7.p-4",
"-0x7.p-4", "-0x7.p-4", "-0x7.4p-4", "-0x7.p-4", "-0x7.p-4", "-0x7.4p-4", "-0x7.4p-4", "-0x7.4p-4",
"-0x7.4p-4", "-0x7.4p-4", "-0x7.4p-4", "-0x7.4p-4", "-0x7.8p-4", "-0x7.8p-4", "-0x7.4p-4", "-0x7.8p-4",
"-0x7.8p-4", "-0x7.8p-4", "-0x7.cp-4", "-0x7.8p-4", "-0x7.8p-4", "-0x7.cp-4", "-0x7.cp-4", "-0x7.cp-4",
"-0x7.cp-4", "-0x7.cp-4", "-0x7.cp-4", "-0x7.cp-4", "-0x8.p-4", "-0x7.cp-4", "-0x8.p-4", "-0x8.p-4",
"-0x8.p-4", "-0x8.p-4", "-0x8.p-4", "-0x8.4p-4", "-0x8.4p-4", "-0x8.p-4", "-0x8.4p-4", "-0x8.4p-4",
"-0x8.4p-4", "-0x8.4p-4", "-0x8.4p-4", "-0x8.4p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.4p-4",
"-0x8.8p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.cp-4", "-0x8.cp-4", "-0x8.8p-4", "-0x8.cp-4",
"-0x8.cp-4", "-0x8.8p-4", "-0x9.p-4", "-0x9.p-4", "-0x9.p-4", "-0x8.cp-4", "-0x8.cp-4", "-0x9.p-4",

"0", "0", "0", "0", "-0x4.p-8", "0", "0", "0",
"-0x4.p-8", "0", "0", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "0",
"-0x4.p-8", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x8.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8",
"-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x4.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8",
"-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8",
"-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4",
"-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4",
"-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.cp-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4",
"-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4",
"-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",

};
};

namespace fourth_order_double {


static const ap_fixed< 59 , 0 > cos_K0 [ 128 ] = {
"0", "0x1.3bd38bab6dap-16", "0x4.ef4b2369256p-16", "0xb.1a5da572f6ep-16", "0x1.3bcfbd9979a6p-12", "0x1.ed71071603eep-12", "0x2.c688008451b8p-12", "0x3.c712923f106ep-12",
"0x4.ef0e43494116p-12", "0x6.3e7839545222p-12", "0x7.b54d38c7296ap-12", "0x9.5389a4c61e2ap-12", "0xb.19297f3be302p-12", "0xd.062868e35fd8p-12", "0xf.1a81a1527b82p-12", "0x1.156300705d52ap-8",
"0x1.3b92e176d6d42p-8", "0x1.64375eefa3de8p-8", "0x1.8f501492cc2a8p-8", "0x1.bcdc980a46f6ep-8", "0x1.ecdc78f30167p-8", "0x2.1f4f40ddf3d18p-8", "0x2.5434735145f84p-8", "0x2.8b8b8dc9822acp-8",
"0x2.c55407bad74c8p-8", "0x3.018d529269bfap-8", "0x3.4036d9b7b32d6p-8", "0x3.8150028df12b4p-8", "0x3.c4d82c75a2b82p-8", "0x4.0aceb0ce148e6p-8", "0x4.5332e2f6fc46ep-8", "0x4.9e04105222486p-8",
"0x4.eb4180451a80ap-8", "0x5.3aea743b0be1p-8", "0x5.8cfe27a6869bcp-8", "0x5.e17bd003691d6p-8", "0x6.38629cd8d3bc2p-8", "0x6.91b1b7bb2b1a2p-8", "0x6.ed68444e2934ap-8", "0x7.4b856046fd1bp-8",
"0x7.ac08236e79492p-8", "0x8.0eef9fa3509fp-8", "0x8.743ae0dc61efep-8", "0x8.dbe8ed2b12246p-8", "0x9.45f8c4bdb4e8ep-8", "0x9.b26961e203e1cp-8", "0xa.2139b907a4612p-8", "0xa.9268b8c2bb962p-8",
"0xb.05f549ce913p-8", "0xb.7bde4f10406f6p-8", "0xb.f422a599779cep-8", "0xc.6ec124ab45e0ep-8", "0xc.ebb89db8f773cp-8", "0xd.6b07dc6b00202p-8", "0xd.ecada6a1f41p-8", "0xe.70a8bc798edd2p-8",
"0xe.f6f7d84bc8dd8p-8", "0xf.7f99aeb3faa4p-8", "0x1.00a8cee920eae4p-4", "0x1.097d0410dc136p-4", "0x1.127624999ee20ap-4", "0x1.1b941a5f7ed026p-4","0x1.24d6cee3afb2d8p-4", "0x1.2e3e2b4cbb3c68p-4",
"0x1.37ca1866b95d2ap-4", "0x1.417a7ea389839p-4", "0x1.4b4f461b0cbadep-4","0x1.5548568b60a7f2p-4", "0x1.5f6597591b636cp-4", "0x1.69a6ef8f8830e2p-4", "0x1.740c45e0e51248p-4", "0x1.7e9580a6a13722p-4",
"0x1.894285e19c46cep-4", "0x1.94133b3a668556p-4", "0x1.9f07860181d22ap-4", "0x1.aa1f4b2fa3801p-4", "0x1.b55a6f65f705cep-4", "0x1.c0b8d6ee6186bcp-4", "0x1.cc3a65bbc632bcp-4", "0x1.d7deff6a4b7cd6p-4",
"0x1.e3a6873fa127e4p-4", "0x1.ef90e02b472884p-4", "0x1.fb9decc6d55bc8p-4", "0x2.07cd8f564411c6p-4", "0x2.141fa9c8356b8p-4", "0x2.20941db63f8b4ep-4", "0x2.2d2acc65379722p-4", "0x2.39e396c57d8bf6p-4",
"0x2.46be5d7348e18cp-4", "0x2.53bb00b6f5fde4p-4", "0x2.60d96085547792p-4", "0x2.6e195c7ff6264p-4", "0x2.7b7ad3f57f008ap-4", "0x2.88fda5e1f5c68p-4", "0x2.96a1b0ef157802p-4", "0x2.a466d3749f9624p-4",
"0x2.b24ceb78af2ed8p-4", "0x2.c053d6b00cb20ep-4", "0x2.ce7b727e828f7ap-4", "0x2.dcc39bf7329c3ap-4", "0x2.eb2c2fdcec3f7p-4", "0x2.f9b50aa283651ap-4", "0x3.085e086b283644p-4", "0x3.1727050abf95a8p-4",
"0x3.260fdc063c6008p-4", "0x3.35186893f96f4ap-4", "0x3.4440859c145f86p-4", "0x3.53880db8c9150ep-4", "0x3.62eedb36ce02bcp-4", "0x3.7274c815b12f6ep-4", "0x3.8219ae0835f9f2p-4", "0x3.91dd6674b39a5ep-4",
"0x3.a1bfca7574600cp-4", "0x3.b1c0b2d915ab2cp-4", "0x3.c1dff822e8a10ep-4", "0x3.d21d728b539a4p-4", "0x3.e278fa00344982p-4", "0x3.f2f26625429a96p-4", "0x4.03898e5474482p-4", "0x4.143e499e61275cp-4",
"0x4.25106ecaa828fep-4", "0x4.35ffd458550e1p-4", "0x4.470c507e46cfdap-4","0x4.5835b92b96b9fp-4", "0x4.697be40800354ep-4", "0x4.7adea67449438ep-4","0x4.8c5dd58aaba92ep-4", "0x4.9df9461f3ec5eap-4",
};

static const ap_fixed< 53 , 1 > cos_K1 [ 128 ] = {
"-0x7.p-52", "0x1.3bd34abafa4p-8", "0x2.77a38a3203ep-8", "0x3.b36db328ae7p-8", "0x4.ef2eba71922p-8", "0x6.2ae394f5ccdp-8", "0x7.668937bc897p-8", "0x8.a21c97f27dbp-8",
"0x9.dd9aaaf16cfp-8", "0xb.19006647aabp-8", "0xc.544abfbf99dp-8", "0xd.8f76ad672dep-8", "0xe.ca81259769bp-8", "0x1.005671efbde3p-4", "0x1.14025909a299p-4", "0x1.27ab971d9728p-4",
"0x1.3b51fba89e4fp-4", "0x1.4ef5562ec2f5p-4", "0x1.6295763b8f9ep-4", "0x1.76322b6285fcp-4", "0x1.89cb453f969fp-4", "0x1.9d6093779807p-4", "0x1.b0f1e5b8be47p-4", "0x1.c47f0bbb11fcp-4",
"0x1.d807d540e7b4p-4", "0x1.eb8c121756a3p-4", "0x1.ff0b9216afc9p-4", "0x2.12862522f4aep-4", "0x2.25fb9b2c4e2bp-4", "0x2.396bc42f82ecp-4", "0x2.4cd670366de1p-4", "0x2.603b6f5874b8p-4",
"0x2.739a91bafddbp-4", "0x2.86f3a791e6b3p-4", "0x2.9a46811ff99dp-4", "0x2.ad92eeb76388p-4", "0x2.c0d8c0ba29b5p-4", "0x2.d417c79a9f2fp-4", "0x2.e74fd3dbda1ep-4", "0x2.fa80b6122902p-4",
"0x3.0daa3ee387acp-4", "0x3.20cc3f0813f4p-4", "0x3.33e6874a82a3p-4", "0x3.46f8e88893c1p-4", "0x3.5a0333b386cdp-4", "0x3.6d0539d08f2p-4", "0x3.7ffecbf94795p-4", "0x3.92efbb5c265dp-4",
"0x3.a5d7d93cf095p-4", "0x3.b8b6f6f52d5ap-4", "0x3.cb8ce5f4993p-4", "0x3.de5977c198bbp-4", "0x3.f11c7df9ab71p-4", "0x4.03d5ca51de12p-4", "0x4.16852e973cd5p-4", "0x4.292a7caf4574p-4",
"0x4.3bc5869858ecp-4", "0x4.4e561e6a2dp-4", "0x4.60dc16563d65p-4", "0x4.735740a83d02p-4", "0x4.85c76fc68676p-4", "0x4.982c76328cb5p-4", "0x4.aa8626894b6ap-4", "0x4.bcd45383b6bdp-4",
"0x4.cf16cff72b1ap-4", "0x4.e14d6ed5dcbap-4", "0x4.f378032f46cfp-4", "0x5.059660309a1dp-4", "0x5.17a859252c16p-4", "0x5.29adc176e4a4p-4", "0x5.3ba66caeac7dp-4", "0x5.4d922e74dabcp-4",
"0x5.5f70da91a259p-4", "0x5.714244ed7f3ep-4", "0x5.83064191a2eep-4", "0x5.94bca4a86155p-4", "0x5.a665427d9c8cp-4", "0x5.b7ffef7f30f5p-4", "0x5.c98c803d6099p-4", "0x5.db0ac96b3e6fp-4",
"0x5.ec7a9fdf1912p-4", "0x5.fddbd892e56fp-4", "0x6.0f2e48a4a8bp-4", "0x6.2071c556e25p-4", "0x6.31a62410f54cp-4", "0x6.42cb3a5f916cp-4", "0x6.53e0ddf51bffp-4", "0x6.64e6e4aa1815p-4",
"0x6.75dd247d8eb3p-4", "0x6.86c373957657p-4", "0x6.9799a83f1a4ap-4", "0x6.a85f98ef8169p-4", "0x6.b9151c43d4c7p-4", "0x6.c9ba0901c5d7p-4", "0x6.da4e3617f3efp-4", "0x6.ead17a9e51bap-4",
"0x6.fb43add68a2fp-4", "0x7.0ba4a72c650cp-4", "0x7.1bf43e362b06p-4", "0x7.2c324ab5095ep-4", "0x7.3c5ea495756p-4", "0x7.4c7923ef8f26p-4", "0x7.5c81a10783eep-4", "0x7.6c77f44df068p-4",
"0x7.7c5bf6604235p-4", "0x7.8c2d8009191p-4", "0x7.9bec6a40a76fp-4", "0x7.ab988e2d1327p-4", "0x7.bb31c522d4e2p-4", "0x7.cab7e8a517c7p-4", "0x7.da2ad266186p-4", "0x7.e98a5c478338p-4",
"0x7.f8d6605ad2b5p-4", "0x8.080eb8e1acc1p-4", "0x8.1733404e4009p-4", "0x8.2643d143a092p-4", "0x8.3540469623cfp-4", "0x8.44287b4bbca3p-4", "0x8.52fc4a9c5628p-4", "0x8.61bb8ff22efp-4",
"0x8.706626ea32fap-4", "0x8.7efbeb545571p-4", "0x8.8d7cb933ea3bp-4", "0x8.9be86cbffe93p-4", "0x8.aa3ee263b157p-4", "0x8.b87ff6be8accp-4", "0x8.c6ab86a4d407p-4", "0x8.d4c16f1fedb3p-4",
};

static const ap_fixed< 45 , 0 > cos_K2 [ 128 ] = {
"0x4.ef4f326fb2p-4", "0x4.ef491be5bp-4", "0x4.ef36d855f9p-4", "0x4.ef1867ed908p-4", "0x4.eeedcaf7868p-4", "0x4.eeb701dd21p-4", "0x4.ee740d2569p-4", "0x4.ee24ed75a08p-4",
"0x4.edc9a3910cp-4", "0x4.ed623058e7p-4", "0x4.ecee94cc75p-4", "0x4.ec6ed208ec8p-4", "0x4.ebe2e9498dp-4", "0x4.eb4adbe79p-4", "0x4.eaa6ab5a0f8p-4", "0x4.e9f659363a8p-4",
"0x4.e939e72f2ep-4", "0x4.e8715715c1p-4", "0x4.e79caad8ep-4", "0x4.e6bbe485578p-4", "0x4.e5cf0645a68p-4", "0x4.e4d612626p-4", "0x4.e3d10b41b7p-4", "0x4.e2bff367c98p-4",
"0x4.e1a2cd7644p-4", "0x4.e0799c2cd58p-4", "0x4.df446268ca8p-4", "0x4.de032325268p-4", "0x4.dcb5e17a7dp-4", "0x4.db5ca09f12p-4", "0x4.d9f763e6d4p-4", "0x4.d8862ec3198p-4",
"0x4.d70904c2fdp-4", "0x4.d57fe993008p-4", "0x4.d3eae0fcf68p-4", "0x4.d249eee8448p-4", "0x4.d09d1759b3p-4", "0x4.cee45e7369p-4", "0x4.cd1fc874db8p-4", "0x4.cb4f59babdp-4",
"0x4.c97316bee28p-4", "0x4.c78b04189cp-4", "0x4.c597267c0f8p-4", "0x4.c39782ba87p-4", "0x4.c18c1dc29d8p-4", "0x4.bf74fc9f99p-4", "0x4.bd522479e5p-4", "0x4.bb239a96cep-4",
"0x4.b8e964585b8p-4", "0x4.b6a3873da9p-4", "0x4.b45208e255p-4", "0x4.b1f4eefebdp-4", "0x4.af8c3f67e7p-4", "0x4.ad18000f68p-4", "0x4.aa9837036ep-4", "0x4.a80cea6e95p-4",
"0x4.a5762097d3p-4", "0x4.a2d3dfe2838p-4", "0x4.a0262ece6p-4", "0x4.9d6d13f729p-4", "0x4.9aa89614fdp-4", "0x4.97d8bbfc06p-4", "0x4.94fd8c9c538p-4", "0x4.92170f0204p-4",
"0x4.8f254a553p-4", "0x4.8c2845d9b18p-4", "0x4.892008eefap-4", "0x4.860c9b1099p-4", "0x4.82ee03d5298p-4", "0x4.7fc44aef42p-4", "0x4.7c8f782cc78p-4", "0x4.794f937708p-4",
"0x4.7604a4d2988p-4", "0x4.72aeb45f3c8p-4", "0x4.6f4dca582ap-4", "0x4.6be1ef13398p-4", "0x4.686b2b01a38p-4", "0x4.64e986af61p-4", "0x4.615d0ac34d8p-4", "0x4.5dc5bffef98p-4",
"0x4.5a23af3ebp-4", "0x4.5676e17933p-4", "0x4.52bf5fbff4p-4", "0x4.4efd333e8b8p-4", "0x4.4b30653b2a8p-4", "0x4.4758ff1612p-4", "0x4.43770a49a4p-4", "0x4.3f8a906a6e8p-4",
"0x4.3b939b26d38p-4", "0x4.37923447238p-4", "0x4.338665ad638p-4", "0x4.2f7039556c8p-4", "0x4.2b4fb9549f8p-4", "0x4.2724efd9928p-4", "0x4.22efe72c88p-4", "0x4.1eb0a9af0bp-4",
"0x4.1a6741dbb48p-4", "0x4.1613ba46478p-4", "0x4.11b61d9b7p-4", "0x4.0d4e76a0d88p-4", "0x4.08dcd034c48p-4", "0x4.0461354e2cp-4", "0x3.ffdbb0fccfp-4", "0x3.fb4c4e68b9p-4",
"0x3.f6b318d23ep-4", "0x3.f2101b91f58p-4", "0x3.ed636218cf8p-4", "0x3.e8acf7ef5ep-4", "0x3.e3ece8b6738p-4", "0x3.df2340269c8p-4", "0x3.da500a1001p-4", "0x3.d573525a478p-4",
"0x3.d08d2504a98p-4", "0x3.cb9d8e25cfp-4", "0x3.c6a499eb778p-4", "0x3.c1a2549a6c8p-4", "0x3.bc96ca8eb28p-4", "0x3.b782083acf8p-4", "0x3.b2641a2879p-4", "0x3.ad3d0cf7a68p-4",
"0x3.a80ced5ee8p-4", "0x3.a2d3c82b74p-4", "0x3.9d91aa4072p-4", "0x3.9846a09738p-4", "0x3.92f2b83f328p-4", "0x3.8d95fe5dcd8p-4", "0x3.8830802e0b8p-4", "0x3.82c24b0083p-4",
};

static const ap_fixed< 35 , -3 > cos_K3 [ 128 ] = {
"-0x2.c8p-32", "-0x2.0783c18p-12", "-0x4.0f025e4p-12", "-0x6.1676f14p-12", "-0x8.1ddc7ap-12", "-0xa.252e074p-12", "-0xc.2c668p-12", "-0xe.3380ef8p-12",
"-0x1.03a78578p-8", "-0x1.24147b8cp-8", "-0x1.447ea13p-8", "-0x1.64e5a6p-8", "-0x1.85493a48p-8", "-0x1.a5a90e18p-8", "-0x1.c604d0ccp-8", "-0x1.e65c338p-8",
"-0x2.06aee6dp-8", "-0x2.26fc9974p-8", "-0x2.4744fcdp-8", "-0x2.6787c13p-8", "-0x2.87c4965p-8", "-0x2.a7fb2da4p-8", "-0x2.c82b3764p-8", "-0x2.e854643cp-8",
"-0x3.0876637cp-8", "-0x3.2890e704p-8", "-0x3.48a39fccp-8", "-0x3.68ae3ee8p-8", "-0x3.88b07484p-8", "-0x3.a8a9f1b4p-8", "-0x3.c89a682p-8", "-0x3.e88187cp-8",
"-0x4.085f0328p-8", "-0x4.28328c18p-8", "-0x4.47fbd2b4p-8", "-0x4.67ba88acp-8", "-0x4.876e5fdcp-8", "-0x4.a7170a84p-8", "-0x4.c6b43a94p-8", "-0x4.e645a23p-8",
"-0x5.05caf1d8p-8", "-0x5.2543de38p-8", "-0x5.44b01854p-8", "-0x5.640f517cp-8", "-0x5.83613ea4p-8", "-0x5.a2a590dcp-8", "-0x5.c1dbfb8p-8", "-0x5.e10431b4p-8",
"-0x6.001de584p-8", "-0x6.1f28cbfcp-8", "-0x6.3e2497ccp-8", "-0x6.5d10fc5p-8", "-0x6.7bedad4p-8", "-0x6.9aba5e34p-8", "-0x6.b976c3b4p-8", "-0x6.d8229204p-8",
"-0x6.f6bd7cacp-8", "-0x7.1547389p-8", "-0x7.33bf7acp-8", "-0x7.5225f6fp-8", "-0x7.707a635p-8", "-0x7.8ebc74f8p-8", "-0x7.acebe0ap-8", "-0x7.cb085b8p-8",
"-0x7.e9119c1p-8", "-0x8.070758ap-8", "-0x8.24e9456p-8", "-0x8.42b71bcp-8", "-0x8.60708eccp-8", "-0x8.7e1556e4p-8", "-0x8.9ba52aecp-8", "-0x8.b91fc1ecp-8",
"-0x8.d684d3p-8", "-0x8.f3d4147cp-8", "-0x9.110d40acp-8", "-0x9.2e300c8cp-8", "-0x9.4b3c31dp-8", "-0x9.683168a8p-8", "-0x9.850f699cp-8", "-0x9.a1d5ed88p-8",
"-0x9.be84ad68p-8", "-0x9.db1b62p-8", "-0x9.f799c5d8p-8", "-0xa.13ff90ep-8", "-0xa.304c7eb8p-8", "-0xa.4c8048cp-8", "-0xa.689aa94p-8", "-0xa.849b5b6cp-8",
"-0xa.a08219a4p-8", "-0xa.bc4e9f54p-8", "-0xa.d800a738p-8", "-0xa.f397ee04p-8", "-0xb.0f1430bp-8", "-0xb.2a752884p-8", "-0xb.45ba931p-8", "-0xb.60e42e2p-8",
"-0xb.7bf1b5b4p-8", "-0xb.96e2e774p-8", "-0xb.b1b780b4p-8", "-0xb.cc6f3fep-8", "-0xb.e709e204p-8", "-0xc.018724e8p-8", "-0xc.1be6c8ap-8", "-0xc.36288c68p-8",
"-0xc.504c2eap-8", "-0xc.6a516e44p-8", "-0xc.84380cd4p-8", "-0xc.9dffc8p-8", "-0xc.b7a86188p-8", "-0xc.d1319bp-8", "-0xc.ea9b348cp-8", "-0xd.03e4eedcp-8",
"-0xd.1d0e8b78p-8", "-0xd.3617cd8p-8", "-0xd.4f00772p-8", "-0xd.67c8498p-8", "-0xd.806f096p-8", "-0xd.98f477c4p-8", "-0xd.b1585a4p-8", "-0xd.c99a7358p-8",
"-0xd.e1ba8648p-8", "-0xd.f9b85a28p-8", "-0xe.1193b294p-8", "-0xe.294c53c4p-8", "-0xe.40e2036p-8", "-0xe.585488cp-8", "-0xe.6fa3a938p-8", "-0xe.86cf2a74p-8",
};

static const ap_fixed< 27 , -4 > cos_K4 [ 128 ] = {
"-0x4.0f067ep-8", "-0x4.0efc84p-8", "-0x4.0ee85cp-8", "-0x4.0eca56p-8", "-0x4.0ea25p-8", "-0x4.0e7026p-8", "-0x4.0e342ap-8", "-0x4.0dee24p-8",
"-0x4.0d9e18p-8", "-0x4.0d43f8p-8", "-0x4.0cdfccp-8", "-0x4.0c71aep-8", "-0x4.0bf98ap-8", "-0x4.0b776cp-8", "-0x4.0aeb8p-8","-0x4.0a5582p-8",
"-0x4.09b56ap-8", "-0x4.090b98p-8", "-0x4.0857b4p-8", "-0x4.0799e4p-8", "-0x4.06d232p-8", "-0x4.06007cp-8", "-0x4.0524bep-8", "-0x4.043f14p-8",
"-0x4.034fbap-8", "-0x4.025672p-8", "-0x4.01532ep-8", "-0x4.0045ecp-8", "-0x3.ff2edep-8", "-0x3.fe0dfap-8", "-0x3.fce326p-8", "-0x3.fbaebp-8",
"-0x3.fa7052p-8", "-0x3.f927f4p-8", "-0x3.f7d5e6p-8", "-0x3.f67a28p-8", "-0x3.f514b2p-8", "-0x3.f3a564p-8", "-0x3.f22c48p-8", "-0x3.f0a94cp-8",
"-0x3.ef1ceap-8", "-0x3.ed8682p-8", "-0x3.ebe666p-8", "-0x3.ea3cfp-8", "-0x3.e8898ap-8", "-0x3.e6cc9cp-8", "-0x3.e5060cp-8", "-0x3.e335d8p-8",
"-0x3.e15c4p-8", "-0x3.df78e4p-8", "-0x3.dd8bf2p-8", "-0x3.db957ap-8", "-0x3.d9958p-8", "-0x3.d78c16p-8", "-0x3.d57922p-8", "-0x3.d35ca2p-8",
"-0x3.d136d6p-8", "-0x3.cf0794p-8", "-0x3.cccee2p-8", "-0x3.ca8cfcp-8", "-0x3.c84194p-8", "-0x3.c5eccep-8", "-0x3.c38ebcp-8", "-0x3.c12784p-8",
"-0x3.beb706p-8", "-0x3.bc3d1cp-8", "-0x3.b9ba46p-8", "-0x3.b72dc8p-8", "-0x3.b4987cp-8", "-0x3.b1fap-8", "-0x3.af5252p-8", "-0x3.aca182p-8",
"-0x3.a9e798p-8", "-0x3.a724ecp-8", "-0x3.a458d8p-8", "-0x3.a1841ep-8", "-0x3.9ea664p-8", "-0x3.9bbfbp-8", "-0x3.98d018p-8", "-0x3.95d78cp-8",
"-0x3.92d62cp-8", "-0x3.8fcc04p-8", "-0x3.8cb8e4p-8", "-0x3.899d44p-8", "-0x3.8678bap-8", "-0x3.834b9p-8", "-0x3.8015cp-8","-0x3.7cd74p-8",
"-0x3.799034p-8", "-0x3.76408ep-8", "-0x3.72e884p-8", "-0x3.6f87e8p-8", "-0x3.6c1e6ep-8", "-0x3.68ace6p-8", "-0x3.653308p-8", "-0x3.61b09p-8",
"-0x3.5e25d6p-8", "-0x3.5a92c8p-8", "-0x3.56f76cp-8", "-0x3.5353b4p-8", "-0x3.4fa7e2p-8", "-0x3.4bf41cp-8", "-0x3.483826p-8", "-0x3.4473e4p-8",
"-0x3.40a794p-8", "-0x3.3cd35ep-8", "-0x3.38f6fp-8", "-0x3.3512ep-8", "-0x3.3126e6p-8", "-0x3.2d32c8p-8", "-0x3.2936ep-8","-0x3.25334p-8",
"-0x3.212804p-8", "-0x3.1d14eep-8", "-0x3.18fap-8", "-0x3.14d7aap-8", "-0x3.10ad7ap-8", "-0x3.0c7bfp-8", "-0x3.0842b2p-8", "-0x3.040206p-8",
"-0x2.ffba3cp-8", "-0x2.fb6ab4p-8", "-0x2.f713bep-8", "-0x2.f2b5a6p-8", "-0x2.ee506ap-8", "-0x2.e9e3b2p-8", "-0x2.e56fcap-8", "-0x2.e0f4dep-8",

};




static const ap_fixed< 60 , 1 > sin_K0 [ 128 ] = {
"0xc.90fdaa22168c24p-4", "0xc.90f87f3380388ep-4", "0xc.90e8fe6f63c232p-4", "0xc.90cf27ecb4a8cep-4", "0xc.90aafbd1b33efcp-4", "0xc.907c7a53ec66ccp-4", "0xc.9043a3b8393364p-4", "0xc.90007852be6fa8p-4",
"0xc.8fb2f886ec09f2p-4", "0xc.8f5b24c77c64ccp-4", "0xc.8ef8fd96738cc4p-4", "0xc.8e8c83851e5344p-4", "0xc.8e15b734114e88p-4", "0xc.8d94995327be9p-4", "0xc.8d092aa1825748p-4", "0xc.8c736bed85efa4p-4",
"0xc.8bd35e14da15fp-4", "0xc.8b290204678928p-4", "0xc.8a7458b8569788p-4","0xc.89b5633c0d622p-4", "0xc.88ec22aa2e05acp-4", "0xc.8818982c94a87ap-4","0xc.873ac4fc556d92p-4", "0xc.8652aa61ba4d02p-4",
"0xc.856049b440d16ap-4", "0xc.8463a45a97bab2p-4", "0xc.835cbbca9c860ep-4", "0xc.824b918958db3cp-4", "0xc.8130272affdf08p-4", "0xc.800a7e52eb6b28p-4", "0xc.7eda98b3992b56p-4", "0xc.7da0780ea79fd8p-4",
"0xc.7c5c1e34d30558p-4", "0xc.7b0d8d05f2221ep-4", "0xc.79b4c670f2f8cp-4", "0xc.7851cc73d7602ep-4", "0xc.76e4a11bb1815p-4", "0xc.756d4684a039fep-4", "0xc.73ebbed9cb659cp-4", "0xc.72600c55600b3p-4",
"0xc.70ca31408c710ep-4", "0xc.6f2a2ff37c161cp-4", "0xc.6d800ad55390bep-4", "0xc.6bcbc45c2c5364p-4", "0xc.6a0d5f0d1056ccp-4", "0xc.6844dd7bf5aa0ap-4", "0xc.6672424bb9e834p-4", "0xc.6495902e1d94p-4",
"0xc.62aec9e3bf5916p-4", "0xc.60bdf23c173356p-4", "0xc.5ec30c15717bfp-4", "0xc.5cbe1a5ce9dc84p-4", "0xc.5aaf200e662824p-4", "0xc.58962034911a64p-4", "0xc.56731de8d4fc82p-4", "0xc.54461c5356309p-4",
"0xc.520f1eaaeda2d4p-4", "0xc.4fce283523214ap-4", "0xc.4d833c46279964p-4", "0xc.4b2e5e40cf3c04p-4", "0xc.48cf91968b87cep-4", "0xc.4666d9c76539d4p-4", "0xc.43f43a61f624ap-4", "0xc.4177b70362edaap-4",
"0xc.3ef1535754b162p-4", "0xc.3c611317f28daap-4", "0xc.39c6fa0ddb12f8p-4", "0xc.37230c101d9c06p-4", "0xc.34754d04338c4ap-4", "0xc.31bdc0ddf9751ap-4", "0xc.2efc6b9fa82196p-4", "0xc.2c315159cd8978p-4",
"0xc.295c762b45aab6p-4", "0xc.267dde41334a24p-4", "0xc.23958dd6f89b0cp-4", "0xc.20a389362fcddcp-4", "0xc.1da7d4b6a385e6p-4", "0xc.1aa274be47365p-4", "0xc.17936dc12f6642p-4", "0xc.147ac44189dc4cp-4",
"0xc.11587ccf95b136p-4", "0xc.0e2c9c099b4a2ap-4", "0xc.0af7269be43a52p-4", "0xc.07b82140b30c04p-4", "0xc.046f90c03af17cp-4", "0xc.011d79f0975d38p-4", "0xb.fdc1e1b5c38216p-4", "0xb.fa5ccd0191bb22p-4",
"0xb.f6ee40d3a2db4cp-4", "0xb.f37642395d65p-4", "0xb.eff4d64de4a9a4p-4","0xb.ec6a023a0fd13ep-4", "0xb.e8d5cb3460ca1p-4", "0xb.e5383680fb2078p-4","0xb.e19149719abf06p-4", "0xb.dde109658a96dp-4",
"0xb.da277bc99b303ep-4", "0xb.d664a618192434p-4", "0xb.d2988dd8c37dccp-4", "0xb.cec338a0c204ap-4", "0xb.cae4ac129b6fbep-4", "0xb.c6fcedde2b8154p-4", "0xb.c30c03c0990b3ap-4", "0xb.bf11f3844bdc46p-4",
"0xb.bb0ec300e296a6p-4", "0xb.b702781b286f3ep-4", "0xb.b2ed18c50ad62p-4", "0xb.aeceaafd8f0836p-4", "0xb.aaa734d0c78a2cp-4", "0xb.a676bc57c98cbap-4", "0xb.a23d47b8a23a5p-4", "0xb.9dfadd264bee4cp-4",
"0xb.99af82e0a355b8p-4", "0xb.955b3f345c79cap-4", "0xb.90fe187af7b4p-4", "0xb.8c98151ab68c38p-4", "0xb.88293b8690808cp-4", "0xb.83b1923e27b74cp-4", "0xb.7f311fcdbd9af6p-4", "0xb.7aa7eace276064p-4",
"0xb.7615f9e4c2773ap-4", "0xb.717b53c368e4ap-4", "0xb.6cd7ff2865887ap-4","0xb.682c02de684d14p-4", "0xb.637765bc7a416cp-4", "0xb.5eba2ea5f19e3p-4", "0xb.59f4648a65b582p-4", "0xb.55260e65a2cd9p-4",
};

static const ap_fixed< 51 , -1 > sin_K1 [ 128 ] = {
"-0x5.p-52", "-0x5.2aedf31dc8p-12", "-0xa.55d43fb839p-12", "-0xf.80ab3f599ep-12", "-0x1.4ab6b4ba721p-8", "-0x1.9d60cbe6e5ap-8", "-0x1.f0087f1b2cep-8", "-0x2.42ad53fbb72p-8",
"-0x2.954ed032029p-8", "-0x2.e7ec796d722p-8", "-0x3.3a85d56426ap-8", "-0x3.8d1a69d3d49p-8", "-0x3.dfa9bc829f4p-8", "-0x4.3233533fe9dp-8", "-0x4.84b6b3e5367p-8", "-0x4.d7336456f7p-8",
"-0x5.29a8ea85688p-8", "-0x5.7c16cc6d658p-8", "-0x5.ce7c901943ap-8", "-0x6.20d9bba1a36p-8", "-0x6.732dd52e4dfp-8", "-0x6.c57862f7056p-8", "-0x7.17b8eb445f3p-8", "-0x7.69eef470986p-8",
"-0x7.bc1a04e86f7p-8", "-0x8.0e39a32bf52p-8", "-0x8.604d55cf66dp-8", "-0x8.b254a37c02cp-8", "-0x9.044f12f0dc9p-8", "-0x9.563c2b03b6bp-8", "-0x9.a81b72a1d22p-8", "-0x9.f9ec70d0c78p-8",
"-0xa.4baeacaf5c6p-8", "-0xa.9d61ad76543p-8", "-0xa.ef04fa794a7p-8", "-0xb.40981b2780ap-8", "-0xb.921a970cb9fp-8", "-0xb.e38bf5d2079p-8", "-0xc.34ebbf3ea2p-8", "-0xc.86397b38ba4p-8",
"-0xc.d774b1c64e1p-8", "-0xd.289ceb0df9ap-8", "-0xd.79b1af57cbcp-8", "-0xd.cab2870e182p-8", "-0xe.1b9efabe483p-8", "-0xe.6c769319b1bp-8", "-0xe.bd38d8f6614p-8", "-0xf.0de5554ff2ap-8",
"-0xf.5e7b91485dbp-8", "-0xf.aefb1628ca8p-8", "-0xf.ff636d625ddp-8", "-0x1.04fb4208f0f1p-4", "-0x1.09fecb97273ep-4", "-0x1.0f00cc1fa8f7p-4", "-0x1.14013c440a69p-4", "-0x1.190014a8a09cp-4",
"-0x1.1dfd4df48e78p-4", "-0x1.22f8e0d1d185p-4", "-0x1.27f2c5ed4efap-4", "-0x1.2ceaf5f6e057p-4", "-0x1.31e169a1605fp-4", "-0x1.36d619a2b807p-4", "-0x1.3bc8feb3eb28p-4", "-0x1.40ba11912502p-4",
"-0x1.45a94af9c571p-4", "-0x1.4a96a3b06d4cp-4", "-0x1.4f82147b0b59p-4", "-0x1.546b9622e8ap-4", "-0x1.59532174b564p-4", "-0x1.5e38af4095aep-4", "-0x1.631c385a2dc1p-4", "-0x1.67fdb598aeddp-4",
"-0x1.6cdd1fd6e39dp-4", "-0x1.71ba6ff33c96p-4", "-0x1.76959ecfdccap-4", "-0x1.7b6ea552a631p-4", "-0x1.80457c654609p-4", "-0x1.851a1cf5413fp-4", "-0x1.89ec7ff40103p-4", "-0x1.8ebc9e56dec4p-4",
"-0x1.938a711730dcp-4", "-0x1.9855f13256adp-4", "-0x1.9d1f17a9c4d9p-4", "-0x1.a1e5dd831197p-4", "-0x1.a6aa3bc800d9p-4", "-0x1.ab6c2b869064p-4", "-0x1.b02ba5d10424p-4", "-0x1.b4e8a3bdf205p-4",
"-0x1.b9a31e684e25p-4", "-0x1.be5b0eef7706p-4", "-0x1.c3106e77411bp-4", "-0x1.c7c336280355p-4", "-0x1.cc735f2ea287p-4", "-0x1.d120e2bc9d9fp-4", "-0x1.d5cbba081996p-4", "-0x1.da73de4bece8p-4",
"-0x1.df1948c7abb4p-4", "-0x1.e3bbf2bfb353p-4", "-0x1.e85bd57d3624p-4", "-0x1.ecf8ea4e473ep-4", "-0x1.f1932a85e614p-4", "-0x1.f62a8f7c09e9p-4", "-0x1.fabf128dadc3p-4", "-0x1.ff50ad1cdb9bp-4",
"-0x2.03df5890b801p-4", "-0x2.086b0e558d96p-4", "-0x2.0cf3c7dcd875p-4", "-0x2.11797e9d5192p-4", "-0x2.15fc2c12fa0dp-4", "-0x2.1a7bc9bf26a1p-4", "-0x2.1ef851288ab8p-4", "-0x2.2371bbdb43e3p-4",
"-0x2.27e80368e4b7p-4", "-0x2.2c5b2168805ap-4", "-0x2.30cb0f76b52dp-4", "-0x2.3537c735b84bp-4", "-0x2.39a1424d602fp-4", "-0x2.3e077a6b2ffap-4", "-0x2.426a69426239p-4", "-0x2.46ca088bf3c7p-4",
"-0x2.4b265206aed8p-4", "-0x2.4f7f3f773577p-4", "-0x2.53d4caa80c9fp-4", "-0x2.5826ed69a6c7p-4", "-0x2.5c75a1926e89p-4", "-0x2.60c0e0fed15dp-4", "-0x2.6508a5914a28p-4", "-0x2.694ce9326b9fp-4",
};

static const ap_fixed< 43 , -2 > sin_K2 [ 128 ] = {
"-0x1.4abbce62538p-4", "-0x1.4abad991ae8p-4", "-0x1.4ab7fb2168p-4", "-0x1.4ab33316748p-4", "-0x1.4aac8179398p-4", "-0x1.4aa3e6558e8p-4", "-0x1.4a9961bab6p-4", "-0x1.4a8cf3bb2fp-4",
"-0x1.4a7e9c6cd08p-4", "-0x1.4a6e5be8e58p-4", "-0x1.4a5c324c0c8p-4", "-0x1.4a481fb6678p-4", "-0x1.4a32244b23p-4", "-0x1.4a1a40313fp-4", "-0x1.4a007392a28p-4", "-0x1.49e4be9cd98p-4",
"-0x1.49c72180968p-4", "-0x1.49a79c7244p-4", "-0x1.49862fa9398p-4", "-0x1.4962db6096p-4", "-0x1.493d9fd65ap-4", "-0x1.49167d4c4p-4", "-0x1.48ed7407358p-4", "-0x1.48c2844faf8p-4",
"-0x1.4895ae71188p-4", "-0x1.4866f2baa1p-4", "-0x1.4836517e92p-4", "-0x1.4803cb1294p-4", "-0x1.47cf5fcfccp-4", "-0x1.479910125ep-4", "-0x1.4760dc3a19p-4", "-0x1.4726c4aa14p-4",
"-0x1.46eac9c878p-4", "-0x1.46acebff29p-4", "-0x1.466d2bbaecp-4", "-0x1.462b896c48p-4", "-0x1.45e80586a4p-4", "-0x1.45a2a08117p-4", "-0x1.455b5ad5cbp-4", "-0x1.45123502558p-4",
"-0x1.44c72f877c8p-4", "-0x1.447a4ae96ep-4", "-0x1.442b87af9ep-4", "-0x1.43dae664b5p-4", "-0x1.43886796d08p-4", "-0x1.43340bd7078p-4", "-0x1.42ddd3ba148p-4", "-0x1.4285bfd7bb8p-4",
"-0x1.422bd0cb1fp-4", "-0x1.41d0073283p-4", "-0x1.417263afb28p-4", "-0x1.4112e6e75d8p-4", "-0x1.40b1918198p-4", "-0x1.404e6429f3p-4", "-0x1.3fe95f8ee3p-4", "-0x1.3f82846256p-4",
"-0x1.3f19d35946p-4", "-0x1.3eaf4d2c14p-4", "-0x1.3e42f2960e8p-4", "-0x1.3dd4c4560b8p-4", "-0x1.3d64c32e17p-4", "-0x1.3cf2efe32dp-4", "-0x1.3c7f4b3d758p-4", "-0x1.3c09d608cp-4",
"-0x1.3b929113908p-4", "-0x1.3b197d2fdb8p-4", "-0x1.3a9e9b32788p-4", "-0x1.3a21ebf3ca8p-4", "-0x1.39a3704f2a8p-4", "-0x1.39232923048p-4", "-0x1.38a117510e8p-4", "-0x1.381d3bbe01p-4",
"-0x1.37979751d58p-4", "-0x1.37102af7ap-4", "-0x1.3686f79d8c8p-4", "-0x1.35fbfe34ce8p-4", "-0x1.356f3fb1c98p-4", "-0x1.34e0bd0c1b8p-4", "-0x1.3450773e1bp-4", "-0x1.33be6f45ae8p-4",
"-0x1.332aa623708p-4", "-0x1.32951cdb28p-4", "-0x1.31fdd473bfp-4", "-0x1.3164cdf7168p-4", "-0x1.30ca0a72228p-4", "-0x1.302d8af4f08p-4", "-0x1.2f8f509267p-4", "-0x1.2eef5c60a18p-4",
"-0x1.2e4daf78c78p-4", "-0x1.2daa4af6a28p-4", "-0x1.2d052ff993p-4", "-0x1.2c5e5fa3548p-4", "-0x1.2bb5db19278p-4", "-0x1.2b0ba38313p-4", "-0x1.2a5fba0bcb8p-4", "-0x1.29b21fe1608p-4",
"-0x1.2902d634a2p-4", "-0x1.2851de395fp-4", "-0x1.279f3926578p-4", "-0x1.26eae83524p-4", "-0x1.2634eca2378p-4", "-0x1.257d47ad3d8p-4", "-0x1.24c3fa9856p-4", "-0x1.240906a8c1p-4",
"-0x1.234c6d2699p-4", "-0x1.228e2f5ccd8p-4", "-0x1.21ce4e9923p-4", "-0x1.210ccc2c428p-4", "-0x1.2049a969b38p-4", "-0x1.1f84e7a7a48p-4", "-0x1.1ebe883f548p-4", "-0x1.1df68c8c778p-4",
"-0x1.1d2cf5edf08p-4", "-0x1.1c61c5c50fp-4", "-0x1.1b94fd763ap-4", "-0x1.1ac69e6853p-4", "-0x1.19f6aa0539p-4", "-0x1.192521b9588p-4", "-0x1.185206f3e68p-4", "-0x1.177d5b26f88p-4",
"-0x1.16a71fc7038p-4", "-0x1.15cf564b998p-4", "-0x1.14f6002ea9p-4", "-0x1.141b1eecep-4", "-0x1.133eb405ad8p-4", "-0x1.1260c0fb0b8p-4", "-0x1.11814751a1p-4", "-0x1.10a04890ecp-4",
};

static const ap_fixed< 33 , -5 > sin_K3 [ 128 ] = {
"-0x4.p-36", "0x5.19ae6p-16", "0xa.3354acp-16", "0xf.4ce8d4p-16", "0x1.466611cp-12", "0x1.97fb50cp-12", "0x1.e98dd1cp-12", "0x2.3b1cf74p-12",
"0x2.8ca828cp-12", "0x2.de2ed7cp-12", "0x3.2fb070cp-12", "0x3.812c7dp-12", "0x3.d2a247p-12", "0x4.24116dp-12", "0x4.75793d8p-12", "0x4.c6d936cp-12",
"0x5.1830b08p-12", "0x5.697f454p-12", "0x5.bac441cp-12", "0x6.0bff41p-12", "0x6.5d2f81cp-12", "0x6.ae548b4p-12", "0x6.ff6dc8p-12", "0x7.507ac8cp-12",
"0x7.a17acbp-12", "0x7.f26d698p-12", "0x8.435207p-12", "0x8.9428114p-12", "0x8.e4ef11cp-12", "0x9.35a651cp-12", "0x9.864d554p-12", "0x9.d6e3a34p-12",
"0xa.276884p-12", "0xa.77db994p-12", "0xa.c83c29p-12", "0xb.1889cc4p-12", "0xb.68c3d4cp-12", "0xb.b8e9cecp-12", "0xc.08fb1cp-12", "0xc.58f73d4p-12",
"0xc.a8dd98p-12", "0xc.f8ada5cp-12", "0xd.4866e3p-12", "0xd.9808b34p-12", "0xd.e7929c8p-12", "0xe.3703fa4p-12", "0xe.865c574p-12", "0xe.d59b224p-12",
"0xf.24bfd14p-12", "0xf.73c9cc8p-12", "0xf.c2b8a78p-12", "0x1.0118bb88p-8", "0x1.060426a4p-8", "0x1.0aedc5ap-8", "0x1.0fd58e54p-8", "0x1.14bb7924p-8",
"0x1.199f7c54p-8", "0x1.1e8190bcp-8", "0x1.2361ab4cp-8", "0x1.283fc4f8p-8", "0x1.2d1bd6dp-8", "0x1.31f5d68cp-8", "0x1.36cdb9e4p-8", "0x1.3ba37cp-8",
"0x1.40771248p-8", "0x1.4548758p-8", "0x1.4a179bp-8", "0x1.4ee47c4cp-8", "0x1.53af1104p-8", "0x1.58774ffp-8", "0x1.5d3d3108p-8", "0x1.6200ab54p-8",
"0x1.66c1b6f8p-8", "0x1.6b804c1cp-8", "0x1.703c623cp-8", "0x1.74f5f04cp-8", "0x1.79acedfcp-8", "0x1.7e6154ep-8", "0x1.831319b4p-8", "0x1.87c23778p-8",
"0x1.8c6ea438p-8", "0x1.911857ccp-8", "0x1.95bf4a98p-8", "0x1.9a637414p-8", "0x1.9f04cc68p-8", "0x1.a3a34bccp-8", "0x1.a83ee92p-8", "0x1.acd79cecp-8",
"0x1.b16d6084p-8", "0x1.b60028a4p-8", "0x1.ba8ff134p-8", "0x1.bf1cae64p-8", "0x1.c3a65b44p-8", "0x1.c82cf03cp-8", "0x1.ccb06288p-8", "0x1.d130abecp-8",
"0x1.d5adc45p-8", "0x1.da27a3ep-8", "0x1.de9e4384p-8", "0x1.e3119b14p-8", "0x1.e781a19p-8", "0x1.ebee51ecp-8", "0x1.f057a23cp-8", "0x1.f4bd8b44p-8",
"0x1.f920059cp-8", "0x1.fd7f0998p-8", "0x2.01da8f48p-8", "0x2.06328f9p-8", "0x2.0a870374p-8", "0x2.0ed7e21cp-8", "0x2.1325260cp-8", "0x2.176ec534p-8",
"0x2.1bb4ba3cp-8", "0x2.1ff6fc6p-8", "0x2.24358558p-8", "0x2.28704cdcp-8", "0x2.2ca74c8p-8", "0x2.30da7c38p-8", "0x2.3509d46p-8", "0x2.39354f9cp-8",
"0x2.3d5ce414p-8", "0x2.41808d54p-8", "0x2.45a042d4p-8", "0x2.49bbfd3p-8", "0x2.4dd3b5e4p-8", "0x2.51e7650cp-8", "0x2.55f703c4p-8", "0x2.5a028d04p-8",
};

static const ap_fixed< 24 , -7 > sin_K4 [ 128 ] = {
"0xa.335e2p-12", "0xa.334cp-12", "0xa.3325ap-12", "0xa.32ed2p-12","0xa.32a6ap-12", "0xa.32502p-12", "0xa.31e2cp-12", "0xa.31632p-12",
"0xa.30d2ap-12", "0xa.30316p-12", "0xa.2f804p-12", "0xa.2eb8ep-12", "0xa.2de48p-12", "0xa.2cf8ap-12", "0xa.2bfccp-12","0xa.2aedep-12",
"0xa.29d22p-12", "0xa.289fap-12", "0xa.275eap-12", "0xa.2604cp-12", "0xa.249eap-12", "0xa.2326ep-12", "0xa.219f2p-12","0xa.1fffp-12",
"0xa.1e546p-12", "0xa.1c93ep-12", "0xa.1ac1ep-12", "0xa.18df2p-12", "0xa.16e5ap-12", "0xa.14df4p-12", "0xa.12c88p-12","0xa.109acp-12",
"0xa.0e61ap-12", "0xa.0c108p-12", "0xa.09b2cp-12", "0xa.073fcp-12", "0xa.04bdep-12", "0xa.0227ep-12", "0x9.ff82ap-12","0x9.fcc9cp-12",
"0x9.fa00cp-12", "0x9.f726ap-12", "0x9.f4386p-12", "0x9.f13bp-12", "0x9.ee2acp-12", "0x9.eb0b6p-12", "0x9.e7d96p-12", "0x9.e495p-12",
"0x9.e13f2p-12", "0x9.ddd9ep-12", "0x9.da5e8p-12", "0x9.d6d3ep-12", "0x9.d33d6p-12", "0x9.cf914p-12", "0x9.cbd4ep-12","0x9.c804ep-12",
"0x9.c4262p-12", "0x9.c0322p-12", "0x9.bc334p-12", "0x9.b8238p-12", "0x9.b3fc6p-12", "0x9.afc54p-12", "0x9.ab84cp-12","0x9.a72cap-12",
"0x9.a2c58p-12", "0x9.9e4a2p-12", "0x9.99c3p-12", "0x9.95298p-12","0x9.907dp-12", "0x9.8bc02p-12", "0x9.86f2ap-12", "0x9.82162p-12",
"0x9.7d292p-12", "0x9.78296p-12", "0x9.73188p-12", "0x9.6df9p-12", "0x9.68cb6p-12", "0x9.6387ep-12", "0x9.5e3b4p-12", "0x9.58d82p-12",
"0x9.53664p-12", "0x9.4de4ep-12", "0x9.48526p-12", "0x9.42b08p-12", "0x9.3cfd6p-12", "0x9.37394p-12", "0x9.31672p-12","0x9.2b858p-12",
"0x9.258ecp-12", "0x9.1f8fcp-12", "0x9.19794p-12", "0x9.135bp-12", "0x9.0d288p-12", "0x9.06e0ep-12", "0x9.008f4p-12", "0x8.fa2dep-12",
"0x8.f3bd2p-12", "0x8.ed3ep-12", "0x8.e6acep-12", "0x8.e00b4p-12","0x8.d95eap-12", "0x8.d29cep-12", "0x8.cbce2p-12", "0x8.c4f0ep-12",
"0x8.be046p-12", "0x8.b708ep-12", "0x8.afffep-12", "0x8.a8e72p-12", "0x8.a1bd2p-12", "0x8.9a874p-12", "0x8.933cep-12","0x8.8be8ep-12",
"0x8.8483cp-12", "0x8.7d10ep-12", "0x8.758e6p-12", "0x8.6dfep-12", "0x8.665dap-12", "0x8.5eafcp-12", "0x8.56f64p-12", "0x8.4f29p-12",
"0x8.47534p-12", "0x8.3f69ep-12", "0x8.3772cp-12", "0x8.2f6e8p-12", "0x8.275b4p-12", "0x8.1f3cep-12", "0x8.1711cp-12","0x8.0ed32p-12",
};


static const ap_fixed< 59 , 1 > sin_cos_K0 [ 256 ] = {
"0x1.p0", "0xf.ffec42c7454924p-4", "0xf.ffb10b4dc96da8p-4", "0xf.ff4e5a25a8d094p-4", "0xf.fec43042668658p-4", "0xf.fe128ef8e9fc14p-4", "0xf.fd3977ff7bae48p-4", "0xf.fc38ed6dc0ef9p-4",
"0xf.fb10f1bcb6bee8p-4", "0xf.f9c187c6abaddcp-4", "0xf.f84ab2c738d694p-4", "0xf.f6ac765b39e1d8p-4", "0xf.f4e6d680c41dp-4", "0xf.f2f9d7971ca028p-4", "0xf.f0e57e5ead848p-4", "0xf.eea9cff8fa2ad4p-4",
"0xf.ec46d1e89292cp-4", "0xf.e9bc8a1105c218p-4", "0xf.e70afeb6d33d58p-4", "0xf.e432367f5b9094p-4", "0xf.e1323870cfe99p-4", "0xf.de0b0bf220c2e8p-4", "0xf.dabcb8caeba07cp-4", "0xf.d747472367dd54p-4",
"0xf.d3aabf84528b38p-4", "0xf.cfe72ad6d96404p-4", "0xf.cbfc926484cd28p-4", "0xf.c7eaffd720ed4cp-4", "0xf.c3b27d38a5d48p-4","0xf.bf5314f31eb718p-4", "0xf.baccd1d0903b94p-4", "0xf.b61fbefadddb78p-4",
"0xf.b14be7fbae57f4p-4", "0xf.ac5158bc4f41fp-4", "0xf.a7301d85979644p-4", "0xf.a1e842ffc96e2cp-4", "0xf.9c79d63272c44p-4", "0xf.96e4e4844d4e5cp-4", "0xf.91297bbb1d6cb4p-4", "0xf.8b47a9fb902e5p-4",
"0xf.853f7dc9186b6cp-4", "0xf.7f110605caf61p-4", "0xf.78bc51f239e104p-4", "0xf.7241712d4eddb8p-4", "0xf.6ba073b424b174p-4", "0xf.64d969e1dfc1e4p-4", "0xf.5dec646f85b9fp-4", "0xf.56d97473d446ap-4",
"0xf.4fa0ab6316edp-4", "0xf.48421b0efbf908p-4", "0xf.40bdd5a668863p-4", "0xf.3913edb54ba1fp-4", "0xf.314476247088c4p-4", "0xf.294f82394ffdfcp-4", "0xf.21352595e0bfp-4", "0xf.18f5743867122cp-4",
"0xf.1090827b437228p-4", "0xf.08066514c055cp-4", "0xe.ff573116df151cp-4", "0xe.f682fbef23ecap-4", "0xe.ed89db66611df4p-4", "0xe.e46be5a0812fdcp-4", "0xe.db29311c504d28p-4", "0xe.d1c1d4b344c398p-4",
"0xe.c835e79946a2d4p-4", "0xe.be85815c767c7p-4", "0xe.b4b0b9e4f3452p-4", "0xe.aab7a9749f581p-4", "0xe.a09a68a6e49c94p-4", "0xe.9659107077cf1cp-4", "0xe.8bf3ba1f1aedb8p-4", "0xe.816a7f595ec8dcp-4",
"0xe.76bd7a1e63b934p-4", "0xe.6becc4c5997aa8p-4", "0xe.60f879fe7e2dd8p-4", "0xe.55e0b4d05c7ffp-4", "0xe.4aa5909a08fa3p-4", "0xe.3f4729119e7944p-4", "0xe.33c59a4439cd44p-4", "0xe.28210095b48328p-4",
"0xe.1c5978c05ed81cp-4", "0xe.106f1fd4b8d77cp-4", "0xe.046213392aa438p-4", "0xd.f83270a9bbee38p-4", "0xd.ebe05637ca948p-4","0xd.df6be249c074bp-4", "0xd.d2d5339ac868dcp-4", "0xd.c61c693a827408p-4",
"0xd.b941a28cb71e74p-4", "0xd.ac44ff490a021cp-4", "0xd.9f269f7aab886cp-4", "0xd.91e6a38009d9cp-4", "0xd.84852c0a80ff74p-4", "0xd.77025a1e0a398p-4", "0xd.695e4f10ea87fcp-4", "0xd.5b992c8b6069dcp-4",
"0xd.4db3148750d128p-4", "0xd.3fac294ff34dfp-4", "0xd.31848d817d7084p-4", "0xd.233c6408cd63c4p-4", "0xd.14d3d02313c09p-4", "0xd.064af55d7c9ae4p-4", "0xc.f7a1f794d7c9bcp-4", "0xc.e8d8faf5406a58p-4",
"0xc.d9f023f9c39ff8p-4", "0xc.cae7976c0690b4p-4", "0xc.bbbf7a63eba078p-4", "0xc.ac77f24736eafp-4", "0xc.9d1124c931fd44p-4", "0xc.8d8b37ea4ed09p-4", "0xc.7de651f7ca060cp-4", "0xc.6e22998b4c65ap-4",
"0xc.5e40358a8b9ff4p-4", "0xc.4e3f4d26ea54d4p-4", "0xc.3e2007dd175efp-4", "0xc.2de28d74ac65cp-4", "0xc.1d8705ffcbb67cp-4", "0xc.0d0d99dabd6568p-4", "0xb.fc7671ab8bb7ep-4", "0xb.ebc1b6619ed8a4p-4",
"0xb.daef913557d7p-4", "0xb.ca002ba7aaf1fp-4", "0xb.b8f3af81b93028p-4", "0xb.a7ca46d469461p-4", "0xb.96841bf7ffcabp-4", "0xb.8521598bb6bc7p-4","0xb.73a22a755456dp-4", "0xb.6206b9e0c13a14p-4",

"0xc.90fdaa22168c24p-4", "0xc.90f87f3380388cp-4", "0xc.90e8fe6f63c234p-4", "0xc.90cf27ecb4a8dp-4", "0xc.90aafbd1b33efcp-4", "0xc.907c7a53ec66ccp-4", "0xc.9043a3b8393364p-4", "0xc.90007852be6fa8p-4",
"0xc.8fb2f886ec09f4p-4", "0xc.8f5b24c77c64ccp-4", "0xc.8ef8fd96738cc4p-4", "0xc.8e8c83851e5344p-4", "0xc.8e15b734114e88p-4","0xc.8d94995327be9p-4", "0xc.8d092aa1825748p-4", "0xc.8c736bed85efa4p-4",
"0xc.8bd35e14da15fp-4", "0xc.8b290204678928p-4", "0xc.8a7458b8569788p-4", "0xc.89b5633c0d622p-4", "0xc.88ec22aa2e05acp-4", "0xc.8818982c94a878p-4", "0xc.873ac4fc556d9p-4", "0xc.8652aa61ba4d04p-4",
"0xc.856049b440d168p-4", "0xc.8463a45a97babp-4", "0xc.835cbbca9c860cp-4", "0xc.824b918958db3cp-4", "0xc.8130272affdf08p-4", "0xc.800a7e52eb6b28p-4", "0xc.7eda98b3992b54p-4", "0xc.7da0780ea79fd8p-4",
"0xc.7c5c1e34d30558p-4", "0xc.7b0d8d05f2221cp-4", "0xc.79b4c670f2f8cp-4", "0xc.7851cc73d7603p-4", "0xc.76e4a11bb1815p-4", "0xc.756d4684a039fcp-4", "0xc.73ebbed9cb659cp-4", "0xc.72600c55600b3p-4",
"0xc.70ca31408c711p-4", "0xc.6f2a2ff37c161cp-4", "0xc.6d800ad55390bcp-4", "0xc.6bcbc45c2c5364p-4", "0xc.6a0d5f0d1056ccp-4", "0xc.6844dd7bf5aa08p-4", "0xc.6672424bb9e834p-4", "0xc.6495902e1d94p-4",
"0xc.62aec9e3bf5914p-4", "0xc.60bdf23c173354p-4", "0xc.5ec30c15717bfp-4", "0xc.5cbe1a5ce9dc84p-4", "0xc.5aaf200e662824p-4", "0xc.58962034911a64p-4", "0xc.56731de8d4fc8p-4", "0xc.54461c5356309p-4",
"0xc.520f1eaaeda2d4p-4", "0xc.4fce283523214cp-4", "0xc.4d833c46279964p-4", "0xc.4b2e5e40cf3c04p-4", "0xc.48cf91968b87dp-4","0xc.4666d9c76539d4p-4", "0xc.43f43a61f624ap-4", "0xc.4177b70362eda8p-4",
"0xc.3ef1535754b16p-4", "0xc.3c611317f28dacp-4", "0xc.39c6fa0ddb12f8p-4", "0xc.37230c101d9c04p-4", "0xc.34754d04338c4cp-4", "0xc.31bdc0ddf97518p-4", "0xc.2efc6b9fa82198p-4", "0xc.2c315159cd8978p-4",
"0xc.295c762b45aab8p-4", "0xc.267dde41334a24p-4", "0xc.23958dd6f89b0cp-4", "0xc.20a389362fcddcp-4", "0xc.1da7d4b6a385e8p-4","0xc.1aa274be47365p-4", "0xc.17936dc12f664p-4", "0xc.147ac44189dc4cp-4",
"0xc.11587ccf95b138p-4", "0xc.0e2c9c099b4a28p-4", "0xc.0af7269be43a5p-4", "0xc.07b82140b30c04p-4", "0xc.046f90c03af17cp-4", "0xc.011d79f0975d38p-4", "0xb.fdc1e1b5c38214p-4", "0xb.fa5ccd0191bb2p-4",
"0xb.f6ee40d3a2db4cp-4", "0xb.f37642395d65p-4", "0xb.eff4d64de4a9a4p-4", "0xb.ec6a023a0fd13cp-4", "0xb.e8d5cb3460ca1p-4", "0xb.e5383680fb2078p-4", "0xb.e19149719abf08p-4", "0xb.dde109658a96dp-4",
"0xb.da277bc99b304p-4", "0xb.d664a618192434p-4", "0xb.d2988dd8c37dccp-4", "0xb.cec338a0c204ap-4", "0xb.cae4ac129b6fbcp-4", "0xb.c6fcedde2b8154p-4", "0xb.c30c03c0990b3cp-4", "0xb.bf11f3844bdc48p-4",
"0xb.bb0ec300e296a8p-4", "0xb.b702781b286f4p-4", "0xb.b2ed18c50ad62p-4", "0xb.aeceaafd8f0834p-4", "0xb.aaa734d0c78a2cp-4", "0xb.a676bc57c98cb8p-4", "0xb.a23d47b8a23a5p-4", "0xb.9dfadd264bee4cp-4",
"0xb.99af82e0a355b8p-4", "0xb.955b3f345c79c8p-4", "0xb.90fe187af7b4p-4", "0xb.8c98151ab68c38p-4", "0xb.88293b8690808cp-4", "0xb.83b1923e27b74cp-4", "0xb.7f311fcdbd9af4p-4", "0xb.7aa7eace276064p-4",
"0xb.7615f9e4c27738p-4", "0xb.717b53c368e4ap-4", "0xb.6cd7ff2865887cp-4", "0xb.682c02de684d14p-4", "0xb.637765bc7a416cp-4", "0xb.5eba2ea5f19e3p-4", "0xb.59f4648a65b58p-4", "0xb.55260e65a2cd9p-4",
};


static const ap_fixed< 52 , 1 > sin_cos_K1 [ 256 ] = {
"0x8.p-52", "-0x1.3bd34abaf94p-8", "-0x2.77a38a3203p-8", "-0x3.b36db328afp-8", "-0x4.ef2eba71914p-8", "-0x6.2ae394f5cdap-8", "-0x7.668937bc896p-8", "-0x8.a21c97f27ccp-8",
"-0x9.dd9aaaf16c2p-8", "-0xb.19006647a9cp-8", "-0xc.544abfbf99p-8", "-0xd.8f76ad672eep-8", "-0xe.ca8125976aap-8", "-0x1.005671efbde6p-4", "-0x1.14025909a2a6p-4", "-0x1.27ab971d971ep-4",
"-0x1.3b51fba89e6p-4", "-0x1.4ef5562ec2f4p-4", "-0x1.6295763b8f9ep-4", "-0x1.76322b628608p-4", "-0x1.89cb453f969cp-4", "-0x1.9d6093779806p-4", "-0x1.b0f1e5b8be48p-4", "-0x1.c47f0bbb11fcp-4",
"-0x1.d807d540e7b2p-4", "-0x1.eb8c12175692p-4", "-0x1.ff0b9216afb8p-4", "-0x2.12862522f4bp-4", "-0x2.25fb9b2c4e36p-4", "-0x2.396bc42f82dcp-4", "-0x2.4cd670366dfp-4", "-0x2.603b6f5874aap-4",
"-0x2.739a91bafddp-4", "-0x2.86f3a791e6b2p-4", "-0x2.9a46811ff99cp-4", "-0x2.ad92eeb7639p-4", "-0x2.c0d8c0ba29cp-4", "-0x2.d417c79a9f1ep-4", "-0x2.e74fd3dbda0cp-4", "-0x2.fa80b61229p-4",
"-0x3.0daa3ee3879ap-4", "-0x3.20cc3f0813fp-4", "-0x3.33e6874a82bp-4", "-0x3.46f8e88893aep-4", "-0x3.5a0333b386d6p-4", "-0x3.6d0539d08f1ap-4", "-0x3.7ffecbf947ap-4", "-0x3.92efbb5c2664p-4",
"-0x3.a5d7d93cf08ep-4", "-0x3.b8b6f6f52d4ap-4", "-0x3.cb8ce5f4991cp-4", "-0x3.de5977c198a8p-4", "-0x3.f11c7df9ab6cp-4", "-0x4.03d5ca51dep-4", "-0x4.16852e973ccep-4", "-0x4.292a7caf4568p-4",
"-0x4.3bc5869858eap-4", "-0x4.4e561e6a2dp-4", "-0x4.60dc16563d62p-4", "-0x4.735740a83dp-4", "-0x4.85c76fc68662p-4", "-0x4.982c76328cbcp-4", "-0x4.aa8626894b64p-4", "-0x4.bcd45383b6bcp-4",
"-0x4.cf16cff72b0ap-4", "-0x4.e14d6ed5dcb4p-4", "-0x4.f378032f46bcp-4", "-0x5.059660309a26p-4", "-0x5.17a859252c12p-4", "-0x5.29adc176e494p-4", "-0x5.3ba66caeac78p-4", "-0x5.4d922e74daa8p-4",
"-0x5.5f70da91a264p-4", "-0x5.714244ed7f2ap-4", "-0x5.83064191a2f8p-4", "-0x5.94bca4a86152p-4", "-0x5.a665427d9c7ap-4", "-0x5.b7ffef7f30eep-4", "-0x5.c98c803d6092p-4", "-0x5.db0ac96b3e5ap-4",
"-0x5.ec7a9fdf190cp-4", "-0x5.fddbd892e568p-4", "-0x6.0f2e48a4a8aap-4", "-0x6.2071c556e23ep-4", "-0x6.31a62410f548p-4", "-0x6.42cb3a5f9158p-4", "-0x6.53e0ddf51beep-4", "-0x6.64e6e4aa1804p-4",
"-0x6.75dd247d8eaap-4", "-0x6.86c373957652p-4", "-0x6.9799a83f1a38p-4", "-0x6.a85f98ef8162p-4", "-0x6.b9151c43d4b4p-4", "-0x6.c9ba0901c5d2p-4", "-0x6.da4e3617f3dcp-4", "-0x6.ead17a9e51b4p-4",
"-0x6.fb43add68a2ap-4", "-0x7.0ba4a72c64f6p-4", "-0x7.1bf43e362af4p-4", "-0x7.2c324ab5094cp-4", "-0x7.3c5ea495755cp-4", "-0x7.4c7923ef8f16p-4", "-0x7.5c81a10783e4p-4", "-0x7.6c77f44df062p-4",
"-0x7.7c5bf660422cp-4", "-0x7.8c2d800918fcp-4", "-0x7.9bec6a40a75cp-4", "-0x7.ab988e2d1314p-4", "-0x7.bb31c522d4dcp-4", "-0x7.cab7e8a517b2p-4", "-0x7.da2ad266184ep-4", "-0x7.e98a5c478322p-4",
"-0x7.f8d6605ad2aep-4", "-0x8.080eb8e1acbap-4", "-0x8.1733404e3ff2p-4", "-0x8.2643d143a08cp-4", "-0x8.3540469623bcp-4", "-0x8.44287b4bbc9p-4", "-0x8.52fc4a9c561ep-4", "-0x8.61bb8ff22eeap-4",
"-0x8.706626ea32e4p-4", "-0x8.7efbeb545568p-4", "-0x8.8d7cb933ea4p-4", "-0x8.9be86cbffe8ap-4", "-0x8.aa3ee263b144p-4", "-0x8.b87ff6be8ab4p-4", "-0x8.c6ab86a4d3f4p-4", "-0x8.d4c16f1fed9ep-4",

"-0x2.p-52", "-0x5.2aedf31dbcp-12", "-0xa.55d43fb846p-12", "-0xf.80ab3f59aap-12", "-0x1.4ab6b4ba722p-8", "-0x1.9d60cbe6e56p-8", "-0x1.f0087f1b2dp-8", "-0x2.42ad53fbb72p-8",
"-0x2.954ed03203ap-8", "-0x2.e7ec796d724p-8", "-0x3.3a85d56426ap-8", "-0x3.8d1a69d3d46p-8", "-0x3.dfa9bc829f4p-8", "-0x4.3233533fe9cp-8", "-0x4.84b6b3e5366p-8", "-0x4.d7336456f74p-8",
"-0x5.29a8ea85688p-8", "-0x5.7c16cc6d658p-8", "-0x5.ce7c9019438p-8", "-0x6.20d9bba1a36p-8", "-0x6.732dd52e4e2p-8", "-0x6.c57862f704cp-8", "-0x7.17b8eb445e6p-8", "-0x7.69eef470996p-8",
"-0x7.bc1a04e86eap-8", "-0x8.0e39a32bf46p-8", "-0x8.604d55cf65cp-8", "-0x8.b254a37c02cp-8", "-0x9.044f12f0dccp-8", "-0x9.563c2b03b6ap-8", "-0x9.a81b72a1d16p-8", "-0x9.f9ec70d0c7cp-8",
"-0xa.4baeacaf5c2p-8", "-0xa.9d61ad7653ap-8", "-0xa.ef04fa794aap-8", "-0xb.40981b27818p-8", "-0xb.921a970cba2p-8", "-0xb.e38bf5d206cp-8", "-0xc.34ebbf3ea1cp-8", "-0xc.86397b38ba4p-8",
"-0xc.d774b1c64ecp-8", "-0xd.289ceb0df9ap-8", "-0xd.79b1af57caep-8", "-0xd.cab2870e184p-8", "-0xe.1b9efabe484p-8", "-0xe.6c769319b0cp-8", "-0xe.bd38d8f661p-8", "-0xf.0de5554ff2ap-8",
"-0xf.5e7b91485cep-8", "-0xf.aefb1628c9ap-8", "-0xf.ff636d625dep-8", "-0x1.04fb4208f0f4p-4", "-0x1.09fecb97273ep-4", "-0x1.0f00cc1fa8f4p-4", "-0x1.14013c440a5cp-4", "-0x1.190014a8a09cp-4",
"-0x1.1dfd4df48e78p-4", "-0x1.22f8e0d1d192p-4", "-0x1.27f2c5ed4efap-4", "-0x1.2ceaf5f6e056p-4", "-0x1.31e169a1606ep-4", "-0x1.36d619a2b806p-4", "-0x1.3bc8feb3eb28p-4", "-0x1.40ba119124f4p-4",
"-0x1.45a94af9c56p-4", "-0x1.4a96a3b06d56p-4", "-0x1.4f82147b0b58p-4", "-0x1.546b9622e89p-4", "-0x1.59532174b56ep-4", "-0x1.5e38af40959ep-4", "-0x1.631c385a2dcep-4", "-0x1.67fdb598aedap-4",
"-0x1.6cdd1fd6e3aap-4", "-0x1.71ba6ff33c96p-4", "-0x1.76959ecfdccap-4", "-0x1.7b6ea552a634p-4", "-0x1.80457c654612p-4", "-0x1.851a1cf54142p-4", "-0x1.89ec7ff400f4p-4", "-0x1.8ebc9e56dec4p-4",
"-0x1.938a711730e8p-4", "-0x1.9855f13256ap-4", "-0x1.9d1f17a9c4c8p-4", "-0x1.a1e5dd831194p-4", "-0x1.a6aa3bc800dcp-4", "-0x1.ab6c2b869064p-4", "-0x1.b02ba5d10418p-4", "-0x1.b4e8a3bdf1f8p-4",
"-0x1.b9a31e684e28p-4", "-0x1.be5b0eef7706p-4", "-0x1.c3106e77411cp-4", "-0x1.c7c336280348p-4", "-0x1.cc735f2ea284p-4", "-0x1.d120e2bc9da2p-4", "-0x1.d5cbba0819a4p-4", "-0x1.da73de4beceap-4",
"-0x1.df1948c7abcp-4", "-0x1.e3bbf2bfb35p-4", "-0x1.e85bd57d3622p-4", "-0x1.ecf8ea4e4742p-4", "-0x1.f1932a85e60ap-4", "-0x1.f62a8f7c09eap-4", "-0x1.fabf128daddp-4", "-0x1.ff50ad1cdba8p-4",
"-0x2.03df5890b80ep-4", "-0x2.086b0e558da6p-4", "-0x2.0cf3c7dcd876p-4", "-0x2.11797e9d5188p-4", "-0x2.15fc2c12fa0ep-4", "-0x2.1a7bc9bf2694p-4", "-0x2.1ef851288abap-4", "-0x2.2371bbdb43e4p-4",
"-0x2.27e80368e4b4p-4", "-0x2.2c5b2168804cp-4", "-0x2.30cb0f76b52ep-4", "-0x2.3537c735b84cp-4", "-0x2.39a1424d603p-4", "-0x2.3e077a6b2ffep-4", "-0x2.426a69426228p-4", "-0x2.46ca088bf3cap-4",
"-0x2.4b265206aec8p-4", "-0x2.4f7f3f773578p-4", "-0x2.53d4caa80cbp-4", "-0x2.5826ed69a6cap-4", "-0x2.5c75a1926e8cp-4", "-0x2.60c0e0fed15cp-4", "-0x2.6508a5914a1cp-4", "-0x2.694ce9326b9cp-4",
};


static const ap_fixed< 44 , 0 > sin_cos_K2 [ 256 ] = {
"-0x4.ef4f326fb5p-4", "-0x4.ef491be5d2p-4", "-0x4.ef36d85612p-4", "-0x4.ef1867ed86p-4", "-0x4.eeedcaf7ap-4", "-0x4.eeb701dd0ap-4", "-0x4.ee740d256cp-4", "-0x4.ee24ed75bfp-4",
"-0x4.edc9a39123p-4", "-0x4.ed62305906p-4", "-0x4.ecee94cc8cp-4", "-0x4.ec6ed208cbp-4", "-0x4.ebe2e9496ep-4", "-0x4.eb4adbe785p-4", "-0x4.eaa6ab59f9p-4", "-0x4.e9f6593647p-4",
"-0x4.e939e72f0ap-4", "-0x4.e8715715c4p-4", "-0x4.e79caad8ep-4", "-0x4.e6bbe48544p-4", "-0x4.e5cf0645b2p-4", "-0x4.e4d6126263p-4", "-0x4.e3d10b41b1p-4", "-0x4.e2bff367cap-4",
"-0x4.e1a2cd7649p-4", "-0x4.e0799c2cfap-4", "-0x4.df446268eep-4", "-0x4.de0323251fp-4", "-0x4.dcb5e17a6bp-4", "-0x4.db5ca09f34p-4", "-0x4.d9f763e6b5p-4", "-0x4.d8862ec333p-4",
"-0x4.d70904c30cp-4", "-0x4.d57fe99304p-4", "-0x4.d3eae0fcfap-4", "-0x4.d249eee83ep-4", "-0x4.d09d1759a1p-4", "-0x4.cee45e738ep-4", "-0x4.cd1fc87504p-4", "-0x4.cb4f59bac3p-4",
"-0x4.c97316bf0ap-4", "-0x4.c78b0418aap-4", "-0x4.c597267bf6p-4", "-0x4.c39782bab1p-4", "-0x4.c18c1dc295p-4", "-0x4.bf74fc9facp-4", "-0x4.bd522479d4p-4", "-0x4.bb239a96cap-4",
"-0x4.b8e9645871p-4", "-0x4.b6a3873dc8p-4", "-0x4.b45208e281p-4", "-0x4.b1f4eefee7p-4", "-0x4.af8c3f67f8p-4", "-0x4.ad18000f9p-4", "-0x4.aa98370383p-4", "-0x4.a80cea6ea7p-4",
"-0x4.a5762097d9p-4", "-0x4.a2d3dfe282p-4", "-0x4.a0262ece69p-4", "-0x4.9d6d13f72fp-4", "-0x4.9aa896152ap-4", "-0x4.97d8bbfc03p-4", "-0x4.94fd8c9c67p-4", "-0x4.92170f0205p-4",
"-0x4.8f254a554fp-4", "-0x4.8c2845d9c5p-4", "-0x4.892008ef24p-4", "-0x4.860c9b108ep-4", "-0x4.82ee03d534p-4", "-0x4.7fc44aef62p-4", "-0x4.7c8f782cd5p-4", "-0x4.794f937736p-4",
"-0x4.7604a4d285p-4", "-0x4.72aeb45f6ap-4", "-0x4.6f4dca581dp-4", "-0x4.6be1ef1343p-4", "-0x4.686b2b01c9p-4", "-0x4.64e986af77p-4", "-0x4.615d0ac363p-4", "-0x4.5dc5bfff2ap-4",
"-0x4.5a23af3ec1p-4", "-0x4.5676e17949p-4", "-0x4.52bf5fc005p-4", "-0x4.4efd333eb1p-4", "-0x4.4b30653b36p-4", "-0x4.4758ff163fp-4", "-0x4.43770a49c6p-4", "-0x4.3f8a906a92p-4",
"-0x4.3b939b26efp-4", "-0x4.3792344732p-4", "-0x4.338665ad89p-4", "-0x4.2f70395583p-4", "-0x4.2b4fb954c7p-4", "-0x4.2724efd9a1p-4", "-0x4.22efe72cbp-4", "-0x4.1eb0a9af1cp-4",
"-0x4.1a6741dbc4p-4", "-0x4.1613ba467ap-4", "-0x4.11b61d9b96p-4", "-0x4.0d4e76a0fep-4", "-0x4.08dcd034cdp-4", "-0x4.0461354e49p-4", "-0x3.ffdbb0fceep-4", "-0x3.fb4c4e68cap-4",
"-0x3.f6b318d25ap-4", "-0x3.f2101b922p-4", "-0x3.ed636218f8p-4", "-0x3.e8acf7ef86p-4", "-0x3.e3ece8b685p-4", "-0x3.df234026cdp-4", "-0x3.da500a1027p-4", "-0x3.d573525a7ap-4",
"-0x3.d08d2504bep-4", "-0x3.cb9d8e25e3p-4", "-0x3.c6a499ebadp-4", "-0x3.c1a2549a7ep-4", "-0x3.bc96ca8edbp-4", "-0x3.b782083af9p-4", "-0x3.b2641a2898p-4", "-0x3.ad3d0cf7b8p-4",
"-0x3.a80ced5f1bp-4", "-0x3.a2d3c82b9p-4", "-0x3.9d91aa4071p-4", "-0x3.9846a09755p-4", "-0x3.92f2b83f5bp-4", "-0x3.8d95fe5e06p-4", "-0x3.8830802e34p-4", "-0x3.82c24b00bp-4",

"-0x1.4abbce625ep-4", "-0x1.4abad991c2p-4", "-0x1.4ab7fb2152p-4", "-0x1.4ab333166p-4", "-0x1.4aac817937p-4", "-0x1.4aa3e6559bp-4", "-0x1.4a9961baadp-4", "-0x1.4a8cf3bb2ep-4",
"-0x1.4a7e9c6cadp-4", "-0x1.4a6e5be8ddp-4", "-0x1.4a5c324c0cp-4", "-0x1.4a481fb672p-4", "-0x1.4a32244b23p-4", "-0x1.4a1a403142p-4", "-0x1.4a007392a5p-4", "-0x1.49e4be9ccdp-4",
"-0x1.49c7218097p-4", "-0x1.49a79c7243p-4", "-0x1.49862fa942p-4", "-0x1.4962db6096p-4", "-0x1.493d9fd65p-4", "-0x1.49167d4c4cp-4", "-0x1.48ed74074cp-4", "-0x1.48c2844f8dp-4",
"-0x1.4895ae712fp-4", "-0x1.4866f2bab5p-4", "-0x1.4836517eb7p-4", "-0x1.4803cb1293p-4", "-0x1.47cf5fcfc2p-4", "-0x1.479910126p-4", "-0x1.4760dc3a2dp-4", "-0x1.4726c4aa07p-4",
"-0x1.46eac9c886p-4", "-0x1.46acebff33p-4", "-0x1.466d2bbae1p-4", "-0x1.462b896c2fp-4", "-0x1.45e8058699p-4", "-0x1.45a2a0812dp-4", "-0x1.455b5ad5d9p-4", "-0x1.4512350255p-4",
"-0x1.44c72f876ep-4", "-0x1.447a4ae96fp-4", "-0x1.442b87afb8p-4", "-0x1.43dae664acp-4", "-0x1.43886796cep-4", "-0x1.43340bd727p-4", "-0x1.42ddd3ba22p-4", "-0x1.4285bfd7bbp-4",
"-0x1.422bd0cb36p-4", "-0x1.41d007329dp-4", "-0x1.417263afbp-4", "-0x1.4112e6e753p-4", "-0x1.40b1918199p-4", "-0x1.404e6429fep-4", "-0x1.3fe95f8efap-4", "-0x1.3f82846257p-4",
"-0x1.3f19d35945p-4", "-0x1.3eaf4d2bfep-4", "-0x1.3e42f2960fp-4", "-0x1.3dd4c4560ep-4", "-0x1.3d64c32df8p-4", "-0x1.3cf2efe32fp-4", "-0x1.3c7f4b3d76p-4", "-0x1.3c09d608dap-4",
"-0x1.3b929113b5p-4", "-0x1.3b197d2fdp-4", "-0x1.3a9e9b327bp-4", "-0x1.3a21ebf3ecp-4", "-0x1.39a3704f1ep-4", "-0x1.3923292326p-4", "-0x1.38a11750f7p-4", "-0x1.381d3bbe0cp-4",
"-0x1.37979751bfp-4", "-0x1.37102af7a1p-4", "-0x1.3686f79d8dp-4", "-0x1.35fbfe34c3p-4", "-0x1.356f3fb1cp-4", "-0x1.34e0bd0c11p-4", "-0x1.3450773e3bp-4", "-0x1.33be6f45afp-4",
"-0x1.332aa6235dp-4", "-0x1.32951cdb3ep-4", "-0x1.31fdd473e3p-4", "-0x1.3164cdf722p-4", "-0x1.30ca0a7218p-4", "-0x1.302d8af4fp-4", "-0x1.2f8f50927bp-4", "-0x1.2eef5c60b8p-4",
"-0x1.2e4daf78bcp-4", "-0x1.2daa4af6a3p-4", "-0x1.2d052ff991p-4", "-0x1.2c5e5fa36cp-4", "-0x1.2bb5db1931p-4", "-0x1.2b0ba38309p-4", "-0x1.2a5fba0bb2p-4", "-0x1.29b21fe158p-4",
"-0x1.2902d6348ep-4", "-0x1.2851de396ap-4", "-0x1.279f39266p-4", "-0x1.26eae83517p-4", "-0x1.2634eca244p-4", "-0x1.257d47ad3bp-4", "-0x1.24c3fa984p-4", "-0x1.240906a8abp-4",
"-0x1.234c6d2682p-4", "-0x1.228e2f5cacp-4", "-0x1.21ce4e992p-4", "-0x1.210ccc2c4ep-4", "-0x1.2049a969b1p-4", "-0x1.1f84e7a7bbp-4", "-0x1.1ebe883f4cp-4", "-0x1.1df68c8c76p-4",
"-0x1.1d2cf5edfbp-4", "-0x1.1c61c5c529p-4", "-0x1.1b94fd7637p-4", "-0x1.1ac69e6851p-4", "-0x1.19f6aa0536p-4", "-0x1.192521b94bp-4", "-0x1.185206f40bp-4", "-0x1.177d5b26edp-4",
"-0x1.16a71fc724p-4", "-0x1.15cf564b97p-4", "-0x1.14f6002e85p-4", "-0x1.141b1eecd5p-4", "-0x1.133eb405a2p-4", "-0x1.1260c0fb0ep-4", "-0x1.11814751b6p-4", "-0x1.10a04890f6p-4",
};


static const ap_fixed< 34 , -3 > sin_cos_K3 [ 256 ] = {
"0x2.fp-32", "0x2.0783db8p-12", "0x4.0f026e8p-12", "0x6.1676eep-12", "0x8.1ddc8bp-12", "0xa.252df8p-12", "0xc.2c66828p-12", "0xe.3381068p-12",
"0x1.03a78668p-8", "0x1.24147d08p-8", "0x1.447ea22p-8", "0x1.64e5a468p-8", "0x1.854938dp-8", "0x1.a5a90d68p-8", "0x1.c604cfe8p-8", "0x1.e65c33c8p-8",
"0x2.06aee518p-8", "0x2.26fc99ap-8", "0x2.4744fcdp-8", "0x2.6787c07p-8", "0x2.87c49708p-8", "0x2.a7fb2ddp-8", "0x2.c82b36fp-8", "0x2.e8546448p-8",
"0x3.087663b8p-8", "0x3.2890e8c8p-8", "0x3.48a3a178p-8", "0x3.68ae3e68p-8", "0x3.88b073dp-8", "0x3.a8a9f358p-8", "0x3.c89a66a8p-8", "0x3.e88188dp-8",
"0x4.085f039p-8", "0x4.28328c48p-8", "0x4.47fbd2e8p-8", "0x4.67ba88bp-8", "0x4.876e5f28p-8", "0x4.a7170c5p-8", "0x4.c6b43c9p-8", "0x4.e645a28p-8",
"0x5.05caf3cp-8", "0x5.2543df1p-8", "0x5.44b0172p-8", "0x5.640f538p-8", "0x5.83613e98p-8", "0x5.a2a591fp-8", "0x5.c1dbfaep-8", "0x5.e10431d8p-8",
"0x6.001de6b8p-8", "0x6.1f28cd5p-8", "0x6.3e2499e8p-8", "0x6.5d10fe58p-8", "0x6.7bedae4p-8", "0x6.9aba6028p-8", "0x6.b976c4ep-8", "0x6.d8229298p-8",
"0x6.f6bd7dp-8", "0x7.1547386p-8", "0x7.33bf7b38p-8", "0x7.5225f74p-8", "0x7.707a658p-8", "0x7.8ebc753p-8", "0x7.acebe1cp-8", "0x7.cb085b7p-8",
"0x7.e9119d68p-8", "0x8.070759cp-8", "0x8.24e94768p-8", "0x8.42b71b7p-8", "0x8.60708f5p-8", "0x8.7e15585p-8", "0x8.9ba52b98p-8", "0x8.b91fc43p-8",
"0x8.d684d22p-8", "0x8.f3d416b8p-8", "0x9.110d4048p-8", "0x9.2e300d1p-8", "0x9.4b3c338p-8", "0x9.683169e8p-8", "0x9.850f6adp-8", "0x9.a1d5efe8p-8",
"0x9.be84ae48p-8", "0x9.db1b634p-8", "0x9.f799c6b8p-8", "0xa.13ff929p-8", "0xa.304c7f5p-8", "0xa.4c804afp-8", "0xa.689aaacp-8", "0xa.849b5d08p-8",
"0xa.a0821b28p-8", "0xa.bc4ea018p-8", "0xa.d800a8e8p-8", "0xa.f397ef5p-8", "0xb.0f143278p-8", "0xb.2a752948p-8", "0xb.45ba94ep-8", "0xb.60e42fp-8",
"0xb.7bf1b688p-8", "0xb.96e2e9e8p-8", "0xb.b1b7827p-8", "0xb.cc6f419p-8", "0xb.e709e25p-8", "0xc.01872608p-8", "0xc.1be6ca58p-8", "0xc.36288d48p-8",
"0xc.504c303p-8", "0xc.6a51703p-8", "0xc.84380ebp-8", "0xc.9dffc9dp-8", "0xc.b7a8627p-8", "0xc.d1319d6p-8", "0xc.ea9b3648p-8", "0xd.03e4f15p-8",
"0xd.1d0e8c88p-8", "0xd.3617ce88p-8", "0xd.4f0079cp-8", "0xd.67c84a68p-8", "0xd.806f0b38p-8", "0xd.98f479bp-8", "0xd.b1585bf8p-8", "0xd.c99a744p-8",
"0xd.e1ba88c8p-8", "0xd.f9b85bb8p-8", "0xe.1193b2cp-8", "0xe.294c5568p-8", "0xe.40e20538p-8", "0xe.58548b88p-8", "0xe.6fa3ab1p-8", "0xe.86cf2c8p-8",

"0x6.8p-36", "0x5.19af2p-16", "0xa.3353dp-16", "0xf.4ce8p-16", "0x1.46661p-12", "0x1.97fb5c8p-12", "0x1.e98dc8p-12", "0x2.3b1cf6p-12",
"0x2.8ca80ep-12", "0x2.de2ece8p-12", "0x3.2fb07p-12", "0x3.812c878p-12", "0x3.d2a247p-12", "0x4.24116f8p-12", "0x4.75793f8p-12", "0x4.c6d92bp-12",
"0x5.1830b1p-12", "0x5.697f44p-12", "0x5.bac44bp-12", "0x6.0bff41p-12", "0x6.5d2f78p-12", "0x6.ae548f8p-12", "0x6.ff6dd68p-12", "0x7.507aaep-12",
"0x7.a17ad98p-12", "0x7.f26d76p-12", "0x8.4352238p-12", "0x8.94281p-12", "0x8.e4ef08p-12", "0x9.35a653p-12", "0x9.864d62p-12", "0x9.d6e397p-12",
"0xa.2768918p-12", "0xa.77db9cp-12", "0xa.c83c1ep-12", "0xb.1889bcp-12", "0xb.68c3c98p-12", "0xb.b8e9dc8p-12", "0xc.08fb298p-12", "0xc.58f73c8p-12",
"0xc.a8dd92p-12", "0xc.f8ada7p-12", "0xd.4866f48p-12", "0xd.9808a98p-12", "0xd.e7929a8p-12", "0xe.3704128p-12", "0xe.865c64p-12", "0xe.d59b218p-12",
"0xf.24bfe08p-12", "0xf.73c9dep-12", "0xf.c2b8a58p-12", "0x1.0118baep-8", "0x1.060426b8p-8", "0x1.0aedc65p-8", "0x1.0fd58f48p-8", "0x1.14bb7938p-8",
"0x1.199f7c4p-8", "0x1.1e818fep-8", "0x1.2361ab58p-8", "0x1.283fc518p-8", "0x1.2d1bd558p-8", "0x1.31f5d6ap-8", "0x1.36cdb9fp-8", "0x1.3ba37d18p-8",
"0x1.40771408p-8", "0x1.45487548p-8", "0x1.4a179b2p-8", "0x1.4ee47dep-8", "0x1.53af10b8p-8", "0x1.58775188p-8", "0x1.5d3d301p-8", "0x1.6200ac08p-8",
"0x1.66c1b61p-8", "0x1.6b804c3p-8", "0x1.703c6248p-8", "0x1.74f5ef9p-8", "0x1.79acedd8p-8", "0x1.7e615438p-8", "0x1.83131b4p-8", "0x1.87c2378p-8",
"0x1.8c6ea378p-8", "0x1.911858a8p-8", "0x1.95bf4c5p-8", "0x1.9a6374dp-8", "0x1.9f04cbcp-8", "0x1.a3a34bcp-8", "0x1.a83ee9e8p-8", "0x1.acd79ddp-8",
"0x1.b16d5fc8p-8", "0x1.b60028bp-8", "0x1.ba8ff12p-8", "0x1.bf1caf6p-8", "0x1.c3a65bd8p-8", "0x1.c82cefap-8", "0x1.ccb06178p-8", "0x1.d130ab58p-8",
"0x1.d5adc388p-8", "0x1.da27a49p-8", "0x1.de9e4418p-8", "0x1.e3119a5p-8", "0x1.e781a1d8p-8", "0x1.ebee51dp-8", "0x1.f057a16p-8", "0x1.f4bd8a68p-8",
"0x1.f92004a8p-8", "0x1.fd7f08p-8", "0x2.01da8f2p-8", "0x2.06328fc8p-8", "0x2.0a870358p-8", "0x2.0ed7e3p-8", "0x2.13252578p-8", "0x2.176ec528p-8",
"0x2.1bb4baep-8", "0x2.1ff6fd78p-8", "0x2.2435853p-8", "0x2.28704cc8p-8", "0x2.2ca74c58p-8", "0x2.30da7b68p-8", "0x2.3509d62p-8", "0x2.39354eep-8",
"0x2.3d5ce598p-8", "0x2.41808d38p-8", "0x2.45a0412p-8", "0x2.49bbfc8p-8", "0x2.4dd3b528p-8", "0x2.51e76528p-8", "0x2.55f704ap-8", "0x2.5a028dap-8",
};


static const ap_fixed< 26 , -4 > sin_cos_K4 [ 256 ] = {
"0x4.0f0674p-8", "0x4.0efc1cp-8", "0x4.0ee824p-8", "0x4.0eca54p-8", "0x4.0ea214p-8", "0x4.0e705cp-8", "0x4.0e342p-8", "0x4.0dedc8p-8",
"0x4.0d9de4p-8", "0x4.0d4398p-8", "0x4.0cdf98p-8", "0x4.0c7214p-8", "0x4.0bf9e8p-8", "0x4.0b77ap-8", "0x4.0aebbp-8","0x4.0a558p-8",
"0x4.09b5d8p-8", "0x4.090b8cp-8", "0x4.0857b4p-8", "0x4.079a0cp-8", "0x4.06d1fcp-8", "0x4.06007p-8", "0x4.0524e4p-8","0x4.043f1p-8",
"0x4.034facp-8", "0x4.0256p-8", "0x4.0152c4p-8", "0x4.004614p-8", "0x3.ff2f04p-8", "0x3.fe0d9p-8", "0x3.fce384p-8", "0x3.fbae74p-8",
"0x3.fa7048p-8", "0x3.f927e8p-8", "0x3.f7d5d8p-8", "0x3.f67a18p-8", "0x3.f514d8p-8", "0x3.f3a4fp-8", "0x3.f22bc8p-8","0x3.f0a938p-8",
"0x3.ef1c7p-8", "0x3.ed8644p-8", "0x3.ebe6b4p-8", "0x3.ea3c7p-8", "0x3.e8897cp-8", "0x3.e6cc5p-8", "0x3.e5062cp-8", "0x3.e335cp-8",
"0x3.e15becp-8", "0x3.df7898p-8", "0x3.dd8b6cp-8", "0x3.db94f8p-8", "0x3.d99538p-8", "0x3.d78b98p-8", "0x3.d578dp-8", "0x3.d35c8cp-8",
"0x3.d136cp-8", "0x3.cf07a8p-8", "0x3.cccec4p-8", "0x3.ca8ce8p-8", "0x3.c84108p-8", "0x3.c5ecbp-8", "0x3.c38e6cp-8", "0x3.c1279p-8",
"0x3.beb6b8p-8", "0x3.bc3cccp-8", "0x3.b9b9c4p-8", "0x3.b72dd4p-8", "0x3.b4985cp-8", "0x3.b1f9acp-8", "0x3.af5228p-8", "0x3.aca0fp-8",
"0x3.a9e7dp-8", "0x3.a7245cp-8", "0x3.a458e8p-8", "0x3.a183fcp-8", "0x3.9ea6p-8", "0x3.9bbf58p-8", "0x3.98cfc4p-8", "0x3.95d6f4p-8",
"0x3.92d5f4p-8", "0x3.8fcbacp-8", "0x3.8cb8acp-8", "0x3.899cep-8", "0x3.867894p-8", "0x3.834b04p-8", "0x3.801568p-8","0x3.7cd6ep-8",
"0x3.798fccp-8", "0x3.76405cp-8", "0x3.72e82p-8", "0x3.6f878cp-8", "0x3.6c1e04p-8", "0x3.68acb4p-8", "0x3.65329cp-8","0x3.61b058p-8",
"0x3.5e25ap-8", "0x3.5a922cp-8", "0x3.56f704p-8", "0x3.53535p-8", "0x3.4fa7d8p-8", "0x3.4bf3e4p-8", "0x3.4837bp-8", "0x3.4473acp-8",
"0x3.40a728p-8", "0x3.3cd2ecp-8", "0x3.38f68p-8", "0x3.351274p-8", "0x3.3126acp-8", "0x3.2d323p-8", "0x3.293678p-8", "0x3.2532a4p-8",
"0x3.2127cp-8", "0x3.1d14acp-8", "0x3.18f958p-8", "0x3.14d77p-8", "0x3.10ad0cp-8", "0x3.0c7b7cp-8", "0x3.08423cp-8", "0x3.0401ccp-8",
"0x2.ffb99cp-8", "0x2.fb6a48p-8", "0x2.f713acp-8", "0x2.f2b534p-8", "0x2.ee4ffcp-8", "0x2.e9e3p-8", "0x2.e56f5cp-8","0x2.e0f464p-8",

"0xa.335bp-12", "0xa.33498p-12", "0xa.33288p-12", "0xa.32fp-12", "0xa.32a7p-12", "0xa.324ccp-12", "0xa.31e5cp-12", "0xa.31638p-12",
"0xa.30d94p-12", "0xa.30344p-12", "0xa.2f808p-12", "0xa.2eb5cp-12", "0xa.2de48p-12", "0xa.2cf8p-12", "0xa.2bfc4p-12","0xa.2af14p-12",
"0xa.29d2p-12", "0xa.28ap-12", "0xa.275bcp-12", "0xa.2604cp-12", "0xa.24a18p-12", "0xa.2326cp-12", "0xa.219cp-12", "0xa.2005cp-12",
"0xa.1e514p-12", "0xa.1c914p-12", "0xa.1abacp-12", "0xa.18df8p-12", "0xa.16e88p-12", "0xa.14dfp-12", "0xa.12c5cp-12","0xa.109e4p-12",
"0xa.0e5dcp-12", "0xa.0c10cp-12", "0xa.09b6p-12", "0xa.07434p-12", "0xa.04c14p-12", "0xa.0225p-12", "0x9.ff7ecp-12", "0x9.fccap-12",
"0x9.fa014p-12", "0x9.f7264p-12", "0x9.f4348p-12", "0x9.f13ep-12", "0x9.ee2b4p-12", "0x9.eb054p-12", "0x9.e7d5cp-12","0x9.e4954p-12",
"0x9.e13bcp-12", "0x9.ddd6p-12", "0x9.da5fp-12", "0x9.d6d7p-12", "0x9.d33dp-12", "0x9.cf8ep-12", "0x9.cbd18p-12", "0x9.c8048p-12",
"0x9.c4268p-12", "0x9.c035p-12", "0x9.bc33p-12", "0x9.b823p-12", "0x9.b4024p-12", "0x9.afc5p-12", "0x9.ab848p-12", "0x9.a728cp-12",
"0x9.a2be8p-12", "0x9.9e4ap-12", "0x9.99c28p-12", "0x9.95234p-12", "0x9.907d4p-12", "0x9.8bb9cp-12", "0x9.86f6p-12","0x9.8212cp-12",
"0x9.7d2c4p-12", "0x9.7829p-12", "0x9.73184p-12", "0x9.6dfc8p-12", "0x9.68cbp-12", "0x9.638bp-12", "0x9.5e35p-12", "0x9.58d8p-12",
"0x9.5368cp-12", "0x9.4de2p-12", "0x9.484b8p-12", "0x9.42adp-12", "0x9.3d008p-12", "0x9.37398p-12", "0x9.31648p-12", "0x9.2b828p-12",
"0x9.25924p-12", "0x9.1f8f8p-12", "0x9.19798p-12", "0x9.13578p-12", "0x9.0d25cp-12", "0x9.06e3cp-12", "0x9.0093p-12", "0x8.fa30cp-12",
"0x8.f3bfcp-12", "0x8.ed3acp-12", "0x8.e6aap-12", "0x8.e00ecp-12", "0x8.d95e8p-12", "0x8.d29d4p-12", "0x8.cbd1p-12","0x8.c4f3cp-12",
"0x8.be07cp-12", "0x8.b70f4p-12", "0x8.b0008p-12", "0x8.a8e74p-12", "0x8.a1bd8p-12", "0x8.9a844p-12", "0x8.933fcp-12", "0x8.8be9p-12",
"0x8.8480cp-12", "0x8.7d0dp-12", "0x8.758fp-12", "0x8.6dfe4p-12", "0x8.665e4p-12", "0x8.5eb38p-12", "0x8.56ef4p-12", "0x8.4f2c8p-12",
"0x8.474d4p-12", "0x8.3f6a4p-12", "0x8.37798p-12", "0x8.2f71cp-12", "0x8.275ecp-12", "0x8.1f3c8p-12", "0x8.170ecp-12", "0x8.0ed04p-12",
};
};

namespace first_order_fixed_16 {


static const ap_fixed< 19 , 2 > sin_cos_K0 [ 256 ] = {
"0x1.p0", "0xf.fffp-4", "0xf.ffbp-4", "0xf.ff5p-4", "0xf.fec8p-4", "0xf.fe18p-4", "0xf.fd38p-4", "0xf.fc38p-4",
"0xf.fb1p-4", "0xf.f9cp-4", "0xf.f85p-4", "0xf.f6bp-4", "0xf.f4e8p-4", "0xf.f3p-4", "0xf.f0e8p-4", "0xf.eebp-4",
"0xf.ec48p-4", "0xf.e9cp-4", "0xf.e71p-4", "0xf.e438p-4", "0xf.e138p-4", "0xf.de1p-4", "0xf.dacp-4", "0xf.d748p-4",
"0xf.d3bp-4", "0xf.cfe8p-4", "0xf.ccp-4", "0xf.c7fp-4", "0xf.c3b8p-4", "0xf.bf58p-4", "0xf.badp-4", "0xf.b62p-4",
"0xf.b15p-4", "0xf.ac5p-4", "0xf.a73p-4", "0xf.a1e8p-4", "0xf.9c8p-4", "0xf.96e8p-4", "0xf.9128p-4", "0xf.8b48p-4",
"0xf.854p-4", "0xf.7f1p-4", "0xf.78cp-4", "0xf.724p-4", "0xf.6bap-4", "0xf.64d8p-4", "0xf.5dfp-4", "0xf.56d8p-4",
"0xf.4fap-4", "0xf.4848p-4", "0xf.40cp-4", "0xf.3918p-4", "0xf.3148p-4", "0xf.295p-4", "0xf.2138p-4", "0xf.18f8p-4",
"0xf.109p-4", "0xf.0808p-4", "0xe.ff58p-4", "0xe.f688p-4", "0xe.ed9p-4", "0xe.e47p-4", "0xe.db28p-4", "0xe.d1c8p-4",
"0xe.c838p-4", "0xe.be88p-4", "0xe.b4bp-4", "0xe.aab8p-4", "0xe.a0ap-4", "0xe.9658p-4", "0xe.8bf8p-4", "0xe.817p-4",
"0xe.76cp-4", "0xe.6bfp-4", "0xe.60f8p-4", "0xe.55ep-4", "0xe.4aa8p-4", "0xe.3f48p-4", "0xe.33c8p-4", "0xe.282p-4",
"0xe.1c58p-4", "0xe.107p-4", "0xe.0468p-4", "0xd.f838p-4", "0xd.ebep-4", "0xd.df7p-4", "0xd.d2d8p-4", "0xd.c62p-4",
"0xd.b94p-4", "0xd.ac48p-4", "0xd.9f28p-4", "0xd.91e8p-4", "0xd.8488p-4", "0xd.7708p-4", "0xd.696p-4", "0xd.5b98p-4",
"0xd.4db8p-4", "0xd.3fbp-4", "0xd.3188p-4", "0xd.234p-4", "0xd.14d8p-4", "0xd.065p-4", "0xc.f7ap-4", "0xc.e8d8p-4",
"0xc.d9fp-4", "0xc.cae8p-4", "0xc.bbcp-4", "0xc.ac78p-4", "0xc.9d1p-4", "0xc.8d9p-4", "0xc.7de8p-4", "0xc.6e28p-4",
"0xc.5e4p-4", "0xc.4e4p-4", "0xc.3e2p-4", "0xc.2de8p-4", "0xc.1d88p-4", "0xc.0d1p-4", "0xb.fc78p-4", "0xb.ebcp-4",
"0xb.dafp-4", "0xb.cap-4", "0xb.b8f8p-4", "0xb.a7dp-4", "0xb.9688p-4", "0xb.852p-4", "0xb.73ap-4", "0xb.6208p-4",
"0xb.505p-4", "0xb.3e8p-4", "0xb.2c9p-4", "0xb.1a8p-4", "0xb.086p-4", "0xa.f618p-4", "0xa.e3cp-4", "0xa.d148p-4",
"0xa.beb8p-4", "0xa.ac08p-4", "0xa.994p-4", "0xa.866p-4", "0xa.7368p-4", "0xa.605p-4", "0xa.4d2p-4", "0xa.39ep-4",
"0xa.2678p-4", "0xa.13p-4", "0x9.ff7p-4", "0x9.ebcp-4", "0x9.d8p-4", "0x9.c42p-4", "0x9.b03p-4", "0x9.9c2p-4",
"0x9.88p-4", "0x9.73cp-4", "0x9.5f7p-4", "0x9.4bp-4", "0x9.368p-4", "0x9.21e8p-4", "0x9.0d4p-4", "0x8.f878p-4",
"0x8.e3ap-4", "0x8.cebp-4", "0x8.b9a8p-4", "0x8.a49p-4", "0x8.8f58p-4", "0x8.7a18p-4", "0x8.64b8p-4", "0x8.4f48p-4",
"0x8.39cp-4", "0x8.243p-4", "0x8.0e8p-4", "0x7.f8cp-4", "0x7.e2e8p-4", "0x7.cdp-4", "0x7.b708p-4", "0x7.a0f8p-4",
"0x7.8ad8p-4", "0x7.74a8p-4", "0x7.5e6p-4", "0x7.4808p-4", "0x7.31ap-4", "0x7.1b2p-4", "0x7.049p-4", "0x6.edfp-4",
"0x6.d74p-4", "0x6.c088p-4", "0x6.a9bp-4", "0x6.92dp-4", "0x6.7bep-4", "0x6.64ep-4", "0x6.4ddp-4", "0x6.36a8p-4",
"0x6.1f78p-4", "0x6.0838p-4", "0x5.f0e8p-4", "0x5.d99p-4", "0x5.c22p-4", "0x5.aaa8p-4", "0x5.932p-4", "0x5.7b88p-4",
"0x5.63e8p-4", "0x5.4c38p-4", "0x5.3478p-4", "0x5.1cbp-4", "0x5.04d8p-4", "0x4.ecfp-4", "0x4.d508p-4", "0x4.bd08p-4",
"0x4.a5p-4", "0x4.8cfp-4", "0x4.74dp-4", "0x4.5ca8p-4", "0x4.4478p-4", "0x4.2c38p-4", "0x4.13fp-4", "0x3.fbap-4",
"0x3.e34p-4", "0x3.cad8p-4", "0x3.b268p-4", "0x3.99fp-4", "0x3.817p-4", "0x3.68e8p-4", "0x3.5058p-4", "0x3.37b8p-4",
"0x3.1f18p-4", "0x3.067p-4", "0x2.edcp-4", "0x2.d5p-4", "0x2.bc4p-4", "0x2.a38p-4", "0x2.8abp-4", "0x2.71ep-4",
"0x2.59p-4", "0x2.402p-4", "0x2.274p-4", "0x2.0e5p-4", "0x1.f568p-4", "0x1.dc7p-4", "0x1.c378p-4", "0x1.aa8p-4",
"0x1.9178p-4", "0x1.7878p-4", "0x1.5f7p-4", "0x1.466p-4", "0x1.2d5p-4", "0x1.144p-4", "0xf.b28p-8", "0xe.218p-8",
"0xc.8f8p-8", "0xa.fep-8", "0x9.6cp-8", "0x7.da8p-8", "0x6.488p-8", "0x4.b68p-8", "0x3.24p-8", "0x1.92p-8",
};

static const ap_fixed< 11 , 2 > sin_cos_K1 [ 256 ] = {
"-0x1.p-8", "-0x4.p-8", "-0x6.p-8", "-0x8.8p-8", "-0xb.p-8", "-0xe.p-8", "-0xf.8p-8", "-0x1.2p-4",
"-0x1.48p-4", "-0x1.7p-4", "-0x1.ap-4", "-0x1.c8p-4", "-0x1.e8p-4", "-0x2.18p-4", "-0x2.38p-4", "-0x2.68p-4",
"-0x2.88p-4", "-0x2.bp-4", "-0x2.ep-4", "-0x3.08p-4", "-0x3.28p-4", "-0x3.5p-4", "-0x3.78p-4", "-0x3.98p-4",
"-0x3.c8p-4", "-0x3.e8p-4", "-0x4.1p-4", "-0x4.38p-4", "-0x4.6p-4", "-0x4.88p-4", "-0x4.bp-4", "-0x4.dp-4",
"-0x5.p-4", "-0x5.2p-4", "-0x5.48p-4", "-0x5.68p-4", "-0x5.98p-4", "-0x5.cp-4", "-0x5.ep-4", "-0x6.08p-4",
"-0x6.28p-4", "-0x6.5p-4", "-0x6.8p-4", "-0x6.98p-4", "-0x6.cp-4", "-0x6.e8p-4", "-0x7.18p-4", "-0x7.3p-4",
"-0x7.58p-4", "-0x7.88p-4", "-0x7.a8p-4", "-0x7.dp-4", "-0x7.f8p-4", "-0x8.18p-4", "-0x8.4p-4", "-0x8.68p-4",
"-0x8.88p-4", "-0x8.bp-4", "-0x8.dp-4", "-0x9.p-4", "-0x9.2p-4", "-0x9.48p-4", "-0x9.6p-4", "-0x9.9p-4",
"-0x9.bp-4", "-0x9.d8p-4", "-0x9.f8p-4", "-0xa.18p-4", "-0xa.48p-4", "-0xa.6p-4", "-0xa.88p-4", "-0xa.bp-4",
"-0xa.dp-4", "-0xa.f8p-4", "-0xb.18p-4", "-0xb.38p-4", "-0xb.6p-4", "-0xb.8p-4", "-0xb.a8p-4", "-0xb.cp-4",
"-0xb.e8p-4", "-0xc.08p-4", "-0xc.38p-4", "-0xc.58p-4", "-0xc.7p-4", "-0xc.98p-4", "-0xc.b8p-4", "-0xc.ep-4",
"-0xc.f8p-4", "-0xd.2p-4", "-0xd.4p-4", "-0xd.6p-4", "-0xd.8p-4", "-0xd.a8p-4", "-0xd.c8p-4", "-0xd.ep-4",
"-0xe.08p-4", "-0xe.28p-4", "-0xe.48p-4", "-0xe.68p-4", "-0xe.88p-4", "-0xe.bp-4", "-0xe.cp-4", "-0xe.e8p-4",
"-0xf.08p-4", "-0xf.28p-4", "-0xf.48p-4", "-0xf.68p-4", "-0xf.8p-4", "-0xf.a8p-4", "-0xf.cp-4", "-0xf.e8p-4",
"-0x1.p0", "-0x1.02p0", "-0x1.038p0", "-0x1.06p0", "-0x1.078p0", "-0x1.098p0", "-0x1.0b8p0", "-0x1.0dp0",
"-0x1.0fp0", "-0x1.108p0", "-0x1.13p0", "-0x1.148p0", "-0x1.168p0", "-0x1.178p0", "-0x1.198p0", "-0x1.1b8p0",
"-0x1.1dp0", "-0x1.1fp0", "-0x1.21p0", "-0x1.22p0", "-0x1.248p0", "-0x1.258p0", "-0x1.278p0", "-0x1.29p0",
"-0x1.2bp0", "-0x1.2c8p0", "-0x1.2ep0", "-0x1.2f8p0", "-0x1.318p0", "-0x1.328p0", "-0x1.34p0", "-0x1.368p0",
"-0x1.378p0", "-0x1.39p0", "-0x1.3bp0", "-0x1.3cp0", "-0x1.3ep0", "-0x1.3fp0", "-0x1.41p0", "-0x1.42p0",
"-0x1.44p0", "-0x1.45p0", "-0x1.468p0", "-0x1.478p0", "-0x1.49p0", "-0x1.4a8p0", "-0x1.4c8p0", "-0x1.4d8p0",
"-0x1.4fp0", "-0x1.508p0", "-0x1.518p0", "-0x1.538p0", "-0x1.54p0", "-0x1.56p0", "-0x1.57p0", "-0x1.58p0",
"-0x1.59p0", "-0x1.5bp0", "-0x1.5cp0", "-0x1.5d8p0", "-0x1.5e8p0", "-0x1.5f8p0", "-0x1.61p0", "-0x1.62p0",
"-0x1.63p0", "-0x1.648p0", "-0x1.658p0", "-0x1.668p0", "-0x1.68p0", "-0x1.69p0", "-0x1.698p0", "-0x1.6a8p0",
"-0x1.6b8p0", "-0x1.6d8p0", "-0x1.6ep0", "-0x1.6fp0", "-0x1.7p0", "-0x1.718p0", "-0x1.728p0", "-0x1.73p0",
"-0x1.74p0", "-0x1.75p0", "-0x1.758p0", "-0x1.77p0", "-0x1.778p0", "-0x1.788p0", "-0x1.798p0", "-0x1.7ap0",
"-0x1.7bp0", "-0x1.7cp0", "-0x1.7c8p0", "-0x1.7d8p0", "-0x1.7ep0", "-0x1.7e8p0", "-0x1.8p0", "-0x1.808p0",
"-0x1.81p0", "-0x1.82p0", "-0x1.828p0", "-0x1.83p0", "-0x1.84p0", "-0x1.848p0", "-0x1.85p0", "-0x1.86p0",
"-0x1.868p0", "-0x1.87p0", "-0x1.878p0", "-0x1.88p0", "-0x1.888p0", "-0x1.89p0", "-0x1.8ap0", "-0x1.8ap0",
"-0x1.8a8p0", "-0x1.8b8p0", "-0x1.8cp0", "-0x1.8cp0", "-0x1.8cp0", "-0x1.8dp0", "-0x1.8d8p0", "-0x1.8ep0",
"-0x1.8ep0", "-0x1.8ep0", "-0x1.8e8p0", "-0x1.8e8p0", "-0x1.8f8p0", "-0x1.8f8p0", "-0x1.9p0", "-0x1.908p0",
"-0x1.9p0", "-0x1.908p0", "-0x1.91p0", "-0x1.91p0", "-0x1.91p0", "-0x1.918p0", "-0x1.91p0", "-0x1.92p0",
"-0x1.918p0", "-0x1.92p0", "-0x1.918p0", "-0x1.92p0", "-0x1.92p0", "-0x1.928p0", "-0x1.92p0", "-0x1.92p0",
};
}



static const ap_fixed< 31 , 1 > second_tanh_K0 [ 512 ] = {
"-0xa.p-28", "0x3.ffea08p-8", "0x7.ff54c4p-8", "0xb.fdbfep-8","0xf.faac2cp-8", "0x1.3f59b34p-4", "0x1.7ee0f88p-4", "0x1.be38ce8p-4",
"0x1.fd5989p-4", "0x2.3c3b974p-4", "0x2.7ad786p-4", "0x2.b926054p-4", "0x2.f71fe9p-4", "0x3.34be2fp-4", "0x3.71f9ffcp-4", "0x3.aeccb1cp-4",
"0x3.eb2fcdp-4", "0x4.271d0c4p-4", "0x4.628e604p-4", "0x4.9d7df18p-4", "0x4.d7e6218p-4", "0x5.11c18d8p-4", "0x5.4b0b0f8p-4", "0x5.83bdbecp-4",
"0x5.bbd4f24p-4", "0x5.f34c404p-4", "0x6.2a1f804p-4", "0x6.604aca4p-4", "0x6.95ca778p-4", "0x6.ca9b228p-4", "0x6.feb9a78p-4", "0x7.322323p-4",
"0x7.64d4f3p-4", "0x7.96ccb48p-4", "0x7.c808444p-4", "0x7.f885bd8p-4", "0x8.284378p-4", "0x8.5740084p-4", "0x8.857a3ep-4","0x8.b2f122p-4",
"0x8.dfa3f5p-4", "0x9.0b922ecp-4", "0x9.36bb7bcp-4", "0x9.611fbbcp-4", "0x9.8abfp-4", "0x9.b399894p-4", "0x9.dbafc7p-4", "0xa.0302538p-4",
"0xa.2991f4p-4", "0xa.4f5f96p-4", "0xa.746c4ccp-4", "0xa.98b95p-4", "0xa.bc47facp-4", "0xa.df19c74p-4", "0xb.01304fcp-4", "0xb.228d4a4p-4",
"0xb.4332888p-4", "0xb.6321f48p-4", "0xb.825d90cp-4", "0xb.a0e774p-4", "0xb.bec1ca4p-4", "0xb.dbeed08p-4", "0xb.f870d58p-4", "0xc.144a368p-4",
"0xc.2f7d5dcp-4", "0xc.4a0cc2cp-4", "0xc.63fae6cp-4", "0xc.7d4a548p-4", "0xc.95fd9fp-4", "0xc.ae175f8p-4", "0xc.c59a354p-4", "0xc.dc88c3cp-4",
"0xc.f2e5b14p-4", "0xd.08b3a74p-4", "0xd.1df54fcp-4", "0xd.32ad554p-4", "0xd.46de618p-4", "0xd.5a8b1dcp-4", "0xd.6db63p-4","0xd.80623bcp-4",
"0xd.9291e14p-4", "0xd.a447bcp-4", "0xd.b58662cp-4", "0xd.c650678p-4", "0xd.d6a855cp-4", "0xd.e690b24p-4", "0xd.f60bfc4p-4", "0xe.051caa4p-4",
"0xe.13c52c8p-4", "0xe.2207ea8p-4", "0xe.2fe743cp-4", "0xe.3d658fcp-4", "0xe.4a851c8p-4", "0xe.57483p-4", "0xe.63b1064p-4", "0xe.6fc1d2cp-4",
"0xe.7b7cbfp-4", "0xe.86e3eb8p-4", "0xe.91f96fp-4", "0xe.9cbf56cp-4", "0xe.a737a5cp-4", "0xe.b16455cp-4", "0xe.bb4756cp-4", "0xe.c4e28ecp-4",
"0xe.ce37da4p-4", "0xe.d7490cp-4", "0xe.e017ec8p-4", "0xe.e8a63b8p-4", "0xe.f0f5aecp-4", "0xe.f907f28p-4", "0xf.00dea98p-4", "0xf.087b6dp-4",
"0xf.0fdfcep-4", "0xf.170d53p-4", "0xf.1e057a4p-4", "0xf.24c9b9p-4", "0xf.2b5b7bcp-4", "0xf.31bc26p-4", "0xf.37ed13p-4","0xf.3def958p-4",
"0xf.43c4f8p-4", "0xf.496e7ccp-4", "0xf.4eed5e4p-4", "0xf.5442ce8p-4", "0xf.596ff88p-4", "0xf.5e75ff4p-4", "0xf.6355fe4p-4", "0xf.68110a4p-4",
"0xf.6ca8308p-4", "0xf.711c768p-4", "0xf.756edc4p-4", "0xf.79a05a4p-4", "0xf.7db1e24p-4", "0xf.81a45fcp-4", "0xf.8578b88p-4", "0xf.892fcbp-4",
"0xf.8cca70cp-4", "0xf.90497ccp-4", "0xf.93adbccp-4", "0xf.96f7f8p-4", "0xf.9a28f14p-4", "0xf.9d41654p-4", "0xf.a0420cp-4","0xf.a32b98p-4",
"0xf.a5feb7p-4", "0xf.a8bc118p-4", "0xf.ab644c4p-4", "0xf.adf806p-4", "0xf.b077da4p-4", "0xf.b2e45f4p-4", "0xf.b53e278p-4", "0xf.b785c1p-4",
"0xf.b9bbb64p-4", "0xf.bbe08dp-4", "0xf.bdf4c8p-4", "0xf.bff8e54p-4", "0xf.c1ed604p-4", "0xf.c3d2bp-4", "0xf.c5a9488p-4", "0xf.c7719acp-4",
"0xf.c92c138p-4", "0xf.cad91d4p-4", "0xf.cc791fp-4", "0xf.ce0c7ccp-4", "0xf.cf93978p-4", "0xf.d10ecdcp-4", "0xf.d27e7bp-4","0xf.d3e2f8p-4",
"0xf.d53c9acp-4", "0xf.d68bb74p-4", "0xf.d7d09ecp-4", "0xf.d90b9fcp-4", "0xf.da3d074p-4", "0xf.db651ecp-4", "0xf.dc842fp-4","0xf.dd9a7d4p-4",
"0xf.dea84dcp-4", "0xf.dfade24p-4", "0xf.e0ab7a4p-4", "0xf.e1a154p-4", "0xf.e28fab8p-4", "0xf.e376bb4p-4", "0xf.e456bb4p-4", "0xf.e52fe3p-4",
"0xf.e602674p-4", "0xf.e6ce7bcp-4", "0xf.e794528p-4", "0xf.e8541c4p-4", "0xf.e90e08p-4", "0xf.e9c2438p-4", "0xf.ea70fbp-4","0xf.eb1a598p-4",
"0xf.ebbe88cp-4", "0xf.ec5db1p-4", "0xf.ecf7f9cp-4", "0xf.ed8d89p-4", "0xf.ee1e834p-4", "0xf.eeab0c8p-4", "0xf.ef33478p-4", "0xf.efb756p-4",
"0xf.f037584p-4", "0xf.f0b36e4p-4", "0xf.f12bb68p-4", "0xf.f1a04ecp-4", "0xf.f21153cp-4", "0xf.f27ee18p-4", "0xf.f2e9134p-4", "0xf.f350034p-4",
"0xf.f3b3cbp-4", "0xf.f414834p-4", "0xf.f47243cp-4", "0xf.f4cd23cp-4", "0xf.f5253ap-4", "0xf.f57a9c8p-4", "0xf.f5cd6p-4","0xf.f61d994p-4",
"0xf.f66b5cp-4", "0xf.f6b6bbcp-4", "0xf.f6ffcb4p-4", "0xf.f7469c8p-4", "0xf.f78b414p-4", "0xf.f7cdca4p-4", "0xf.f80e488p-4", "0xf.f84ccb8p-4",
"0xf.f889634p-4", "0xf.f8c41e8p-4", "0xf.f8fd0cp-4", "0xf.f93439cp-4", "0xf.f969b5cp-4", "0xf.f99d8dp-4", "0xf.f9cfcccp-4", "0xf.fa00814p-4",
"0xf.fa2fb6cp-4", "0xf.fa5d78cp-4", "0xf.fa89d3p-4", "0xf.fab4d04p-4", "0xf.fade7b8p-4", "0xf.fb06decp-4", "0xf.fb2e048p-4", "0xf.fb53f64p-4",
"0xf.fb78bd4p-4", "0xf.fb9c63p-4", "0xf.fbbef04p-4", "0xf.fbe06dcp-4", "0xf.fc00e3cp-4", "0xf.fc205a4p-4", "0xf.fc3ed94p-4", "0xf.fc5c68p-4",
"0xf.fc790e8p-4", "0xf.fc94d34p-4", "0xf.fcafbdcp-4", "0xf.fcc9d44p-4", "0xf.fce31d8p-4", "0xf.fcfb9f8p-4", "0xf.fd1361p-4","0xf.fd2a674p-4",
"0xf.fd40b84p-4", "0xf.fd5659cp-4", "0xf.fd6b51p-4", "0xf.fd7fa3p-4", "0xf.fd93554p-4", "0xf.fda66c8p-4", "0xf.fdb8ed4p-4", "0xf.fdcadc8p-4",
"0xf.fddc3e8p-4", "0xf.fded17cp-4", "0xf.fdfd6c4p-4", "0xf.fe0d404p-4", "0xf.fe1c97cp-4", "0xf.fe2b764p-4", "0xf.fe39dfcp-4", "0xf.fe47d8p-4",
"0xf.fe5562p-4", "0xf.fe62818p-4", "0xf.fe6f39cp-4", "0xf.fe7b8dcp-4", "0xf.fe8780cp-4", "0xf.fe93158p-4", "0xf.fe9e4f4p-4", "0xf.fea9308p-4",
"0xf.feb3bc4p-4", "0xf.febdf4cp-4", "0xf.fec7ddp-4", "0xf.fed177p-4", "0xf.fedac58p-4", "0xf.fee3cacp-4", "0xf.feec89p-4","0xf.fef5028p-4",
"0xf.fefd39p-4", "0xf.ff052fp-4", "0xf.ff0ce64p-4", "0xf.ff1460cp-4", "0xf.ff1ba08p-4", "0xf.ff22a7p-4", "0xf.ff29764p-4", "0xf.ff300fcp-4",
"0xf.ff36758p-4", "0xf.ff3ca8cp-4", "0xf.ff42abp-4", "0xf.ff487e4p-4", "0xf.ff4e238p-4", "0xf.ff539c4p-4", "0xf.ff58eap-4","0xf.ff5e0dcp-4",
"0xf.ff63094p-4", "0xf.ff67dd8p-4", "0xf.ff6c8b8p-4", "0xf.ff7115p-4", "0xf.ff757a8p-4", "0xf.ff79bd8p-4", "0xf.ff7ddfp-4","0xf.ff81dfcp-4",
"0xf.ff85c1p-4", "0xf.ff8984p-4", "0xf.ff8d29p-4", "0xf.ff90b18p-4", "0xf.ff941e4p-4", "0xf.ff976fcp-4", "0xf.ff9aa74p-4", "0xf.ff9dc58p-4",
"0xf.ffa0cb4p-4", "0xf.ffa3b9p-4", "0xf.ffa68fcp-4", "0xf.ffa9504p-4", "0xf.ffabfbp-4", "0xf.ffae90cp-4", "0xf.ffb112p-4","0xf.ffb37fcp-4",
"0xf.ffb5da4p-4", "0xf.ffb8224p-4", "0xf.ffba584p-4", "0xf.ffbc7ccp-4", "0xf.ffbe908p-4", "0xf.ffc094p-4", "0xf.ffc2878p-4", "0xf.ffc46bcp-4",
"0xf.ffc641p-4", "0xf.ffc807cp-4", "0xf.ffc9c08p-4", "0xf.ffcb6bcp-4", "0xf.ffcd0ap-4", "0xf.ffce9b4p-4", "0xf.ffd0204p-4", "0xf.ffd1994p-4",
"0xf.ffd306cp-4", "0xf.ffd469p-4", "0xf.ffd5c04p-4", "0xf.ffd70dp-4", "0xf.ffd84fcp-4", "0xf.ffd9884p-4", "0xf.ffdab74p-4", "0xf.ffdbdccp-4",
"0xf.ffdcf98p-4", "0xf.ffde0d4p-4", "0xf.ffdf18cp-4", "0xf.ffe01cp-4", "0xf.ffe117p-4", "0xf.ffe20a8p-4", "0xf.ffe2f68p-4", "0xf.ffe3db4p-4",
"0xf.ffe4b8cp-4", "0xf.ffe58fcp-4", "0xf.ffe66p-4", "0xf.ffe729cp-4", "0xf.ffe7ed8p-4", "0xf.ffe8abp-4", "0xf.ffe962cp-4", "0xf.ffea14cp-4",
"0xf.ffeac18p-4", "0xf.ffeb68cp-4", "0xf.ffec0bp-4", "0xf.ffeca84p-4", "0xf.ffed408p-4", "0xf.ffedd44p-4", "0xf.ffee634p-4", "0xf.ffeeeep-4",
"0xf.ffef748p-4", "0xf.ffeff6cp-4", "0xf.fff075p-4", "0xf.fff0ef8p-4", "0xf.fff1664p-4", "0xf.fff1d94p-4", "0xf.fff248cp-4", "0xf.fff2b4cp-4",
"0xf.fff31d4p-4", "0xf.fff382cp-4", "0xf.fff3e54p-4", "0xf.fff4448p-4", "0xf.fff4a1p-4", "0xf.fff4fa8p-4", "0xf.fff5514p-4", "0xf.fff5a58p-4",
"0xf.fff5f7p-4", "0xf.fff646p-4", "0xf.fff692cp-4", "0xf.fff6ddp-4", "0xf.fff725p-4", "0xf.fff76acp-4", "0xf.fff7ae4p-4", "0xf.fff7efcp-4",
"0xf.fff82f4p-4", "0xf.fff86ccp-4", "0xf.fff8a88p-4", "0xf.fff8e24p-4", "0xf.fff91a4p-4", "0xf.fff950cp-4", "0xf.fff9854p-4", "0xf.fff9b84p-4",
"0xf.fff9e9cp-4", "0xf.fffa19cp-4", "0xf.fffa484p-4", "0xf.fffa754p-4", "0xf.fffaa1p-4", "0xf.fffacb4p-4", "0xf.fffaf44p-4", "0xf.fffb1cp-4",
"0xf.fffb428p-4", "0xf.fffb67cp-4", "0xf.fffb8cp-4", "0xf.fffbafp-4", "0xf.fffbd1p-4", "0xf.fffbf2p-4", "0xf.fffc12p-4","0xf.fffc31p-4",
"0xf.fffc4fp-4", "0xf.fffc6cp-4", "0xf.fffc884p-4", "0xf.fffca38p-4", "0xf.fffcbep-4", "0xf.fffcd7cp-4", "0xf.fffcf08p-4", "0xf.fffd088p-4",
"0xf.fffd2p-4", "0xf.fffd368p-4", "0xf.fffd4c8p-4", "0xf.fffd61cp-4", "0xf.fffd768p-4", "0xf.fffd8a8p-4", "0xf.fffd9dcp-4", "0xf.fffdb08p-4",
"0xf.fffdc2cp-4", "0xf.fffdd48p-4", "0xf.fffde58p-4", "0xf.fffdf6p-4", "0xf.fffe064p-4", "0xf.fffe15cp-4", "0xf.fffe24cp-4", "0xf.fffe338p-4",
"0xf.fffe418p-4", "0xf.fffe4f4p-4", "0xf.fffe5c8p-4", "0xf.fffe698p-4", "0xf.fffe76p-4", "0xf.fffe824p-4", "0xf.fffe8ep-4","0xf.fffe994p-4",
"0xf.fffea44p-4", "0xf.fffeafp-4", "0xf.fffeb98p-4", "0xf.fffec38p-4", "0xf.fffecd4p-4", "0xf.fffed68p-4", "0xf.fffedfcp-4", "0xf.fffee8cp-4",
"0xf.fffef14p-4", "0xf.fffef98p-4", "0xf.ffff01cp-4", "0xf.ffff098p-4", "0xf.ffff11p-4", "0xf.ffff188p-4", "0xf.ffff1f8p-4", "0xf.ffff268p-4",
"0xf.ffff2dp-4", "0xf.ffff338p-4", "0xf.ffff3ap-4", "0xf.ffff4p-4", "0xf.ffff46p-4", "0xf.ffff4bcp-4", "0xf.ffff514p-4", "0xf.ffff568p-4",
"0xf.ffff5bcp-4", "0xf.ffff60cp-4", "0xf.ffff65cp-4", "0xf.ffff6a8p-4", "0xf.ffff6fp-4", "0xf.ffff738p-4", "0xf.ffff77cp-4", "0xf.ffff7cp-4",
"0xf.ffff8p-4", "0xf.ffff84p-4", "0xf.ffff87cp-4", "0xf.ffff8b8p-4", "0xf.ffff8f4p-4", "0xf.ffff928p-4", "0xf.ffff96p-4", "0xf.ffff994p-4",
"0xf.ffff9c8p-4", "0xf.ffff9f8p-4", "0xf.ffffa28p-4", "0xf.ffffa54p-4", "0xf.ffffa8p-4", "0xf.ffffaacp-4", "0xf.ffffad8p-4", "0xf.ffffbp-4",
"0xf.ffffb28p-4", "0xf.ffffb4cp-4", "0xf.ffffb7p-4", "0xf.ffffb94p-4", "0xf.ffffbb8p-4", "0xf.ffffbdcp-4", "0xf.ffffbfcp-4", "0xf.ffffc1cp-4",
};

static const ap_fixed< 26 , 5 > second_tanh_K1 [ 512 ] = {
"0x8.001758p0", "0x7.ff978p0", "0x7.fe17b8p0", "0x7.fb98f8p0", "0x7.f81c68p0","0x7.f3a3fp0", "0x7.ee3188p0", "0x7.e7c808p0",
"0x7.e06abp0", "0x7.d81cd8p0", "0x7.cee2d8p0", "0x7.c4c0cp0", "0x7.b9bcp0", "0x7.add948p0", "0x7.a11e7p0", "0x7.93918p0",
"0x7.85389p0", "0x7.761a58p0", "0x7.663da8p0", "0x7.55a97p0", "0x7.446538p0","0x7.327858p0", "0x7.1fea78p0", "0x7.0cc388p0",
"0x6.f90b5p0", "0x6.e4ca18p0", "0x6.d007b8p0", "0x6.bacc6p0", "0x6.a5205p0", "0x6.8f0bb8p0", "0x6.7896ap0", "0x6.61c95p0",
"0x6.4aab9p0", "0x6.33459p0", "0x6.1b9f08p0", "0x6.03bf98p0", "0x5.ebaf28p0","0x5.d37518p0", "0x5.bb187p0", "0x5.a2a068p0",
"0x5.8a141p0", "0x5.717ap0", "0x5.58d8cp0", "0x5.403698p0", "0x5.2799bp0", "0x5.0f07fp0", "0x4.f686ap0", "0x4.de1b8p0",
"0x4.c5cbap0", "0x4.ad9bcp0", "0x4.9590bp0", "0x4.7daefp0", "0x4.65fa6p0", "0x4.4e7768p0", "0x4.372958p0", "0x4.2013ep0",
"0x4.093a2p0", "0x3.f29f58p0", "0x3.dc4608p0", "0x3.c63128p0", "0x3.b062bp0", "0x3.9add38p0", "0x3.85a268p0", "0x3.70b418p0",
"0x3.5c1418p0", "0x3.47c38p0", "0x3.33c3cp0", "0x3.2015f8p0", "0x3.0cbafp0", "0x2.f9b38p0", "0x2.e70048p0", "0x2.d4a198p0",
"0x2.c2981p0", "0x2.b0e3b8p0", "0x2.9f84a8p0", "0x2.8e7ae8p0", "0x2.7dc678p0","0x2.6d66d8p0", "0x2.5d5bfp0", "0x2.4da548p0",
"0x2.3e4258p0", "0x2.2f3298p0", "0x2.207588p0", "0x2.120a2p0", "0x2.03efc8p0","0x1.f625ep0", "0x1.e8ab1p0", "0x1.db7efp0",
"0x1.cea02p0", "0x1.c20ddp0", "0x1.b5c718p0", "0x1.a9ca88p0", "0x1.9e1758p0","0x1.92ac28p0", "0x1.878808p0", "0x1.7ca9a8p0",
"0x1.72101p0", "0x1.67b9d8p0", "0x1.5da5e8p0", "0x1.53d2dp0", "0x1.4a3fa8p0","0x1.40eb28p0", "0x1.37d3f8p0", "0x1.2ef8f8p0",
"0x1.2658ep0", "0x1.1df268p0", "0x1.15c4a8p0", "0x1.0dce28p0", "0x1.060dcp0", "0xf.e823p-4", "0xf.72a8p-4", "0xf.0058p-4",
"0xe.911dp-4", "0xe.24e8p-4", "0xd.bba78p-4", "0xd.5548p-4", "0xc.f1b7p-4", "0xc.90e6p-4", "0xc.32c28p-4", "0xb.d73c8p-4",
"0xb.7e43p-4", "0xb.27c58p-4", "0xa.d3b38p-4", "0xa.82008p-4", "0xa.329bp-4", "0x9.e574p-4", "0x9.9a7fp-4", "0x9.51a9p-4",
"0x9.0ae5p-4", "0x8.c62a8p-4", "0x8.8365p-4", "0x8.42898p-4", "0x8.038c8p-4","0x7.c662p-4", "0x7.8af88p-4", "0x7.514ap-4",
"0x7.1946p-4", "0x6.e2e4p-4", "0x6.ae14p-4", "0x6.7ad18p-4", "0x6.490c8p-4","0x6.18bd8p-4", "0x5.e9d78p-4", "0x5.bc52p-4",
"0x5.90228p-4", "0x5.65428p-4", "0x5.3ba2p-4", "0x5.133fp-4", "0x4.ec0bp-4", "0x4.c602p-4", "0x4.a1188p-4", "0x4.7d498p-4",
"0x4.5a878p-4", "0x4.38dp-4", "0x4.1817p-4", "0x3.f8598p-4", "0x3.d98d8p-4","0x3.bbadp-4", "0x3.9eb28p-4", "0x3.82928p-4",
"0x3.674dp-4", "0x3.4cd7p-4", "0x3.332c8p-4", "0x3.1a47p-4", "0x3.02218p-4","0x2.eab5p-4", "0x2.d3fc8p-4", "0x2.bdf28p-4",
"0x2.a895p-4", "0x2.93dbp-4", "0x2.7fc08p-4", "0x2.6c428p-4", "0x2.59588p-4","0x2.47038p-4", "0x2.353a8p-4", "0x2.23fdp-4",
"0x2.13438p-4", "0x2.030bp-4", "0x1.f3528p-4", "0x1.e413p-4", "0x1.d54a8p-4","0x1.c6f2p-4", "0x1.b90c8p-4", "0x1.ab9p-4",
"0x1.9e7dp-4", "0x1.91d1p-4", "0x1.85878p-4", "0x1.799d8p-4", "0x1.6e1p-4", "0x1.62dc8p-4", "0x1.58008p-4", "0x1.4d79p-4",
"0x1.4343p-4", "0x1.395d8p-4", "0x1.2fc5p-4", "0x1.2676p-4", "0x1.1d71p-4", "0x1.14b3p-4", "0x1.0c39p-4", "0x1.04008p-4",
"0xf.c09p-8", "0xf.44e8p-8", "0xe.cd1p-8", "0xe.58ep-8", "0xd.e85p-8", "0xd.7b3p-8", "0xd.1158p-8", "0xc.aab8p-8",
"0xc.473p-8", "0xb.e6b8p-8", "0xb.8948p-8", "0xb.2ebp-8", "0xa.d6ep-8", "0xa.81a8p-8", "0xa.2f2p-8", "0x9.df2p-8",
"0x9.919p-8", "0x9.4668p-8", "0x8.fd8p-8", "0x8.b6ep-8", "0x8.725p-8", "0x8.3p-8", "0x7.ef88p-8", "0x7.b138p-8",
"0x7.74bp-8", "0x7.3a1p-8", "0x7.013p-8", "0x6.ca3p-8", "0x6.94cp-8", "0x6.6118p-8", "0x6.2eep-8", "0x5.fe4p-8",
"0x5.cf08p-8", "0x5.a17p-8", "0x5.7518p-8", "0x5.4a4p-8", "0x5.209p-8", "0x4.f85p-8", "0x4.d12p-8", "0x4.ab3p-8",
"0x4.8688p-8", "0x4.62fp-8", "0x4.407p-8", "0x4.1ef8p-8", "0x3.fe8p-8", "0x3.df18p-8", "0x3.c098p-8", "0x3.a33p-8",
"0x3.8678p-8", "0x3.6ac8p-8", "0x3.4fc8p-8", "0x3.35c8p-8", "0x3.1c78p-8", "0x3.041p-8", "0x2.ec38p-8", "0x2.d54p-8",
"0x2.bfp-8", "0x2.a96p-8", "0x2.946p-8", "0x2.802p-8", "0x2.6c78p-8", "0x2.595p-8", "0x2.46ep-8", "0x2.34fp-8",
"0x2.239p-8", "0x2.12b8p-8", "0x2.0268p-8", "0x1.f2ap-8", "0x1.e338p-8", "0x1.d468p-8", "0x1.c608p-8", "0x1.b7f8p-8",
"0x1.aa78p-8", "0x1.9d58p-8", "0x1.9098p-8", "0x1.8448p-8", "0x1.786p-8", "0x1.6cd8p-8", "0x1.61ap-8", "0x1.56cp-8",
"0x1.4c3p-8", "0x1.42p-8", "0x1.381p-8", "0x1.2e88p-8", "0x1.2538p-8", "0x1.1c3p-8", "0x1.1368p-8", "0x1.0ae8p-8",
"0x1.02cp-8", "0xf.ac8p-12", "0xf.31p-12", "0xe.b98p-12", "0xe.448p-12", "0xd.d48p-12", "0xd.678p-12", "0xc.fe8p-12",
"0xc.97p-12", "0xc.348p-12", "0xb.d5p-12", "0xb.77p-12", "0xb.1c8p-12", "0xa.c5p-12", "0xa.7p-12", "0xa.1fp-12",
"0x9.ce8p-12", "0x9.818p-12", "0x9.378p-12", "0x8.eep-12", "0x8.a8p-12", "0x8.638p-12", "0x8.21p-12", "0x7.e28p-12",
"0x7.a5p-12", "0x7.67p-12", "0x7.2ep-12", "0x6.f48p-12", "0x6.bd8p-12", "0x6.8ap-12", "0x6.568p-12", "0x6.24p-12",
"0x5.f3p-12", "0x5.c5p-12", "0x5.97p-12", "0x5.6a8p-12", "0x5.4p-12", "0x5.17p-12", "0x4.ef8p-12", "0x4.c8p-12",
"0x4.a28p-12", "0x4.7d8p-12", "0x4.5bp-12", "0x4.398p-12", "0x4.178p-12", "0x3.f68p-12", "0x3.d7p-12", "0x3.b8p-12",
"0x3.9bp-12", "0x3.7fp-12", "0x3.64p-12", "0x3.49p-12", "0x3.2e8p-12", "0x3.168p-12", "0x2.ffp-12", "0x2.e78p-12",
"0x2.dp-12", "0x2.bap-12", "0x2.a5p-12", "0x2.908p-12", "0x2.7ap-12", "0x2.67p-12", "0x2.54p-12", "0x2.43p-12",
"0x2.308p-12", "0x2.2p-12", "0x2.0ep-12", "0x1.fd8p-12", "0x1.efp-12", "0x1.df8p-12", "0x1.dp-12", "0x1.c2p-12",
"0x1.b5p-12", "0x1.a68p-12", "0x1.998p-12", "0x1.8dp-12", "0x1.8p-12", "0x1.75p-12", "0x1.6ap-12", "0x1.5f8p-12",
"0x1.54p-12", "0x1.4ap-12", "0x1.3fp-12", "0x1.35p-12", "0x1.2cp-12", "0x1.228p-12", "0x1.1a8p-12", "0x1.118p-12",
"0x1.088p-12", "0x1.01p-12", "0xf.98p-16", "0xf.1p-16", "0xe.88p-16", "0xe.18p-16", "0xd.a8p-16", "0xd.38p-16",
"0xc.f8p-16", "0xc.88p-16", "0xc.18p-16", "0xb.cp-16", "0xb.6p-16", "0xb.1p-16", "0xa.b8p-16", "0xa.58p-16",
"0xa.1p-16", "0x9.cp-16", "0x9.6p-16", "0x9.1p-16", "0x8.c8p-16", "0x8.88p-16", "0x8.5p-16", "0x8.1p-16",
"0x7.d8p-16", "0x7.ap-16", "0x7.58p-16", "0x7.28p-16", "0x6.fp-16", "0x6.bp-16", "0x6.88p-16", "0x6.58p-16",
"0x6.2p-16", "0x5.e8p-16", "0x5.b8p-16", "0x5.88p-16", "0x5.58p-16", "0x5.3p-16", "0x5.08p-16", "0x4.ep-16",
"0x4.cp-16", "0x4.ap-16", "0x4.78p-16", "0x4.6p-16", "0x4.38p-16", "0x4.1p-16", "0x3.e8p-16", "0x3.cp-16",
"0x3.a8p-16", "0x3.9p-16", "0x3.7p-16", "0x3.58p-16", "0x3.38p-16", "0x3.18p-16", "0x3.18p-16", "0x3.p-16",
"0x2.ep-16", "0x2.d8p-16", "0x2.cp-16", "0x2.a8p-16", "0x2.8p-16", "0x2.7p-16", "0x2.7p-16", "0x2.58p-16",
"0x2.4p-16", "0x2.2p-16", "0x2.2p-16", "0x2.18p-16", "0x1.e8p-16", "0x1.e8p-16", "0x1.d8p-16", "0x1.c8p-16",
"0x1.c8p-16", "0x1.cp-16", "0x1.bp-16", "0x1.98p-16", "0x1.88p-16", "0x1.7p-16", "0x1.68p-16", "0x1.7p-16",
"0x1.68p-16", "0x1.5p-16", "0x1.38p-16", "0x1.3p-16", "0x1.2p-16", "0x1.38p-16", "0x1.2p-16", "0x1.08p-16",
"0x1.1p-16", "0x1.18p-16", "0xf.p-20", "0xf.8p-20", "0xf.p-20", "0xe.p-20", "0xe.p-20", "0xc.8p-20",
"0xe.8p-20", "0xd.8p-20", "0xb.8p-20", "0xb.8p-20", "0xa.8p-20", "0xa.p-20", "0xa.8p-20", "0xb.p-20",
"0xa.8p-20", "0xa.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.p-20",
"0x9.p-20", "0x8.8p-20", "0x8.8p-20", "0x8.p-20", "0x6.8p-20", "0x7.8p-20", "0x6.8p-20", "0x6.p-20",
"0x5.8p-20", "0x5.8p-20", "0x5.8p-20", "0x6.8p-20", "0x6.8p-20", "0x5.8p-20", "0x4.8p-20", "0x4.8p-20",
"0x4.8p-20", "0x5.8p-20", "0x6.p-20", "0x5.8p-20", "0x4.p-20", "0x3.p-20", "0x3.8p-20", "0x3.8p-20",
};

static const ap_fixed< 18 , 6 > second_tanh_K2 [ 512 ] = {
"-0x7.ebp-4", "-0x1.7ecp0", "-0x2.7dbp0", "-0x3.7b8p0", "-0x4.777p0", "-0x5.717p0", "-0x6.688p0", "-0x7.5c6p0",
"-0x8.4cep0", "-0x9.392p0", "-0xa.213p0", "-0xb.03ep0", "-0xb.e2p0", "-0xc.bap0", "-0xd.8c2p0", "-0xe.582p0",
"-0xf.1d6p0", "-0xf.dbep0", "-0x1.0936p4", "-0x1.1436p4", "-0x1.1ec1p4", "-0x1.28dp4", "-0x1.3262p4", "-0x1.3b76p4",
"-0x1.4406p4", "-0x1.4c1ap4", "-0x1.53a9p4", "-0x1.5ab4p4", "-0x1.613ep4", "-0x1.6746p4", "-0x1.6ccbp4", "-0x1.71d2p4",
"-0x1.7656p4", "-0x1.7a6p4", "-0x1.7decp4", "-0x1.80fbp4", "-0x1.8398p4", "-0x1.85c3p4", "-0x1.8778p4", "-0x1.88bdp4",
"-0x1.8999p4", "-0x1.8a0cp4", "-0x1.8a1ap4", "-0x1.89c6p4", "-0x1.8916p4", "-0x1.880fp4", "-0x1.86abp4", "-0x1.84f8p4",
"-0x1.82f8p4", "-0x1.80abp4", "-0x1.7e18p4", "-0x1.7b44p4", "-0x1.782bp4", "-0x1.74dep4", "-0x1.7155p4", "-0x1.6d98p4",
"-0x1.69a9p4", "-0x1.6591p4", "-0x1.614bp4", "-0x1.5ce5p4", "-0x1.5855p4", "-0x1.53acp4", "-0x1.4ee3p4", "-0x1.4ap4",
"-0x1.450ap4", "-0x1.3ffbp4", "-0x1.3adcp4", "-0x1.35b1p4", "-0x1.3078p4", "-0x1.2b35p4", "-0x1.25ecp4", "-0x1.2099p4",
"-0x1.1b46p4", "-0x1.15f2p4", "-0x1.109cp4", "-0x1.0b48p4", "-0x1.05fap4", "-0x1.00aep4", "-0xf.b6bp0", "-0xf.62fp0",
"-0xf.0fcp0", "-0xe.bd3p0", "-0xe.6b9p0", "-0xe.1a6p0", "-0xd.ca1p0", "-0xd.7afp0", "-0xd.2c3p0", "-0xc.defp0",
"-0xc.925p0", "-0xc.46dp0", "-0xb.fccp0", "-0xb.b36p0", "-0xb.6b5p0", "-0xb.243p0", "-0xa.de6p0", "-0xa.99ap0",
"-0xa.566p0", "-0xa.142p0", "-0x9.d34p0", "-0x9.933p0", "-0x9.549p0", "-0x9.175p0", "-0x8.db2p0", "-0x8.a04p0",
"-0x8.668p0", "-0x8.2ddp0", "-0x7.f6bp0", "-0x7.c0ap0", "-0x7.8bbp0", "-0x7.57bp0", "-0x7.252p0", "-0x6.f3cp0",
"-0x6.c36p0", "-0x6.942p0", "-0x6.663p0", "-0x6.394p0", "-0x6.0d3p0", "-0x5.e26p0", "-0x5.b88p0", "-0x5.8fcp0",
"-0x5.68p0", "-0x5.412p0", "-0x5.1b2p0", "-0x4.f65p0", "-0x4.d27p0", "-0x4.af7p0", "-0x4.8d9p0", "-0x4.6c4p0",
"-0x4.4bcp0", "-0x4.2c8p0", "-0x4.0dcp0", "-0x3.efdp0", "-0x3.d2cp0", "-0x3.b6bp0", "-0x3.9bp0", "-0x3.806p0",
"-0x3.664p0", "-0x3.4d1p0", "-0x3.343p0", "-0x3.1c6p0", "-0x3.05p0", "-0x2.ee7p0", "-0x2.d86p0", "-0x2.c2fp0",
"-0x2.ae1p0", "-0x2.9a1p0", "-0x2.863p0", "-0x2.734p0", "-0x2.608p0", "-0x2.4e9p0", "-0x2.3dp0", "-0x2.2c4p0",
"-0x2.1b9p0", "-0x2.0bap0", "-0x1.fbep0", "-0x1.eccp0", "-0x1.de1p0", "-0x1.cfcp0", "-0x1.c21p0", "-0x1.b46p0",
"-0x1.a77p0", "-0x1.9abp0", "-0x1.8e6p0", "-0x1.827p0", "-0x1.76ep0", "-0x1.6b9p0", "-0x1.609p0", "-0x1.55dp0",
"-0x1.4bbp0", "-0x1.41bp0", "-0x1.38p0", "-0x1.2ebp0", "-0x1.256p0", "-0x1.1c9p0", "-0x1.13fp0", "-0x1.0bbp0",
"-0x1.038p0", "-0xf.b8p-4", "-0xf.4p-4", "-0xe.cap-4", "-0xe.59p-4", "-0xd.e6p-4", "-0xd.7dp-4", "-0xd.12p-4",
"-0xc.aap-4", "-0xc.49p-4", "-0xb.eap-4", "-0xb.8ep-4", "-0xb.34p-4", "-0xa.ddp-4", "-0xa.89p-4", "-0xa.37p-4",
"-0x9.e6p-4", "-0x9.99p-4", "-0x9.4fp-4", "-0x9.05p-4", "-0x8.bep-4", "-0x8.7bp-4", "-0x8.39p-4", "-0x7.f9p-4",
"-0x7.bbp-4", "-0x7.7dp-4", "-0x7.42p-4", "-0x7.09p-4", "-0x6.d4p-4", "-0x6.ap-4", "-0x6.6cp-4", "-0x6.39p-4",
"-0x6.06p-4", "-0x5.d6p-4", "-0x5.aap-4", "-0x5.7dp-4", "-0x5.53p-4", "-0x5.28p-4", "-0x5.p-4", "-0x4.dap-4",
"-0x4.b3p-4", "-0x4.8fp-4", "-0x4.6bp-4", "-0x4.4ap-4", "-0x4.26p-4", "-0x4.08p-4", "-0x3.e5p-4", "-0x3.c9p-4",
"-0x3.aap-4", "-0x3.8dp-4", "-0x3.6fp-4", "-0x3.57p-4", "-0x3.3bp-4", "-0x3.25p-4", "-0x3.0bp-4", "-0x2.f3p-4",
"-0x2.d9p-4", "-0x2.c6p-4", "-0x2.aep-4", "-0x2.9cp-4", "-0x2.85p-4", "-0x2.74p-4", "-0x2.5ep-4", "-0x2.4ap-4",
"-0x2.3ap-4", "-0x2.29p-4", "-0x2.18p-4", "-0x2.07p-4", "-0x1.f6p-4", "-0x1.e8p-4", "-0x1.d8p-4", "-0x1.cdp-4",
"-0x1.bcp-4", "-0x1.bp-4", "-0x1.9fp-4", "-0x1.95p-4", "-0x1.87p-4", "-0x1.7dp-4", "-0x1.6ep-4", "-0x1.64p-4",
"-0x1.5ap-4", "-0x1.5p-4", "-0x1.44p-4", "-0x1.3bp-4", "-0x1.33p-4", "-0x1.27p-4", "-0x1.1fp-4", "-0x1.16p-4",
"-0x1.0dp-4", "-0x1.05p-4", "-0xf.dp-8", "-0xf.7p-8", "-0xe.dp-8", "-0xe.7p-8", "-0xe.1p-8", "-0xd.7p-8",
"-0xd.1p-8", "-0xc.ap-8", "-0xc.3p-8", "-0xb.dp-8", "-0xb.9p-8", "-0xb.4p-8", "-0xa.fp-8", "-0xa.9p-8",
"-0xa.4p-8", "-0x9.fp-8", "-0x9.ap-8", "-0x9.7p-8", "-0x9.2p-8", "-0x8.dp-8", "-0x8.7p-8", "-0x8.3p-8",
"-0x8.p-8", "-0x7.cp-8", "-0x7.8p-8", "-0x7.4p-8", "-0x6.fp-8", "-0x6.cp-8", "-0x6.9p-8", "-0x6.6p-8",
"-0x6.1p-8", "-0x6.p-8", "-0x5.dp-8", "-0x5.9p-8", "-0x5.6p-8", "-0x5.3p-8", "-0x5.1p-8", "-0x5.p-8",
"-0x4.cp-8", "-0x4.bp-8", "-0x4.9p-8", "-0x4.6p-8", "-0x4.4p-8", "-0x4.1p-8", "-0x3.fp-8", "-0x4.p-8",
"-0x3.fp-8", "-0x3.ap-8", "-0x3.ap-8", "-0x3.6p-8", "-0x3.5p-8", "-0x3.6p-8", "-0x3.4p-8", "-0x3.1p-8",
"-0x2.fp-8", "-0x2.fp-8", "-0x2.cp-8", "-0x2.ap-8", "-0x2.9p-8", "-0x2.9p-8", "-0x2.8p-8", "-0x2.6p-8",
"-0x2.5p-8", "-0x2.3p-8", "-0x2.4p-8", "-0x2.4p-8", "-0x2.1p-8", "-0x1.fp-8", "-0x1.dp-8", "-0x1.bp-8",
"-0x1.bp-8", "-0x1.bp-8", "-0x1.bp-8", "-0x1.9p-8", "-0x1.8p-8", "-0x1.9p-8", "-0x1.ap-8", "-0x1.9p-8",
"-0x1.7p-8", "-0x1.7p-8", "-0x1.7p-8", "-0x1.7p-8", "-0x1.2p-8", "-0x1.2p-8", "-0x1.1p-8", "-0x1.3p-8",
"-0x1.2p-8", "-0x1.2p-8", "-0xf.p-12", "-0xf.p-12", "-0x1.p-8", "-0xf.p-12", "-0xd.p-12", "-0xe.p-12",
"-0xe.p-12", "-0xc.p-12", "-0xc.p-12", "-0xb.p-12", "-0xa.p-12", "-0xb.p-12", "-0xc.p-12", "-0xc.p-12",
"-0xb.p-12", "-0xb.p-12", "-0x9.p-12", "-0x9.p-12", "-0x9.p-12", "-0x9.p-12", "-0xa.p-12", "-0x9.p-12",
"-0x8.p-12", "-0x9.p-12", "-0x9.p-12", "-0x7.p-12", "-0x5.p-12", "-0x5.p-12", "-0x5.p-12", "-0x4.p-12",
"-0x9.p-12", "-0x7.p-12", "-0x6.p-12", "-0x6.p-12", "-0x6.p-12", "-0x7.p-12", "-0x6.p-12", "-0x5.p-12",
"-0x6.p-12", "-0x5.p-12", "-0x3.p-12", "-0x2.p-12", "-0x2.p-12", "-0x3.p-12", "-0x4.p-12", "-0x4.p-12",
"-0x5.p-12", "-0x5.p-12", "-0x4.p-12", "-0x5.p-12", "-0x4.p-12", "-0x4.p-12", "-0x5.p-12", "-0x5.p-12",
"-0x4.p-12", "-0x3.p-12", "-0x3.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12",
"-0x3.p-12", "-0x3.p-12", "-0x3.p-12", "-0x4.p-12", "-0x3.p-12", "-0x2.p-12", "-0x1.p-12", "0",
"-0x1.p-12", "-0x1.p-12", "-0x1.p-12", "-0x1.p-12", "0", "0", "-0x3.p-12", "-0x2.p-12",
"-0x2.p-12", "-0x3.p-12", "-0x3.p-12", "-0x2.p-12", "0", "-0x1.p-12", "-0x3.p-12", "-0x2.p-12",
"-0x1.p-12", "0", "-0x2.p-12", "-0x3.p-12", "0x1.p-12", "-0x1.p-12", "0", "-0x1.p-12",
"-0x2.p-12", "-0x3.p-12", "-0x2.p-12", "-0x1.p-12", "0", "0x1.p-12", "0", "-0x2.p-12",
"-0x2.p-12", "0", "0x1.p-12", "0x1.p-12", "0x2.p-12", "-0x2.p-12", "0", "0x1.p-12",
"-0x1.p-12", "-0x3.p-12", "0x1.p-12", "-0x1.p-12", "0", "0", "0", "0x2.p-12",
"-0x3.p-12", "-0x1.p-12", "0x1.p-12", "0x1.p-12", "0x2.p-12", "0x2.p-12", "0", "-0x1.p-12",
"-0x1.p-12", "-0x1.p-12", "0", "-0x1.p-12", "-0x1.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12",
"-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "0", "-0x1.p-12", "0", "0x1.p-12",
"0x1.p-12", "0x1.p-12", "0", "-0x2.p-12", "-0x2.p-12", "0", "0x1.p-12", "0x1.p-12",
"0", "-0x2.p-12", "-0x3.p-12", "-0x2.p-12", "0x1.p-12", "0x2.p-12", "0x1.p-12", "0",
};





static const ap_fixed< 32 , 4 > second_atanh_K0 [ 256 ] = {
"0", "0x1.00005p-8", "0x2.0002bp-8", "0x3.0009p-8", "0x4.00156p-8", "0x5.0029bp-8", "0x6.00481p-8", "0x7.00726p-8",
"0x8.00aacp-8", "0x9.00f33p-8", "0xa.014dap-8", "0xb.01bc3p-8", "0xc.0240cp-8", "0xd.02dd8p-8", "0xe.03945p-8", "0xf.04675p-8",
"0x1.005589p-4", "0x1.1066ap-4", "0x1.2079ddp-4", "0x1.308f5fp-4", "0x1.40a748p-4", "0x1.50c1b9p-4", "0x1.60ded2p-4", "0x1.70feb7p-4",
"0x1.812187p-4", "0x1.914766p-4", "0x1.a17073p-4", "0x1.b19cd2p-4", "0x1.c1cca5p-4", "0x1.d2000ep-4", "0x1.e2372ep-4", "0x1.f2722ap-4",
"0x2.02b124p-4", "0x2.12f43ep-4", "0x2.233b9cp-4", "0x2.338762p-4", "0x2.43d7b3p-4", "0x2.542cb3p-4", "0x2.648686p-4", "0x2.74e55p-4",
"0x2.854936p-4", "0x2.95b25ep-4", "0x2.a620ebp-4", "0x2.b69504p-4", "0x2.c70ecdp-4", "0x2.d78e6ep-4", "0x2.e8140cp-4", "0x2.f89fcep-4",
"0x3.0931dbp-4", "0x3.19ca5ap-4", "0x3.2a6972p-4", "0x3.3b0f4cp-4", "0x3.4bbc0fp-4", "0x3.5c6fe5p-4", "0x3.6d2af7p-4", "0x3.7ded6cp-4",
"0x3.8eb771p-4", "0x3.9f892ep-4", "0x3.b062cep-4", "0x3.c1447dp-4", "0x3.d22e65p-4", "0x3.e320b4p-4", "0x3.f41b94p-4", "0x4.051f33p-4",
"0x4.162bbfp-4", "0x4.274165p-4", "0x4.386053p-4", "0x4.4988b9p-4", "0x4.5abac6p-4", "0x4.6bf6aap-4", "0x4.7d3c95p-4", "0x4.8e8cb9p-4",
"0x4.9fe748p-4", "0x4.b14c73p-4", "0x4.c2bc6fp-4", "0x4.d4376ep-4", "0x4.e5bda4p-4", "0x4.f74f48p-4", "0x5.08ec8ep-4", "0x5.1a95aep-4",
"0x5.2c4addp-4", "0x5.3e0c55p-4", "0x5.4fda4ep-4", "0x5.61b501p-4", "0x5.739ca8p-4", "0x5.85918p-4", "0x5.9793c3p-4", "0x5.a9a3afp-4",
"0x5.bbc182p-4", "0x5.cded7ap-4", "0x5.e027d7p-4", "0x5.f270dap-4", "0x6.04c8c4p-4", "0x6.172fd8p-4", "0x6.29a65ap-4", "0x6.3c2c8fp-4",
"0x6.4ec2bcp-4", "0x6.616929p-4", "0x6.74201ep-4", "0x6.86e7e4p-4", "0x6.99c0c7p-4", "0x6.acab12p-4", "0x6.bfa713p-4", "0x6.d2b518p-4",
"0x6.e5d571p-4", "0x6.f9087p-4", "0x7.0c4e68p-4", "0x7.1fa7adp-4", "0x7.331495p-4", "0x7.469577p-4", "0x7.5a2aaep-4", "0x7.6dd493p-4",
"0x7.819384p-4", "0x7.9567dep-4", "0x7.a95202p-4", "0x7.bd5253p-4", "0x7.d16933p-4", "0x7.e5970ap-4", "0x7.f9dc3fp-4", "0x8.0e393cp-4",
"0x8.22ae6ep-4", "0x8.373c44p-4", "0x8.4be32dp-4", "0x8.60a39fp-4", "0x8.757e0ep-4", "0x8.8a72f2p-4", "0x8.9f82c8p-4", "0x8.b4ae0cp-4",
"0x8.c9f53ep-4", "0x8.df58e3p-4", "0x8.f4d97fp-4", "0x9.0a779ep-4", "0x9.2033cap-4", "0x9.360e94p-4", "0x9.4c088fp-4", "0x9.622252p-4",
"0x9.785c76p-4", "0x9.8eb799p-4", "0x9.a5345ep-4", "0x9.bbd36ap-4", "0x9.d29567p-4", "0x9.e97b03p-4", "0xa.0084f1p-4", "0xa.17b3e7p-4",
"0xa.2f08a2p-4", "0xa.4683e2p-4", "0xa.5e266dp-4", "0xa.75f10fp-4", "0xa.8de497p-4", "0xa.a601ddp-4", "0xa.be49bcp-4", "0xa.d6bd17p-4",
"0xa.ef5cd5p-4", "0xb.0829e8p-4", "0xb.212544p-4", "0xb.3a4fe6p-4", "0xb.53aad4p-4", "0xb.6d371ap-4", "0xb.86f5ccp-4", "0xb.a0e807p-4",
"0xb.bb0eefp-4", "0xb.d56bb5p-4", "0xb.efff9p-4", "0xc.0acbc1p-4", "0xc.25d194p-4", "0xc.411262p-4", "0xc.5c8f8bp-4", "0xc.784a7dp-4",
"0xc.9444b3p-4", "0xc.b07fb3p-4", "0xc.ccfd12p-4", "0xc.e9be72p-4", "0xd.06c583p-4", "0xd.241408p-4", "0xd.41abcfp-4", "0xd.5f8ebbp-4",
"0xd.7dbebfp-4", "0xd.9c3de1p-4", "0xd.bb0e3ap-4", "0xd.da31fap-4", "0xd.f9ab63p-4", "0xe.197cd2p-4", "0xe.39a8b9p-4", "0xe.5a31a5p-4",
"0xe.7b1a3dp-4", "0xe.9c6545p-4", "0xe.be159ep-4", "0xe.e02e4bp-4", "0xf.02b26ep-4", "0xf.25a54ep-4", "0xf.490a56p-4", "0xf.6ce51cp-4",
"0xf.91395dp-4", "0xf.b60b05p-4", "0xf.db5e3p-4", "0x1.001372dp0", "0x1.0279a82p0", "0x1.04e8cedp0", "0x1.076136dp0", "0x1.09e3343p0",
"0x1.0c6f1f4p0", "0x1.0f05557p0", "0x1.11a638fp0", "0x1.145231bp0", "0x1.1709ad9p0", "0x1.19cd20ap0", "0x1.1c9d05fp0", "0x1.1f79e02p0",
"0x1.226439bp0", "0x1.255ca6p0", "0x1.2863c1dp0", "0x1.2b7a346p0", "0x1.2ea0affp0", "0x1.31d7f35p0", "0x1.3520cabp0", "0x1.387c10dp0",
"0x1.3beab0ep0", "0x1.3f6da7dp0", "0x1.4306065p0", "0x1.46b4f2cp0", "0x1.4a7babep0", "0x1.4e5b8b2p0", "0x1.5256082p0", "0x1.566cbc4p0",
"0x1.5aa1666p0", "0x1.5ef5f02p0", "0x1.636c734p0", "0x1.6807403p0", "0x1.6cc8e5bp0", "0x1.71b43ap0", "0x1.76cc65bp0", "0x1.7c14f05p0",
"0x1.8191d04p0", "0x1.87477d4p0", "0x1.8d3b07ep0", "0x1.9372359p0", "0x1.99f3a42p0", "0x1.a0c6f63p0", "0x1.a7f50b9p0", "0x1.af884a1p0",
"0x1.b78cfbdp0", "0x1.c011ccdp0", "0x1.c928734p0", "0x1.d2e696dp0", "0x1.dd67145p0", "0x1.e8cbcefp0", "0x1.f5405fep0", "0x2.02fe319p0",
"0x2.125309ep0", "0x2.23abf9ap0", "0x2.37a8ce5p0", "0x2.4f417dp0", "0x2.6c16345p0", "0x2.9137576p0", "0x2.c5b1cb6p0", "0x6.5c82b7bp0",
};

static const ap_fixed< 29 , 9 > second_atanh_K1 [ 256 ] = {
"0xf.fffep-4", "0x1.0001p0", "0x1.0003cp0", "0x1.0008ep0", "0x1.000fbp0", "0x1.0018dp0", "0x1.0023cp0", "0x1.0030fp0",
"0x1.003ffp0", "0x1.0050fp0", "0x1.00641p0", "0x1.0078fp0", "0x1.00904p0", "0x1.00a92p0", "0x1.00c47p0", "0x1.00e1bp0",
"0x1.0100dp0", "0x1.01224p0", "0x1.01455p0", "0x1.016adp0", "0x1.01924p0", "0x1.01bbbp0", "0x1.01e79p0", "0x1.02152p0",
"0x1.02451p0", "0x1.0276cp0", "0x1.02aafp0", "0x1.02e11p0", "0x1.03196p0", "0x1.0353bp0", "0x1.03907p0", "0x1.03cf3p0",
"0x1.040ffp0", "0x1.04533p0", "0x1.0498ap0", "0x1.04e02p0", "0x1.052ap0", "0x1.0576p0", "0x1.05c44p0", "0x1.0614fp0",
"0x1.0667fp0", "0x1.06bcfp0", "0x1.07149p0", "0x1.076e6p0", "0x1.07cacp0", "0x1.08296p0", "0x1.088a7p0", "0x1.08eddp0",
"0x1.0953cp0", "0x1.09bcp0", "0x1.0a26fp0", "0x1.0a944p0", "0x1.0b044p0", "0x1.0b76ap0", "0x1.0beb7p0", "0x1.0c634p0",
"0x1.0cdd6p0", "0x1.0d5a3p0", "0x1.0dd9ep0", "0x1.0e5cp0", "0x1.0ee12p0", "0x1.0f689p0", "0x1.0ff33p0", "0x1.1080bp0",
"0x1.1110dp0", "0x1.11a3cp0", "0x1.1239ep0", "0x1.12d2dp0", "0x1.136edp0", "0x1.140dap0", "0x1.14afcp0", "0x1.1554fp0",
"0x1.15fdp0", "0x1.16a88p0", "0x1.1756fp0", "0x1.1808cp0", "0x1.18be2p0", "0x1.19767p0", "0x1.1a326p0", "0x1.1af17p0",
"0x1.1bb46p0", "0x1.1c7a9p0", "0x1.1d445p0", "0x1.1e11bp0", "0x1.1ee31p0", "0x1.1fb7dp0", "0x1.20907p0", "0x1.216d1p0",
"0x1.224d5p0", "0x1.2331bp0", "0x1.241ap0", "0x1.25065p0", "0x1.25f6ep0", "0x1.26ebap0", "0x1.27e49p0", "0x1.28e1ep0",
"0x1.29e3ap0", "0x1.2ae9ep0", "0x1.2bf4ap0", "0x1.2d043p0", "0x1.2e185p0", "0x1.2f313p0", "0x1.304eep0", "0x1.3171ap0",
"0x1.32997p0", "0x1.33c65p0", "0x1.34f86p0", "0x1.362fep0", "0x1.376cdp0", "0x1.38af5p0", "0x1.39f75p0", "0x1.3b452p0",
"0x1.3c98bp0", "0x1.3df27p0", "0x1.3f522p0", "0x1.40b7ep0", "0x1.42242p0", "0x1.4396ap0", "0x1.450fdp0", "0x1.468fcp0",
"0x1.48168p0", "0x1.49a41p0", "0x1.4b39p0", "0x1.4cd5p0", "0x1.4e78ap0", "0x1.5023fp0", "0x1.51d6bp0", "0x1.53917p0",
"0x1.55549p0", "0x1.571fbp0", "0x1.58f3bp0", "0x1.5acfep0", "0x1.5cb55p0", "0x1.5ea3bp0", "0x1.609b7p0", "0x1.629c9p0",
"0x1.64a79p0", "0x1.66bcap0", "0x1.68dbdp0", "0x1.6b05ap0", "0x1.6d3ap0", "0x1.6f796p0", "0x1.71c41p0", "0x1.741a7p0",
"0x1.767cap0", "0x1.78eb1p0", "0x1.7b661p0", "0x1.7deddp0", "0x1.8082fp0", "0x1.83257p0", "0x1.85d61p0", "0x1.8894dp0",
"0x1.8b62bp0", "0x1.8e3f5p0", "0x1.912b9p0", "0x1.94284p0", "0x1.97353p0", "0x1.9a532p0", "0x1.9d82bp0", "0x1.a0c43p0",
"0x1.a4189p0", "0x1.a77fep0", "0x1.aafafp0", "0x1.ae8a9p0", "0x1.b22f7p0", "0x1.b5e9bp0", "0x1.b9babp0", "0x1.bda2ep0",
"0x1.c1a31p0", "0x1.c5bc4p0", "0x1.c9eefp0", "0x1.ce3c4p0", "0x1.d2a55p0", "0x1.d72a9p0", "0x1.dbcd9p0", "0x1.e08f3p0",
"0x1.e5708p0", "0x1.ea72dp0", "0x1.ef979p0", "0x1.f4df8p0", "0x1.fa4ccp0", "0x1.ffe03p0", "0x2.059bbp0", "0x2.0b80bp0",
"0x2.11911p0", "0x2.17ceap0", "0x2.1e3b6p0", "0x2.24d92p0", "0x2.2baa2p0", "0x2.32b09p0", "0x2.39ef3p0", "0x2.4168p0",
"0x2.491e5p0", "0x2.5114fp0", "0x2.594ecp0", "0x2.61cf2p0", "0x2.6a997p0", "0x2.73b1fp0", "0x2.7d1c3p0", "0x2.86dc4p0",
"0x2.90f79p0", "0x2.9b724p0", "0x2.a6521p0", "0x2.b19ccp0", "0x2.bd57fp0", "0x2.c98aep0", "0x2.d63c9p0", "0x2.e3746p0",
"0x2.f13b2p0", "0x2.ff998p0", "0x3.0e99ep0", "0x3.1e468p0", "0x3.2eabbp0", "0x3.3fd5dp0", "0x3.51d2fp0", "0x3.64b2fp0",
"0x3.78867p0", "0x3.8d603p0", "0x3.a354cp0", "0x3.ba7b7p0", "0x3.d2ed1p0", "0x3.ecc6bp0", "0x4.0827dp0", "0x4.2533ap0",
"0x4.44126p0", "0x4.64f15p0", "0x4.88035p0", "0x4.ad82cp0", "0x4.d5b22p0", "0x5.00dddp0", "0x5.2f5dap0", "0x5.6197ep0",
"0x5.98037p0", "0x5.d32c9p0", "0x6.13b81p0", "0x6.5a6a8p0", "0x6.a82f9p0", "0x6.fe24bp0", "0x7.5da66p0", "0x7.c8626p0",
"0x8.40722p0", "0x8.c87d6p0", "0x9.63ed6p0", "0xa.17358p0", "0xa.e8432p0", "0xb.df25dp0", "0xd.071d8p0", "0xe.70589p0",
"0x1.032f6cp4", "0x1.2748a2p4", "0x1.572d2cp4", "0x1.99a52dp4", "0x1.fba102p4", "0x2.97f084p4", "0x3.9b3891p4", "0xf.a9c012p4",
};

static const ap_fixed< 29 , 17 > second_atanh_K2 [ 256 ] = {
"0x7.p-12", "0x1.5p-8", "0x2.9p-8", "0x3.7p-8", "0x4.ap-8", "0x5.8p-8", "0x6.9p-8", "0x7.7p-8",
"0x8.8p-8", "0x9.8p-8", "0xa.7p-8", "0xb.ap-8", "0xc.7p-8", "0xd.bp-8", "0xe.9p-8", "0xf.8p-8",
"0x1.0ap-4", "0x1.18p-4", "0x1.2dp-4", "0x1.3bp-4", "0x1.4cp-4", "0x1.5ep-4", "0x1.6bp-4", "0x1.7ep-4",
"0x1.8dp-4", "0x1.a1p-4", "0x1.bp-4", "0x1.c2p-4", "0x1.d2p-4", "0x1.e5p-4", "0x1.f5p-4", "0x2.06p-4",
"0x2.1bp-4", "0x2.2bp-4", "0x2.3cp-4", "0x2.4fp-4", "0x2.5fp-4", "0x2.72p-4", "0x2.86p-4", "0x2.97p-4",
"0x2.a8p-4", "0x2.bep-4", "0x2.cfp-4", "0x2.e3p-4", "0x2.f5p-4", "0x3.08p-4", "0x3.1bp-4", "0x3.3p-4",
"0x3.42p-4", "0x3.58p-4", "0x3.6bp-4", "0x3.7fp-4", "0x3.92p-4", "0x3.a7p-4", "0x3.bep-4", "0x3.dp-4",
"0x3.e6p-4", "0x3.fdp-4", "0x4.1p-4", "0x4.28p-4", "0x4.3cp-4", "0x4.57p-4", "0x4.6cp-4", "0x4.8p-4",
"0x4.98p-4", "0x4.b2p-4", "0x4.c8p-4", "0x4.ep-4", "0x4.f6p-4", "0x5.11p-4", "0x5.28p-4", "0x5.3fp-4",
"0x5.5bp-4", "0x5.73p-4", "0x5.8fp-4", "0x5.aap-4", "0x5.c1p-4", "0x5.dfp-4", "0x5.f9p-4", "0x6.18p-4",
"0x6.31p-4", "0x6.4fp-4", "0x6.6dp-4", "0x6.8cp-4", "0x6.a6p-4", "0x6.c5p-4", "0x6.e5p-4", "0x7.01p-4",
"0x7.22p-4", "0x7.41p-4", "0x7.62p-4", "0x7.84p-4", "0x7.a5p-4", "0x7.c7p-4", "0x7.ebp-4", "0x8.0ep-4",
"0x8.32p-4", "0x8.56p-4", "0x8.7cp-4", "0x8.9fp-4", "0x8.c5p-4", "0x8.edp-4", "0x9.16p-4", "0x9.3ep-4",
"0x9.67p-4", "0x9.92p-4", "0x9.bep-4", "0x9.e9p-4", "0xa.14p-4", "0xa.41p-4", "0xa.6fp-4", "0xa.9ep-4",
"0xa.cep-4", "0xa.fcp-4", "0xb.2ep-4", "0xb.61p-4", "0xb.94p-4", "0xb.cap-4", "0xb.ffp-4", "0xc.35p-4",
"0xc.6cp-4", "0xc.a7p-4", "0xc.e1p-4", "0xd.1ep-4", "0xd.59p-4", "0xd.95p-4", "0xd.d7p-4", "0xe.1ap-4",
"0xe.5ap-4", "0xe.ap-4", "0xe.e2p-4", "0xf.2dp-4", "0xf.74p-4", "0xf.bfp-4", "0x1.00ap0", "0x1.059p0",
"0x1.0a9p0", "0x1.0fap0", "0x1.14ep0", "0x1.1a1p0", "0x1.1fap0", "0x1.256p0", "0x1.2b3p0", "0x1.312p0",
"0x1.374p0", "0x1.3d8p0", "0x1.43fp0", "0x1.4a9p0", "0x1.515p0", "0x1.586p0", "0x1.5f7p0", "0x1.66fp0",
"0x1.6e5p0", "0x1.764p0", "0x1.7e7p0", "0x1.867p0", "0x1.8fp0", "0x1.97dp0", "0x1.a0cp0", "0x1.aa2p0",
"0x1.b3ap0", "0x1.bd9p0", "0x1.c7ep0", "0x1.d27p0", "0x1.dd3p0", "0x1.e8ap0", "0x1.f43p0", "0x2.004p0",
"0x2.0cbp0", "0x2.196p0", "0x2.26cp0", "0x2.349p0", "0x2.42bp0", "0x2.519p0", "0x2.60ep0", "0x2.70bp0",
"0x2.814p0", "0x2.926p0", "0x2.a4p0", "0x2.b6bp0", "0x2.c9cp0", "0x2.dddp0", "0x2.f29p0", "0x3.085p0",
"0x3.1efp0", "0x3.367p0", "0x3.4efp0", "0x3.688p0", "0x3.834p0", "0x3.9f5p0", "0x3.bc8p0", "0x3.db6p0",
"0x3.fb8p0", "0x4.1dp0", "0x4.405p0", "0x4.656p0", "0x4.8c7p0", "0x4.b53p0", "0x4.e03p0", "0x5.0dep0",
"0x5.3d9p0", "0x5.702p0", "0x5.a59p0", "0x5.ddep0", "0x6.19dp0", "0x6.591p0", "0x6.9c2p0", "0x6.e3ap0",
"0x7.2f8p0", "0x7.809p0", "0x7.d6cp0", "0x8.33p0", "0x8.958p0", "0x8.ff3p0", "0x9.70ap0", "0x9.ea6p0",
"0xa.6d9p0", "0xa.fb2p0", "0xb.944p0", "0xc.39ep0", "0xc.ee1p0", "0xd.b1ep0", "0xe.877p0", "0xf.712p0",
"0x1.0718p4", "0x1.18b5p4", "0x1.2c27p4", "0x1.41acp4", "0x1.5995p4", "0x1.743fp4", "0x1.921dp4", "0x1.b3b6p4",
"0x1.d9b3p4", "0x2.04dap4", "0x2.362bp4", "0x2.6ee2p4", "0x2.b08fp4", "0x2.fd2ap4", "0x3.5746p4", "0x3.c247p4",
"0x4.42acp4", "0x4.de8fp4", "0x5.9e5fp4", "0x6.8e1dp4", "0x7.bf29p4", "0x9.4b9bp4", "0xb.5bffp4", "0xe.3225p4",
"0x1.23eb8p8", "0x1.84fe8p8", "0x2.200d3p8", "0x3.2ea37p8", "0x5.48ee9p8", "0xa.7a499p8", "0x1.e65acdp12", "0xb.1690a4p12",
};



static const ap_fixed< 29 , 1 > first_tanh_K0 [ 512 ] = {
"0x3.dp-24", "0x3.fff61p-8", "0x7.ff687p-8", "0xb.fddb3p-8", "0xf.facf2p-8","0x1.3f5c5dp-4", "0x1.7ee41bp-4", "0x1.be3c69p-4",
"0x1.fd5d9ap-4", "0x2.3c401cp-4", "0x2.7adc7ep-4", "0x2.b92b6dp-4", "0x2.f725bfp-4", "0x3.34c47p-4", "0x3.7200a9p-4", "0x3.aed3c1p-4",
"0x3.eb373ep-4", "0x4.2724dcp-4", "0x4.62968cp-4", "0x4.9d8675p-4", "0x4.d7eef9p-4", "0x5.11cab6p-4", "0x5.4b1484p-4","0x5.83c77cp-4",
"0x5.bbdef4p-4", "0x5.f35683p-4", "0x6.2a2ap-4", "0x6.605582p-4","0x6.95d564p-4", "0x6.caa64p-4", "0x6.fec4f1p-4", "0x7.322e95p-4",
"0x7.64e08ap-4", "0x7.96d86cp-4", "0x7.c81419p-4", "0x7.f891abp-4", "0x8.284f7bp-4", "0x8.574c1dp-4", "0x8.858661p-4","0x8.b2fd4fp-4",
"0x8.dfb02ap-4", "0x9.0b9e67p-4", "0x9.36c7b5p-4", "0x9.612bf3p-4", "0x9.8acb32p-4", "0x9.b3a5b4p-4", "0x9.dbbbe7p-4","0xa.030e67p-4",
"0xa.299df8p-4", "0xa.4f6b88p-4", "0xa.74782ap-4", "0xa.98c518p-4", "0xa.bc53aap-4", "0xa.df255dp-4", "0xb.013bc9p-4","0xb.2298a6p-4",
"0xb.433dc6p-4", "0xb.632d11p-4", "0xb.82688cp-4", "0xb.a0f24cp-4", "0xb.becc7ep-4", "0xb.dbf96p-4", "0xb.f87b3fp-4", "0xc.145479p-4",
"0xc.2f8779p-4", "0xc.4a16b6p-4", "0xc.6404b2p-4", "0xc.7d53f6p-4", "0xc.960717p-4", "0xc.ae20aep-4", "0xc.c5a35ap-4","0xc.dc91bep-4",
"0xc.f2ee82p-4", "0xd.08bc4dp-4", "0xd.1dfdcbp-4", "0xd.32b5a6p-4", "0xd.46e689p-4", "0xd.5a931bp-4", "0xd.6dbe03p-4","0xd.8069e5p-4",
"0xd.929961p-4", "0xd.a44f13p-4", "0xd.b58d91p-4", "0xd.c6576ep-4", "0xd.d6af34p-4", "0xd.e69769p-4", "0xd.f6128cp-4","0xe.052314p-4",
"0xe.13cb7p-4", "0xe.220e08p-4", "0xe.2fed3dp-4", "0xe.3d6b64p-4","0xe.4a8acdp-4", "0xe.574dbdp-4", "0xe.63b671p-4", "0xe.6fc71bp-4",
"0xe.7b81e6p-4", "0xe.86e8f1p-4", "0xe.91fe54p-4", "0xe.9cc41cp-4", "0xe.a73c4cp-4", "0xe.b168dep-4", "0xe.bb4bc1p-4","0xe.c4e6dbp-4",
"0xe.ce3c0ap-4", "0xe.d74d1fp-4", "0xe.e01be5p-4", "0xe.e8aa19p-4", "0xe.f0f971p-4", "0xe.f90b9bp-4", "0xf.00e239p-4","0xf.087ee4p-4",
"0xf.0fe32dp-4", "0xf.17109ap-4", "0xf.1e08abp-4", "0xf.24ccd3p-4", "0xf.2b5e8p-4", "0xf.31bf15p-4", "0xf.37efedp-4", "0xf.3df25bp-4",
"0xf.43c7aap-4", "0xf.49711bp-4", "0xf.4eefeap-4", "0xf.544548p-4", "0xf.59726p-4", "0xf.5e7855p-4", "0xf.635843p-4", "0xf.68133fp-4",
"0xf.6caa55p-4", "0xf.711e8bp-4", "0xf.7570e2p-4", "0xf.79a251p-4", "0xf.7db3cap-4", "0xf.81a63ap-4", "0xf.857a85p-4","0xf.89318ap-4",
"0xf.8ccc23p-4", "0xf.904b22p-4", "0xf.93af56p-4", "0xf.96f985p-4", "0xf.9a2a73p-4", "0xf.9d42dbp-4", "0xf.a04377p-4","0xf.a32cf9p-4",
"0xf.a6000dp-4", "0xf.a8bd5ep-4", "0xf.ab658ep-4", "0xf.adf93fp-4", "0xf.b0790ap-4", "0xf.b2e586p-4", "0xf.b53f45p-4","0xf.b786d6p-4",
"0xf.b9bcc3p-4", "0xf.bbe192p-4", "0xf.bdf5c5p-4", "0xf.bff9dbp-4", "0xf.c1ee4fp-4", "0xf.c3d397p-4", "0xf.c5aa29p-4","0xf.c77274p-4",
"0xf.c92ce7p-4", "0xf.cad9eap-4", "0xf.cc79e6p-4", "0xf.ce0d3dp-4", "0xf.cf9452p-4", "0xf.d10f83p-4", "0xf.d27f2bp-4","0xf.d3e3a2p-4",
"0xf.d53d4p-4", "0xf.d68c58p-4", "0xf.d7d13ap-4", "0xf.d90c37p-4","0xf.da3d99p-4", "0xf.db65adp-4", "0xf.dc84b9p-4", "0xf.dd9b03p-4",
"0xf.dea8cfp-4", "0xf.dfae6p-4", "0xf.e0abf4p-4", "0xf.e1a1cap-4","0xf.e2901ep-4", "0xf.e3772ap-4", "0xf.e45727p-4", "0xf.e5304bp-4",
"0xf.e602ccp-4", "0xf.e6cedep-4", "0xf.e794b2p-4", "0xf.e85478p-4", "0xf.e90e61p-4", "0xf.e9c29ap-4", "0xf.ea714fp-4","0xf.eb1aabp-4",
"0xf.ebbed8p-4", "0xf.ec5dfep-4", "0xf.ecf844p-4", "0xf.ed8dd1p-4", "0xf.ee1ec9p-4", "0xf.eeab5p-4", "0xf.ef3389p-4", "0xf.efb796p-4",
"0xf.f03796p-4", "0xf.f0b3aap-4", "0xf.f12bfp-4", "0xf.f1a087p-4","0xf.f2118ap-4", "0xf.f27f16p-4", "0xf.f2e947p-4", "0xf.f35035p-4",
"0xf.f3b3fbp-4", "0xf.f414b2p-4", "0xf.f47271p-4", "0xf.f4cd5p-4", "0xf.f52565p-4", "0xf.f57ac6p-4", "0xf.f5cd88p-4", "0xf.f61dcp-4",
"0xf.f66b82p-4", "0xf.f6b6ep-4", "0xf.f6ffefp-4", "0xf.f746bfp-4","0xf.f78b62p-4", "0xf.f7cdeap-4", "0xf.f80e68p-4", "0xf.f84ceap-4",
"0xf.f8898p-4", "0xf.f8c43bp-4", "0xf.f8fd27p-4", "0xf.f93454p-4","0xf.f969dp-4", "0xf.f99da6p-4", "0xf.f9cfe5p-4", "0xf.fa0099p-4",
"0xf.fa2fcdp-4", "0xf.fa5d8fp-4", "0xf.fa89e8p-4", "0xf.fab4e5p-4", "0xf.fade9p-4", "0xf.fb06f2p-4", "0xf.fb2e17p-4", "0xf.fb5408p-4",
"0xf.fb78cfp-4", "0xf.fb9c74p-4", "0xf.fbbf01p-4", "0xf.fbe07ep-4", "0xf.fc00f3p-4", "0xf.fc2069p-4", "0xf.fc3ee8p-4","0xf.fc5c76p-4",
"0xf.fc791cp-4", "0xf.fc94e1p-4", "0xf.fcafcbp-4", "0xf.fcc9e1p-4", "0xf.fce32ap-4", "0xf.fcfbabp-4", "0xf.fd136cp-4","0xf.fd2a72p-4",
"0xf.fd40c3p-4", "0xf.fd5664p-4", "0xf.fd6b5bp-4", "0xf.fd7fadp-4", "0xf.fd935fp-4", "0xf.fda676p-4", "0xf.fdb8f6p-4","0xf.fdcae5p-4",
"0xf.fddc47p-4", "0xf.fded2p-4", "0xf.fdfd74p-4", "0xf.fe0d48p-4","0xf.fe1c9fp-4", "0xf.fe2b7dp-4", "0xf.fe39e7p-4", "0xf.fe47dfp-4",
"0xf.fe5569p-4", "0xf.fe6288p-4", "0xf.fe6f4p-4", "0xf.fe7b94p-4","0xf.fe8786p-4", "0xf.fe931bp-4", "0xf.fe9e55p-4", "0xf.fea936p-4",
"0xf.feb3c1p-4", "0xf.febdfap-4", "0xf.fec7e2p-4", "0xf.fed17cp-4", "0xf.fedacap-4", "0xf.fee3cfp-4", "0xf.feec8dp-4","0xf.fef507p-4",
"0xf.fefd3dp-4", "0xf.ff0533p-4", "0xf.ff0ceap-4", "0xf.ff1464p-4", "0xf.ff1ba4p-4", "0xf.ff22aap-4", "0xf.ff2979p-4","0xf.ff3013p-4",
"0xf.ff3679p-4", "0xf.ff3cacp-4", "0xf.ff42aep-4", "0xf.ff4881p-4", "0xf.ff4e26p-4", "0xf.ff539fp-4", "0xf.ff58ecp-4","0xf.ff5e1p-4",
"0xf.ff630cp-4", "0xf.ff67ep-4", "0xf.ff6c8ep-4", "0xf.ff7117p-4","0xf.ff757dp-4", "0xf.ff79cp-4", "0xf.ff7de1p-4", "0xf.ff81e2p-4",
"0xf.ff85c3p-4", "0xf.ff8986p-4", "0xf.ff8d2bp-4", "0xf.ff90b3p-4", "0xf.ff942p-4", "0xf.ff9771p-4", "0xf.ff9aa9p-4", "0xf.ff9dc7p-4",
"0xf.ffa0cdp-4", "0xf.ffa3bap-4", "0xf.ffa691p-4", "0xf.ffa952p-4", "0xf.ffabfcp-4", "0xf.ffae92p-4", "0xf.ffb113p-4","0xf.ffb381p-4",
"0xf.ffb5dbp-4", "0xf.ffb823p-4", "0xf.ffba59p-4", "0xf.ffbc7ep-4", "0xf.ffbe92p-4", "0xf.ffc095p-4", "0xf.ffc288p-4","0xf.ffc46dp-4",
"0xf.ffc642p-4", "0xf.ffc809p-4", "0xf.ffc9c1p-4", "0xf.ffcb6dp-4", "0xf.ffcd0bp-4", "0xf.ffce9cp-4", "0xf.ffd021p-4","0xf.ffd19ap-4",
"0xf.ffd308p-4", "0xf.ffd46ap-4", "0xf.ffd5c1p-4", "0xf.ffd70ep-4", "0xf.ffd85p-4", "0xf.ffd989p-4", "0xf.ffdab8p-4", "0xf.ffdbddp-4",
"0xf.ffdcfap-4", "0xf.ffde0ep-4", "0xf.ffdf19p-4", "0xf.ffe01cp-4", "0xf.ffe118p-4", "0xf.ffe20bp-4", "0xf.ffe2f7p-4","0xf.ffe3dcp-4",
"0xf.ffe4b9p-4", "0xf.ffe59p-4", "0xf.ffe66p-4", "0xf.ffe72ap-4", "0xf.ffe7eep-4", "0xf.ffe8abp-4", "0xf.ffe963p-4", "0xf.ffea15p-4",
"0xf.ffeac2p-4", "0xf.ffeb69p-4", "0xf.ffec0bp-4", "0xf.ffeca8p-4", "0xf.ffed41p-4", "0xf.ffedd4p-4", "0xf.ffee64p-4","0xf.ffeeeep-4",
"0xf.ffef75p-4", "0xf.ffeff7p-4", "0xf.fff075p-4", "0xf.fff0fp-4", "0xf.fff166p-4", "0xf.fff1d9p-4", "0xf.fff249p-4", "0xf.fff2b5p-4",
"0xf.fff31ep-4", "0xf.fff383p-4", "0xf.fff3e5p-4", "0xf.fff445p-4", "0xf.fff4a1p-4", "0xf.fff4fbp-4", "0xf.fff552p-4","0xf.fff5a6p-4",
"0xf.fff5f7p-4", "0xf.fff646p-4", "0xf.fff693p-4", "0xf.fff6ddp-4", "0xf.fff725p-4", "0xf.fff76bp-4", "0xf.fff7aep-4","0xf.fff7fp-4",
"0xf.fff82fp-4", "0xf.fff86dp-4", "0xf.fff8a9p-4", "0xf.fff8e2p-4", "0xf.fff91ap-4", "0xf.fff951p-4", "0xf.fff985p-4","0xf.fff9b8p-4",
"0xf.fff9eap-4", "0xf.fffa1ap-4", "0xf.fffa48p-4", "0xf.fffa75p-4", "0xf.fffaa1p-4", "0xf.fffacbp-4", "0xf.fffaf4p-4","0xf.fffb1cp-4",
"0xf.fffb43p-4", "0xf.fffb68p-4", "0xf.fffb8cp-4", "0xf.fffbafp-4", "0xf.fffbd1p-4", "0xf.fffbf2p-4", "0xf.fffc12p-4","0xf.fffc31p-4",
"0xf.fffc4fp-4", "0xf.fffc6cp-4", "0xf.fffc88p-4", "0xf.fffca4p-4", "0xf.fffcbep-4", "0xf.fffcd8p-4", "0xf.fffcf1p-4","0xf.fffd09p-4",
"0xf.fffd2p-4", "0xf.fffd37p-4", "0xf.fffd4dp-4", "0xf.fffd62p-4","0xf.fffd76p-4", "0xf.fffd8ap-4", "0xf.fffd9ep-4", "0xf.fffdb1p-4",
"0xf.fffdc3p-4", "0xf.fffdd4p-4", "0xf.fffde6p-4", "0xf.fffdf6p-4", "0xf.fffe06p-4", "0xf.fffe16p-4", "0xf.fffe25p-4","0xf.fffe33p-4",
"0xf.fffe42p-4", "0xf.fffe4fp-4", "0xf.fffe5dp-4", "0xf.fffe6ap-4", "0xf.fffe76p-4", "0xf.fffe82p-4", "0xf.fffe8ep-4","0xf.fffe99p-4",
"0xf.fffea4p-4", "0xf.fffeafp-4", "0xf.fffeb9p-4", "0xf.fffec3p-4", "0xf.fffecdp-4", "0xf.fffed7p-4", "0xf.fffeep-4","0xf.fffee9p-4",
"0xf.fffef1p-4", "0xf.fffefap-4", "0xf.ffff02p-4", "0xf.ffff09p-4", "0xf.ffff11p-4", "0xf.ffff18p-4", "0xf.ffff2p-4","0xf.ffff26p-4",
"0xf.ffff2dp-4", "0xf.ffff34p-4", "0xf.ffff3ap-4", "0xf.ffff4p-4", "0xf.ffff46p-4", "0xf.ffff4cp-4", "0xf.ffff51p-4", "0xf.ffff57p-4",
"0xf.ffff5cp-4", "0xf.ffff61p-4", "0xf.ffff66p-4", "0xf.ffff6ap-4", "0xf.ffff6fp-4", "0xf.ffff74p-4", "0xf.ffff78p-4","0xf.ffff7cp-4",
"0xf.ffff8p-4", "0xf.ffff84p-4", "0xf.ffff88p-4", "0xf.ffff8cp-4","0xf.ffff8fp-4", "0xf.ffff93p-4", "0xf.ffff96p-4", "0xf.ffff99p-4",
"0xf.ffff9cp-4", "0xf.ffff9fp-4", "0xf.ffffa2p-4", "0xf.ffffa5p-4", "0xf.ffffa8p-4", "0xf.ffffabp-4", "0xf.ffffadp-4","0xf.ffffbp-4",
"0xf.ffffb2p-4", "0xf.ffffb5p-4", "0xf.ffffb7p-4", "0xf.ffffb9p-4", "0xf.ffffbcp-4", "0xf.ffffbep-4", "0xf.ffffcp-4","0xf.ffffc2p-4",
};

static const ap_fixed< 23 , 4 > first_tanh_K1 [ 512 ] = {
"0x7.ffd66p0", "0x7.fed7ep0", "0x7.fcd9ep0", "0x7.f9dd6p0", "0x7.f5e3cp0", "0x7.f0efp0", "0x7.eb01cp0", "0x7.e41ecp0",
"0x7.dc49ap0", "0x7.d3864p0", "0x7.c9d86p0", "0x7.bf456p0", "0x7.b3d1cp0", "0x7.a7834p0", "0x7.9a5f8p0", "0x7.8c6cap0",
"0x7.7db14p0", "0x7.6e33ep0", "0x7.5dfb8p0", "0x7.4d0f6p0", "0x7.3b76cp0", "0x7.29396p0", "0x7.165fp0", "0x7.02ef8p0",
"0x6.eef2cp0", "0x6.da70cp0", "0x6.c571ep0", "0x6.affe4p0", "0x6.9a1dcp0", "0x6.83d8cp0", "0x6.6d378p0", "0x6.5641ep0",
"0x6.3effep0", "0x6.27798p0", "0x6.0fb66p0", "0x5.f7be6p0", "0x5.df98ep0", "0x5.c74d6p0", "0x5.aee2ep0", "0x5.9660cp0",
"0x5.7dcd4p0", "0x5.652fap0", "0x5.4c8dcp0", "0x5.33ee2p0", "0x5.1b56ap0", "0x5.02ccep0", "0x4.ea56ap0", "0x4.d1f8ep0",
"0x4.b9b8ep0", "0x4.a19b4p0", "0x4.89a4cp0", "0x4.71d96p0", "0x4.5a3d8p0", "0x4.42d4cp0", "0x4.2ba3p0", "0x4.14ab6p0",
"0x3.fdf0ep0", "0x3.e776cp0", "0x3.d13f8p0", "0x3.bb4dcp0", "0x3.a5a3cp0", "0x3.90436p0", "0x3.7b2ecp0", "0x3.66678p0",
"0x3.51efp0", "0x3.3dc6cp0", "0x3.29efep0", "0x3.166b6p0", "0x3.033a2p0", "0x2.f05cap0", "0x2.ddd3ap0", "0x2.cb9f6p0",
"0x2.b9c04p0", "0x2.a836ap0", "0x2.97022p0", "0x2.8623p0", "0x2.7598cp0", "0x2.65638p0", "0x2.5582ap0", "0x2.45f5ep0",
"0x2.36bc8p0", "0x2.27d5ep0", "0x2.1941ap0", "0x2.0afeap0", "0x1.fd0c8p0", "0x1.ef6a2p0", "0x1.e2168p0", "0x1.d511p0",
"0x1.c8586p0", "0x1.bbebep0", "0x1.afcap0", "0x1.a3f24p0", "0x1.9863p0", "0x1.8d1b6p0", "0x1.821ap0", "0x1.775ep0",
"0x1.6ce6p0", "0x1.62b0ep0", "0x1.58bd6p0", "0x1.4f0a4p0", "0x1.45966p0", "0x1.3c606p0", "0x1.33674p0", "0x1.2aa9cp0",
"0x1.22268p0", "0x1.19dc6p0", "0x1.11ca2p0", "0x1.09eeap0", "0x1.0248cp0", "0xf.ad72p-4", "0xf.398cp-4", "0xe.c8c6p-4",
"0xe.5b0cp-4", "0xd.f052p-4", "0xd.888p-4", "0xd.2388p-4", "0xc.c156p-4", "0xc.61dcp-4", "0xc.0508p-4", "0xb.aac8p-4",
"0xb.530cp-4", "0xa.fdc6p-4", "0xa.aae2p-4", "0xa.5a54p-4", "0xa.0c0ep-4", "0x9.cp-4", "0x9.761ap-4", "0x9.2e4cp-4",
"0x8.e88cp-4", "0x8.a4cep-4", "0x8.62fcp-4", "0x8.231p-4", "0x7.e4fcp-4", "0x7.a8b2p-4", "0x7.6e26p-4", "0x7.354cp-4",
"0x6.fe18p-4", "0x6.c88p-4", "0x6.9476p-4", "0x6.61f4p-4", "0x6.30e8p-4", "0x6.015p-4", "0x5.d31ap-4", "0x5.a63ep-4",
"0x5.7ab6p-4", "0x5.5074p-4", "0x5.2776p-4", "0x4.ffa8p-4", "0x4.d90ap-4", "0x4.b39p-4", "0x4.8f34p-4", "0x4.6becp-4",
"0x4.49aep-4", "0x4.2876p-4", "0x4.083cp-4", "0x3.e8f6p-4", "0x3.ca9ep-4", "0x3.ad32p-4", "0x3.90a4p-4", "0x3.74f2p-4",
"0x3.5a12p-4", "0x3.4004p-4", "0x3.26bap-4", "0x3.0e36p-4", "0x2.f66ep-4", "0x2.df5ap-4", "0x2.c8fap-4", "0x2.b348p-4",
"0x2.9e3ap-4", "0x2.89cep-4", "0x2.7604p-4", "0x2.62cep-4", "0x2.503p-4", "0x2.3e2p-4", "0x2.2c9cp-4", "0x2.1bap-4",
"0x2.0b2ap-4", "0x1.fb3p-4", "0x1.ebb4p-4", "0x1.dcbp-4", "0x1.ce2p-4", "0x1.cp-4", "0x1.b24ep-4", "0x1.a50ap-4",
"0x1.982ap-4", "0x1.8bacp-4", "0x1.7f92p-4", "0x1.73d8p-4", "0x1.6878p-4", "0x1.5d7p-4", "0x1.52bep-4", "0x1.485ep-4",
"0x1.3e5p-4", "0x1.349p-4", "0x1.2b1ep-4", "0x1.21f4p-4", "0x1.1912p-4", "0x1.1076p-4", "0x1.081ep-4", "0x1.0004p-4",
"0xf.82cp-8", "0xf.09p-8", "0xe.932p-8", "0xe.20ap-8", "0xd.b1cp-8", "0xd.464p-8", "0xc.ddep-8", "0xc.79p-8",
"0xc.17p-8", "0xb.b8p-8", "0xb.5cp-8", "0xb.02cp-8", "0xa.ac4p-8", "0xa.586p-8", "0xa.072p-8", "0x9.b86p-8",
"0x9.6bep-8", "0x9.22p-8", "0x8.da2p-8", "0x8.948p-8", "0x8.514p-8", "0x8.0fep-8", "0x7.d06p-8", "0x7.92ep-8",
"0x7.578p-8", "0x7.1dap-8", "0x6.e5cp-8", "0x6.af8p-8", "0x6.7aep-8", "0x6.48p-8", "0x6.168p-8", "0x5.e6ap-8",
"0x5.b86p-8", "0x5.8b4p-8", "0x5.5fcp-8", "0x5.356p-8", "0x5.0c6p-8", "0x4.e4cp-8", "0x4.be4p-8", "0x4.99p-8",
"0x4.74cp-8", "0x4.51cp-8", "0x4.2fcp-8", "0x4.0ecp-8", "0x3.eeep-8", "0x3.dp-8", "0x3.b1ep-8", "0x3.94ep-8",
"0x3.78ap-8", "0x3.5d4p-8", "0x3.42cp-8", "0x3.292p-8", "0x3.104p-8", "0x2.f84p-8", "0x2.e0ep-8", "0x2.ca4p-8",
"0x2.b44p-8", "0x2.9eep-8", "0x2.8a4p-8", "0x2.764p-8", "0x2.62ep-8", "0x2.5p-8", "0x2.3ep-8", "0x2.2c4p-8",
"0x2.1b2p-8", "0x2.0a8p-8", "0x1.fa8p-8", "0x1.eaep-8", "0x1.dbep-8", "0x1.cd4p-8", "0x1.bfp-8", "0x1.b14p-8",
"0x1.a3ep-8", "0x1.97p-8", "0x1.8a8p-8", "0x1.7e6p-8", "0x1.72ap-8", "0x1.674p-8", "0x1.5c2p-8", "0x1.516p-8",
"0x1.472p-8", "0x1.3dp-8", "0x1.334p-8", "0x1.29cp-8", "0x1.20ap-8", "0x1.17cp-8", "0x1.0f4p-8", "0x1.06cp-8",
"0xf.ecp-12", "0xf.6ep-12", "0xe.f6p-12", "0xe.8p-12", "0xe.0cp-12", "0xd.ap-12", "0xd.34p-12", "0xc.ccp-12",
"0xc.66p-12", "0xc.04p-12", "0xb.a6p-12", "0xb.4ap-12", "0xa.f2p-12", "0xa.9ap-12", "0xa.4ap-12", "0x9.f8p-12",
"0x9.a8p-12", "0x9.5cp-12", "0x9.12p-12", "0x8.ccp-12", "0x8.86p-12", "0x8.42p-12", "0x8.02p-12", "0x7.c2p-12",
"0x7.86p-12", "0x7.4ap-12", "0x7.1p-12", "0x6.dap-12", "0x6.a2p-12", "0x6.7p-12", "0x6.3cp-12", "0x6.0cp-12",
"0x5.dap-12", "0x5.aep-12", "0x5.82p-12", "0x5.54p-12", "0x5.2cp-12", "0x5.02p-12", "0x4.dcp-12", "0x4.b4p-12",
"0x4.92p-12", "0x4.6cp-12", "0x4.4ap-12", "0x4.28p-12", "0x4.06p-12", "0x3.e6p-12", "0x3.cap-12", "0x3.aap-12",
"0x3.8ep-12", "0x3.7p-12", "0x3.58p-12", "0x3.3cp-12", "0x3.22p-12", "0x3.0ap-12", "0x2.f2p-12", "0x2.dcp-12",
"0x2.c4p-12", "0x2.aep-12", "0x2.9ap-12", "0x2.84p-12", "0x2.72p-12", "0x2.5ep-12", "0x2.4ap-12", "0x2.3ap-12",
"0x2.28p-12", "0x2.16p-12", "0x2.06p-12", "0x1.f8p-12", "0x1.e6p-12", "0x1.d8p-12", "0x1.cap-12", "0x1.bap-12",
"0x1.aep-12", "0x1.ap-12", "0x1.94p-12", "0x1.88p-12", "0x1.7ap-12", "0x1.7p-12", "0x1.64p-12", "0x1.5ap-12",
"0x1.4ep-12", "0x1.44p-12", "0x1.3cp-12", "0x1.32p-12", "0x1.26p-12", "0x1.2p-12", "0x1.14p-12", "0x1.0ep-12",
"0x1.04p-12", "0xf.cp-16", "0xf.6p-16", "0xe.cp-16", "0xe.8p-16", "0xe.p-16", "0xd.8p-16", "0xd.2p-16",
"0xc.ap-16", "0xc.4p-16", "0xc.p-16", "0xb.8p-16", "0xb.4p-16", "0xa.cp-16", "0xa.6p-16", "0xa.2p-16",
"0x9.ep-16", "0x9.ap-16", "0x9.4p-16", "0x9.p-16", "0x8.cp-16", "0x8.6p-16", "0x8.4p-16", "0x7.ep-16",
"0x7.cp-16", "0x7.8p-16", "0x7.2p-16", "0x7.2p-16", "0x6.ep-16", "0x6.8p-16", "0x6.8p-16", "0x6.4p-16",
"0x6.p-16", "0x5.cp-16", "0x5.ap-16", "0x5.8p-16", "0x5.4p-16", "0x5.2p-16", "0x5.p-16", "0x4.ep-16",
"0x4.ap-16", "0x4.8p-16", "0x4.6p-16", "0x4.4p-16", "0x4.2p-16", "0x4.p-16", "0x3.ep-16", "0x3.cp-16",
"0x3.ap-16", "0x3.8p-16", "0x3.8p-16", "0x3.4p-16", "0x3.4p-16", "0x3.p-16", "0x3.p-16", "0x2.ep-16",
"0x2.ep-16", "0x2.ap-16", "0x2.ap-16", "0x2.8p-16", "0x2.ap-16", "0x2.8p-16", "0x2.6p-16", "0x2.4p-16",
"0x2.2p-16", "0x2.4p-16", "0x2.p-16", "0x2.p-16", "0x2.p-16", "0x1.ep-16", "0x1.cp-16", "0x1.ep-16",
"0x1.ap-16", "0x1.cp-16", "0x1.8p-16", "0x1.8p-16", "0x1.8p-16", "0x1.8p-16", "0x1.6p-16", "0x1.6p-16",
"0x1.6p-16", "0x1.4p-16", "0x1.6p-16", "0x1.4p-16", "0x1.4p-16", "0x1.2p-16", "0x1.2p-16", "0x1.p-16",
"0x1.2p-16", "0x1.p-16", "0xe.p-20", "0x1.p-16", "0xe.p-20", "0x1.p-16", "0xc.p-20", "0xe.p-20",
"0xe.p-20", "0xc.p-20", "0xc.p-20", "0xc.p-20", "0xc.p-20", "0xa.p-20", "0xc.p-20", "0xa.p-20",
"0xa.p-20", "0xa.p-20", "0x8.p-20", "0xa.p-20", "0xa.p-20", "0x8.p-20", "0x8.p-20", "0x8.p-20",
"0x8.p-20", "0x8.p-20", "0x8.p-20", "0x6.p-20", "0x8.p-20", "0x6.p-20", "0x6.p-20", "0x6.p-20",
"0x8.p-20", "0x8.p-20", "0x6.p-20", "0x6.p-20", "0x6.p-20", "0x4.p-20", "0x6.p-20", "0x4.p-20",
"0x6.p-20", "0x4.p-20", "0x4.p-20", "0x6.p-20", "0x2.p-20", "0x4.p-20", "0x4.p-20", "0x2.p-20",
};
#55 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h" 2

template<class T>
struct value_list{
};

template<>
struct value_list<double>{
    typedef double T;
 static const int g = 10;
 static const int p1 = 61;
 static const int alpha = 7;

 static const int beta1 = 0;

 static const int beta2 = alpha;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<3> &k,
                                               ap_ufixed<Wx, 0> &x,
                                               ap_ufixed<Wr, 0> &Mx,
                                               ap_int<fp_struct<double>::EXP_BITS> &Ex){

        const bool swap_table[8] = {0,1,1,0,0,1,1,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K4 core=ROM_1P_LUTRAM

        ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
        ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
        ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

        bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
        A[alpha] = sin_basis;

        ap_fixed<Wx, 1> t1 = fourth_order_double::sin_cos_K0[A];
        ap_fixed<Wx, 1> t2 = B*fourth_order_double::sin_cos_K1[A];
        ap_fixed<Wx, 1> t3 = B_squared*fourth_order_double::sin_cos_K2[A];
        ap_fixed<Wx, 1> t4 = B_third_power*fourth_order_double::sin_cos_K3[A];
        ap_fixed<Wx, 1> t5 = B_fourth_power*fourth_order_double::sin_cos_K4[A];
        ap_ufixed<Wx, 1> result = Mx*(t1+t2+t3+t4+t5);
#123 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
        return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
                              ap_ufixed<Wx, 0> &x,
                              ap_ufixed<Wr, 0> Mx,
                              ap_int<fp_struct<double>::EXP_BITS> Ex,
                              ap_ufixed<Wr, 1> &sin_result,
                              ap_ufixed<Wr, 1> &cos_result
                              ) {
#pragma HLS RESOURCE variable=fourth_order_double::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K4 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K4 core=ROM_1P_LUTRAM

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
                             x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
        ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
        ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

        ap_fixed<Wx, 1> cos_t1 = fourth_order_double::cos_K0[A];
        ap_fixed<Wx, 1> cos_t2 = B*fourth_order_double::cos_K1[A];
        ap_fixed<Wx, 1> cos_t3 = B_squared*fourth_order_double::cos_K2[A];
        ap_fixed<Wx, 1> cos_t4 = B_third_power*fourth_order_double::cos_K3[A];
        ap_fixed<Wx, 1> cos_t5 = B_fourth_power*fourth_order_double::cos_K4[A];
        cos_result = 1 - (cos_t1 + cos_t2 + cos_t3 + cos_t4 + cos_t5);

        ap_fixed<Wx, 1> sin_t1 = fourth_order_double::sin_K0[A];
        ap_fixed<Wx, 1> sin_t2 = B*fourth_order_double::sin_K1[A];
        ap_fixed<Wx, 1> sin_t3 = B_squared*fourth_order_double::sin_K2[A];
        ap_fixed<Wx, 1> sin_t4 = B_third_power*fourth_order_double::sin_K3[A];
        ap_fixed<Wx, 1> sin_t5 = B_fourth_power*fourth_order_double::sin_K4[A];
        sin_result = Mx * (sin_t1 + sin_t2 + sin_t3 + sin_t4 + sin_t5);
#185 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
    }
};


template<>
struct value_list<float> {
    typedef float T;
 static const int g = 5;
 static const int p1 = 29;
 static const int alpha = 7;

 static const int beta1 = 0;

 static const int beta2 = 7;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;



    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<3> &k,
                                               ap_ufixed<Wx, 0> &x,
                                               ap_ufixed<Wr, 0> &Mx,
                                               ap_int<fp_struct<float>::EXP_BITS> &Ex){

        const bool swap_table[8] = {0,1,1,0,0,1,1,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K2 core=ROM_1P_LUTRAM

        ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

        bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
        A[alpha] = sin_basis;

        ap_fixed<Wx, 1> t1 = second_order_float::sin_cos_K0[A];
        ap_fixed<Wx, 1> t2 = B*second_order_float::sin_cos_K1[A];
        ap_fixed<Wx, 1> t3 = B_squared*second_order_float::sin_cos_K2[A];
        ap_ufixed<Wx, 1> result =
            (t1+t2+t3) * Mx;
#245 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
        return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
                              ap_ufixed<Wx, 0> &x,
                              ap_ufixed<Wr, 0> &Mx,
                              ap_int<fp_struct<float>::EXP_BITS> &Ex,
                              ap_ufixed<Wr, 1> &sin_result,
                              ap_ufixed<Wr, 1> &cos_result
                              ) {
#pragma HLS RESOURCE variable=second_order_float::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K2 core=ROM_1P_LUTRAM

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
                             x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;


        ap_ufixed<Wx, 1> cos_t1 = second_order_float::cos_K0[A];
        ap_ufixed<Wx, 1> cos_t2 = B*second_order_float::cos_K1[A];
        ap_ufixed<Wx, 1> cos_t3 = B_squared*second_order_float::cos_K2[A];
        cos_result = 1 - (cos_t1 + cos_t2 + cos_t3);

        ap_fixed<Wx, 1> sin_t1 = second_order_float::sin_K0[A];
        ap_fixed<Wx, 1> sin_t2 = B*second_order_float::sin_K1[A];
        ap_fixed<Wx, 1> sin_t3 = B_squared*second_order_float::sin_K2[A];
        sin_result = Mx * (sin_t1 + sin_t2 + sin_t3);
#298 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
    }

};

template<>
struct value_list<half>{
    typedef half T;
 static const int g = 4;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<3> &k,
                                               ap_ufixed<Wx, 0> &x,
                                               ap_ufixed<Wr, 0> &Mx,
                                               ap_int<fp_struct<half>::EXP_BITS> &Ex){

        const bool swap_table[8] = {0,1,1,0,0,1,1,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS RESOURCE variable=first_order_half::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_order_half::sin_cos_K1 core=ROM_1P_LUTRAM

        ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;

        bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
        A[alpha] = sin_basis;

        ap_fixed<Wx, 1> t1 = first_order_half::sin_cos_K0[A];
        ap_fixed<Wx, 1> t2 = B*first_order_half::sin_cos_K1[A];
        ap_ufixed<Wx, 1> result =
            (t1+t2) * Mx;
#345 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
        return result;
    }
    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
                              ap_ufixed<Wx, 0> &x,
                              ap_ufixed<Wr, 0> Mx,
                              ap_int<fp_struct<half>::EXP_BITS> Ex,
                              ap_ufixed<Wr, 1> &sin_result,
                              ap_ufixed<Wr, 1> &cos_result
                              ) {
#pragma HLS RESOURCE variable=first_order_half::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_order_half::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_order_half::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_order_half::sin_K1 core=ROM_1P_LUTRAM

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
                             x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;

        ap_ufixed<Wx, 1> cos_t1 = first_order_half::cos_K0[A];
        ap_ufixed<Wx, 1> cos_t2 = B*first_order_half::cos_K1[A];
        cos_result = 1 - (cos_t1 + cos_t2);

        ap_fixed<Wx, 1> sin_t1 = first_order_half::sin_K0[A];
        ap_fixed<Wx, 1> sin_t2 = B*first_order_half::sin_K1[A];
        sin_result = Mx * (sin_t1 + sin_t2);
#385 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
    }
};

template<class T>
void generic_sincos(T t_in, T *s, T *c)
{

    const int g = value_list<T>::g;
    const int p1 = value_list<T>::p1;

    const bool swap_table[8] = {0,1,1,0,0,1,1,0};
    const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
    const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete




    fp_struct<T> din(t_in);





    ap_uint<3> k;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> x;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> Mx;
    ap_int<fp_struct<T>::EXP_BITS> Ex;

    range_redux_payne_hanek_hotbm<p1,T>(t_in,k,x,Mx,Ex);

    ap_ufixed<value_list<T>::W_dout, 1> sin_result, cos_result;
    value_list<T>::sincos_approximation(k,x,Mx,Ex,sin_result,cos_result);

    T sin_resultf, cos_resultf;
    scaled_fixed2ieee(cos_result, cos_resultf, 0);
    scaled_fixed2ieee(sin_result, sin_resultf, -Ex);






    ap_uint<4> index = k;
    index[3] = din.sign;
    fp_struct<T> sin_results(sin_resultf);
    fp_struct<T> cos_results(cos_resultf);

    if(neg_sin_table[index]) { sin_results.sign = 1; }
    if(neg_cos_table[index]) { cos_results.sign = 1; }

    T s_out, c_out;
    if(din.exp == 0 && din.sig == 0) {
        sin_results.sign = din.sign;
        sin_results.exp = 0;
        sin_results.sig = 0;
        cos_results.sign = 0;
        cos_results.exp = fp_struct<T>::EXP_BIAS;
        cos_results.sig = 0;
    } else if(din.exp == fp_struct<T>::EXP_INFNAN) {
        sin_results.sign = 0;
        sin_results.exp = -1;
        sin_results.sig = -1;
        cos_results.sign = 0;
        cos_results.exp = -1;
        cos_results.sig = -1;
    }

    if(swap_table[k]) {
        s_out = cos_results.to_ieee();
        c_out = sin_results.to_ieee();
    } else {
        s_out = sin_results.to_ieee();
        c_out = cos_results.to_ieee();
    }

    *s = s_out;
    *c = c_out;
}


template<class T>
T sin_or_cos(T t_in, bool do_cos, bool do_pi)
{

    const int g = value_list<T>::g;
    const int p1 = value_list<T>::p1;

    const bool swap_table[8] = {0,1,1,0,0,1,1,0};
    const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
    const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

    fp_struct<T> din(t_in);






    ap_uint<3> k;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> x;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> Mx;
    ap_int<fp_struct<T>::EXP_BITS> Ex;

    int exactly_pi_over_2 = 0;
    if(do_pi) {
        range_redux_payne_hanek_hotbm_pi<p1,T>(t_in,k,x,Mx,Ex,exactly_pi_over_2);
    } else {
        range_redux_payne_hanek_hotbm<p1,T>(t_in,k,x,Mx,Ex);
    }

    bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
    if(cos_basis) {


        Mx = ap_ufixed<value_list<T>::W_dout, 0, AP_RND, AP_SAT>(1);
        Ex = 0;
    }

    ap_ufixed<value_list<T>::W_dout, 1> result = value_list<T>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);
    T resultf;
    scaled_fixed2ieee(result, resultf, -Ex);



    if(exactly_pi_over_2) {
        resultf = 0.7071067811865475244008443;
    }
 fp_struct<T> results(resultf);





    ap_uint<4> index = k;
    index[3] = din.sign;
    if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
        results.sign = 1;
    }

    if(din.exp == 0 && (do_pi ? 1 : din.sig == 0)) {



        results.sign = din.sign;
        results.exp = 0;
        results.sig = 0;
        if(do_cos) {
            results.sign = 0;
            results.exp = fp_struct<T>::EXP_BIAS;
        }
    } else if(din.exp == fp_struct<T>::EXP_INFNAN) {
        results.sign = 0;
        results.exp = -1;
        results.sig = -1;
    }
    return results.to_ieee();
}

template<int W, int I>
ap_fixed<W,2>
sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi, typename enable_if<(W > 16) && (W <= 32), bool>::type dummy = true)
{
    const int WO = W;
    const int g = 3;

    const bool swap_table[8] = {0,1,1,0,0,1,1,0};
    const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
    const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete
#571 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
    ap_uint<3> k;
    ap_ufixed<WO+1+g, 0> x;
    ap_ufixed<WO+1+g, 0> Mx;
    ap_int<fp_struct<float>::EXP_BITS> Ex = 0;

    int exactly_pi_over_4 = 0;
    bool is_negative = t_in[t_in.wl()-1];
    ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

    if(do_pi) {
        k = din*4;
        x = din*4;
        ap_ufixed<W, 1> Mx_bits_extended = din*4;



        exactly_pi_over_4 = (Mx_bits_extended == 1);
    } else {
        ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
        k = Wx;
        x = Wx;
    }




    if(k[0] == 1) {
        x = 1-x;
    }
    Mx = x;

    bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
    if(cos_basis) {


        Mx = ap_ufixed<value_list<float>::W_dout, 0, AP_RND, AP_SAT>(1);
        Ex = 0;
    }

    ap_ufixed<WO+1+g, 1> result = value_list<float>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

    if(exactly_pi_over_4) {
        result = 0.7071067811865475244008443;
    }






    ap_uint<4> index = k;
    index[3] = is_negative;





    if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
        return -result;
    } else {
        return result;
    }
}

    struct sin_cos_fixed_16 {
    typedef half T;
 static const int g = 3;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

    template <int W_dout>
    static ap_ufixed<W_dout, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<2> &k,
                                               ap_ufixed<W_dout, 0> &x){

#pragma HLS RESOURCE variable=first_order_fixed_16::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_order_fixed_16::sin_cos_K1 core=ROM_1P_LUTRAM

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<W_dout-alpha-beta1, -alpha> B = x;

        ap_fixed<W_dout, 1> t1 = first_order_fixed_16::sin_cos_K0[A];
        ap_fixed<W_dout, 1> t2 = B*first_order_fixed_16::sin_cos_K1[A];
        ap_ufixed<W_dout, 1> result = (t1+t2);
#665 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
        return result;
    }
};
#678 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
template<int W, int I>
ap_fixed<W,2>
sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi, typename enable_if<W <= 16, bool>::type dummy = true)
{
    const int WO = W;
    const int g = 4;

    const bool neg_sin_table[8] = {0,0,1,1, 1,1,0,0};
    const bool neg_cos_table[8] = {0,1,1,0, 0,1,1,0};
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete
#697 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
    ap_uint<2> k;
    ap_ufixed<WO+1+g, 0> x;

    bool is_negative = t_in[t_in.wl()-1];
    ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

    if(do_pi) {
        k = din*2;
        x = din*2;
        ap_ufixed<W, 1> Mx_bits_extended = din*2;



    } else {
        ap_ufixed<WO+1+g+2, 2> Wx = din * ap_ufixed<W+1+g,2>(2/3.14159265358979323846);
        k = Wx;
        x = Wx;
    }



    bool is_special_case = false;

    if((k[0] == 1) ^ !do_cos) {


        ap_ufixed<WO+1+g+1, 1> Wx = 1-x;
        x = Wx;
        is_special_case = (Wx[Wx.wl()-1] == 1);
    }

    ap_ufixed<WO+1+g, 1> result = sin_cos_fixed_16::sin_or_cos_approximation(do_cos,k,x);

    if(is_special_case) {
        ap_uint<3> index = k;
        index[2] = do_cos;
        const bool special_case_table[8] = {0,1,0,1,1,0,1,0};
        result(result.wl()-2,0) = 0;
        result[result.wl()-1] = special_case_table[index];
    }






    {
        ap_uint<3> index = k;
        index[2] = is_negative;



        if(do_cos ? neg_cos_table[index] : neg_sin_table[index]) {
            return -result;
        } else {
            return result;
        }
    }
}

template<class T> ap_ufixed<31,1> tanh_approximation(ap_ufixed<31, 0> &dout)
{
     const int g = value_list<T>::g;
 const int alpha = 9;
 const int beta1 = 0;
        const int beta2 = 0;
#pragma HLS RESOURCE variable=second_tanh_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_tanh_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_tanh_K2 core=ROM_1P_LUTRAM

    ap_uint<alpha> A = dout(dout.wl()-dout.iwl()-1,dout.wl()-dout.iwl()-alpha);

    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-alpha-beta1, -alpha> B = dout;

    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-alpha-beta2, -alpha> B_trunc = B;
    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t1 = second_tanh_K0[A];
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t2 = B*second_tanh_K1[A];
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t3 = B_squared*second_tanh_K2[A];
    ap_ufixed<fp_struct<T>::SIG_BITS+g+1, 1> result =t1+t2+t3;
#796 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
    return result;
}

template<class T> ap_ufixed<15,1> tanh_approximation(ap_ufixed<15, 0> &dout)
{
     const int g = value_list<T>::g;
 const int alpha = 9;
 const int beta1 = 0;
#pragma HLS RESOURCE variable=first_tanh_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_tanh_K1 core=ROM_1P_LUTRAM

    ap_uint<alpha> A = dout(dout.wl()-dout.iwl()-1,dout.wl()-dout.iwl()-alpha);

    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-alpha-beta1, -alpha> B = dout;
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t1 = second_tanh_K0[A];
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t2 = B*second_tanh_K1[A];
    ap_ufixed<fp_struct<T>::SIG_BITS+g+1, 1> result =t1+t2;
#826 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_hotbm.h"
    return result;
}


static
float
cosf(float t_in)
{
    return sin_or_cos(t_in, 1, 0);
}

static
float
sinf(float t_in)
{
    return sin_or_cos(t_in, 0, 0);
}

static
float
cospif(float t_in)
{
    return sin_or_cos(t_in, 1, 1);
}

static
float
sinpif(float t_in)
{
    return sin_or_cos(t_in, 0, 1);
}

static
half
half_cos(half t_in)
{
    return sin_or_cos(t_in, 1, 0);
}

static
half
half_sin(half t_in)
{
    return sin_or_cos(t_in, 0, 0);
}

static
half
half_cospi(half t_in)
{
    return sin_or_cos(t_in, 1, 1);
}

static
half
half_sinpi(half t_in)
{
    return sin_or_cos(t_in, 0, 1);
}

static
double
cos(double t_in)
{
    return sin_or_cos(t_in, 1, 0);
}

static
double
sin(double t_in)
{
    return sin_or_cos(t_in, 0, 0);
}

static
double
cospi(double t_in)
{
    return sin_or_cos(t_in, 1, 1);
}

static
double
sinpi(double t_in)
{
    return sin_or_cos(t_in, 0, 1);
}

template<int W, int I>
ap_fixed<W, 2> cosf(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 1, 0);
}
template<int W, int I>
ap_fixed<W, 2> sinf(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 0, 0);
}

template<int W, int I>
ap_fixed<W, 2> cospif(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 1, 1);
}
template<int W, int I>
ap_fixed<W, 2> sinpif(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 0, 1);
}

static void sincos(double t_in, double *s, double *c) {
    generic_sincos(t_in, s, c);
}
static void sincosf(float t_in, float *s, float *c) {
    generic_sincos(t_in, s, c);
}
static void half_sincos(half t_in, half *s, half *c) {
    generic_sincos(t_in, s, c);
}

}
#301 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2


static double sin(double t_in)
{
    return hotbm::sin(t_in);
}
static float sin(float t_in)
{
    return hotbm::sinf(t_in);
}
static float sinf(float t_in)
{
    return hotbm::sinf(t_in);
}
static half half_sin(half t_in)
{
    return hotbm::half_sin(t_in);
}
static half sin(half t_in)
{
    return ::hls::half_sin(t_in);
}


static double cos(double t_in)
{
    return hotbm::cos(t_in);
}
static float cos(float t_in)
{
    return hotbm::cosf(t_in);
}
static float cosf(float t_in)
{
    return hotbm::cosf(t_in);
}
static half half_cos(half t_in)
{
    return hotbm::half_cos(t_in);
}
static half cos(half t_in)
{
    return ::hls::half_cos(t_in);
}


template<int W, int I>
ap_fixed<W, 2> cosf(ap_fixed<W, I> t_in)
{
    return hotbm::cosf(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sinf(ap_fixed<W, I> t_in)
{
    return hotbm::sinf(t_in);
}
template<int W, int I>
ap_fixed<W, 2> cos(ap_fixed<W, I> t_in)
{
    return hotbm::cosf(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sin(ap_fixed<W, I> t_in)
{
    return hotbm::sinf(t_in);
}



static double sinpi(double t_in)
{
    return hotbm::sinpi(t_in);
}
static float sinpif(float t_in)
{
    return hotbm::sinpif(t_in);
}
static half half_sinpi(half t_in)
{
    return hotbm::half_sinpi(t_in);
}


static double cospi(double t_in)
{
    return hotbm::cospi(t_in);
}
static float cospif(float t_in)
{
    return hotbm::cospif(t_in);
}
static half half_cospi(half t_in)
{
    return hotbm::half_cospi(t_in);
}


template<int W, int I>
ap_fixed<W, 2> cospif(ap_fixed<W, I> t_in)
{
    return hotbm::cospif(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sinpif(ap_fixed<W, I> t_in)
{
    return hotbm::sinpif(t_in);
}
template<int W, int I>
ap_fixed<W, 2> cospi(ap_fixed<W, I> t_in)
{
    return hotbm::cospif(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sinpi(ap_fixed<W, I> t_in)
{
    return hotbm::sinpif(t_in);
}


static void sincos(double x, double *sin, double *cos)
{
    hotbm::sincos(x, sin, cos);
}
static void sincosf(float x, float *sin, float *cos)
{
    hotbm::sincosf(x, sin, cos);
}
static void half_sincos(half x, half *sin, half *cos)
{
    hotbm::half_sincos(x, sin, cos);
}

static double atan(double t_in)
{
 return cordic::atan(t_in);
}

static float atanf(float t_in)
{
 return cordic::atanf(t_in);
}

static half half_atan(half t_in)
{
 return cordic::half_atan(t_in);
}

static double atan2(double y_in, double x_in)
{
 return cordic::atan2(y_in, x_in);
}

static float atan2f(float y_in, float x_in)
{
 return cordic::atan2f(y_in, x_in);
}

static half half_atan2(half y_in, half x_in)
{
 return cordic::half_atan2(y_in, x_in);
}

static double sinh(double t_in)
{
 return cordic::sinh(t_in);
}
static float sinhf(float t_in)
{
 return cordic::sinhf(t_in);
}
static half half_sinh(half t_in)
{
 return cordic::half_sinh(t_in);
}

static double cosh(double t_in)
{
 return cordic::cosh(t_in);
}
static float coshf(float t_in)
{
 return cordic::coshf(t_in);
}
static half half_cosh(half t_in)
{
 return cordic::half_cosh(t_in);
}

}
#506 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h"
namespace hls {

static float tanf(float t_in)
{
 float s_out, c_out;
    fp_struct<float> fs = t_in;
    if(fs.exp <= 0x1) {

        return t_in;
    } else {
        ::hls::sincosf(t_in, &s_out, &c_out);
        return xil_fpo_div_flt(s_out,c_out);
    }
}

static double tan(double t_in)
{
 double s_out, c_out;
    fp_struct<double> fs = t_in;
    if(fs.exp <= 0x1) {

        return t_in;
    } else {
        ::hls::sincos(t_in, &s_out, &c_out);
        return xil_fpo_div_d(s_out,c_out);
    }
}
static half half_tan(half t_in)
{
 half s_out, c_out;
    fp_struct<half> fs = t_in;
    if(fs.exp <= 0x1) {

        return t_in;
    } else {
        ::hls::half_sincos(t_in, &s_out, &c_out);
        return s_out/c_out;
    }
}
static half tan(half t_in)
{
    return ::hls::half_tan(t_in);
}

static float logf(float x)
{
    return ::xil_fpo_log_flt(x);

}
static float log2f(float x)
{

    return hls::log_reduce::log2f(x);
}
static float log10f(float x)
{
    return xil_fpo_mul_flt(logf(x),0.434294481903251827651128918916605082294397005f);

}
static float logbf(float x)
{
    return hls::log_reduce::logbf(x);
}

static double log(double x)
{
    return ::xil_fpo_log_d(x);

}
static float log(float x)
{
    return ::xil_fpo_log_flt(x);

}
static half log(half x)
{
    return hls::log_reduce::log(x);
}
static double log2(double x)
{

    return hls::log_reduce::log2(x);
}
static float log2(float x)
{
    return hls::log_reduce::log2(x);
}
static half log2(half x)
{
    return hls::log_reduce::log2(x);
}
static double log10(double x)
{
    return xil_fpo_mul_d(log(x),0.434294481903251827651128918916605082294397005);

}
static float log10(float x)
{
    return xil_fpo_mul_flt(logf(x),0.434294481903251827651128918916605082294397005f);

}
static half log10(half x)
{
    return hls::log_reduce::log10(x);
}
static double logb(double x)
{
    return hls::log_reduce::logb(x);
}
static float logb(float x)
{
    return hls::log_reduce::logb(x);
}
static half logb(half x)
{
    return hls::log_reduce::logb(x);
}

static half half_log(half x) {
    return hls::log_reduce::half_log(x);
}
static half half_log10(half x) {
    return hls::log_reduce::half_log10(x);
}
static half half_log2(half x) {
    return hls::log_reduce::half_log2(x);
}
static half half_logb(half x) {
    return hls::log_reduce::half_logb(x);
}

static double log1p(double x) {
    return hls::log_reduce::log1p(x);
}
static float log1p(float x) {
    return hls::log_reduce::log1p(x);
}
static half log1p(half x) {
    return hls::log_reduce::log1p(x);
}
static half half_log1p(half x) {
    return hls::log_reduce::log1p(x);
}
static float log1pf(float x) {
    return hls::log_reduce::log1p(x);
}

static half pow(half x, half y) {
 return hls::pow_reduce::pow(x,y);
}
static float pow(float x, float y) {
        return hls::pow_reduce::pow(x,y);
}
static double pow(double x, double y) {
        return hls::pow_reduce::pow(x,y);
}
static float powf(float x, float y) {
        return hls::pow_reduce::pow(x,y);
}
static half half_pow(half x, half y) {
        return hls::pow_reduce::pow(x,y);
}

static half powr(half x, half y) {
        return hls::pow_reduce::powr(x,y);
}
static float powr(float x, float y) {
        return hls::pow_reduce::powr(x,y);
}
static double powr(double x, double y) {
        return hls::pow_reduce::powr(x,y);
}
static float powrf(float x, float y) {
        return hls::pow_reduce::powr(x,y);
}
static half half_powr(half x, half y) {
        return hls::pow_reduce::powr(x,y);
}

static half pown(half x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static float pown(float x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static double pown(double x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static float pownf(float x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static half half_pown(half x, int y) {
        return hls::pow_reduce::pown(x,y);
}

static half rootn(half x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static float rootn(float x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static double rootn(double x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static float rootnf(float x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static half half_rootn(half x, int y) {
        return hls::pow_reduce::rootn(x,y);
}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr.h" 1
#41 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr.h"
namespace hls_rsr {

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr_tables.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr_tables.h"


namespace {

 template<typename T> class Trait{};

 template<> class Trait<half>{
  public:







   const static int k_bits = 6;
   const static int n_bits = 4 * k_bits;

   typedef ap_ufixed<k_bits + 1, 0> LUT_RType;
   typedef ap_ufixed<n_bits + 1, 1> LUT_MType;
   const static int LUTsize = 1 << k_bits;
   const static ap_ufixed<1, -fp_struct<half>::SIG_BITS> RC;

 };

 const ap_ufixed<1, -fp_struct<half>::SIG_BITS> Trait<half>::RC = 0x0.002p0;


 template <typename R, typename T, int size> class RTable {};

 template<> class RTable<typename Trait<half>::LUT_RType,
  half, Trait<half>::LUTsize> {
   public:
    static const typename Trait<half>::LUT_RType arrayR[Trait<half>::LUTsize];
  };
 const Trait<half>::LUT_RType RTable<Trait<half>::LUT_RType,
    half, Trait<half>::LUTsize>::arrayR[Trait<half>::LUTsize] = {
     0x1,
     0x0.fcp0,
     0x0.f8p0,
     0x0.f4p0,
     0x0.f0p0,
     0x0.ecp0,
     0x0.eap0,
     0x0.e6p0,
     0x0.e2p0,
     0x0.e0p0,
     0x0.dcp0,
     0x0.dap0,
     0x0.d6p0,
     0x0.d4p0,
     0x0.d2p0,
     0x0.cep0,
     0x0.ccp0,
     0x0.cap0,
     0x0.c6p0,
     0x0.c4p0,
     0x0.c2p0,
     0x0.c0p0,
     0x0.bep0,
     0x0.bcp0,
     0x0.bap0,
     0x0.b8p0,
     0x0.b6p0,
     0x0.b4p0,
     0x0.b2p0,
     0x0.b0p0,
     0x0.aep0,
     0x0.acp0,
     0x0.aap0,
     0x0.a8p0,
     0x0.a6p0,
     0x0.a4p0,
     0x0.a2p0,
     0x0.a2p0,
     0x0.a0p0,
     0x0.9ep0,
     0x0.9cp0,
     0x0.9cp0,
     0x0.9ap0,
     0x0.98p0,
     0x0.96p0,
     0x0.96p0,
     0x0.94p0,
     0x0.92p0,
     0x0.92p0,
     0x0.90p0,
     0x0.8ep0,
     0x0.8ep0,
     0x0.8cp0,
     0x0.8cp0,
     0x0.8ap0,
     0x0.88p0,
     0x0.88p0,
     0x0.86p0,
     0x0.86p0,
     0x0.84p0,
     0x0.84p0,
     0x0.82p0,
     0x0.82p0,
     0x0.80p0
    };


 template <typename M, typename T, int size> class RecipMTable {};
 template <typename M, typename T, int size> class SqrtMTable {};
 template <typename M, typename T, int size> class RsqrtMTable {};
#154 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr_tables.h"
 template<> class RsqrtMTable<typename Trait<half>::LUT_MType,
  half, Trait<half>::LUTsize> {
   public:
    static const typename Trait<half>::LUT_MType arrayM[Trait<half>::LUTsize];
  };
 const Trait<half>::LUT_MType RsqrtMTable<Trait<half>::LUT_MType,
    half, Trait<half>::LUTsize>::arrayM[Trait<half>::LUTsize] = {
     0x0,
     0x0.fdfdfb8p0,
     0x0.fbf7df0p0,
     0x0.f9ed908p0,
     0x0.f7def58p0,
     0x0.f5cbf20p0,
     0x0.f4c0c00p0,
     0x0.f2a6ea0p0,
     0x0.f088618p0,
     0x0.ef77508p0,
     0x0.ed517f0p0,
     0x0.ec3cb70p0,
     0x0.ea0f500p0,
     0x0.e8f6a90p0,
     0x0.e7dcad8p0,
     0x0.e5a4a88p0,
     0x0.e486948p0,
     0x0.e367190p0,
     0x0.e123d40p0,
     0x0.e000000p0,
     0x0.dedaad8p0,
     0x0.ddb3d70p0,
     0x0.dc8b768p0,
     0x0.db61858p0,
     0x0.da35fe0p0,
     0x0.d908d88p0,
     0x0.d7da0f8p0,
     0x0.d6a99b0p0,
     0x0.d577748p0,
     0x0.d443948p0,
     0x0.d30df30p0,
     0x0.d1d6890p0,
     0x0.d09d4e0p0,
     0x0.cf623a0p0,
     0x0.ce25448p0,
     0x0.cce6648p0,
     0x0.cba5918p0,
     0x0.cba5918p0,
     0x0.ca62c18p0,
     0x0.c91deb8p0,
     0x0.c7d7060p0,
     0x0.c7d7060p0,
     0x0.c68e058p0,
     0x0.c542e10p0,
     0x0.c3f58c8p0,
     0x0.c3f58c8p0,
     0x0.c2a5fd8p0,
     0x0.c154280p0,
     0x0.c154280p0,
     0x0.c000000p0,
     0x0.bea9790p0,
     0x0.bea9790p0,
     0x0.bd50868p0,
     0x0.bd50868p0,
     0x0.bbf51a8p0,
     0x0.ba97280p0,
     0x0.ba97280p0,
     0x0.b936a08p0,
     0x0.b936a08p0,
     0x0.b7d3750p0,
     0x0.b7d3750p0,
     0x0.b66d958p0,
     0x0.b66d958p0,
     0x0.b504f30p0
    };
 template<> class SqrtMTable<typename Trait<half>::LUT_MType,
  half, Trait<half>::LUTsize> {
   public:
    static const typename Trait<half>::LUT_MType arrayM[Trait<half>::LUTsize];
  };
 const Trait<half>::LUT_MType SqrtMTable<Trait<half>::LUT_MType,
    half, Trait<half>::LUTsize>::arrayM[Trait<half>::LUTsize] = {
     0x0,
     0x1.020614p0,
     0x1.0418a4p0,
     0x1.063833p0,
     0x1.08654ap0,
     0x1.0aa07bp0,
     0x1.0bc38ep0,
     0x1.0e150dp0,
     0x1.10763cp0,
     0x1.11aceep0,
     0x1.1426fap0,
     0x1.156a87p0,
     0x1.17ff2ep0,
     0x1.19507ep0,
     0x1.1aa69ep0,
     0x1.1d61c0p0,
     0x1.1ec701p0,
     0x1.20318cp0,
     0x1.23170dp0,
     0x1.249249p0,
     0x1.26135ep0,
     0x1.279a74p0,
     0x1.2927b2p0,
     0x1.2abb43p0,
     0x1.2c5552p0,
     0x1.2df60cp0,
     0x1.2f9d9fp0,
     0x1.314c3dp0,
     0x1.330218p0,
     0x1.34bf63p0,
     0x1.368457p0,
     0x1.38512bp0,
     0x1.3a261bp0,
     0x1.3c0365p0,
     0x1.3de948p0,
     0x1.3fd807p0,
     0x1.41cfe9p0,
     0x1.41cfe9p0,
     0x1.43d136p0,
     0x1.45dc3ap0,
     0x1.47f144p0,
     0x1.47f144p0,
     0x1.4a10a9p0,
     0x1.4c3abep0,
     0x1.4e6fdfp0,
     0x1.4e6fdfp0,
     0x1.50b06ap0,
     0x1.52fcc4p0,
     0x1.52fcc4p0,
     0x1.555555p0,
     0x1.57ba8bp0,
     0x1.57ba8bp0,
     0x1.5a2cd8p0,
     0x1.5a2cd8p0,
     0x1.5cacb7p0,
     0x1.5f3aa6p0,
     0x1.5f3aa6p0,
     0x1.61d72bp0,
     0x1.61d72bp0,
     0x1.6482d3p0,
     0x1.6482d3p0,
     0x1.673e32p0,
     0x1.673e32p0,
     0x1.6a09e6p0,
    };

}
#44 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr.h" 2


 template <typename T, typename R>
  void fixed2Float(T in, int exponent, int sign, R &result) {
   fp_struct<R> out;
   out.sign = sign;
   out.exp = exponent;

   T ain = in - static_cast<T>(0x1.0p0);
   (((ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS) >= 0) ? static_cast<void> (0) : __assert_fail ("(ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS) >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr.h", 53, __PRETTY_FUNCTION__));
   ((ain.wl() - ain.iwl() - 2 >= 0) ? static_cast<void> (0) : __assert_fail ("ain.wl() - ain.iwl() - 2 >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_rsr.h", 54, __PRETTY_FUNCTION__));
   int bits = ain.wl() - ain.iwl() - 2;

   if(bits >= fp_struct<R>::SIG_BITS) {
    ap_uint<1> Lb, Gb, Tb;
    Lb = ain[ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS];
    Gb = ain[ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS - 1];
    Tb = (ain(ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS - 2, 0) != 0)? 1: 0;
    if( Gb & (Lb | Tb) ) {
     ain += Trait<R>::RC;
    }
    if (ain >= static_cast<T>(0x1.0p0)){
     ain -= static_cast<T>(0x1.0p0);
     ++out.exp;
     ain >>= 1;
    }
   }
   out.sig = ain(ain.wl() - ain.iwl() - 1, ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS);

   result = out.to_ieee();
  }



 template<typename T> class RecipTrait {
  public:
   typedef ap_ufixed<fp_struct<T>::SIG_BITS + 1, 1> FxType;
   typedef ap_fixed<Trait<T>::n_bits - Trait<T>::k_bits + 1,
       -Trait<T>::k_bits + 1> TypeA;
   typedef ap_uint<Trait<T>::k_bits * 2> TypeP;
   typedef ap_fixed<1 + Trait<T>::n_bits - 2 * Trait<T>::k_bits, 1 - 2 * Trait<T>::k_bits> TypeY;
   typedef typename Trait<T>::LUT_RType TypeR;
   typedef typename Trait<T>::LUT_RType TypeMT;
   typedef typename Trait<T>::LUT_RType TypeMM;
   typedef ap_ufixed<1 + Trait<T>::n_bits, 1> TypeRe;

   typedef ap_uint<Trait<T>::k_bits * 2 + 1> TypeS;
   static const int C_A22 = 1, C_A23 = 1, C_A222 = 1;
   static const int C_SHIFT = 0, A_SHIFT = 0;

   static bool f_procInf(const T & x, T & result) {
    result = ::hls::copysign(static_cast<T>(0), x);
    return true;
   }


   static bool f_procZero(const T & x, T & result) {
    result = ::hls::copysign(fp_struct<T>::infinity(), x);
    return true;
   }


   static bool f_preProc(const T & x, T & result) {
    fp_struct<T> xg(x);
    if((xg.exp == (1 << fp_struct<T>::EXP_BITS) - 2) ||
      ((xg.exp == (1 << fp_struct<T>::EXP_BITS) - 3) && xg.sig != 0)) {
     result = ::hls::copysign(static_cast<T>(0), x);
     return true;
    }
    return false;
   }

   static bool f_procOne(const T & x, T & result) {
    fp_struct<T> xg(x);
    fixed2Float<FxType, T>(1, fp_struct<T>::EXP_BIAS - xg.expv(), xg.sign, result);
    return true;
   }

   static void f_evalueA(TypeY yA, TypeA & A0) {
    A0 = yA - A0;
   }
   static void f_getM(int indexM, TypeMM &M0) {
    M0 = RTable<TypeMM, half, Trait<T>::LUTsize>::arrayR[indexM];

   }


   static void f_postProc(const T & x, TypeRe yR, T & result) {
    fp_struct<T> xg(x);
    yR <<= 1;
    fixed2Float(yR, fp_struct<T>::EXP_BIAS - xg.expv() - 1, xg.sign, result);
   }
 };


 template<typename T> class SqrtTrait {
  public:
   typedef ap_ufixed<fp_struct<T>::SIG_BITS + 1, 1> FxType;
   typedef ap_fixed<Trait<T>::n_bits - Trait<T>::k_bits + 1,
       -Trait<T>::k_bits + 1> TypeA;
   typedef ap_uint<Trait<T>::k_bits * 2> TypeP;
   typedef ap_fixed<1 + Trait<T>::n_bits - 2 * Trait<T>::k_bits,
       1 - 2 * Trait<T>::k_bits> TypeY;
   typedef typename Trait<T>::LUT_RType TypeR;
   typedef typename Trait<T>::LUT_MType TypeMM;
   typedef ap_ufixed<3 * Trait<T>::k_bits + 2, 1> TypeMT;
   typedef ap_uint<Trait<T>::k_bits * 2 + 1> TypeS;
   typedef ap_ufixed<1 + Trait<T>::n_bits, 1> TypeRe;

   static const int C_A22 = 1, C_A23 = 1, C_A222 = 1;
   static const int C_SHIFT = 1, A_SHIFT = 3;
   static const TypeRe SQRT2;

   static bool f_procInf(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign)
     return false;
    result = fp_struct<T>::infinity();
    return true;
   }

   static bool f_procZero(const T & x, T & result) {
    result = ::hls::copysign(static_cast<T>(0), x);
    return true;
   }

   static bool f_preProc(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign && xg.exp){
     result = ::hls::nan("");
     return true;
    }
    return false;
   }
   static bool f_procOne(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     fixed2Float(SQRT2, fp_struct<T>::EXP_BIAS + (xg.expv() >> 1), 0, result);
    else
     fixed2Float<FxType, T>(1, fp_struct<T>::EXP_BIAS + (xg.expv() >> 1), 0, result);
    return true;
   }

   static void f_evalueA(TypeY yA, TypeA & A0) {
    A0 = (A0 >> 1) - yA;
   }
   static void f_getM(int indexM, TypeMM &M0) {
    M0 = SqrtMTable<typename Trait<T>::LUT_MType,
      T, Trait<T>::LUTsize>::arrayM[indexM];
   }


   static void f_postProc(const T & x, TypeRe yR, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     yR *= SQRT2;
    fixed2Float(yR, fp_struct<T>::EXP_BIAS + (xg.expv() >> 1), 0, result);
   }
 };

 template<typename T> const ap_ufixed<1 + Trait<T>::n_bits, 1> SqrtTrait<T>::SQRT2 = 1.4142135623730950488016887242097;



 template<typename T> class RsqrtTrait {
  public:
   typedef ap_ufixed<fp_struct<T>::SIG_BITS + 1, 1> FxType;
   typedef ap_fixed<Trait<T>::n_bits - Trait<T>::k_bits + 1,
       -Trait<T>::k_bits + 1> TypeA;
   typedef ap_uint<Trait<T>::k_bits * 2 + 3> TypeP;
   typedef ap_fixed<1 + Trait<T>::n_bits - 2 * Trait<T>::k_bits,
       1 - 2 * Trait<T>::k_bits> TypeY;
   typedef typename Trait<T>::LUT_RType TypeR;
   typedef typename Trait<T>::LUT_MType TypeMM;
   typedef ap_ufixed<3 * Trait<T>::k_bits + 2, 1> TypeMT;
   typedef ap_uint<Trait<T>::k_bits * 2 + 3> TypeS;
   typedef ap_ufixed<1 + Trait<T>::n_bits, 1> TypeRe;

   static const int C_A22 = 3, C_A23 = 3, C_A222 = 5;
   static const int C_SHIFT = 1, A_SHIFT = 3;
   static const TypeRe SQRT2;

   static bool f_procInf(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign)
     return false;
    result = 0.0;
    return true;
   }

   static bool f_procZero(const T & x, T & result) {
    result = ::hls::copysign(fp_struct<T>::infinity(), x);
    return true;
   }

   static bool f_preProc(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign && xg.exp){
     result = ::hls::nan("");
     return true;
    }
    return false;
   }
   static bool f_procOne(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     fixed2Float(SQRT2, fp_struct<T>::EXP_BIAS - (xg.expv() >> 1) - 1, 0, result);
    else
     fixed2Float<FxType, T>(1, fp_struct<T>::EXP_BIAS - (xg.expv() >> 1), 0, result);
    return true;
   }

   static void f_evalueA(TypeY yA, TypeA & A0) {
    A0 = yA - (A0 >> 1);
   }

   static void f_getM(int indexM, TypeMM & M0) {
    M0 = RsqrtMTable<typename Trait<T>::LUT_MType,
      T, Trait<T>::LUTsize>::arrayM[indexM];
   }


   static void f_postProc(const T & x, TypeRe yR, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     yR *= SQRT2;
    else
     yR <<= 1;
    fixed2Float(yR, fp_struct<T>::EXP_BIAS - ((xg.expv() + 2) >> 1), 0, result);
   }
 };


 template<typename T> const ap_ufixed<1 + Trait<T>::n_bits, 1> RsqrtTrait<T>::SQRT2 = 1.4142135623730950488016887242097;

 template<typename T, typename FUN>
  T proc_generic(T x) {
   fp_struct<T> xg(x);
   T result;

   if (::hls::__isnan(x)) {
    return ::hls::nan("");
   }

   if(::hls::__isinf(x) && FUN::f_procInf(x, result)) {
    return result;
   }

   if (xg.exp == 0 && FUN::f_procZero(x, result)) {
    return result;
   }

   if(FUN::f_preProc(x, result))
    return result;

   if (xg.sig == 0 && FUN::f_procOne(x, result)) {
    return result;
   }


   typename FUN::FxType y = 0;
   y[y.wl() - y.iwl()] = 1;
   y(y.wl() - 1 - y.iwl(), y.wl() - y.iwl() - fp_struct<T>::SIG_BITS) = xg.sig;


   int indexR = y(y.wl() - y.iwl() - 1, y.wl() - y.iwl() - Trait<T>::k_bits);
   typename FUN::TypeR R0 = RTable<typename FUN::TypeR,
        T, Trait<T>::LUTsize>::arrayR[indexR];


   typename FUN::TypeA A0, Ap;
   if (indexR == 0) {
    A0 = y - 1;
   } else
    A0 = y * R0 - 1;

   bool sign_bit = false;
   if (A0[A0.wl() - 1]) {
    Ap = -A0;
    sign_bit = true;
   } else
    Ap = A0;
   ap_uint<Trait<T>::k_bits> A2, A3;
   A2=Ap(Ap.wl() - 2, Ap.wl() - Trait<T>::k_bits - 1);
   A3=Ap(Ap.wl() - Trait<T>::k_bits - 2, Ap.wl() - Trait<T>::k_bits * 2 - 1);
   typename FUN::TypeP A22 = A2 * A2, A23 = A2 * A3,
        A222 = static_cast<ap_uint<Trait<T>::k_bits> >(A22 >> Trait<T>::k_bits) * A2;

   A22 *= FUN::C_A22;
   A23 *= FUN::C_A23;
   A222 *= FUN::C_A222;

   typename FUN::TypeS Asum;
   if (sign_bit) {
    Asum = A22 + (A23 >> (Trait<T>::k_bits - 1)) + (A222 >> (Trait<T>::k_bits + FUN::C_SHIFT));
   } else {
    Asum = A22 + (A23 >> (Trait<T>::k_bits - 1)) - (A222 >> (Trait<T>::k_bits + FUN::C_SHIFT));
   }
   typename FUN::TypeY yA = 0;
   yA(Trait<T>::k_bits * 2, 0) = Asum >> FUN::A_SHIFT;
   FUN::f_evalueA(yA, A0);

   typename FUN::TypeMM M0 = R0;
   typename FUN::TypeRe yR;
   if(indexR == 0)
    yR = A0 + 1;
   else {
    FUN::f_getM(indexR, M0);
    yR = A0 * static_cast<typename FUN::TypeMT>(M0);
    yR += M0;
   }

   FUN::f_postProc(x, yR, result);
   return result;
  }


 template<typename T> static T recip(T x) {
  return proc_generic<T, RecipTrait<T> >(x);
 }
 static half half_recip(half x) {
  return recip<half>(x);
 }

 template<typename T> static T sqrt(T x) {
  return proc_generic<T, SqrtTrait<T> >(x);
 }
 static half half_sqrt(half x) {
  return sqrt<half>(x);
 }

 template<typename T> static T rsqrt(T x) {
  return proc_generic<T, RsqrtTrait<T> >(x);
 }
 static half half_rsqrt(half x) {
  return rsqrt<half>(x);
 }


}
#718 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h"
template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
ap_ufixed<W,I> sqrt(ap_ufixed<W,I, _AP_Q, _AP_O> x) {
    ((I >= 0 && "Number of integer bits for sqrt() must be greater than zero") ? static_cast<void> (0) : __assert_fail ("I >= 0 && \"Number of integer bits for sqrt() must be greater than zero\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 41, __PRETTY_FUNCTION__));
    ((W >= I && "Number of integer bits for sqrt() must be less than or equal to total width") ? static_cast<void> (0) : __assert_fail ("W >= I && \"Number of integer bits for sqrt() must be less than or equal to total width\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 42, __PRETTY_FUNCTION__));
    ap_ufixed<W+1,I> factor = 0;
    int offset;



    if(I%2 == 0) {
        offset = 1;
    } else {
        offset = 0;
    }
    factor[W+1 -1-offset] = 1;
    ap_ufixed<W+1 +1,I+1> result = 0;
    ap_ufixed<W+1 +2,I+2> x2 = x;
    for(int i = W+1 -offset; i > (I-1)/2; i -= 1 ) {

        ap_ufixed<W+2+1,I+2> t = (result << 1) + factor;

        ap_ufixed<W+1,I> thisfactor = 0;
        if(x2 >= t) {
            x2 -= t;
            thisfactor = factor;
        }
        result = result + thisfactor;
        factor >>= 1;
        x2 <<= 1;
    }

    return result >> ((I-1) >> 1);

}

template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
ap_fixed<W,I> sqrt(ap_fixed<W,I, _AP_Q, _AP_O> x) {
    ap_ufixed<W-1,I-1> x2 = x;
    if(x < 0) return 0; else return ::hls::sqrt(x2);
}


template <typename T>
class cbrt_traits {};

template <> class cbrt_traits<half>
{
public:
    static ap_uint<2> exp_cbrt ( ap_uint<5> &exp ) {



 ap_uint<1> r_0; {r_0 = (exp[0]) ? 1 : 0;}
        ap_uint<2> r_1; {r_1 = (exp[1]) ? 2 : 0;}
        ap_uint<1> r_2; {r_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> r_3; {r_3 = (exp[3]) ? 2 : 0;}
        ap_uint<1> r_4; {r_4 = (exp[4]) ? 1 : 0;}
 ap_uint<3> r_l = r_0 + r_1 + r_2 + r_3 + r_4;




 ap_uint<2> exp_r;
 ap_uint<2> r;
 exp_r[1] = ( r_l[2] & r_l[1] );
 exp_r[0] = ( r_l[1] & r_l[0] ) | ( r_l[2] & ~r_l[1] );
     r[1] = ( ~r_l[2] & ~r_l[0] ) | ( r_l[2] & r_l[0] );
     r[0] = ( ~r_l[2] & ~r_l[1] ) | ( ~r_l[1] & ~r_l[0] );
 ((r < 3) ? static_cast<void> (0) : __assert_fail ("r < 3", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 107, __PRETTY_FUNCTION__));
 ((r_l = exp_r * 3 + r) ? static_cast<void> (0) : __assert_fail ("r_l = exp_r * 3 + r", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 108, __PRETTY_FUNCTION__));


        ap_uint<1> exp_2; {exp_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> exp_3; {exp_3 = (exp[3]) ? 2 : 0;}
        ap_uint<3> exp_4; {exp_4 = (exp[4]) ? 5 : 0;}


 exp = exp_r + exp_2 + exp_3 + exp_4 + 10;

 return r;
    }
};

template <> class cbrt_traits<float>
{
public:
    static ap_uint<2> exp_cbrt ( ap_uint<8> &exp ) {



 ap_uint<1> r_0; {r_0 = (exp[0]) ? 1 : 0;}
        ap_uint<2> r_1; {r_1 = (exp[1]) ? 2 : 0;}
        ap_uint<1> r_2; {r_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> r_3; {r_3 = (exp[3]) ? 2 : 0;}
        ap_uint<1> r_4; {r_4 = (exp[4]) ? 1 : 0;}
        ap_uint<2> r_5; {r_5 = (exp[5]) ? 2 : 0;}
        ap_uint<1> r_6; {r_6 = (exp[6]) ? 1 : 0;}
        ap_uint<2> r_7; {r_7 = (exp[7]) ? 2 : 0;}
 ap_uint<4> r_l = r_0 + r_1 + r_2 + r_3 + r_4 + r_5 + r_6 + r_7;




 ap_uint<2> exp_r;
 ap_uint<2> r;
 exp_r[1] = ( r_l[2] & r_l[1] & r_l[0] ) | ( r_l[3] );
 exp_r[0] = ( r_l[2] & ~r_l[1] ) | ( r_l[2] & r_l[1] & ~r_l[0] ) | ( r_l[3] & r_l[1] );
     r[1] = ( ~r_l[3] & ~r_l[2] & r_l[1] & r_l[0] ) | ( r_l[2] & r_l[1] & ~r_l[0] ) | ( r_l[3] & ~r_l[1] & r_l[0] );
     r[0] = ( ~r_l[3] & ~r_l[2] & ~r_l[0] ) | ( r_l[2] & ~r_l[1] & r_l[0] ) |
     ( ~r_l[2] & ~r_l[1] & ~r_l[0] ) | ( r_l[3] & r_l[1] & r_l[0] );
 ((r < 3) ? static_cast<void> (0) : __assert_fail ("r < 3", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 149, __PRETTY_FUNCTION__));
        ((r_l = exp_r * 3 + r + 1) ? static_cast<void> (0) : __assert_fail ("r_l = exp_r * 3 + r + 1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 150, __PRETTY_FUNCTION__));


 ap_uint<1> exp_2; {exp_2 = (exp[2]) ? 1 : 0;}
 ap_uint<2> exp_3; {exp_3 = (exp[3]) ? 2 : 0;}
 ap_uint<3> exp_4; {exp_4 = (exp[4]) ? 5 : 0;}
        ap_uint<4> exp_5; {exp_5 = (exp[5]) ? 10 : 0;}
        ap_uint<5> exp_6; {exp_6 = (exp[6]) ? 21 : 0;}
        ap_uint<6> exp_7; {exp_7 = (exp[7]) ? 42 : 0;}


 exp = exp_r + exp_2 + exp_3 + exp_4 + exp_5 + exp_6 + exp_7 + 85;

 return r;
    }
};

template <> class cbrt_traits<double>
{
public:
    static ap_uint<2> exp_cbrt ( ap_uint<11> &exp ) {



 ap_uint<1> r_0; {r_0 = (exp[0]) ? 1 : 0;}
        ap_uint<2> r_1; {r_1 = (exp[1]) ? 2 : 0;}
        ap_uint<1> r_2; {r_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> r_3; {r_3 = (exp[3]) ? 2 : 0;}
        ap_uint<1> r_4; {r_4 = (exp[4]) ? 1 : 0;}
        ap_uint<2> r_5; {r_5 = (exp[5]) ? 2 : 0;}
        ap_uint<1> r_6; {r_6 = (exp[6]) ? 1 : 0;}
        ap_uint<2> r_7; {r_7 = (exp[7]) ? 2 : 0;}
        ap_uint<1> r_8; {r_8 = (exp[8]) ? 1 : 0;}
        ap_uint<2> r_9; {r_9 = (exp[9]) ? 2 : 0;}
        ap_uint<1> r_10; {r_10 = (exp[10]) ? 1 : 0;}
 ap_uint<4> r_l = r_0 + r_1 + r_2 + r_3 + r_4 + r_5 + r_6 + r_7 + r_8 + r_9 + r_10;




 ap_uint<3> exp_r;
 ap_uint<2> r;
 exp_r[2] = ( r_l[3] & r_l[2] );
 exp_r[1] = ( ~r_l[3] & r_l[2] & r_l[1] ) | ( r_l[3] & ~r_l[2] );
 exp_r[0] = ( ~r_l[3] & ~r_l[2] & r_l[1] & r_l[0] ) | ( ~r_l[3] & r_l[2] & ~r_l[1] ) | ( r_l[3] & ~r_l[2] & ~r_l[1] & r_l[0] ) |
     ( r_l[3] & ~r_l[2] & r_l[1] ) | ( r_l[3] & r_l[2] & r_l[1] & r_l[0] );
     r[1] = ( ~r_l[3] & ~r_l[2] & ~r_l[0] ) | ( ~r_l[3] & r_l[2] & ~r_l[1] & r_l[0] ) | ( ~r_l[2] & ~r_l[1] & ~r_l[0] ) |
     ( r_l[3] & ~r_l[2] & r_l[1] & r_l[0] ) | ( r_l[3] & r_l[2] & r_l[1] & ~r_l[0] );
     r[0] = ( ~r_l[3] & ~r_l[2] & ~r_l[1] ) | ( ~r_l[3] & ~r_l[1] & ~r_l[0] ) | ( ~r_l[3] & r_l[2] & r_l[1] & r_l[0] ) |
     ( r_l[3] & ~r_l[2] & r_l[1] & ~r_l[0] ) | ( r_l[3] & r_l[2] & ~r_l[1] & r_l[0] );
        ((r < 3) ? static_cast<void> (0) : __assert_fail ("r < 3", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 200, __PRETTY_FUNCTION__));
        ((r_l = exp_r * 3 + r) ? static_cast<void> (0) : __assert_fail ("r_l = exp_r * 3 + r", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 201, __PRETTY_FUNCTION__));


 ap_uint<1> exp_2; {exp_2 = (exp[2]) ? 1 : 0;}
 ap_uint<2> exp_3; {exp_3 = (exp[3]) ? 2 : 0;}
 ap_uint<3> exp_4; {exp_4 = (exp[4]) ? 5 : 0;}
        ap_uint<4> exp_5; {exp_5 = (exp[5]) ? 10 : 0;}
        ap_uint<5> exp_6; {exp_6 = (exp[6]) ? 21 : 0;}
        ap_uint<6> exp_7; {exp_7 = (exp[7]) ? 42 : 0;}
        ap_uint<7> exp_8; {exp_8 = (exp[8]) ? 85 : 0;}
        ap_uint<8> exp_9; {exp_9 = (exp[9]) ? 170 : 0;}
        ap_uint<9> exp_10; {exp_10 = (exp[10]) ? 341 : 0;}


 exp = exp_r + exp_2 + exp_3 + exp_4 + exp_5 + exp_6 + exp_7 + exp_8 + exp_9 + exp_10 + 682;

 return r;
    }
};

template <typename T>
T cbrt_generic(T x)
{
#pragma HLS pipeline

        fp_struct<T> xs(x);





    if ( xs.exp == 0 ) xs.sig = 0;
    if ( ( xs.exp == 0 ) || ( xs.exp == fp_struct<T>::EXP_INFNAN ) ) return xs.to_ieee();


        const static int we = fp_struct<T>::EXP_BITS;
        const static int wf = fp_struct<T>::SIG_BITS;

        fp_struct<T> out;
        out.sign[0] = xs.sign[0];

    ap_uint<we> x_exp = xs.exp;
    ap_uint<2> r = cbrt_traits<T>::exp_cbrt(x_exp);
    const static int prcs = (wf+1)*3;
    ap_ufixed<4 + prcs, 4> x_frac = 0;
    x_frac[x_frac.wl()-x_frac.iwl()] = 1;
    x_frac(x_frac.wl()-x_frac.iwl()-1,x_frac.wl()-x_frac.iwl()-wf) = xs.sig(wf-1,0);
    if (r[1] | r[0]) x_frac <<= 1;
    if (r[1]) x_frac <<= 1;

    ap_ufixed<3,3> x_frac_i;
    x_frac_i ( 2 , 0 ) = x_frac ( x_frac.wl()-2 , x_frac.wl()-x_frac.iwl() );
    x_frac_i -= 1;
    x_frac ( x_frac.wl()-2 , x_frac.wl()-x_frac.iwl() ) = x_frac_i ( 2 , 0 );

    ap_ufixed<1 + prcs, 1> res = 1;
    ap_ufixed<2 + prcs, 2> resq = 1;
#pragma unroll



    for ( int pos = -1; pos >= -wf-1; pos-- ) {
 ap_ufixed<2 + prcs, 2> mul1a = 0;
 ap_ufixed<1 + prcs, 1> mul1b = 0;
 ((resq(pos*2+1+prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("resq(pos*2+1+prcs,0)==0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 265, __PRETTY_FUNCTION__));
 mul1a ( pos+2 + prcs , pos*3+3 + prcs ) = resq ( 1 + prcs , pos*2+2 + prcs );
 mul1b ( pos+1 + prcs , pos*3+2 + prcs ) = resq ( 1 + prcs , pos*2+2 + prcs );

 ap_ufixed< 0 + prcs, 0> mul2a = 0;
 ap_ufixed<-1 + prcs, -1> mul2b = 0;
 ((res(pos+prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("res(pos+prcs,0)==0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 271, __PRETTY_FUNCTION__));
 mul2a ( pos*2+1 + prcs , pos*3+2 + prcs ) = res ( 0 + prcs , pos+1 + prcs );
 mul2b ( pos*2 + prcs , pos*3+1 + prcs ) = res ( 0 + prcs , pos+1 + prcs );







        ap_ufixed<3 + prcs, 3> mulH = 0;
        ap_ufixed<3 + prcs, 3> mulL = 0;
 mulL ( pos*2+3 + prcs , pos*3+1 + prcs ) = mul1a ( pos*2+1 + prcs , pos*3+1 + prcs ) + mul1b ( pos*2+1 + prcs , pos*3+1 + prcs ) +
                                                   mul2a ( pos*2+1 + prcs , pos*3+1 + prcs ) + mul2b ( pos*2 + prcs , pos*3+1 + prcs );
 mulH ( pos +3 + prcs , pos*2+2 + prcs ) = mul1a ( pos +2 + prcs , pos*2+2 + prcs ) + mul1b ( pos +1 + prcs , pos*2+2 + prcs ) +
                                                   mulL ( pos*2+3 + prcs , pos*2+2 + prcs );



 mulL [ pos*3 + prcs ] = 1;

 (((pos>=-2) || (x_frac(2+prcs,pos+5+prcs)==0)) ? static_cast<void> (0) : __assert_fail ("(pos>=-2) || (x_frac(2+prcs,pos+5+prcs)==0)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 292, __PRETTY_FUNCTION__));
 bool cond1 = ( x_frac ( pos +4 + prcs , pos*2+2 + prcs ) > mulH ( pos +3 + prcs, pos*2+2 + prcs ) );
 bool cond2 = ( x_frac ( pos +4 + prcs , pos*2+2 + prcs ) == mulH ( pos +3 + prcs, pos*2+2 + prcs ) );
 bool cond3 = ( x_frac ( pos*2+1 + prcs , pos*3 + prcs ) >= mulL ( pos*2+1 + prcs, pos*3 + prcs ) );

 if ( cond1 | ( cond2 & cond3 ) ) {




     ap_ufixed<4 + prcs, 4> x_frac_L = 0;
     x_frac_L ( pos*2+1 + prcs , pos*3 + prcs ) = x_frac ( pos*2+1 + prcs , pos*3 + prcs );
     x_frac_L [ pos*2+2 + prcs ] = cond3 ? 0 : 1;
     x_frac ( pos+4 + prcs , pos*2+2 + prcs ) = x_frac ( pos +4 + prcs , pos*2+2 + prcs )
          - mulH ( pos +3 + prcs , pos*2+2 + prcs )
          - x_frac_L ( pos*2+2 + prcs , pos*2+2 + prcs );
     x_frac ( pos*2+1 + prcs , pos*3 + prcs ) = x_frac_L ( pos*2+2 + prcs , pos*3 + prcs )
          - mulL ( pos*2+1 + prcs , pos*3 + prcs );


     ap_ufixed<1 + prcs, 1> mul3 = 0;
     ((res(pos+prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("res(pos+prcs,0)==0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 313, __PRETTY_FUNCTION__));
     ((resq(pos*2+1+prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("resq(pos*2+1+prcs,0)==0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_sqrt.h", 314, __PRETTY_FUNCTION__));
     mul3 ( pos+1 + prcs , pos*2+2 + prcs ) = res ( 0 + prcs , pos+1 + prcs );

     ap_ufixed<2 + prcs, 2> resq_L = 0;
     resq_L ( pos+2 + prcs , pos*2+2 + prcs ) = resq ( pos+1 + prcs , pos*2+2 + prcs ) + mul3 ( pos+1 + prcs , pos*2+2 + prcs );
     resq ( pos+1 + prcs , pos*2+2 + prcs ) = resq_L ( pos+1 + prcs , pos*2+2 + prcs );
     resq ( 1 + prcs , pos +2 + prcs ) = resq ( 1 + prcs , pos +2 + prcs ) + resq_L ( pos+2 + prcs , pos +2 + prcs );
     resq [ pos*2 + prcs ] = 1;
            res [ pos + prcs ] = 1;
 }
    }

    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+1, 2> res_s = res;
    res_s += delta;

    if ( res_s[res_s.wl()-1] == 1 ) {
        x_exp++;
 res_s >>= 1;
    }

    out.exp = x_exp;
    out.sig(wf-1,0) = res_s(res_s.wl()-res_s.iwl()-1,res_s.wl()-res_s.iwl()-wf);
    return out.to_ieee();

}

static double hypot(double x, double y) {
    if ( ::hls::__isinf(x) )
 return fabs(x);
    if ( ::hls::__isinf(y) )
 return fabs(y);
    return ::xil_fpo_sqrt_d(x*x+y*y);
}
static float hypotf(float x, float y) {
    if ( ::hls::__isinf(x) )
        return fabs(x);
    if ( ::hls::__isinf(y) )
        return fabs(y);
    double xd = x;
    double yd = y;
    return ::xil_fpo_sqrt_d(xd*xd+yd*yd);
}
static half half_hypot(half x, half y) {
    if ( ::hls::__isinf(x) )
        return fabs(x);
    if ( ::hls::__isinf(y) )
        return fabs(y);
    float xf = x;
    float yf = y;
    return ::xil_fpo_sqrt_flt(xf*xf+yf*yf);
}
#719 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
static double sqrt(double x) {
    return ::xil_fpo_sqrt_d(x);
}
static float sqrtf(float x) {
    return ::xil_fpo_sqrt_flt(x);
}
static half half_sqrt(half x) {
    return hls::hls_rsr::half_sqrt(x);
}


static half half_recip(half x) {
    return hls::hls_rsr::half_recip(x);
}
static half half_rsqrt(half x) {
    return hls::hls_rsr::half_rsqrt(x);
}

static half cbrt(half x) {
 return hls::cbrt_generic(x);
}
static float cbrt(float x) {
 return hls::cbrt_generic(x);
}
static double cbrt(double x) {
 return hls::cbrt_generic(x);
}
static float cbrtf(float x) {
 return hls::cbrt_generic(x);
}
static half half_cbrt(half x) {
 return hls::cbrt_generic(x);
}

static half hypot(half x, half y) {
        return hls::half_hypot(x,y);
}
static float hypot(float x, float y) {
        return hls::hypotf(x,y);
}
#783 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h"
static double recip(double x)
{
    return xil_fpo_rec_d(x);
}

static float recipf(float x)
{
    return xil_fpo_rec_flt(x);
}

static double rsqrt(double x)
{
    return xil_fpo_recsqrt_d(x);
}

static float rsqrtf(float x)
{
    return xil_fpo_recsqrt_flt(x);
}


#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_asin_acos.h" 1
#27 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_asin_acos.h"
namespace asin_acos_approx{
static float asin(float x)
{
    static const float
    one = 1.0000000000e+00,
    huge = 1.000e+30,

    pio2_hi = 1.57079637050628662109375f,
    pio2_lo = -4.37113900018624283e-8f,
    pio4_hi = 0.785398185253143310546875f,




    p0 = 1.666675248e-1f,
    p1 = 7.495297643e-2f,
    p2 = 4.547037598e-2f,
    p3 = 2.417951451e-2f,
    p4 = 4.216630880e-2f;


    if(fpclassify(x) == 3)
        x = 0.0f;

 float t,w,p,q,c,r,s;
 int32_t hx,ix;

    fp_struct<float> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(31,0);
    hx = tmp.to_int();
 ix = hx&0x7fffffff;
 if(ix==0x3f800000) {

     return x*pio2_hi+x*pio2_lo;
 } else if(ix> 0x3f800000) {
     return (x-x)/(x-x);
 } else if (ix<0x3f000000) {
     if(ix<0x32000000) {
  if(huge+x>one) return x;
     } else {
  t = x*x;
  w = t * (p0 + t * (p1 + t * (p2 + t * (p3 + t * p4))));
  return x+x*w;
     }
 }

 w = one-fabsf(x);
 t = w*0.5f;
 p = t * (p0 + t * (p1 + t * (p2 + t * (p3 + t * p4))));

 s = sqrtf(t);
 if(ix>=0x3F79999A) {
     t = pio2_hi-(2.0f*(s+s*p)-pio2_lo);
 } else {

     w = s;


        fp_struct<float> fp_w(w);
        ap_uint<Type_BitWidth<float>::Value> data = fp_w.data() & 0xfffff000;
        fp_struct<float> fp_w_new(data);
        w = fp_w_new.to_ieee();
     c = (t-w*w)/(s+w);
     r = p;
     p = 2.0f*s*r-(pio2_lo-2.0f*c);
     q = pio4_hi-2.0f*w;
     t = pio4_hi-(p-q);
 }
 if(hx>0) return t; else return -t;
}

static float acos(float x)
{
    static const float
    one = 1.0000000000e+00,
    pi = 3.1415925026e+00,
    pio2_hi = 1.5707962513e+00,
    pio2_lo = 7.5497894159e-08,
    pS0 = 1.6666667163e-01,
    pS1 = -3.2556581497e-01,
    pS2 = 2.0121252537e-01,
    pS3 = -4.0055535734e-02,
    pS4 = 7.9153501429e-04,
    pS5 = 3.4793309169e-05,
    qS1 = -2.4033949375e+00,
    qS2 = 2.0209457874e+00,
    qS3 = -6.8828397989e-01,
    qS4 = 7.7038154006e-02;

 float z,p,q,r,w,s,c,df;
 int32_t hx,ix;

    fp_struct<float> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(31,0);
    hx = tmp.to_int();
 ix = hx&0x7fffffff;
 if(ix==0x3f800000) {
     if(hx>0) return 0.0;
     else return pi+(float)2.0*pio2_lo;
 } else if(ix>0x3f800000) {
     return (x-x)/(x-x);
 }
 if(ix<0x3f000000) {
     if(ix<=0x23000000) return pio2_hi+pio2_lo;
     z = x*x;
     p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
     q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
     r = p/q;
     return pio2_hi - (x - (pio2_lo-x*r));
 } else if (hx<0) {
     z = (one+x)*(float)0.5;
     p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
     q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
     s = sqrtf(z);
     r = p/q;
     w = r*s-pio2_lo;
     return pi - (float)2.0*(s+w);
 } else {

     z = (one-x)*(float)0.5;
     s = sqrtf(z);
     df = s;


        fp_struct<float> fp_df(df);
        ap_uint<Type_BitWidth<float>::Value> data = fp_df.data() & 0xfffff000;
        fp_struct<float> fp_df_new(data);
        df = fp_df_new.to_ieee();
     c = (z-df*df)/(s+df);
     p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
     q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
     r = p/q;
     w = r*s+c;
     return (float)2.0*(df+w);
 }
}



static volatile const double Infinity = (__builtin_inff());
static volatile const double Tiny = 0x1p-1022;

typedef struct { double d0, d1; } double2;


static inline double2 Mul112(double a, double b)
{
 static const double c = 0x1p27 + 1;

 double
  ap = a * c, bp = b * c,
  a0 = (a-ap)+ap, b0 = (b-bp)+bp,
  a1 = a - a0, b1 = b - b0,
  d0 = a * b,
  d1 = a0*b0 - d0 + a0*b1 + a1*b0 + a1*b1;
 return (double2) { d0, d1 };
}



static inline double2 Add212RightSmaller(double2 a, double b)
{
 double
  c0 = a.d0 + b,
  c1 = a.d0 - c0 + b + a.d1,
  d0 = c0 + c1,
  d1 = c0 - d0 + c1;
 return (double2) { d0, d1 };
}





static inline double Add221RightSmaller(double2 a, double2 b)
{
 double
  c0 = a.d0 + b.d0,
  c1 = a.d0 - c0 + b.d0 + b.d1 + a.d1,
  d0 = c0 + c1;
 return d0;
}





static inline double Mul121Special(double a, double2 b)
{
 static const double c = 0x1p27 + 1;

 double
  ap = a * c, bp = b.d0 * c,
  a0 = (a-ap)+ap, b0 = (b.d0-bp)+bp,
  a1 = a - a0, b1 = b.d0 - b0,
  m1 = a0*b0 - 1 + a0*b1 + a1*b0 + a1*b1 + a*b.d1;
 return m1;
}



static inline double2 Mul222(double2 a, double2 b)
{
 static const double c = 0x1p27 + 1;

 double
  ap = a.d0 * c, bp = b.d0 * c,
  a0 = (a.d0-ap)+ap, b0 = (b.d0-bp)+bp,
  a1 = a.d0 - a0, b1 = b.d0 - b0,
  m0 = a.d0 * b.d0,
  m1 = a0*b0 - m0 + a0*b1 + a1*b0 + a1*b1 + (a.d0*b.d1 + a.d1*b.d0),
  d0 = m0 + m1,
  d1 = m0 - d0 + m1;
 return (double2) { d0, d1 };
}



static inline double2 Add112RightSmaller(double a, double b)
{
 double d0 = a + b, d1 = b - (d0 - a);
 return (double2) { d0, d1 };
}





static inline double Sub211RightSmaller(double2 a, double b)
{
 double
  c0 = a.d0 - b,
  c1 = a.d0 - c0 - b + a.d1,
  d0 = c0 + c1;
 return d0;
}





static inline double Sub221RightSmaller(double2 a, double2 b)
{
 double
  c0 = a.d0 - b.d0,
  c1 = a.d0 - c0 - b.d0 - b.d1 + a.d1,
  d0 = c0 + c1;
 return d0;
}



static inline double Mul221(double2 a, double2 b)
{
 static const double c = 0x1p27 + 1;

 double
  ap = a.d0 * c, bp = b.d0 * c,
  a0 = (a.d0-ap)+ap, b0 = (b.d0-bp)+bp,
  a1 = a.d0 - a0, b1 = b.d0 - b0,
  m0 = a.d0 * b.d0,
  m1 = a0*b0 - m0 + a0*b1 + a1*b0 + a1*b1 + (a.d0*b.d1 + a.d1*b.d0),
  d0 = m0 + m1;
 return d0;
}



static double Center(double x)
{
 if (-0x1.7137449123ef5p-26 <= x && x <= +0x1.7137449123ef5p-26)
  return -0x1p-1022 < x && x < +0x1p-1022

   ? x - x*x

   : x * (Tiny + 1);

 static const double p03 = 0.1666666666666558995379880;
 static const double p05 = 0.0750000000029696112392353;
 static const double p07 = 0.0446428568582815922683933;
 static const double p09 = 0.0303819580081956423799529;
 static const double p11 = 0.0223717830666671020710108;
 static const double p13 = 0.0173593516996479249428647;
 static const double p15 = 0.0138885410156894774969889;
 static const double p17 = 0.0121483892822292648695383;
 static const double p19 = 0.0066153165197009078340075;
 static const double p21 = 0.0192942786775238654913582;
 static const double p23 = -0.0158620440988475212803145;
 static const double p25 = 0.0316658385792867081040808;


 double x2 = x * x;

 return ((((((((((((
  + p25) * x2
  + p23) * x2
  + p21) * x2
  + p19) * x2
  + p17) * x2
  + p15) * x2
  + p13) * x2
  + p11) * x2
  + p09) * x2
  + p07) * x2
  + p05) * x2
  + p03) * x2 * x + x;
}



static double Tail(double x)
{
 if (1 <= x)
  return 1 == x

   ? 0x3.243f6a8885a308d313198a2e03707344ap-1 + Tiny

   : Infinity - Infinity;

 static const double p01 = 0.2145993335526539017488949;
 static const double p02 = -0.0890259194305537131666744;
 static const double p03 = 0.0506659694457588602631748;
 static const double p04 = -0.0331919619444009606270380;
 static const double p05 = 0.0229883479552557203133368;
 static const double p06 = -0.0156746038587246716524035;
 static const double p07 = 0.0097868293573384001221447;
 static const double p08 = -0.0052049731575223952626203;
 static const double p09 = 0.0021912255981979442677477;
 static const double p10 = -0.0006702485124770180942917;
 static const double p11 = 0.0001307564187657962919394;
 static const double p12 = -0.0000121189820098929624806;

 double polynomial = ((((((((((((
  + p12) * x
  + p11) * x
  + p10) * x
  + p09) * x
  + p08) * x
  + p07) * x
  + p06) * x
  + p05) * x
  + p04) * x
  + p03) * x
  + p02) * x
  + p01) * x;

  static const double2
   HalfPi = { 0x1.921fb54442d18p+0, 0x1.1a62633145c07p-54 },
   p00 = { -0x1.921fb31e97d96p0, +0x1.eab77149ad27cp-54 };


  double e = 1 / sqrt(1-x);

  double2 ex = Mul112(e, 1-x);
  double e2x = Mul121Special(e, ex);


  double2 t0 = Add212RightSmaller(ex, ex.d0 * -.5 * e2x);


  return Add221RightSmaller(HalfPi, Mul222(
   t0,
   Add212RightSmaller(p00, polynomial)));
}


static double Center_acos(double x)
{
 static const double
  HalfPi = 0x3.243f6a8885a308d313198a2e03707344ap-1;




 if (-0x1.8d313198a2e03p-53 <= x && x <= +0x1.8d313198a2e03p-53)
  return HalfPi + Tiny;

 static const double p03 = + .1666666666666251331848183;
 static const double p05 = + .7500000000967090522908427e-1;
 static const double p07 = + .4464285630020156622713320e-1;
 static const double p09 = + .3038198238851575770651788e-1;
 static const double p11 = + .2237115216935265224962544e-1;
 static const double p13 = + .1736953298172084894468665e-1;
 static const double p15 = + .1378527665685754961528021e-1;
 static const double p17 = + .1277870997666947910124296e-1;
 static const double p19 = + .4673473145155259234911049e-2;
 static const double p21 = + .1951350766744288383625404e-1;


 double x2 = x * x;

 return HalfPi - (((((((((((
  + p21) * x2
  + p19) * x2
  + p17) * x2
  + p15) * x2
  + p13) * x2
  + p11) * x2
  + p09) * x2
  + p07) * x2
  + p05) * x2
  + p03) * x2 * x + x);
}



static double Gap_acos(double x)
{
 static const double p03 = + .1666666544260252354339083;
 static const double p05 = + .7500058936188719422797382e-1;
 static const double p07 = + .4462999611462664666589096e-1;
 static const double p09 = + .3054999576148835435598555e-1;
 static const double p11 = + .2090953485621966528477317e-1;
 static const double p13 = + .2626916834046217573905021e-1;
 static const double p15 = - .2496419961469848084029243e-1;
 static const double p17 = + .1336320190979444903198404;
 static const double p19 = - .2609082745402891409913617;
 static const double p21 = + .4154485118940996442799104;
 static const double p23 = - .3718481677216955169129325;
 static const double p25 = + .1791132167840254903934055;


 double x2 = x * x;

 double poly = ((((((((((((
  + p25) * x2
  + p23) * x2
  + p21) * x2
  + p19) * x2
  + p17) * x2
  + p15) * x2
  + p13) * x2
  + p11) * x2
  + p09) * x2
  + p07) * x2
  + p05) * x2
  + p03) * x2 * x;

  static const double2
   HalfPi = { 0x1.921fb54442d18p+0, 0x1.1a62633145c07p-54 };
  return Sub221RightSmaller(HalfPi, Add112RightSmaller(x, poly));
}



static double pTail_acos(double x)
{
 if (1 <= x)
  return 1 == x

   ? 0

   : Infinity - Infinity;

 static const double p01 = - .2145900291823555067724496;
 static const double p02 = + .8895931658903454714161991e-1;
 static const double p03 = - .5037781062999805015401690e-1;
 static const double p04 = + .3235271184788013959507217e-1;
 static const double p05 = - .2125492340970560944012545e-1;
 static const double p06 = + .1307107321829037349021838e-1;
 static const double p07 = - .6921689208385164161272068e-2;
 static const double p08 = + .2912114685670939037614086e-2;
 static const double p09 = - .8899459104279910976564839e-3;
 static const double p10 = + .1730883544880830573920551e-3;
 static const double p11 = - .1594866672026418356538789e-4;

 double t0 = (((((((((((
  + p11) * x
  + p10) * x
  + p09) * x
  + p08) * x
  + p07) * x
  + p06) * x
  + p05) * x
  + p04) * x
  + p03) * x
  + p02) * x
  + p01) * x;

  static const double2
   p00 = { 0x1.921fa926d2f24p0, +0x1.b4a23d0ecbb40p-59 };





  double e = 1 / sqrt(1-x);


  double2 ex = Mul112(e, 1-x);
  double e2x = Mul121Special(e, ex);
  double2 t1 = Add212RightSmaller(ex, ex.d0 * -.5 * e2x);


  return Mul221(t1, Add212RightSmaller(p00, t0));
}



static double nTail_acos(double x)
{
 if (x <= -1)
  return -1 == x

   ? 0x3.243f6a8885a308d313198a2e03707344ap0 + Tiny

   : Infinity - Infinity;

 static const double p00 = +1.5707956513160834076561054;
 static const double p01 = + .2145907003920708442108238;
 static const double p02 = + .8896369437915166409934895e-1;
 static const double p03 = + .5039488847935731213671556e-1;
 static const double p04 = + .3239698582040400391437898e-1;
 static const double p05 = + .2133501549935443220662813e-1;
 static const double p06 = + .1317423797769298396461497e-1;
 static const double p07 = + .7016307696008088925432394e-2;
 static const double p08 = + .2972670140131377611481662e-2;
 static const double p09 = + .9157019394367251664320071e-3;
 static const double p10 = + .1796407754831532447333023e-3;
 static const double p11 = + .1670402962434266380655447e-4;

 double poly = sqrt(1+x) * ((((((((((((
  + p11) * x
  + p10) * x
  + p09) * x
  + p08) * x
  + p07) * x
  + p06) * x
  + p05) * x
  + p04) * x
  + p03) * x
  + p02) * x
  + p01) * x
  + p00);

  static const double2
   Pi = { 0x1.921fb54442d18p+1, 0x1.1a62633145c07p-53 };
  return Sub211RightSmaller(Pi, poly);
}

static double asin(double x)
{

    if(fpclassify(x) == 3)
        x = 0.0;

    if ((x <= 0.5) && (x >= -0.5)) {
  return Center(x);
    } else {
        double x1;
        if (x < 0)
            x1 = -x;
        else
            x1 = x;
        double r = Tail(x1);
        if (x < 0)
            r = -r;

        return r;
    }
}


static double acos(double x)
{
 if (x < -.4)
  if (x < -.6)
   return nTail_acos(x);
  else
   return Gap_acos(x);
 else if (x <= +.4)
  return Center_acos(x);
 else
  if (x <= +.6)
   return Gap_acos(x);
  else
   return pTail_acos(x);
}

static half asin(half x)
{
    return asin((float)x);
}

static half acos(half x)
{
    return acos((float)x);
}

static float asinf(float x)
{
    return asin(x);
}

static float acosf(float x)
{
    return acos(x);
}

}
#805 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
static double asin(double x)
{
    return asin_acos_approx::asin(x);
}
static double acos(double x)
{
    return asin_acos_approx::acos(x);
}
static float asin(float x)
{
    return asin_acos_approx::asin(x);
}
static float acos(float x)
{
    return asin_acos_approx::acos(x);
}
static half asin(half x)
{
    return asin_acos_approx::asin(x);
}
static half acos(half x)
{
    return asin_acos_approx::acos(x);
}
static half half_asin(half x)
{
    return asin_acos_approx::asin(x);
}
static half half_acos(half x)
{
    return asin_acos_approx::acos(x);
}
static float asinf(float x)
{
    return asin_acos_approx::asinf(x);
}
static float acosf(float x)
{
    return asin_acos_approx::acosf(x);
}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h" 1
#37 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
namespace exp_reduce_ {

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_tables_.h" 1
#32 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_tables_.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/ap_fixed.h" 1
#33 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_tables_.h" 2
namespace {


template <typename T> class table_exp_Z1 {};


template <> class table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};


template <> class table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};


template <> class table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x1.000000000000000p0",
"0x1.0100802AB55777Dp0",
"0x1.0202015600445B0p0",
"0x1.0304848362076A0p0",
"0x1.04080AB55DE3917p0",
"0x1.050C94EF7A206DCp0",
"0x1.06122436410DD14p0",
"0x1.0718B98F42084EFp0",
"0x1.08205601127EC98p0",
"0x1.0928FA934EF9093p0",
"0x1.0A32A84E9C1F581p0",
"0x1.0B3D603CA7C3273p0",
"0x1.0C49236829E8BC2p0",
"0x1.0D55F2DCE5D1E96p0",
"0x1.0E63CFA7AB09D17p0",
"0x1.0F72BAD65671B69p0",
"0x1.1082B577D34ED7Dp0",
"0x1.1193C09C1C595C4p0",
"0x1.12A5DD543CCC4DDp0",
"0x1.13B90CB25176A4Cp0",
"0x1.14CD4FC989CD645p0",
"0x1.15E2A7AE28FECA6p0",
"0x1.16F91575870692Fp0",
"0x1.18109A3611C34FBp0",
"0x1.192937074E0CD68p0",
"0x1.1A42ED01D8CBC61p0",
"0x1.1B5DBD3F6812230p0",
"0x1.1C79A8DACC350DEp0",
"0x1.1D96B0EFF0E793Dp0",
"0x1.1EB4D69BDE569A3p0",
"0x1.1FD41AFCBA45E6Ep0",
"0x1.20F47F31C92E464p0",
"0x1.2216045B6F5CCF9p0",
"0x1.2338AB9B3213497p0",
"0x1.245C7613B8A9AF2p0",
"0x1.258164E8CDB0D82p0",
"0x1.26A7793F601642Bp0",
"0x1.27CEB43D844902Fp0",
"0x1.28F7170A755FD75p0",
"0x1.2A20A2CE964063Dp0",
"0x1.2B4B58B372C7950p0",
"0x1.2C7739E3C0F32BDp0",
"0x1.2DA4478B620C73Ep0",
"0x1.2ED282D763D424Dp0",
"0x1.3001ECF601AF700p0",
"0x1.31328716A5D63C2p0",
"0x1.32645269EA828F9p0",
"0x1.339750219B212A8p0",
"0x1.34CB8170B58352Dp0",
"0x1.3600E78B6B11D19p0",
"0x1.373783A7220124Fp0",
"0x1.386F56FA7686E62p0",
"0x1.39A862BD3C1065Fp0",
"0x1.3AE2A8287E7A804p0",
"0x1.3C1E2876834AA7Fp0",
"0x1.3D5AE4E2CAE92C8p0",
"0x1.3E98DEAA11DCBAAp0",
"0x1.3FD8170A520718Bp0",
"0x1.41188F42C3E320Fp0",
"0x1.425A4893DFC3F9Ep0",
"0x1.439D443F5F158EEp0",
"0x1.44E183883D9E498p0",
"0x1.462707B2BAC20DBp0",
"0x1.476DD2045AC678Dp0",
"0x1.48B5E3C3E818667p0",
"0x1.49FF3E397492BACp0",
"0x1.4B49E2AE5AC6746p0",
"0x1.4C95D26D3F44074p0",
"0x1.4DE30EC211E6013p0",
"0x1.4F3198FA0F1CF9Ep0",
"0x1.50817263C13CCF5p0",
"0x1.51D29C4F01CB308p0",
"0x1.5325180CFACF76Cp0",
"0x1.5478E6F02823D02p0",
"0x1.55CE0A4C58C7BB2p0",
"0x1.57248376B033D61p0",
"0x1.587C53C5A7AF027p0",
"0x1.59D57C910FA4DE7p0",
"0x1.5B2FFF3210FD957p0",
"0x1.5C8BDD032E7708Fp0",
"0x1.5DE9176045FF53Bp0",
"0x1.5F47AFA69210A75p0",
"0x1.60A7A734AB0E875p0",
"0x1.6208FF6A88A4614p0",
"0x1.636BB9A9832584Dp0",
"0x1.64CFD75454EE7BFp0",
"0x1.663559CF1BC7C5Ap0",
"0x1.679C427F5A49F39p0",
"0x1.690492CBF9432CFp0",
"0x1.6A6E4C1D491E179p0",
"0x1.6BD96FDD034A27Fp0",
"0x1.6D45FF764BA55B5p0",
"0x1.6EB3FC55B1E75B4p0",
"0x1.702367E9330E0DDp0",
"0x1.719443A03ACB928p0",
"0x1.730690EBA4F5ADFp0",
"0x1.747A513DBEF6A62p0",
"0x1.75EF860A493F8FBp0",
"0x1.776630C678BC0EDp0",
"0x1.78DE52E8F8478BBp0",
"0x1.7A57EDE9EA23DE3p0",
"0x1.7BD30342E9716FBp0",
"0x1.7D4F946F0BA8D6Ap0",
"0x1.7ECDA2EAE215EBFp0",
"0x1.804D30347B545CBp0",
"0x1.81CE3DCB64CDB88p0",
"0x1.8350CD30AC38FF6p0",
"0x1.84D4DFE6E11BAF5p0",
"0x1.865A7772164C541p0",
"0x1.87E19557E3769A2p0",
"0x1.896A3B1F66A0E69p0",
"0x1.8AF46A5145B3750p0",
"0x1.8C802477B000FDCp0",
"0x1.8E0D6B1E5FD0E54p0",
"0x1.8F9C3FD29BEAF6Bp0",
"0x1.912CA4233924AA7p0",
"0x1.92BE99A09BEFFB7p0",
"0x1.945221DCB9EBCBAp0",
"0x1.95E73E6B1B75D9Bp0",
"0x1.977DF0E0DD3E499p0",
"0x1.99163AD4B1DCC13p0",
"0x1.9AB01DDEE3671B6p0",
"0x1.9C4B9B995509B1Fp0",
"0x1.9DE8B59F84A1410p0",
"0x1.9F876D8E8C56650p0",
"0x1.A127C505243AB4Fp0",
"0x1.A2C9BDA3A3E77AAp0",
"0x1.A46D590C041E0A9p0",
"0x0.9B4597E37CB04FFp0",
"0x0.9BE12B381386EBAp0",
"0x0.9C7D5A6DE293099p0",
"0x0.9D1A262119177CBp0",
"0x0.9DB78EEE82D48C8p0",
"0x0.9E55957388A4C0Ep0",
"0x0.9EF43A4E311A4ACp0",
"0x0.9F937E1D211D0B1p0",
"0x0.A033617F9C89377p0",
"0x0.A0D3E51586CE9E3p0",
"0x0.A175097F63908A0p0",
"0x0.A216CF5E5746455p0",
"0x0.A2B9375427DC3EFp0",
"0x0.A35C42033D55D02p0",
"0x0.A3FFF00EA26FA4Ap0",
"0x0.A4A4421A0542C56p0",
"0x0.A54938C9B7E846Bp0",
"0x0.A5EED4C2B11D9A6p0",
"0x0.A69516AA8CE986Cp0",
"0x0.A73BFF278D41C26p0",
"0x0.A7E38EE09AB1365p0",
"0x0.A88BC67D44FEE6Bp0",
"0x0.A934A6A5C3D5825p0",
"0x0.A9DE3002F76B9AEp0",
"0x0.AA88633E692C84Ap0",
"0x0.AB3341024C61E05p0",
"0x0.ABDEC9F97EDDCE4p0",
"0x0.AC8AFECF89A5CC7p0",
"0x0.AD37E030A19E3F4p0",
"0x0.ADE56EC9A836A6Ep0",
"0x0.AE93AB482C16806p0",
"0x0.AF42965A69CAD4Cp0",
"0x0.AFF230AF4C74755p0",
"0x0.B0A27AF66E76E6Dp0",
"0x0.B15375E01A27FC3p0",
"0x0.B205221D4A8020Cp0",
"0x0.B2B7805FABCB532p0",
"0x0.B36A91599C5AD1Dp0",
"0x0.B41E55BE2D37798p0",
"0x0.B4D2CE4122D4D60p0",
"0x0.B587FB96F5C4E71p0",
"0x0.B63DDE74D36C98Bp0",
"0x0.B6F477909EB8F0Cp0",
"0x0.B7ABC7A0F0D4F20p0",
"0x0.B863CF5D19E0354p0",
"0x0.B91C8F7D21A6399p0",
"0x0.B9D608B9C8566BFp0",
"0x0.BA903BCC873CE7Ep0",
"0x0.BB4B296F917BF09p0",
"0x0.BC06D25DD4C6241p0",
"0x0.BCC33752FA19691p0",
"0x0.BD80590B667A97Fp0",
"0x0.BE3E38443BB1DFEp0",
"0x0.BEFCD5BB5907E8Dp0",
"0x0.BFBC322F5C03B26p0",
"0x0.C07C4E5FA129321p0",
"0x0.C13D2B0C44B8AF4p0",
"0x0.C1FEC8F6236EE00p0",
"0x0.C2C128DEDB45C57p0",
"0x0.C3844B88CC364A2p0",
"0x0.C44831B718FAA1Dp0",
"0x0.C50CDC2DA7D16C9p0",
"0x0.C5D24BB123419CAp0",
"0x0.C6988106FADF218p0",
"0x0.C75F7CF56410574p0",
"0x0.C82740435AD43C0p0",
"0x0.C8EFCBB8A2896C2p0",
"0x0.C9B9201DC6B5E5Bp0",
"0x0.CA833E3C1BCF93Ep0",
"0x0.CB4E26DDC005A3Ap0",
"0x0.CC19DACD9C0AA1Dp0",
"0x0.CCE65AD763DF644p0",
"0x0.CDB3A7C7979EBD5p0",
"0x0.CE81C26B8449FC9p0",
"0x0.CF50AB9144963B9p0",
"0x0.D0206407C1BA78Bp0",
"0x0.D0F0EC9EB43E807p0",
"0x0.D1C24626A4CAA61p0",
"0x0.D2947170ECF84C4p0",
"0x0.D3676F4FB8233EDp0",
"0x0.D43B4096043BDE0p0",
"0x0.D50FE617A29A1CBp0",
"0x0.D5E560A938D151Dp0",
"0x0.D6BBB1204184DDBp0",
"0x0.D792D8530D3DA53p0",
"0x0.D86AD718C34061Dp0",
"0x0.D943AE496264C99p0",
"0x0.DA1D5EBDC1ED8D8p0",
"0x0.DAF7E94F9261313p0",
"0x0.DBD34ED95E63BB6p0",
"0x0.DCAF90368B91406p0",
"0x0.DD8CAE435B59485p0",
"0x0.DE6AA9DCEBDB100p0",
"0x0.DF4983E138C2A7Bp0",
"0x0.E0293D2F1C26EE7p0",
"0x0.E109D6A64F686C6p0",
"0x0.E1EB51276C110C3p0",
"0x0.E2CDAD93ECB4B4Ep0",
"0x0.E3B0ECCE2DD2C3Fp0",
"0x0.E4950FB96EB86A9p0",
"0x0.E57A1739D263EC9p0",
"0x0.E66004346068C38p0",
"0x0.E746D78F05D4A68p0",
"0x0.E82E92309615774p0",
"0x0.E9173500CBE0159p0",
"0x0.EA00C0E84A181A3p0",
"0x0.EAEB36D09CB879Ap0",
"0x0.EBD697A439BD105p0",
"0x0.ECC2E44E820D18Cp0",
"0x0.EDB01DBBC2668C3p0",
"0x0.EE9E44D9344A6FEp0",
"0x0.EF8D5A94FEEA0E4p0",
"0x0.F07D5FDE38151E7p0",
"0x0.F16E55A4E528DA0p0",
"0x0.F2603CD9FC00028p0",
"0x0.F353166F63E3D78p0",
"0x0.F446E357F67DFD8p0",
"0x0.F53BA48780CB586p0",
"0x0.F6315AF2C40FD7Bp0",
"0x0.F728078F76CB38Cp0",
"0x0.F81FAB5445AEBC8p0",
"0x0.F9184738D493D4Fp0",
"0x0.FA11DC35BF73C89p0",
"0x0.FB0C6B449B604ECp0",
"0x0.FC07F55FF77D249p0",
"0x0.FD047B835DFA9C5p0",
"0x0.FE01FEAB551127Cp0",
"0x0.FF007FD55FFDDE3p0",
};



template <typename T> class table_f_Z2 {};


template <> class table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [32];};
const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [32] = {
"0x0",
"0x0.0000000p0",
"0x0.0000002p0",
"0x0.0000004p0",
"0x0.0000008p0",
"0x0.000000Cp0",
"0x0.0000012p0",
"0x0.0000018p0",
"0x0.0000020p0",
"0x0.0000028p0",
"0x0.0000032p0",
"0x0.000003Cp0",
"0x0.0000048p0",
"0x0.0000054p0",
"0x0.0000062p0",
"0x0.0000070p0",
"0x0.0000080p0",
"0x0.0000090p0",
"0x0.00000A2p0",
"0x0.00000B4p0",
"0x0.00000C8p0",
"0x0.00000DCp0",
"0x0.00000F2p0",
"0x0.0000108p0",
"0x0.0000120p0",
"0x0.0000138p0",
"0x0.0000152p0",
"0x0.000016Cp0",
"0x0.0000188p0",
"0x0.00001A4p0",
"0x0.00001C2p0",
"0x0.00001E0p0",
};


template <> class table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.0000000080002AAp0",
"0x0.000000020001555p0",
"0x0.000000048004800p0",
"0x0.00000008000AAABp0",
"0x0.0000000C8014D56p0",
"0x0.000000120024003p0",
"0x0.0000001880392B0p0",
"0x0.000000200055560p0",
"0x0.000000288079811p0",
"0x0.0000003200A6AC4p0",
"0x0.0000003C80DDD7Bp0",
"0x0.000000480120036p0",
"0x0.00000054816E2F5p0",
"0x0.0000006201C95B9p0",
"0x0.000000708232883p0",
"0x0.0000008002AAB55p0",
"0x0.000000908332E2Ep0",
"0x0.000000A203CC111p0",
"0x0.000000B484773FEp0",
"0x0.000000C805356F6p0",
"0x0.000000DC86079FAp0",
"0x0.000000F206EED0Cp0",
"0x0.0000010887EC02Ep0",
"0x0.000001200900360p0",
"0x0.000001388A2C6A3p0",
"0x0.000001520B719FBp0",
"0x0.0000016C8CD0D68p0",
"0x0.000001880E4B0EBp0",
"0x0.000001A48FE1487p0",
"0x0.000001C2119483Dp0",
"0x0.000001E09365C0Fp0",
"0x0.000002001556000p0",
"0x0.000002209766410p0",
"0x0.000002421997843p0",
"0x0.000002649BEAC99p0",
"0x0.000002881E61116p0",
"0x0.000002ACA0FB5BBp0",
"0x0.000002D223BAA8Cp0",
"0x0.000002F8A69FF89p0",
"0x0.0000032029AC4B6p0",
"0x0.00000348ACE0A15p0",
"0x0.00000372303DFA8p0",
"0x0.0000039CB3C5572p0",
"0x0.000003C83777B77p0",
"0x0.000003F4BB561B8p0",
"0x0.000004223F61838p0",
"0x0.00000450C39AEFAp0",
"0x0.000004804803602p0",
"0x0.000004B0CC9BD51p0",
"0x0.000004E251654EBp0",
"0x0.00000514D660CD4p0",
"0x0.000005485B8F50Ep0",
"0x0.0000057CE0F1D9Cp0",
"0x0.000005B26689683p0",
"0x0.000005E8EC56FC4p0",
"0x0.00000620725B964p0",
"0x0.00000658F898366p0",
"0x0.000006927F0DDCDp0",
"0x0.000006CD05BD89Ep0",
"0x0.000007088CA83DCp0",
"0x0.0000074513CEF8Ap0",
"0x0.000007829B32BACp0",
"0x0.000007C122D4847p0",
"0x0.00000800AAB555Dp0",
"0x0.0000084132D62F4p0",
"0x0.00000882BB3810Fp0",
"0x0.000008C543DBFB2p0",
"0x0.00000908CCC2EE1p0",
"0x0.0000094D55EDEA1p0",
"0x0.00000992DF5DEF6p0",
"0x0.000009D96913FE3p0",
"0x0.00000A20F31116Fp0",
"0x0.00000A697D5639Cp0",
"0x0.00000AB307E4671p0",
"0x0.00000AFD92BC9F0p0",
"0x0.00000B491DDFE1Fp0",
"0x0.00000B95A94F303p0",
"0x0.00000BE3350B8A0p0",
"0x0.00000C31C115EFBp0",
"0x0.00000C814D6F61Ap0",
"0x0.00000CD1DA18E00p0",
"0x0.00000D2367136B4p0",
"0x0.00000D75F46003Ap0",
"0x0.00000DC981FFA97p0",
"0x0.00000E1E0FF35D1p0",
"0x0.00000E739E3C1ECp0",
"0x0.00000ECA2CDAEEFp0",
"0x0.00000F21BBD0CDFp0",
"0x0.00000F7A4B1EBC0p0",
"0x0.00000FD3DAC5B9Ap0",
"0x0.0000102E6AC6C70p0",
"0x0.00001089FB22E4Ap0",
"0x0.000010E68BDB12Cp0",
"0x0.000011441CF051Dp0",
"0x0.000011A2AE63A21p0",
"0x0.000012024036040p0",
"0x0.00001262D26877Fp0",
"0x0.000012C464FBFE5p0",
"0x0.00001326F7F1976p0",
"0x0.0000138A8B4A43Ap0",
"0x0.000013EF1F07037p0",
"0x0.00001454B328D73p0",
"0x0.000014BB47B0BF4p0",
"0x0.00001522DC9FBC0p0",
"0x0.0000158B71F6CDFp0",
"0x0.000015F507B6F57p0",
"0x0.0000165F9DE132Dp0",
"0x0.000016CB347686Ap0",
"0x0.00001737CB77F14p0",
"0x0.000017A562E6731p0",
"0x0.00001813FAC30C8p0",
"0x0.00001883930EBE1p0",
"0x0.000018F42BCA882p0",
"0x0.00001965C4F76B2p0",
"0x0.000019D85E96678p0",
"0x0.00001A4BF8A87DCp0",
"0x0.00001AC0932EAE5p0",
"0x0.00001B362E29F9Ap0",
"0x0.00001BACC99B602p0",
"0x0.00001C246583E25p0",
"0x0.00001C9D01E480Bp0",
"0x0.00001D169EBE3BAp0",
"0x0.00001D913C1213Ap0",
"0x0.00001E0CD9E1094p0",
"0x0.00001E89782C1CEp0",
"0x0.00001F0716F44F1p0",
"0x0.00001F85B63AA05p0",
"0x0.000020055600111p0",
"0x0.00002085F645A1Dp0",
"0x0.00002107970C531p0",
"0x0.0000218A3855256p0",
"0x0.0000220DDA21194p0",
"0x0.000022927C712F3p0",
"0x0.000023181F4667Ap0",
"0x0.0000239EC2A1C34p0",
"0x0.000024266684427p0",
"0x0.000024AF0AEEE5Cp0",
"0x0.00002538AFE2ADDp0",
"0x0.000025C355609B1p0",
"0x0.0000264EFB69AE1p0",
"0x0.000026DBA1FEE76p0",
"0x0.000027694921479p0",
"0x0.000027F7F0D1CF3p0",
"0x0.0000288799117ECp0",
"0x0.0000291841E156Dp0",
"0x0.000029A9EB42580p0",
"0x0.00002A3C953582Ep0",
"0x0.00002AD03FBBD7Fp0",
"0x0.00002B64EAD657Ep0",
"0x0.00002BFA9686033p0",
"0x0.00002C9142CBDA7p0",
"0x0.00002D28EFA8DE5p0",
"0x0.00002DC19D1E0F5p0",
"0x0.00002E5B4B2C6E1p0",
"0x0.00002EF5F9D4FB3p0",
"0x0.00002F91A918B74p0",
"0x0.0000302E58F8A2Ep0",
"0x0.000030CC0975BECp0",
"0x0.0000316ABA910B6p0",
"0x0.0000320A6C4B897p0",
"0x0.000032AB1EA6398p0",
"0x0.0000334CD1A21C4p0",
"0x0.000033EF8540325p0",
"0x0.0000349339817C5p0",
"0x0.00003537EE66FAEp0",
"0x0.000035DDA3F1AEAp0",
"0x0.000036845A22985p0",
"0x0.0000372C10FAB88p0",
"0x0.000037D4C87B0FDp0",
"0x0.0000387E80A49F0p0",
"0x0.00003929397866Ap0",
"0x0.000039D4F2F7678p0",
"0x0.00003A81AD22A22p0",
"0x0.00003B2F67FB175p0",
"0x0.00003BDE2381C7Bp0",
"0x0.00003C8DDFB7B3Ep0",
"0x0.00003D3E9C9DDCBp0",
"0x0.00003DF05A3542Bp0",
"0x0.00003EA3187EE6Ap0",
"0x0.00003F56D77BC94p0",
"0x0.0000400B972CEB3p0",
"0x0.000040C157934D3p0",
"0x0.0000417818AFEFEp0",
"0x0.0000422FDA83D42p0",
"0x0.000042E89D0FFA8p0",
"0x0.000043A2605563Dp0",
"0x0.0000445D245510Cp0",
"0x0.00004518E910021p0",
"0x0.000045D5AE87387p0",
"0x0.0000469374BBB4Bp0",
"0x0.000047523BAE778p0",
"0x0.00004812036081Ap0",
"0x0.000048D2CBD2D3Dp0",
"0x0.0000499495066EEp0",
"0x0.00004A575EFC538p0",
"0x0.00004B1B29B5827p0",
"0x0.00004BDFF532FC8p0",
"0x0.00004CA5C175C27p0",
"0x0.00004D6C8E7ED50p0",
"0x0.00004E345C4F350p0",
"0x0.00004EFD2AE7E33p0",
"0x0.00004FC6FA49E06p0",
"0x0.00005091CA762D6p0",
"0x0.0000515D9B6DCAFp0",
"0x0.0000522A6D31B9Dp0",
"0x0.000052F83FC2FAFp0",
"0x0.000053C713228EFp0",
"0x0.00005496E75176Dp0",
"0x0.00005567BC50B33p0",
"0x0.000056399221450p0",
"0x0.0000570C68C42D1p0",
"0x0.000057E0403A6C3p0",
"0x0.000058B51885032p0",
"0x0.0000598AF1A4F2Dp0",
"0x0.00005A61CB9B3C1p0",
"0x0.00005B39A668DFAp0",
"0x0.00005C12820EDE8p0",
"0x0.00005CEC5E8E396p0",
"0x0.00005DC73BE7F13p0",
"0x0.00005EA31A1D06Dp0",
"0x0.00005F7FF92E7B1p0",
"0x0.0000605DD91D4EDp0",
"0x0.0000613CB9EA82Ep0",
"0x0.0000621C9B97184p0",
"0x0.000062FD7E240FBp0",
"0x0.000063DF61926A2p0",
"0x0.000064C245E3288p0",
"0x0.000065A62B174B9p0",
"0x0.0000668B112FD45p0",
"0x0.00006770F82DC39p0",
"0x0.00006857E0121A4p0",
"0x0.0000693FC8DDD95p0",
"0x0.00006A28B29201Ap0",
"0x0.00006B129D2F942p0",
"0x0.00006BFD88B791Bp0",
"0x0.00006CE9752AFB3p0",
"0x0.00006DD6628AD1Ap0",
"0x0.00006EC450D815Fp0",
"0x0.00006FB34013C8Fp0",
"0x0.000070A3303EEBBp0",
"0x0.00007194215A7F2p0",
"0x0.000072861367841p0",
"0x0.000073790666FB9p0",
"0x0.0000746CFA59E68p0",
"0x0.00007561EF4145Fp0",
"0x0.00007657E51E1ABp0",
"0x0.0000774EDBF165Dp0",
"0x0.00007846D3BC284p0",
"0x0.0000793FCC7F62Fp0",
"0x0.00007A39C63C16Ep0",
"0x0.00007B34C0F3451p0",
"0x0.00007C30BCA5EE7p0",
"0x0.00007D2DB955140p0",
"0x0.00007E2BB701B6Cp0",
"0x0.00007F2AB5ACD7Bp0",
};



template <typename T> class table_f_Z3 {};


template <> class table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.000000000000800p0",
"0x0.000000000002000p0",
"0x0.000000000004800p0",
"0x0.000000000008000p0",
"0x0.00000000000C800p0",
"0x0.000000000012000p0",
"0x0.000000000018800p0",
"0x0.000000000020000p0",
"0x0.000000000028800p0",
"0x0.000000000032000p0",
"0x0.00000000003C800p0",
"0x0.000000000048000p0",
"0x0.000000000054800p0",
"0x0.000000000062000p0",
"0x0.000000000070800p0",
"0x0.000000000080000p0",
"0x0.000000000090800p0",
"0x0.0000000000A2000p0",
"0x0.0000000000B4800p0",
"0x0.0000000000C8000p0",
"0x0.0000000000DC800p0",
"0x0.0000000000F2000p0",
"0x0.000000000108800p0",
"0x0.000000000120000p0",
"0x0.000000000138800p0",
"0x0.000000000152000p0",
"0x0.00000000016C800p0",
"0x0.000000000188000p0",
"0x0.0000000001A4800p0",
"0x0.0000000001C2001p0",
"0x0.0000000001E0801p0",
"0x0.000000000200001p0",
"0x0.000000000220801p0",
"0x0.000000000242001p0",
"0x0.000000000264801p0",
"0x0.000000000288001p0",
"0x0.0000000002AC802p0",
"0x0.0000000002D2002p0",
"0x0.0000000002F8802p0",
"0x0.000000000320002p0",
"0x0.000000000348802p0",
"0x0.000000000372003p0",
"0x0.00000000039C803p0",
"0x0.0000000003C8003p0",
"0x0.0000000003F4803p0",
"0x0.000000000422003p0",
"0x0.000000000450804p0",
"0x0.000000000480004p0",
"0x0.0000000004B0804p0",
"0x0.0000000004E2005p0",
"0x0.000000000514805p0",
"0x0.000000000548005p0",
"0x0.00000000057C806p0",
"0x0.0000000005B2006p0",
"0x0.0000000005E8806p0",
"0x0.000000000620007p0",
"0x0.000000000658807p0",
"0x0.000000000692007p0",
"0x0.0000000006CC808p0",
"0x0.000000000708008p0",
"0x0.000000000744809p0",
"0x0.000000000782009p0",
"0x0.0000000007C080Ap0",
"0x0.00000000080000Ap0",
"0x0.00000000084080Bp0",
"0x0.00000000088200Bp0",
"0x0.0000000008C480Cp0",
"0x0.00000000090800Cp0",
"0x0.00000000094C80Dp0",
"0x0.00000000099200Dp0",
"0x0.0000000009D880Ep0",
"0x0.000000000A2000Fp0",
"0x0.000000000A6880Fp0",
"0x0.000000000AB2010p0",
"0x0.000000000AFC811p0",
"0x0.000000000B48011p0",
"0x0.000000000B94812p0",
"0x0.000000000BE2013p0",
"0x0.000000000C30814p0",
"0x0.000000000C80014p0",
"0x0.000000000CD0815p0",
"0x0.000000000D22016p0",
"0x0.000000000D74817p0",
"0x0.000000000DC8018p0",
"0x0.000000000E1C818p0",
"0x0.000000000E72019p0",
"0x0.000000000EC881Ap0",
"0x0.000000000F2001Bp0",
"0x0.000000000F7881Cp0",
"0x0.000000000FD201Dp0",
"0x0.00000000102C81Ep0",
"0x0.00000000108801Fp0",
"0x0.0000000010E4820p0",
"0x0.000000001142021p0",
"0x0.0000000011A0822p0",
"0x0.000000001200024p0",
"0x0.000000001260825p0",
"0x0.0000000012C2026p0",
"0x0.000000001324827p0",
"0x0.000000001388028p0",
"0x0.0000000013EC829p0",
"0x0.00000000145202Bp0",
"0x0.0000000014B882Cp0",
"0x0.00000000152002Dp0",
"0x0.00000000158882Fp0",
"0x0.0000000015F2030p0",
"0x0.00000000165C831p0",
"0x0.0000000016C8033p0",
"0x0.000000001734834p0",
"0x0.0000000017A2036p0",
"0x0.000000001810837p0",
"0x0.000000001880039p0",
"0x0.0000000018F083Ap0",
"0x0.00000000196203Cp0",
"0x0.0000000019D483Dp0",
"0x0.000000001A4803Fp0",
"0x0.000000001ABC841p0",
"0x0.000000001B32042p0",
"0x0.000000001BA8844p0",
"0x0.000000001C20046p0",
"0x0.000000001C98848p0",
"0x0.000000001D12049p0",
"0x0.000000001D8C84Bp0",
"0x0.000000001E0804Dp0",
"0x0.000000001E8484Fp0",
"0x0.000000001F02051p0",
"0x0.000000001F80853p0",
"0x0.000000002000055p0",
"0x0.000000002080857p0",
"0x0.000000002102059p0",
"0x0.00000000218485Bp0",
"0x0.00000000220805Dp0",
"0x0.00000000228C85Fp0",
"0x0.000000002312061p0",
"0x0.000000002398864p0",
"0x0.000000002420066p0",
"0x0.0000000024A8868p0",
"0x0.00000000253206Ap0",
"0x0.0000000025BC86Dp0",
"0x0.00000000264806Fp0",
"0x0.0000000026D4872p0",
"0x0.000000002762074p0",
"0x0.0000000027F0876p0",
"0x0.000000002880079p0",
"0x0.00000000291087Cp0",
"0x0.0000000029A207Ep0",
"0x0.000000002A34881p0",
"0x0.000000002AC8083p0",
"0x0.000000002B5C886p0",
"0x0.000000002BF2089p0",
"0x0.000000002C8888Cp0",
"0x0.000000002D2008Ep0",
"0x0.000000002DB8891p0",
"0x0.000000002E52094p0",
"0x0.000000002EEC897p0",
"0x0.000000002F8809Ap0",
"0x0.00000000302489Dp0",
"0x0.0000000030C20A0p0",
"0x0.0000000031608A3p0",
"0x0.0000000032000A6p0",
"0x0.0000000032A08A9p0",
"0x0.0000000033420ACp0",
"0x0.0000000033E48B0p0",
"0x0.0000000034880B3p0",
"0x0.00000000352C8B6p0",
"0x0.0000000035D20BAp0",
"0x0.0000000036788BDp0",
"0x0.0000000037200C0p0",
"0x0.0000000037C88C4p0",
"0x0.0000000038720C7p0",
"0x0.00000000391C8CBp0",
"0x0.0000000039C80CFp0",
"0x0.000000003A748D2p0",
"0x0.000000003B220D6p0",
"0x0.000000003BD08DAp0",
"0x0.000000003C800DDp0",
"0x0.000000003D308E1p0",
"0x0.000000003DE20E5p0",
"0x0.000000003E948E9p0",
"0x0.000000003F480EDp0",
"0x0.000000003FFC8F1p0",
"0x0.0000000040B20F5p0",
"0x0.0000000041688F9p0",
"0x0.0000000042200FDp0",
"0x0.0000000042D8901p0",
"0x0.000000004392105p0",
"0x0.00000000444C90Ap0",
"0x0.00000000450810Ep0",
"0x0.0000000045C4912p0",
"0x0.000000004682117p0",
"0x0.00000000474091Bp0",
"0x0.000000004800120p0",
"0x0.0000000048C0924p0",
"0x0.000000004982129p0",
"0x0.000000004A4492Dp0",
"0x0.000000004B08132p0",
"0x0.000000004BCC937p0",
"0x0.000000004C9213Bp0",
"0x0.000000004D58940p0",
"0x0.000000004E20145p0",
"0x0.000000004EE894Ap0",
"0x0.000000004FB214Fp0",
"0x0.00000000507C954p0",
"0x0.000000005148159p0",
"0x0.00000000521495Ep0",
"0x0.0000000052E2163p0",
"0x0.0000000053B0968p0",
"0x0.00000000548016Ep0",
"0x0.000000005550973p0",
"0x0.000000005622178p0",
"0x0.0000000056F497Ep0",
"0x0.0000000057C8183p0",
"0x0.00000000589C989p0",
"0x0.00000000597218Ep0",
"0x0.000000005A48994p0",
"0x0.000000005B2019Ap0",
"0x0.000000005BF899Fp0",
"0x0.000000005CD21A5p0",
"0x0.000000005DAC9ABp0",
"0x0.000000005E881B1p0",
"0x0.000000005F649B7p0",
"0x0.0000000060421BDp0",
"0x0.0000000061209C3p0",
"0x0.0000000062001C9p0",
"0x0.0000000062E09CFp0",
"0x0.0000000063C21D5p0",
"0x0.0000000064A49DBp0",
"0x0.0000000065881E2p0",
"0x0.00000000666C9E8p0",
"0x0.0000000067521EFp0",
"0x0.0000000068389F5p0",
"0x0.0000000069201FCp0",
"0x0.000000006A08A02p0",
"0x0.000000006AF2209p0",
"0x0.000000006BDCA10p0",
"0x0.000000006CC8216p0",
"0x0.000000006DB4A1Dp0",
"0x0.000000006EA2224p0",
"0x0.000000006F90A2Bp0",
"0x0.000000007080232p0",
"0x0.000000007170A39p0",
"0x0.000000007262240p0",
"0x0.000000007354A47p0",
"0x0.00000000744824Fp0",
"0x0.00000000753CA56p0",
"0x0.00000000763225Dp0",
"0x0.000000007728A65p0",
"0x0.00000000782026Cp0",
"0x0.000000007918A74p0",
"0x0.000000007A1227Bp0",
"0x0.000000007B0CA83p0",
"0x0.000000007C0828Bp0",
"0x0.000000007D04A92p0",
"0x0.000000007E0229Ap0",
"0x0.000000007F00AA2p0",
};
#1921 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_tables_.h"
class table_exp_x_hi { public:
table_exp_x_hi ();
static const ap_ufixed<7, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array_0[64];
static const ap_ufixed<8, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array_1[64];
static const ap_ufixed<7, -8, (ap_q_mode)5, (ap_o_mode)3, 0> array_2[64];};

 const ap_ufixed<7, 7, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x_hi::array_0[64] = {
"0x1.000000000000000000000000000000000000000000p0",
"0x1.48B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.A61298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x2.1DF3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.B7E151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x3.7D871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x4.7B4FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x5.C12DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x7.63992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x9.7CDC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xC.2EB7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xF.A48385EDF47E967751198A5B272F75C260F29691A0p0",
"0x14.15E5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x19.CA53B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x21.1D8E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x2A.8565A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x36.99205C4E74B0CF1ADA77FB727B72DA0594D50C2E86p0",
"0x46.1AFC4DB59E7474902055DF28644F442A9E0E994CD9p0",
"0x5A.0462B7877AA8B7CEC5D7D5D435D47F34F294DB9976p0",
"0x73.9593ABB7D46EB9BDC798BC724FEBAA13D9797916DDp0",
"0x94.69C4CB819C78FB37D56C91AD5F3A152E3863B69195p0",
"0xBE.90F6F83E92793E9812DE9B67AC4A0B67794FB0BF86p0",
"0xF4.B122790DDFB1298C834010B3969829412DCF5ADBBDp0",
"0x13A.30CF1CCBB3DD712D7E9F020974648E01F6E6ABB52Fp0",
"0x193.6DC5690C08F37A9AE51F9733225FFE391C8FE46235p0",
"0x206.03487A3B1C6DA37FE8832776A513F4B5E522768CE1p0",
"0x299.2442102D91286ADC35D9242DDF710888D666CC2896p0",
"0x356.0F0B0F980D1FA20F84DF9C2A4663472077AFD94C45p0",
"0x448.A216ABB76A9BC7E802A24DEB83C19118812A5379BBp0",
"0x580.1AD754FA363912642E45D1489452EA303073266BD3p0",
"0x710.0ADBAC7DAB4A4E2FEA0200F7CF3314DB6D466A8026p0",
"0x911.9289C3923DC4E45FBB198DFFF31B92274CCCDD528Cp0",
"0x0.0015FC21041027ACBBFCD46780FEE71EAD23FBCB7Fp0",
"0x0.001C3AA91FF0D49824E2426C56E9E14E76FFA0E0C7p0",
"0x0.00243F37481E63A93106235D10A5837F9B9068603Bp0",
"0x0.002E8ABFC647F5FAA77574769EE917008332DB845Bp0",
"0x0.003BC2D73849531D57332EFD57EF4A2B8A392CD9A6p0",
"0x0.004CBC19ADC92D737A7FBD319DF8B3BE9114673693p0",
"0x0.006287862A553FE97980EF7971AC049D26841D52CDp0",
"0x0.007E83A561ABAF1AE4E699A1D49FF332750B364376p0",
"0x0.00A2728F889EA6AEC05D023E000435E6089AC958E5p0",
"0x0.00D096336E6CAE8354C436134E24EB0959BB119FD9p0",
"0x0.010BD4A5ACA7728750451FE402CA590BE5BD2A53EFp0",
"0x0.0157E6BFE8DE51A99D4DFD8E6A27B702C0BD655748p0",
"0x0.01B993FE00D53761C45C249149A5B95DC61840D80Dp0",
"0x0.0236FF5BF3CE1321EC22F9DF29C343B308525032B9p0",
"0x0.02D80A08D2B882E7A4347E73A3CAF88BBF8604675Ap0",
"0x0.03A6D2222442EA3BCB888D8C3D446984C6E9229055p0",
"0x0.04B0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0605424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.07BB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.09ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.0CBED86667585764A4130191C84086803A08AE39CCp0",
"0x0.105D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.150385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1AFB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.22A555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2C7C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.391F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.495860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.5E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.78ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.9B4597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.C75F7CF564105743415CBC9D6368F3B96071095ABEp0",
        };

        const ap_ufixed<8, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x_hi::array_1[64] = {
"0x1.000000000000000000000000000000000000000000p0",
"0x1.48B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.A61298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x2.1DF3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.B7E151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x3.7D871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x4.7B4FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x5.C12DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x7.63992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x9.7CDC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xC.2EB7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xF.A48385EDF47E967751198A5B272F75C260F29691A0p0",
"0x14.15E5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x19.CA53B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x21.1D8E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x2A.8565A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x36.99205C4E74B0CF1ADA77FB727B72DA0594D50C2E86p0",
"0x46.1AFC4DB59E7474902055DF28644F442A9E0E994CD9p0",
"0x5A.0462B7877AA8B7CEC5D7D5D435D47F34F294DB9976p0",
"0x73.9593ABB7D46EB9BDC798BC724FEBAA13D9797916DDp0",
"0x94.69C4CB819C78FB37D56C91AD5F3A152E3863B69195p0",
"0xBE.90F6F83E92793E9812DE9B67AC4A0B67794FB0BF86p0",
"0xF4.B122790DDFB1298C834010B3969829412DCF5ADBBDp0",
"0x13A.30CF1CCBB3DD712D7E9F020974648E01F6E6ABB52Fp0",
"0x193.6DC5690C08F37A9AE51F9733225FFE391C8FE46235p0",
"0x206.03487A3B1C6DA37FE8832776A513F4B5E522768CE1p0",
"0x299.2442102D91286ADC35D9242DDF710888D666CC2896p0",
"0x356.0F0B0F980D1FA20F84DF9C2A4663472077AFD94C45p0",
"0x448.A216ABB76A9BC7E802A24DEB83C19118812A5379BBp0",
"0x580.1AD754FA363912642E45D1489452EA303073266BD3p0",
"0x710.0ADBAC7DAB4A4E2FEA0200F7CF3314DB6D466A8026p0",
"0x911.9289C3923DC4E45FBB198DFFF31B92274CCCDD528Cp0",
"0x0.0015FC21041027ACBBFCD46780FEE71EAD23FBCB7Fp0",
"0x0.001C3AA91FF0D49824E2426C56E9E14E76FFA0E0C7p0",
"0x0.00243F37481E63A93106235D10A5837F9B9068603Bp0",
"0x0.002E8ABFC647F5FAA77574769EE917008332DB845Bp0",
"0x0.003BC2D73849531D57332EFD57EF4A2B8A392CD9A6p0",
"0x0.004CBC19ADC92D737A7FBD319DF8B3BE9114673693p0",
"0x0.006287862A553FE97980EF7971AC049D26841D52CDp0",
"0x0.007E83A561ABAF1AE4E699A1D49FF332750B364376p0",
"0x0.00A2728F889EA6AEC05D023E000435E6089AC958E5p0",
"0x0.00D096336E6CAE8354C436134E24EB0959BB119FD9p0",
"0x0.010BD4A5ACA7728750451FE402CA590BE5BD2A53EFp0",
"0x0.0157E6BFE8DE51A99D4DFD8E6A27B702C0BD655748p0",
"0x0.01B993FE00D53761C45C249149A5B95DC61840D80Dp0",
"0x0.0236FF5BF3CE1321EC22F9DF29C343B308525032B9p0",
"0x0.02D80A08D2B882E7A4347E73A3CAF88BBF8604675Ap0",
"0x0.03A6D2222442EA3BCB888D8C3D446984C6E9229055p0",
"0x0.04B0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0605424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.07BB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.09ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.0CBED86667585764A4130191C84086803A08AE39CCp0",
"0x0.105D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.150385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1AFB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.22A555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2C7C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.391F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.495860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.5E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.78ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.9B4597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.C75F7CF564105743415CBC9D6368F3B96071095ABEp0",
        };

        const ap_ufixed<7, -8, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x_hi::array_2[64] = {
"0x1.000000000000000000000000000000000000000000p0",
"0x1.48B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.A61298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x2.1DF3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.B7E151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x3.7D871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x4.7B4FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x5.C12DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x7.63992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x9.7CDC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xC.2EB7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xF.A48385EDF47E967751198A5B272F75C260F29691A0p0",
"0x14.15E5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x19.CA53B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x21.1D8E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x2A.8565A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x36.99205C4E74B0CF1ADA77FB727B72DA0594D50C2E86p0",
"0x46.1AFC4DB59E7474902055DF28644F442A9E0E994CD9p0",
"0x5A.0462B7877AA8B7CEC5D7D5D435D47F34F294DB9976p0",
"0x73.9593ABB7D46EB9BDC798BC724FEBAA13D9797916DDp0",
"0x94.69C4CB819C78FB37D56C91AD5F3A152E3863B69195p0",
"0xBE.90F6F83E92793E9812DE9B67AC4A0B67794FB0BF86p0",
"0xF4.B122790DDFB1298C834010B3969829412DCF5ADBBDp0",
"0x13A.30CF1CCBB3DD712D7E9F020974648E01F6E6ABB52Fp0",
"0x193.6DC5690C08F37A9AE51F9733225FFE391C8FE46235p0",
"0x206.03487A3B1C6DA37FE8832776A513F4B5E522768CE1p0",
"0x299.2442102D91286ADC35D9242DDF710888D666CC2896p0",
"0x356.0F0B0F980D1FA20F84DF9C2A4663472077AFD94C45p0",
"0x448.A216ABB76A9BC7E802A24DEB83C19118812A5379BBp0",
"0x580.1AD754FA363912642E45D1489452EA303073266BD3p0",
"0x710.0ADBAC7DAB4A4E2FEA0200F7CF3314DB6D466A8026p0",
"0x911.9289C3923DC4E45FBB198DFFF31B92274CCCDD528Cp0",
"0x0.0015FC21041027ACBBFCD46780FEE71EAD23FBCB7Fp0",
"0x0.001C3AA91FF0D49824E2426C56E9E14E76FFA0E0C7p0",
"0x0.00243F37481E63A93106235D10A5837F9B9068603Bp0",
"0x0.002E8ABFC647F5FAA77574769EE917008332DB845Bp0",
"0x0.003BC2D73849531D57332EFD57EF4A2B8A392CD9A6p0",
"0x0.004CBC19ADC92D737A7FBD319DF8B3BE9114673693p0",
"0x0.006287862A553FE97980EF7971AC049D26841D52CDp0",
"0x0.007E83A561ABAF1AE4E699A1D49FF332750B364376p0",
"0x0.00A2728F889EA6AEC05D023E000435E6089AC958E5p0",
"0x0.00D096336E6CAE8354C436134E24EB0959BB119FD9p0",
"0x0.010BD4A5ACA7728750451FE402CA590BE5BD2A53EFp0",
"0x0.0157E6BFE8DE51A99D4DFD8E6A27B702C0BD655748p0",
"0x0.01B993FE00D53761C45C249149A5B95DC61840D80Dp0",
"0x0.0236FF5BF3CE1321EC22F9DF29C343B308525032B9p0",
"0x0.02D80A08D2B882E7A4347E73A3CAF88BBF8604675Ap0",
"0x0.03A6D2222442EA3BCB888D8C3D446984C6E9229055p0",
"0x0.04B0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0605424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.07BB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.09ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.0CBED86667585764A4130191C84086803A08AE39CCp0",
"0x0.105D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.150385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1AFB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.22A555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2C7C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.391F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.495860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.5E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.78ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.9B4597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.C75F7CF564105743415CBC9D6368F3B96071095ABEp0",
        };




class table_f_x_lo { public:
table_f_x_lo ();
static const ap_ufixed<11, -4, (ap_q_mode)5, (ap_o_mode)3, 0> array[64];};
        const ap_ufixed<11, -4, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_x_lo::array[64] = {
"0x0",
"0x0.0000802AB55777D28A2A42D26AA9EE67BCF00C930Bp0",
"0x0.0002015600445B0C326382BC73689D326F63923DD8p0",
"0x0.0004848362076A08D9411A1CEE76CA2D65B11DB813p0",
"0x0.00080AB55DE3917AB864B3E9044E6B456F21041F46p0",
"0x0.000C94EF7A206DC2DA1F7B86DE3F8E864EF6A65A2Dp0",
"0x0.00122436410DD14E5659D75E95B76E1A857A4E668Ap0",
"0x0.0018B98F42084EFBDB328B919E6909847EC98C185Dp0",
"0x0.00205601127EC98E0BD083ABA80C97A6AA50178521p0",
"0x0.0028FA934EF9093044EF6E13ADF7CD6EBA2F758725p0",
"0x0.0032A84E9C1F58145CC1CF959B1B11093F5F980F92p0",
"0x0.003D603CA7C32730FADC469F215FD20BF82FEA5810p0",
"0x0.0049236829E8BC292CFE63D64B295EA1DA758B4607p0",
"0x0.0055F2DCE5D1E966E6B6D0A6A8E24E20C45FA36580p0",
"0x0.0063CFA7AB09D17324137D6C341C1D5CFB16053CCDp0",
"0x0.0072BAD65671B69772CC4A342D0E03A3DEEF5AF201p0",
"0x0.0082B577D34ED7D5B1A019E225C9A951BA29557586p0",
"0x0.0093C09C1C595C43E2F28C2BB379A6D086B8952F77p0",
"0x0.00A5DD543CCC4DDAFE1CC4A63C84ADEC1A44CA37FEp0",
"0x0.00B90CB25176A4C8BA56BA7452D24FE356F4915E61p0",
"0x0.00CD4FC989CD64555EA19C6E279C5E0A6409A56A48p0",
"0x0.00E2A7AE28FECA6FB3AFF16E11359ED08C61A07628p0",
"0x0.00F91575870692F2476E554B0595C0F3EDC574BF3Ep0",
"0x0.01109A3611C34FB645891BA5A60F3530346EEFC88Bp0",
"0x0.012937074E0CD6893D18CDBA80EABC29E7B47B51D4p0",
"0x0.0142ED01D8CBC61C41827CBB47DD2F852164B039D4p0",
"0x0.015DBD3F68122303EB9254A401DDB5572ACEE779B1p0",
"0x0.0179A8DACC350DE1D7E7D3123D7FE102B8BC392562p0",
"0x0.0196B0EFF0E793D158F49A640D8602BEEC5365B4D2p0",
"0x0.01B4D69BDE569A322D12247CD011F69D2E03754848p0",
"0x0.01D41AFCBA45E6ED2490B441CC4BF7EB8AFB05311Bp0",
"0x0.01F47F31C92E464FC01BEC8EC5D88F84D69100B065p0",
"0x0.0216045B6F5CCF9CED688384E06B8D4278BF0C84A8p0",
"0x0.0238AB9B3213497226D3BF43B81CF0C2FE0D1C3784p0",
"0x0.025C7613B8A9AF215A71E40ABAEFAE6577D7D2A116p0",
"0x0.028164E8CDB0D8211DFD9B442823E2E014E19AABBFp0",
"0x0.02A7793F601642B5D730C0089A0E0B24CEC78FD0C5p0",
"0x0.02CEB43D844902F7A3480A58247D40B3B00D34F43Dp0",
"0x0.02F7170A755FD759ECCFE9CE012E333515097AB7F3p0",
"0x0.0320A2CE964063DAC45AA7526D44A178FE71EDC1ADp0",
"0x0.034B58B372C795013767C0C59D7D934A6542EC445Ep0",
"0x0.037739E3C0F32BD3089388767EC6CB651FFE523747p0",
"0x0.03A4478B620C73EB551D8C3F85A23D53879A9974FDp0",
"0x0.03D282D763D424DCDDF54E52AAFD9DBF745B1F8C05p0",
"0x0.0401ECF601AF700BD5C89634FFF557C6E8B1333EEAp0",
"0x0.04328716A5D63C2C42063E75D0BF952B219E8089E3p0",
"0x0.04645269EA828F932A6D0FC4D8CD212A227168671Ap0",
"0x0.049750219B212A8A019121D35445577E130E744FEFp0",
"0x0.04CB8170B58352D4E0C48CB7C664934508E6B0A712p0",
"0x0.0500E78B6B11D19D6303225E84933F8D304B642D12p0",
"0x0.053783A7220124F51CE5A01C8187E7260077A5FEDFp0",
"0x0.056F56FA7686E623E3387F2344843C33967EA3C152p0",
"0x0.05A862BD3C1065F7469E72F43F0775514CC9BA2094p0",
"0x0.05E2A8287E7A8049E0A7F3D2D1427DACBD29348AB4p0",
"0x0.061E2876834AA7FA46011E98ABEADF76922C682878p0",
"0x0.065AE4E2CAE92C8AA9C6F26FE20BB71E4D971A328Ap0",
"0x0.0698DEAA11DCBAA377BDC040C05156D7577607601Fp0",
"0x0.06D8170A520718B46605B0C04672B6E2E3712843E6p0",
"0x0.07188F42C3E320F0BB08D7E21627BED4718E9B2C2Dp0",
"0x0.075A4893DFC3F9E4C1B99B1C7DBAB7A71F673EAE51p0",
"0x0.079D443F5F158EE3A4D178CA5BD3E80FE90C7BF9CFp0",
"0x0.07E183883D9E498E2998C09E5A0A5A8A0AEB9ED2FBp0",
"0x0.082707B2BAC20DB403D8C766005B3819B00D2918D6p0",
"0x0.086DD2045AC678D2BEF4D46281F716045167644BD9p0",
        };
#2209 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_tables_.h"
class table_exp_x { public:
table_exp_x ();
static const ap_ufixed<3, 3, (ap_q_mode)5, (ap_o_mode)3, 0> array_0[128];
static const ap_ufixed<4, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array_1[128];};

        const ap_ufixed<3, 3, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x::array_0[128] = {
"0x1.080000000000000000000000000000000000000000p0",
"0x1.1882B577D34ED7D5B1A019E225C9A951BA29557586p0",
"0x1.2A16045B6F5CCF9CED688384E06B8D4278BF0C84A8p0",
"0x1.3CCB8170B58352D4E0C48CB7C664934508E6B0A712p0",
"0x1.50B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.65E9176045FF53B513246531754403C29DB2C2F00Cp0",
"0x1.7C7A513DBEF6A623478B659B092405C578FA421F32p0",
"0x1.94802477B000FDC24DB40ED853110BEF137E20CF0Ap0",
"0x1.AE1298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x1.C94B4312564464432AA513BA422005EB74C2FFC3E4p0",
"0x1.E6455DF80E3C05CA897B072F6DAA5BC5942E1EE808p0",
"0x2.051DE6182F8C89D2C3B6D08C6597224224E114F55Ap0",
"0x2.25F3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.48E7A7E37AA2FFF223A7861B5865C559CC5920068Ep0",
"0x2.6E1CB0F6C564F38443FEAF672143A7EACCA15D6A42p0",
"0x2.95B809E9CA6704A25BFD953414F0F56C5439D7AA17p0",
"0x2.BFE151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x2.ECC2B42C0E5311F75A0A1AE923D4C04A68DA878226p0",
"0x3.1C891766B0ED0E3E661D5353DE3B7439677194BA13p0",
"0x3.4F64457102470C378267B1384AD9BC964CAF5D84D5p0",
"0x3.85871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x3.BF27C7915B29EC086E39B73B1905D65ADAB3D23565p0",
"0x3.FC7FE87A1D5F19A0D2DAC7AD2963D6DE6729BA390Bp0",
"0x4.3DCCDDAE27C89E47DCA21D8366EEA56A459715E270p0",
"0x4.834FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x4.CD4EC5127E2CC7E5CE59DD8C683540F9C5A8043103p0",
"0x5.1C134520127F660EE92DC97A97881578C14F21D2F9p0",
"0x5.6FEC44CD53E1D8103FDD848ED5EFCD994CAC5EA776p0",
"0x5.C92DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x6.2830ABCC7EBFE38D76963C6F0D9C0D6D434443A528p0",
"0x6.8D5466E0F306C77840907E7A69B2500F3CE65D86E8p0",
"0x6.F8FE017D49522BB3EB958EB5FEA9C3818259AFF22Ap0",
"0x7.6B992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x7.E59891C2B5263E4C74F8D3C24507F1751B727B44FCp0",
"0x8.677635B44463F17EFA0E17757F51A71C4857889976p0",
"0x8.F1B40280AB62E9EF755B858E49CA33771E8D70C830p0",
"0x9.84DC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xA.21822723BCCBF221C19AE0BEB2159249E7CA141876p0",
"0xA.C8426671100D96B2B37571D71915ACD425F0B4EEC6p0",
"0xB.79C3CD87578A85080EE6C10CC7D647BC947C530F21p0",
"0xC.36B7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xC.FFDBC7847516AD91A6FCAA504E5DF4422FF1B0F652p0",
"0xD.D5F892E85D2E8CB0206BB684F2DA5279F20EF41393p0",
"0xE.B9E47D68606FA157CCD6F76473055969133DEE3080p0",
"0xF.AC8385EDF47E967751198A5B272F75C260F29691A0p0",
"0x10.AEC85FBA36DADF507672125F699093D1DAE6913AB7p0",
"0x11.C1B5652D684392AF6521A8C41433F1502819A62959p0",
"0x12.E65D9A36D537EA6A7FCC5F658281D4A6436EB3458Cp0",
"0x14.1DE5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x15.698576F41530240D56EB5B6AE25A81C41120FE0855p0",
"0x16.CA887C1F169185A6DA92E2A3396F3877B58A5D45B9p0",
"0x18.424FEF61C650B5933FB79C08B46FF0B430A9D3608Dp0",
"0x19.D253B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x1B.7C23F99BD9475B0139A2A70CF9A29228932F866B75p0",
"0x1D.416AA9716D628E255DFA13F7B666F420F17A6D6916p0",
"0x1F.23ED3378C98744EA28E250B177BBD69D288C69504Bp0",
"0x21.258E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x23.484FA23D6B2ED9FD781B133D4E6B87157609DB32FDp0",
"0x25.8E5441C9F0A90028DC4FF65D5CA0725172591CAD95p0",
"0x27.F9E25639F534250CE816C34E3E5B0D1C21A7368507p0",
"0x2A.8D65A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x2D.4B71DD2CF5EA28AF5B2B91180451A25943D46F2C8Ep0",
"0x30.36C550B14DF3D5527158A5BC3CD7C207ACA19A6927p0",
"0x33.524B8D8E6206082357267EECCFB29182F42CD0B199p0",
"0x0.0CB0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0CFDBFA328F1B34A802A5024FBC337B0034E46CBFCp0",
"0x0.0D5028026AECB880451ECA0B595FC35DE4D10BBED2p0",
"0x0.0DA7E0FB0BC4D2D7FCE9051B77BE93AE64D0B84171p0",
"0x0.0E05424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.0E68A9625D8EB6A6F81B6A947F2837271A845A71E0p0",
"0x0.0ED279A9870EAA507BC020D1582BB0CCE72AED0E15p0",
"0x0.0F431CFBE91328DB6897AF05354B214C23CC0BD7A9p0",
"0x0.0FBB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.103AA6B98025B4B192724A53EE4DB3B8DDED61AD3Bp0",
"0x0.10C284C3144AAB3179BAAD3EF63F2F1AA34FC71EF7p0",
"0x0.1153260C52244DEAA4CBB664911EBF842811ED3EF9p0",
"0x0.11ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.1290FE67DB5155FD3C187CA8C3C60C9A3EA642A50Ap0",
"0x0.133F736CFFC23DC7E4182AEFE0C42733347CEB3F82p0",
"0x0.13F928D58D7BBDBAAA611045EF878892C954C1CF70p0",
"0x0.14BED86667585764A4130191C84086803A08AE39CCp0",
"0x0.159147DF980A8FA4110B923D1A7D4753312F2EA76Ap0",
"0x0.167149C222A2D95BEEFD44C6578E12FFC68DE20E2Ap0",
"0x0.175FBE22951DFBDBFAEA0C0A8EC44F7CCE920B7C99p0",
"0x0.185D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.196BC7E08095FED37B29FD5115086885BE66B95D4Cp0",
"0x0.1A8B6973646D8276ED2A35B2B25E379666F604AD85p0",
"0x0.1BBD97FB66F892E685E2829F35E912A08799530ECEp0",
"0x0.1D0385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1E5E78CBDD9BC0CA47DC2ED2F3C2FBC368CDD4D771p0",
"0x0.1FCFCC2D36C51196CF1FFF5217148DF1815FE0A94Dp0",
"0x0.2158F156C9C2AE2DD48183AEB708FF5B16863E4479p0",
"0x0.22FB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.24B8EF777F6DC635771D7602B129B513DB93332163p0",
"0x0.269328B4C50F6BEC0E3B76BC62AE6740870784571Ep0",
"0x0.288BF7A71898E505A0CEC7E946DBF6AF88D95B240Dp0",
"0x0.2AA555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2CE15B206201726FC504969004226BDF4AC2473927p0",
"0x0.2F4245674733A988F3F11726FB27DD9AE00B90CB29p0",
"0x0.31CA753935610B35ED6FCDBE21196A6BE7F827965Fp0",
"0x0.347C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.375AF0E6F85D04AFCCE5548E7EFEEFF31781F9D195p0",
"0x0.3A68CDB533DCC75F0F737009CB549F6E361916E0ADp0",
"0x0.3DA91784AEE38ED3932C7B8462E1F57E1513B17A91p0",
"0x0.411F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.44CE2A16225603BB465BB3430136F9098F44B96ADCp0",
"0x0.48BA18831D80B0FA9E97D677851A1386BC8A49851Ap0",
"0x0.4CE6C66DA13121ACB7530B5B6AB2714BEDC56F447Dp0",
"0x0.515860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.561359C97520CCB54CC51183E6D91A57BD94B4ADBEp0",
"0x0.5B1C6C91DEAC7F580C378A03213ED3B40E479C6D31p0",
"0x0.6078A2B41E3DFB5C3E632789C6C48259A4FAF6C0B3p0",
"0x0.662D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.6C40442F81A5D8382985CFA3934786E77794E54459p0",
"0x0.72B7782576B52D00953B6EA1C5FEC2B4F0CCAC5732p0",
"0x0.79996C787C78341066BFC732C2072F8F5D17386676p0",
"0x0.80ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.88B991FEC8010361182AA185169DE382A3EF78F891p0",
"0x0.9106E49A4C9F3D5958A5D1795C6AF854435B3A38CBp0",
"0x0.99DD49860AB457FE49ECBC03DE5C559D7E5D1F1536p0",
"0x0.A34597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.AD4938C9B7E846B122756D14A7C2C4BBB56E395688p0",
"0x0.B7F230AF4C747553D8DB804C224277431FE89589FAp0",
"0x0.C34B296F917BF09A22FBAA27077B854A35098FBF2Ap0",
"0x0.CF5F7CF564105743415CBC9D6368F3B96071095ABEp0",
"0x0.DC3B4096043BDE02C9DD90522BBE5C1ED729F2E882p0",
"0x0.E9EB51276C110C3C3EB1269F2F5D4AFABD8029F1B7p0",
"0x0.F87D5FDE38151E72F18FF03049AC5D7EA18E816731p0",
        };

        const ap_ufixed<4, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x::array_1[128] = {
"0x1.080000000000000000000000000000000000000000p0",
"0x1.1882B577D34ED7D5B1A019E225C9A951BA29557586p0",
"0x1.2A16045B6F5CCF9CED688384E06B8D4278BF0C84A8p0",
"0x1.3CCB8170B58352D4E0C48CB7C664934508E6B0A712p0",
"0x1.50B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.65E9176045FF53B513246531754403C29DB2C2F00Cp0",
"0x1.7C7A513DBEF6A623478B659B092405C578FA421F32p0",
"0x1.94802477B000FDC24DB40ED853110BEF137E20CF0Ap0",
"0x1.AE1298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x1.C94B4312564464432AA513BA422005EB74C2FFC3E4p0",
"0x1.E6455DF80E3C05CA897B072F6DAA5BC5942E1EE808p0",
"0x2.051DE6182F8C89D2C3B6D08C6597224224E114F55Ap0",
"0x2.25F3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.48E7A7E37AA2FFF223A7861B5865C559CC5920068Ep0",
"0x2.6E1CB0F6C564F38443FEAF672143A7EACCA15D6A42p0",
"0x2.95B809E9CA6704A25BFD953414F0F56C5439D7AA17p0",
"0x2.BFE151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x2.ECC2B42C0E5311F75A0A1AE923D4C04A68DA878226p0",
"0x3.1C891766B0ED0E3E661D5353DE3B7439677194BA13p0",
"0x3.4F64457102470C378267B1384AD9BC964CAF5D84D5p0",
"0x3.85871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x3.BF27C7915B29EC086E39B73B1905D65ADAB3D23565p0",
"0x3.FC7FE87A1D5F19A0D2DAC7AD2963D6DE6729BA390Bp0",
"0x4.3DCCDDAE27C89E47DCA21D8366EEA56A459715E270p0",
"0x4.834FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x4.CD4EC5127E2CC7E5CE59DD8C683540F9C5A8043103p0",
"0x5.1C134520127F660EE92DC97A97881578C14F21D2F9p0",
"0x5.6FEC44CD53E1D8103FDD848ED5EFCD994CAC5EA776p0",
"0x5.C92DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x6.2830ABCC7EBFE38D76963C6F0D9C0D6D434443A528p0",
"0x6.8D5466E0F306C77840907E7A69B2500F3CE65D86E8p0",
"0x6.F8FE017D49522BB3EB958EB5FEA9C3818259AFF22Ap0",
"0x7.6B992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x7.E59891C2B5263E4C74F8D3C24507F1751B727B44FCp0",
"0x8.677635B44463F17EFA0E17757F51A71C4857889976p0",
"0x8.F1B40280AB62E9EF755B858E49CA33771E8D70C830p0",
"0x9.84DC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xA.21822723BCCBF221C19AE0BEB2159249E7CA141876p0",
"0xA.C8426671100D96B2B37571D71915ACD425F0B4EEC6p0",
"0xB.79C3CD87578A85080EE6C10CC7D647BC947C530F21p0",
"0xC.36B7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xC.FFDBC7847516AD91A6FCAA504E5DF4422FF1B0F652p0",
"0xD.D5F892E85D2E8CB0206BB684F2DA5279F20EF41393p0",
"0xE.B9E47D68606FA157CCD6F76473055969133DEE3080p0",
"0xF.AC8385EDF47E967751198A5B272F75C260F29691A0p0",
"0x10.AEC85FBA36DADF507672125F699093D1DAE6913AB7p0",
"0x11.C1B5652D684392AF6521A8C41433F1502819A62959p0",
"0x12.E65D9A36D537EA6A7FCC5F658281D4A6436EB3458Cp0",
"0x14.1DE5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x15.698576F41530240D56EB5B6AE25A81C41120FE0855p0",
"0x16.CA887C1F169185A6DA92E2A3396F3877B58A5D45B9p0",
"0x18.424FEF61C650B5933FB79C08B46FF0B430A9D3608Dp0",
"0x19.D253B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x1B.7C23F99BD9475B0139A2A70CF9A29228932F866B75p0",
"0x1D.416AA9716D628E255DFA13F7B666F420F17A6D6916p0",
"0x1F.23ED3378C98744EA28E250B177BBD69D288C69504Bp0",
"0x21.258E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x23.484FA23D6B2ED9FD781B133D4E6B87157609DB32FDp0",
"0x25.8E5441C9F0A90028DC4FF65D5CA0725172591CAD95p0",
"0x27.F9E25639F534250CE816C34E3E5B0D1C21A7368507p0",
"0x2A.8D65A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x2D.4B71DD2CF5EA28AF5B2B91180451A25943D46F2C8Ep0",
"0x30.36C550B14DF3D5527158A5BC3CD7C207ACA19A6927p0",
"0x33.524B8D8E6206082357267EECCFB29182F42CD0B199p0",
"0x0.0CB0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0CFDBFA328F1B34A802A5024FBC337B0034E46CBFCp0",
"0x0.0D5028026AECB880451ECA0B595FC35DE4D10BBED2p0",
"0x0.0DA7E0FB0BC4D2D7FCE9051B77BE93AE64D0B84171p0",
"0x0.0E05424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.0E68A9625D8EB6A6F81B6A947F2837271A845A71E0p0",
"0x0.0ED279A9870EAA507BC020D1582BB0CCE72AED0E15p0",
"0x0.0F431CFBE91328DB6897AF05354B214C23CC0BD7A9p0",
"0x0.0FBB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.103AA6B98025B4B192724A53EE4DB3B8DDED61AD3Bp0",
"0x0.10C284C3144AAB3179BAAD3EF63F2F1AA34FC71EF7p0",
"0x0.1153260C52244DEAA4CBB664911EBF842811ED3EF9p0",
"0x0.11ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.1290FE67DB5155FD3C187CA8C3C60C9A3EA642A50Ap0",
"0x0.133F736CFFC23DC7E4182AEFE0C42733347CEB3F82p0",
"0x0.13F928D58D7BBDBAAA611045EF878892C954C1CF70p0",
"0x0.14BED86667585764A4130191C84086803A08AE39CCp0",
"0x0.159147DF980A8FA4110B923D1A7D4753312F2EA76Ap0",
"0x0.167149C222A2D95BEEFD44C6578E12FFC68DE20E2Ap0",
"0x0.175FBE22951DFBDBFAEA0C0A8EC44F7CCE920B7C99p0",
"0x0.185D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.196BC7E08095FED37B29FD5115086885BE66B95D4Cp0",
"0x0.1A8B6973646D8276ED2A35B2B25E379666F604AD85p0",
"0x0.1BBD97FB66F892E685E2829F35E912A08799530ECEp0",
"0x0.1D0385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1E5E78CBDD9BC0CA47DC2ED2F3C2FBC368CDD4D771p0",
"0x0.1FCFCC2D36C51196CF1FFF5217148DF1815FE0A94Dp0",
"0x0.2158F156C9C2AE2DD48183AEB708FF5B16863E4479p0",
"0x0.22FB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.24B8EF777F6DC635771D7602B129B513DB93332163p0",
"0x0.269328B4C50F6BEC0E3B76BC62AE6740870784571Ep0",
"0x0.288BF7A71898E505A0CEC7E946DBF6AF88D95B240Dp0",
"0x0.2AA555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2CE15B206201726FC504969004226BDF4AC2473927p0",
"0x0.2F4245674733A988F3F11726FB27DD9AE00B90CB29p0",
"0x0.31CA753935610B35ED6FCDBE21196A6BE7F827965Fp0",
"0x0.347C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.375AF0E6F85D04AFCCE5548E7EFEEFF31781F9D195p0",
"0x0.3A68CDB533DCC75F0F737009CB549F6E361916E0ADp0",
"0x0.3DA91784AEE38ED3932C7B8462E1F57E1513B17A91p0",
"0x0.411F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.44CE2A16225603BB465BB3430136F9098F44B96ADCp0",
"0x0.48BA18831D80B0FA9E97D677851A1386BC8A49851Ap0",
"0x0.4CE6C66DA13121ACB7530B5B6AB2714BEDC56F447Dp0",
"0x0.515860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.561359C97520CCB54CC51183E6D91A57BD94B4ADBEp0",
"0x0.5B1C6C91DEAC7F580C378A03213ED3B40E479C6D31p0",
"0x0.6078A2B41E3DFB5C3E632789C6C48259A4FAF6C0B3p0",
"0x0.662D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.6C40442F81A5D8382985CFA3934786E77794E54459p0",
"0x0.72B7782576B52D00953B6EA1C5FEC2B4F0CCAC5732p0",
"0x0.79996C787C78341066BFC732C2072F8F5D17386676p0",
"0x0.80ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.88B991FEC8010361182AA185169DE382A3EF78F891p0",
"0x0.9106E49A4C9F3D5958A5D1795C6AF854435B3A38CBp0",
"0x0.99DD49860AB457FE49ECBC03DE5C559D7E5D1F1536p0",
"0x0.A34597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.AD4938C9B7E846B122756D14A7C2C4BBB56E395688p0",
"0x0.B7F230AF4C747553D8DB804C224277431FE89589FAp0",
"0x0.C34B296F917BF09A22FBAA27077B854A35098FBF2Ap0",
"0x0.CF5F7CF564105743415CBC9D6368F3B96071095ABEp0",
"0x0.DC3B4096043BDE02C9DD90522BBE5C1ED729F2E882p0",
"0x0.E9EB51276C110C3C3EB1269F2F5D4AFABD8029F1B7p0",
"0x0.F87D5FDE38151E72F18FF03049AC5D7EA18E816731p0",
        };

}
#40 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h" 2

template<typename T>
class exp_traits {};

template <> class exp_traits<half>
{
public:
    const static int we = fp_struct<half>::EXP_BITS;
    const static int wf = fp_struct<half>::SIG_BITS;

    const static int gbits = 3;
    const static int gbits_Z2 = 3;
    const static int w_Z1 = 9;



    static ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<wf+gbits-w_Z1,-w_Z1> Z1P ) {
        ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> Z1P_l = Z1P;
        return Z1P_l;
    }
};

template <> class exp_traits<float>
{
public:
    const static int we = fp_struct<float>::EXP_BITS;
    const static int wf = fp_struct<float>::SIG_BITS;

    const static int gbits = 4;
    const static int gbits_Z2 = 3;
    const static int w_Z1 = 9;






    static ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<wf+gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2_ind = 5;
        ap_uint<w_Z2_ind> Z2_ind = Z1P ( Z1P.wl()-1 , Z1P.wl()-w_Z2_ind );
        ap_ufixed<wf+gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<wf+gbits,0> >::array [ Z2_ind ];
        ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = Z1P + f_Z2;
        return exp_Z1P_m_1;
    }
};

template <> class exp_traits<double>
{
public:
    const static int we = fp_struct<double>::EXP_BITS;
    const static int wf = fp_struct<double>::SIG_BITS;





    const static int gbits = 7;
    const static int gbits_Z2 = 5;
    const static int w_Z1 = 8;




    static ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<wf+gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2 = 8;
 const static int w_Z2P = 43;
        const static int w_Z3 = 8;
        const static int w_Z4 = 35;

 ap_ufixed < w_Z2 , -w_Z1 > Z2 = Z1P;
 ap_ufixed < w_Z2P , -w_Z1-w_Z2 > Z2P = Z1P;
 ap_ufixed < w_Z3 , -w_Z1-w_Z2 > Z3 = Z1P;
 ap_ufixed < w_Z4 , -w_Z1-w_Z2-w_Z3 > Z4 = Z1P;
#125 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
        const static int w_Z4_ind = w_Z3;
 ap_uint<w_Z4_ind> Z4_ind = Z4 ( Z4.wl()-1 , Z4.wl()-w_Z4_ind );
 ap_ufixed<wf+gbits-2*(w_Z1+w_Z2+w_Z3)-1,-2*(w_Z1+w_Z2+w_Z3)-1> f_Z4 = table_f_Z3< ap_ufixed<wf+gbits,0> >::array [ Z4_ind ] >> ( 2*w_Z3 );
 ap_ufixed<wf+gbits-w_Z1-w_Z2-w_Z3+1,-w_Z1-w_Z2-w_Z3+1> exp_Z4_m_1 = Z4 + f_Z4;


 ap_uint<w_Z3> Z3_ind = Z3 ( Z3.wl()-1, 0 );
        ap_ufixed<wf+gbits-2*(w_Z1+w_Z2)-1,-2*(w_Z1+w_Z2)-1> f_Z3 = table_f_Z3< ap_ufixed<wf+gbits,0> >::array [ Z3_ind ];
        ap_ufixed<wf+gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z3_m_1 = Z3 + f_Z3;


 ap_ufixed<wf+gbits-2*(w_Z1+w_Z2)-w_Z3+2,-2*(w_Z1+w_Z2)-w_Z3+2> exp_Z2P_m_1_lo = exp_Z3_m_1 * exp_Z4_m_1;


 ap_ufixed<wf+gbits-w_Z1-w_Z2+2,-w_Z1-w_Z2+2> exp_Z2P_m_1_l = exp_Z3_m_1 + exp_Z4_m_1 + exp_Z2P_m_1_lo;
 ((exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 140, __PRETTY_FUNCTION__));
 ap_ufixed<wf+gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z2P_m_1 = exp_Z2P_m_1_l;






        ap_uint<w_Z2> Z2_ind = Z2 ( Z2.wl()-1, 0 );
        ap_ufixed<wf+gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<wf+gbits,0> >::array [ Z2_ind ];
 ap_ufixed<wf+gbits-w_Z1+1 -2,-w_Z1+1> exp_Z2_m_1 = Z2 + f_Z2;


 ap_ufixed<wf+gbits-2*w_Z1-w_Z2+2,-2*w_Z1-w_Z2+2> exp_Z1P_m_1_lo = exp_Z2_m_1 * exp_Z2P_m_1;


        ap_ufixed<wf+gbits-w_Z1+2,-w_Z1+2> exp_Z1P_m_1_l = exp_Z2_m_1 + exp_Z2P_m_1 + exp_Z1P_m_1_lo;
        ((exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 157, __PRETTY_FUNCTION__));
        ap_ufixed<wf+gbits_Z2-w_Z1+1,-w_Z1+1> exp_Z1P_m_1 = exp_Z1P_m_1_l;

 return exp_Z1P_m_1;
    }
};

template<typename T>
T exp_generic(T x)
{
#pragma HLS pipeline

 fp_struct<T> es(x);
        const static int we = exp_traits<T>::we;
        const static int wf = exp_traits<T>::wf;

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;
#184 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    bool x_is_NaN = 0;
    bool x_is_inf = 0;
    bool x_is_pinf = 0;
    bool x_is_ninf = 0;

    if ( ::hls::__isnan(x) ) x_is_NaN = 1;
    if ( ::hls::__isinf(x) ) x_is_inf = 1;
    x_is_pinf = x_is_inf & ~es.sign[0];
    x_is_ninf = x_is_inf & es.sign[0];

    if (x_is_NaN) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if (x_is_pinf) {



 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if (x_is_ninf) {



        out.exp = 0;
        return out.to_ieee();
    }


    int m_exp = es.expv();
    fp_struct<T> nes = es;
#230 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    ap_fixed<1 + 1 + wf, 1 + 1> e_frac = 0;
    e_frac[e_frac.wl()-e_frac.iwl()] = 1;
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    const static int gbits = exp_traits<T>::gbits;
    ap_fixed<1 + we + wf+gbits, 1 + we> m_frac_l = e_frac;

    ap_fixed<1 + we + wf, 1 + we> m_fix_l = m_frac_l << m_exp;
    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    ap_fixed<1 + we + wf+gbits, 1 + we> m_fix;
    m_fix = m_frac_l << m_exp;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<wf+gbits+we+1, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2_lo = 0.60444058366692929317548838826088;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+gbits, 1 + we+1> m_fix_a = r_exp * LOG2;

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 260, __PRETTY_FUNCTION__));
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 261, __PRETTY_FUNCTION__));
    ap_fixed<1 -1 + wf+gbits, 1 -1> m_diff = m_fix - m_fix_a;
#291 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    const static int w_Z1 = exp_traits<T>::w_Z1;

    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );

    ap_ufixed<wf+gbits-w_Z1, -w_Z1> m_diff_lo = m_diff;


    const static int gbits_Z2 = exp_traits<T>::gbits_Z2;
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + wf+gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = exp_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + wf+gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 305, __PRETTY_FUNCTION__));
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }


    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {



            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {



            out.exp = 0;
            return out.to_ieee();
 }
    }


    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {



        out.exp = 0;
        return out.to_ieee();
    }


    out.sig(wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;
    return out.to_ieee();

}
#356 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
static ap_fixed<16, 8> exp_generic(ap_fixed<16, 8> x)
{
#pragma HLS pipeline

 const static int W_ = 16;
 const static int I_ = 8;
 const static int F_ = 8;
 const static int w_hi = 6;
 const static int w_lo = 6;

 const static int gbits = 7;

 ap_uint<w_hi> x_hi_ind;
 x_hi_ind [ w_hi-1 ] = x [ W_-1 ];
 x_hi_ind ( w_hi-2 , 0 ) = x ( w_hi+w_lo-2 , w_lo );
 ap_uint<w_lo> x_lo_ind = x ( w_lo-1 , 0 );

 ap_ufixed<W_-1+gbits,I_-1> exp_x_hi;
 exp_x_hi ( W_-1+gbits-1 , F_+gbits ) = table_exp_x_hi::array_0[x_hi_ind];
 exp_x_hi ( F_+gbits-1 , gbits ) = table_exp_x_hi::array_1[x_hi_ind];
 exp_x_hi ( gbits-1 , 0 ) = table_exp_x_hi::array_2[x_hi_ind];

 ap_ufixed<F_+(w_lo-F_)*2+gbits,(w_lo-F_)*2> f_x_lo = table_f_x_lo::array [ x_lo_ind ];

        ap_ufixed<w_lo,w_lo-F_> x_lo = x;
 ap_ufixed<w_lo+1+gbits,w_lo-F_+1> exp_x_lo_m_1 = x_lo + f_x_lo;
 ap_ufixed<w_lo+1+gbits,I_-1> exp_x_hi_hi = exp_x_hi;
 ap_ufixed<1,-F_> delta;
 delta[0] = 1;
 ap_ufixed<W_-1+gbits,I_-1> exp_x_l = ( exp_x_hi + delta ) + exp_x_hi_hi * exp_x_lo_m_1;

 ap_fixed<W_,I_> exp_x = exp_x_l;

 if ( x > 4.8515625 ) exp_x = 127.99609375;
 if ( x < -6 ) exp_x = 0;

 return exp_x;
}




static ap_fixed<8, 4> exp_generic(ap_fixed<8, 4> x)
{
#pragma HLS pipeline

        const static int W_ = 8;
        const static int I_ = 4;

 ap_uint<W_-1> x_ind;
 x_ind ( W_-2, 0 ) = x ( W_-2, 0 );

 ap_fixed<W_,I_> exp_x;
 exp_x[7] = 0;
 exp_x(6,4) = table_exp_x::array_0[x_ind];
 exp_x(3,0) = table_exp_x::array_1[x_ind];

 if ( x >= 2.125 ) exp_x = 7.9375;
        if ( x < -3 ) exp_x = 0;

        return exp_x;
}

static half exp(half x)
{
 return exp_generic(x);
}
static float exp(float x)
{
 return exp_generic(x);
}
static double exp(double x)
{
 return exp_generic(x);
}
static ap_fixed<16, 8> exp(ap_fixed<16, 8> x)
{
 return exp_generic(x);
}
static ap_fixed<8, 4> exp(ap_fixed<8, 4> x)
{
        return exp_generic(x);
}

static float expf(float x)
{
 return exp_generic(x);
}

static half half_exp(half x)
{
 return exp_generic(x);
}


template<typename T>
T exp2_generic(T x)
{
#pragma HLS pipeline

 fp_struct<T> es(x);
        const static int we = exp_traits<T>::we;
        const static int wf = exp_traits<T>::wf;

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;
#471 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    bool x_is_NaN = 0;
    bool x_is_inf = 0;
    bool x_is_pinf = 0;
    bool x_is_ninf = 0;

    if ( ::hls::__isnan(x) ) x_is_NaN = 1;
    if ( ::hls::__isinf(x) ) x_is_inf = 1;
    x_is_pinf = x_is_inf & ~es.sign[0];
    x_is_ninf = x_is_inf & es.sign[0];

    if (x_is_NaN) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if (x_is_pinf) {



 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if (x_is_ninf) {



        out.exp = 0;
        return out.to_ieee();
    }


    int m_exp = es.expv();
    fp_struct<T> nes = es;
#517 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    ap_fixed<1 + 1 + wf, 1 + 1> e_frac = 0;
    e_frac[e_frac.wl()-e_frac.iwl()] = 1;
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    const static int gbits = exp_traits<T>::gbits;
    ap_fixed<1 + we + wf+gbits, 1 + we> m_frac_l = e_frac;

    ap_fixed<1 + we + wf, 1 + we> m_fix_l = m_frac_l << m_exp;
    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    ap_fixed<1 + we + wf+gbits, 1 + we> m_fix;
    m_fix = m_frac_l << m_exp;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix + delta1;

    const ap_ufixed<wf+gbits+we+1, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2_lo = 0.60444058366692929317548838826088;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+gbits, 1 + we+1> m_fix_a = r_exp;

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 1)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 1)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 543, __PRETTY_FUNCTION__));
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -1)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -1)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 544, __PRETTY_FUNCTION__));
    ap_fixed<1 + wf+gbits, 1> m_diff_l = ( m_fix - m_fix_a ) * LOG2;

    (((m_fix_back != m_frac_l) || (m_diff_l < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_diff_l < 0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 547, __PRETTY_FUNCTION__));
    (((m_fix_back != m_frac_l) || (m_diff_l > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_diff_l > -0.5)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 548, __PRETTY_FUNCTION__));
    ap_fixed<1 -1 + wf+gbits, 1 -1> m_diff = m_diff_l;
#578 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    const static int w_Z1 = exp_traits<T>::w_Z1;

    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );

    ap_ufixed<wf+gbits-w_Z1, -w_Z1> m_diff_lo = m_diff;


    const static int gbits_Z2 = exp_traits<T>::gbits_Z2;
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + wf+gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = exp_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + wf+gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 592, __PRETTY_FUNCTION__));
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }


    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {



            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {



            out.exp = 0;
            return out.to_ieee();
 }
    }


    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {



        out.exp = 0;
        return out.to_ieee();
    }


    out.sig(wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;
    return out.to_ieee();

}

static half exp2(half x)
{
 return exp2_generic(x);
}
static float exp2(float x)
{
 return exp2_generic(x);
}
static double exp2(double x)
{
 return exp2_generic(x);
}

static float exp2f(float x)
{
 return exp2_generic(x);
}

static half half_exp2(half x)
{
 return exp2_generic(x);
}


template<typename T>
T exp10_generic(T x)
{
#pragma HLS pipeline

 fp_struct<T> es(x);
        const static int we = exp_traits<T>::we;
        const static int wf = exp_traits<T>::wf;

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;
#677 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    bool x_is_NaN = 0;
    bool x_is_inf = 0;
    bool x_is_pinf = 0;
    bool x_is_ninf = 0;

    if ( ::hls::__isnan(x) ) x_is_NaN = 1;
    if ( ::hls::__isinf(x) ) x_is_inf = 1;
    x_is_pinf = x_is_inf & ~es.sign[0];
    x_is_ninf = x_is_inf & es.sign[0];

    if (x_is_NaN) {


        out.sig = -1;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if (x_is_pinf) {



 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if (x_is_ninf) {



        out.exp = 0;
        return out.to_ieee();
    }


    int m_exp = es.expv();
    fp_struct<T> nes = es;
#723 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    ap_fixed<1 + 1 + wf, 1 + 1> e_frac = 0;
    e_frac[e_frac.wl()-e_frac.iwl()] = 1;
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    const static int gbits = exp_traits<T>::gbits;
    ap_fixed<1 + we + wf+gbits, 1 + we> m_frac_l = e_frac;

    ap_fixed<1 + we + wf, 1 + we> m_fix_l = m_frac_l << m_exp;
    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    ap_fixed<1 + we + wf+gbits, 1 + we> m_fix;
    m_fix = m_frac_l << m_exp;

    ap_fixed<1 + we + 5, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<2 + we+3, 2> LOG2_10 = 3.3219280948873623478703194294894;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+2> r_exp = m_fix_hi * LOG2_10 + delta1;

    const ap_ufixed< 2 + wf+gbits+we+1, 2> LOG10_hi = 2.302585092994045679049008867878;
    const ap_ufixed<-5 + wf+gbits+we+1, -5> LOG10_lo = 0.02237830812635162513896609861137;
    const ap_ufixed< 2 + wf+gbits+we+1, 2> LOG10 = LOG10_hi + ( LOG10_lo >> 52 );

    const ap_ufixed<-1 + wf+gbits+we+3, -1> LOG10_2_hi = 0.30102999566398103148401332873618;
    const ap_ufixed< wf+gbits+we+3, 0> LOG10_2_lo = 0.73737313104845853883700312679039;
    const ap_ufixed<-1 + wf+gbits+we+3, -1> LOG10_2 = LOG10_2_hi + ( LOG10_2_lo >> 52 );

    ap_fixed<1 + we+1 + wf+gbits, 1 + we+1> m_fix_a = r_exp * LOG10_2;

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.25)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.25)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 757, __PRETTY_FUNCTION__));
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.25)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.25)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 758, __PRETTY_FUNCTION__));
    ap_fixed<1 -1 + wf+gbits, 1 -1> m_diff = ( m_fix - m_fix_a ) * LOG10;
#788 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h"
    const static int w_Z1 = exp_traits<T>::w_Z1;

    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );

    ap_ufixed<wf+gbits-w_Z1, -w_Z1> m_diff_lo = m_diff;


    const static int gbits_Z2 = exp_traits<T>::gbits_Z2;
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + wf+gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = exp_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + wf+gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_exp_.h", 802, __PRETTY_FUNCTION__));
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }


    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {



            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {



            out.exp = 0;
            return out.to_ieee();
 }
    }


    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {



        out.exp = 0;
        return out.to_ieee();
    }


    out.sig(wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;
    return out.to_ieee();

}

static half exp10(half x)
{
 return exp10_generic(x);
}
static float exp10(float x)
{
 return exp10_generic(x);
}
static double exp10(double x)
{
 return exp10_generic(x);
}

static float exp10f(float x)
{
 return exp10_generic(x);
}

static half half_exp10(half x)
{
 return exp10_generic(x);
}


static double expm1(double x)
{
        fp_struct<double> xs(x);
        if ( (xs.sign[0]==1) && (xs.exp<996) && (xs.exp!=0) ) return x;
 if ( (xs.sign[0]==0) && (xs.exp<=996) && (xs.exp!=0) ) return x;
 return exp_generic(x)-1;
}

static float expm1(float x)
{
        fp_struct<float> xs(x);
 if ( xs.exp == 0 ) return 0;
        if ( xs.exp < 96 ) return x;
 double xd = x;
 return exp_generic(xd)-1;
}

static half expm1(half x)
{
 float xf = x;
 return exp_generic(xf)-1;
}

}
#847 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
static double exp(double x)
{
    return ::xil_fpo_exp_d(x);

}
static float exp(float x)
{
    return ::xil_fpo_exp_flt(x);

}
static half exp(half x)
{
    return hls::exp_reduce_::exp(x);
}
static ap_fixed<16,8> exp(ap_fixed<16,8> x)
{
    return hls::exp_reduce_::exp(x);
}
static ap_fixed<8,4> exp(ap_fixed<8,4> x)
{
    return hls::exp_reduce_::exp(x);
}
static double exp2(double x)
{

    return hls::exp_reduce_::exp2(x);
}
static float exp2(float x)
{
    return hls::exp_reduce_::exp2(x);
}
static half exp2(half x)
{
    return hls::exp_reduce_::exp2(x);
}
static double exp10(double x)
{

    return hls::exp_reduce_::exp10(x);
}
static float exp10(float x)
{
    return hls::exp_reduce_::exp10(x);
}
static half exp10(half x)
{
    return hls::exp_reduce_::exp10(x);
}

static float expf(float x)
{
    return ::xil_fpo_exp_flt(x);

}
static float exp2f(float x)
{

    return hls::exp_reduce_::exp2(x);
}
static float exp10f(float x)
{

    return hls::exp_reduce_::exp10(x);
}

static half half_exp(half x) {
    return hls::exp_reduce_::half_exp(x);
}
static half half_exp2(half x) {
    return hls::exp_reduce_::half_exp2(x);
}
static half half_exp10(half x) {
    return hls::exp_reduce_::half_exp10(x);
}

static double expm1(double x) {
    return hls::exp_reduce_::expm1(x);
}
static float expm1(float x) {
    return hls::exp_reduce_::expm1(x);
}
static half expm1(half x) {
    return hls::exp_reduce_::expm1(x);
}
static float expm1f(float x) {
    return hls::exp_reduce_::expm1(x);
}
static half half_expm1(half x) {
    return hls::exp_reduce_::expm1(x);
}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_erf.h" 1
#123 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_erf.h"
namespace erf_approx{

namespace {
template <typename T> class coeff { };
template <> class coeff<double> {
public:
    static const double tiny;
    static const double one_over_two;
    static const double one;
    static const double two;
    static const double erx;
    static const double efx;
    static const double efx8;
    static const double pp[5];
    static const double qq[6];
    static const double pa[7];
    static const double qa[7];
    static const double ra[8];
    static const double sa[9];
    static const double rb[7];
    static const double sb[8];
};
const double coeff<double>::tiny = 1e-300;
const double coeff<double>::one_over_two= 5.00000000000000000000e-01;
const double coeff<double>::one = 1.00000000000000000000e+00;
const double coeff<double>::two = 2.00000000000000000000e+00;

const double coeff<double>::erx = 8.45062911510467529297e-01;



const double coeff<double>::efx = 1.28379167095512586316e-01;
const double coeff<double>::efx8= 1.02703333676410069053e+00;
const double coeff<double>::pp[] =
{1.28379167095512558561e-01,
 -3.25042107247001499370e-01,
 -2.84817495755985104766e-02,
 -5.77027029648944159157e-03,
 -2.37630166566501626084e-05};
const double coeff<double>::qq[] =
{0.0, 3.97917223959155352819e-01,
  6.50222499887672944485e-02,
  5.08130628187576562776e-03,
  1.32494738004321644526e-04,
 -3.96022827877536812320e-06};



const double coeff<double>::pa[] =
{-2.36211856075265944077e-03,
  4.14856118683748331666e-01,
 -3.72207876035701323847e-01,
  3.18346619901161753674e-01,
 -1.10894694282396677476e-01,
  3.54783043256182359371e-02,
 -2.16637559486879084300e-03};
const double coeff<double>::qa[] =
{0.0, 1.06420880400844228286e-01,
  5.40397917702171048937e-01,
  7.18286544141962662868e-02,
  1.26171219808761642112e-01,
  1.36370839120290507362e-02,
  1.19844998467991074170e-02};



const double coeff<double>::ra[] =
{-9.86494403484714822705e-03,
 -6.93858572707181764372e-01,
 -1.05586262253232909814e+01,
 -6.23753324503260060396e+01,
 -1.62396669462573470355e+02,
 -1.84605092906711035994e+02,
 -8.12874355063065934246e+01,
 -9.81432934416914548592e+00};
const double coeff<double>::sa[] =
{0.0,1.96512716674392571292e+01,
  1.37657754143519042600e+02,
  4.34565877475229228821e+02,
  6.45387271733267880336e+02,
  4.29008140027567833386e+02,
  1.08635005541779435134e+02,
  6.57024977031928170135e+00,
 -6.04244152148580987438e-02};



const double coeff<double>::rb[] =
{-9.86494292470009928597e-03,
 -7.99283237680523006574e-01,
 -1.77579549177547519889e+01,
 -1.60636384855821916062e+02,
 -6.37566443368389627722e+02,
 -1.02509513161107724954e+03,
 -4.83519191608651397019e+02};
const double coeff<double>::sb[] =
{0.0,3.03380607434824582924e+01,
  3.25792512996573918826e+02,
  1.53672958608443695994e+03,
  3.19985821950859553908e+03,
  2.55305040643316442583e+03,
  4.74528541206955367215e+02,
 -2.24409524465858183362e+01};

template <> class coeff<float> {
public:
    static const float tiny;
    static const float one_over_two;
    static const float one;
    static const float two;
    static const float erx;
    static const float efx;
    static const float efx8;
    static const float pp[5];
    static const float qq[6];
    static const float pa[7];
    static const float qa[7];
    static const float ra[8];
    static const float sa[9];
    static const float rb[7];
    static const float sb[8];
};
const float coeff<float>::tiny = 1e-30;
const float coeff<float>::one_over_two= 5.0000000000e-01;
const float coeff<float>::one = 1.0000000000e+00;
const float coeff<float>::two = 2.0000000000e+00;

const float coeff<float>::erx = 8.4506291151e-01;



const float coeff<float>::efx = 1.2837916613e-01;
const float coeff<float>::efx8= 1.0270333290e+00;
const float coeff<float>::pp[] =
{1.2837916613e-01,
-3.2504209876e-01,
-2.8481749818e-02,
-5.7702702470e-03,
-2.3763017452e-05};
const float coeff<float>::qq[] =
{0.0, 3.9791721106e-01,
 6.5022252500e-02,
 5.0813062117e-03,
 1.3249473704e-04,
-3.9602282413e-06};



const float coeff<float>::pa[] =
{-2.3621185683e-03,
 4.1485610604e-01,
-3.7220788002e-01,
 3.1834661961e-01,
-1.1089469492e-01,
 3.5478305072e-02,
-2.1663755178e-03};
const float coeff<float>::qa[] =
{0.0, 1.0642088205e-01,
 5.4039794207e-01,
 7.1828655899e-02,
 1.2617121637e-01,
 1.3637083583e-02,
 1.1984500103e-02};



const float coeff<float>::ra[] =
{-9.8649440333e-03,
-6.9385856390e-01,
-1.0558626175e+01,
-6.2375331879e+01,
-1.6239666748e+02,
-1.8460508728e+02,
-8.1287437439e+01,
-9.8143291473e+00};
const float coeff<float>::sa[] =
{0.0, 1.9651271820e+01,
 1.3765776062e+02,
 4.3456588745e+02,
 6.4538726807e+02,
 4.2900814819e+02,
 1.0863500214e+02,
 6.5702495575e+00,
-6.0424413532e-02};



const float coeff<float>::rb[] =
{-9.8649431020e-03,
-7.9928326607e-01,
-1.7757955551e+01,
-1.6063638306e+02,
-6.3756646729e+02,
-1.0250950928e+03,
-4.8351919556e+02};
const float coeff<float>::sb[] =
{0.0, 3.0338060379e+01,
 3.2579251099e+02,
 1.5367296143e+03,
 3.1998581543e+03,
 2.5530502930e+03,
 4.7452853394e+02,
-2.2440952301e+01};

template<typename T> class erf_traits{ };
template<> class erf_traits<float> {
public:
    static const uint32_t mask;
    static const uint32_t segment[10];
};
const uint32_t erf_traits<float>::mask = 0xfffff000;
const uint32_t erf_traits<float>::segment[10] =
{
    0x7fffffff,
    0x7f800000,
    0x3f580000,
    0x31800000,
    0x04000000,
    0x3fa00000,
    0x40c00000,
    0x4036DB6E,
    31,
    0
};
template<> class erf_traits<double> {
public:
    static const uint64_t mask;
    static const uint32_t segment[10];
};
const uint64_t erf_traits<double>::mask = 0xffffffff00000000;
const uint32_t erf_traits<double>::segment[10] =
{
    0x7fffffff,
    0x7ff00000,
    0x3feb0000,
    0x3e300000,
    0x00800000,
    0x3ff40000,
    0x40180000,
    0x4006DB6E,
    63,
    32
};

template<typename T> class erfc_traits{};
template<> class erfc_traits<float>{
public:
    static const uint32_t segment[11];
};
const uint32_t erfc_traits<float>::segment[11] =
{
    0x7fffffff,
    0x7f800000,
    0x3f580000,
    0x23800000,
    0x3e800000,
    0x3fa00000,
    0x41e00000,
    0x4036DB6D,
    0x40c00000,
    31,
    0
};
template<> class erfc_traits<double>{
public:
    static const uint32_t segment[11];
};
const uint32_t erfc_traits<double>::segment[11] =
{
    0x7fffffff,
    0x7ff00000,
    0x3feb0000,
    0x3c700000,
    0x3fd00000,
    0x3ff40000,
    0x403c0000,
    0x4006DB6D,
    0x40180000,
    63,
    32
};
}
#425 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_erf.h"
template<typename T>
T generic_erf(T x)
{
 int32_t hx;
    uint32_t ix;
 T R,S,P,Q,s,y,z,r;

    fp_struct<T> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erf_traits<T>::segment[8],erf_traits<T>::segment[9]);
    hx = tmp.to_int();
 ix = hx & erf_traits<T>::segment[0];

    if(3 == ::hls::fpclassify(x)) {
        return 0;
    }

 if(ix>=erf_traits<T>::segment[1]) {

        if(hx>0)
         return (T)1.0 +(coeff<T>::one)/x;
        else
         return (coeff<T>::one)/x-(T)1.0;
 }

 if(ix < erf_traits<T>::segment[2]) {
     T r1,r2,s1,s2,s3,z2,z4;
     if(ix < erf_traits<T>::segment[3]) {
         if (ix < erf_traits<T>::segment[2])
      return ((T)0.125)*((T)8.0*x+(coeff<T>::efx8)*x);
  return x + (coeff<T>::efx)*x;
     }
     z = x*x;




     r1 = coeff<T>::pp[0]+z*coeff<T>::pp[1]; z2=z*z;
     r2 = coeff<T>::pp[2]+z*coeff<T>::pp[3]; z4=z2*z2;
     s1 = (coeff<T>::one)+z*coeff<T>::qq[1];
     s2 = coeff<T>::qq[2]+z*coeff<T>::qq[3];
     s3 = coeff<T>::qq[4]+z*coeff<T>::qq[5];
            r = r1 + z2*r2 + z4*coeff<T>::pp[4];
     s = s1 + z2*s2 + z4*s3;

     y = r/s;
     return x + x*y;
 }
 if(ix < erf_traits<T>::segment[5]) {
     T s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
     s = fabs(x)-(coeff<T>::one);




     P1 = coeff<T>::pa[0]+s*coeff<T>::pa[1]; s2=s*s;
     Q1 = (coeff<T>::one)+s*coeff<T>::qa[1]; s4=s2*s2;
     P2 = coeff<T>::pa[2]+s*coeff<T>::pa[3]; s6=s4*s2;
     Q2 = coeff<T>::qa[2]+s*coeff<T>::qa[3];
     P3 = coeff<T>::pa[4]+s*coeff<T>::pa[5];
     Q3 = coeff<T>::qa[4]+s*coeff<T>::qa[5];
     P4 = coeff<T>::pa[6];
     Q4 = coeff<T>::qa[6];
     P = P1 + s2*P2 + s4*P3 + s6*P4;
     Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

     if(hx>=0) return (coeff<T>::erx) + P/Q; else return -(coeff<T>::erx) - P/Q;
 }
 if (ix >= erf_traits<T>::segment[6]) {
     if(hx>=0) return (coeff<T>::one)-(coeff<T>::tiny); else return (coeff<T>::tiny)-(coeff<T>::one);
 }
 x = fabs(x);
  s = (coeff<T>::one)/(x*x);
 if(ix< erf_traits<T>::segment[7]) {






     T R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<T>::ra[0]+s*coeff<T>::ra[1];s2 = s*s;
     S1 = (coeff<T>::one)+s*coeff<T>::sa[1]; s4 = s2*s2;
     R2 = coeff<T>::ra[2]+s*coeff<T>::ra[3];s6 = s4*s2;
     S2 = coeff<T>::sa[2]+s*coeff<T>::sa[3];s8 = s4*s4;
     R3 = coeff<T>::ra[4]+s*coeff<T>::ra[5];
     S3 = coeff<T>::sa[4]+s*coeff<T>::sa[5];
     R4 = coeff<T>::ra[6]+s*coeff<T>::ra[7];
     S4 = coeff<T>::sa[6]+s*coeff<T>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<T>::sa[8];

 } else {






     T R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
     R1 = coeff<T>::rb[0]+s*coeff<T>::rb[1];s2 = s*s;
     S1 = (coeff<T>::one)+s*coeff<T>::sb[1]; s4 = s2*s2;
     R2 = coeff<T>::rb[2]+s*coeff<T>::rb[3];s6 = s4*s2;
     S2 = coeff<T>::sb[2]+s*coeff<T>::sb[3];
     R3 = coeff<T>::rb[4]+s*coeff<T>::rb[5];
     S3 = coeff<T>::sb[4]+s*coeff<T>::sb[5];
     S4 = coeff<T>::sb[6]+s*coeff<T>::sb[7];
     R = R1 + s2*R2 + s4*R3 + s6*coeff<T>::rb[6];
     S = S1 + s2*S2 + s4*S3 + s6*S4;

 }
 z = x;

    fp_struct<T> fp_z(z);
    ap_uint<Type_BitWidth<T>::Value> data = fp_z.data() & erf_traits<T>::mask;
    fp_struct<T> fp_z_new(data);
    z = fp_z_new.to_ieee();

 r = ::hls::exp(-z*z-(T)0.5625)*::hls::exp((z-x)*(z+x)+R/S);

 if(hx>=0) return (coeff<T>::one)-r/x; else return r/x-(coeff<T>::one);
}

template<typename T>
T generic_erfc(T x)
{
 int32_t hx;
    uint32_t ix;
 T R,S,P,Q,s,y,z,r;

    fp_struct<T> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erfc_traits<T>::segment[9],erfc_traits<T>::segment[10]);
    hx = tmp.to_int();
 ix = hx & erfc_traits<T>::segment[0];
 if(ix>=erfc_traits<T>::segment[1]) {

        if(hx>0)
         return (coeff<T>::one)/x;
        else
         return (coeff<T>::two) + (coeff<T>::one)/x;

 }

 if(ix < erfc_traits<T>::segment[2]) {
     T r1,r2,s1,s2,s3,z2,z4;
     if(ix < erfc_traits<T>::segment[3])
  return (coeff<T>::one)-x;
     z = x*x;




     r1 = coeff<T>::pp[0]+z*coeff<T>::pp[1]; z2=z*z;
     r2 = coeff<T>::pp[2]+z*coeff<T>::pp[3]; z4=z2*z2;
     s1 = (coeff<T>::one)+z*coeff<T>::qq[1];
     s2 = coeff<T>::qq[2]+z*coeff<T>::qq[3];
     s3 = coeff<T>::qq[4]+z*coeff<T>::qq[5];
            r = r1 + z2*r2 + z4*coeff<T>::pp[4];
     s = s1 + z2*s2 + z4*s3;

     y = r/s;
     if(ix < erfc_traits<T>::segment[4]) {
  return (coeff<T>::one)-(x+x*y);
     } else {
  r = x*y;
  r += (x-(coeff<T>::one_over_two));
         return (coeff<T>::one_over_two) - r ;
     }
 }
 if(ix < erfc_traits<T>::segment[5]) {
     T s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
     s = fabs(x)-(coeff<T>::one);




     P1 = coeff<T>::pa[0]+s*coeff<T>::pa[1]; s2=s*s;
     Q1 = (coeff<T>::one)+s*coeff<T>::qa[1]; s4=s2*s2;
     P2 = coeff<T>::pa[2]+s*coeff<T>::pa[3]; s6=s4*s2;
     Q2 = coeff<T>::qa[2]+s*coeff<T>::qa[3];
     P3 = coeff<T>::pa[4]+s*coeff<T>::pa[5];
     Q3 = coeff<T>::qa[4]+s*coeff<T>::qa[5];
     P4 = coeff<T>::pa[6];
     Q4 = coeff<T>::qa[6];
     P = P1 + s2*P2 + s4*P3 + s6*P4;
     Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

     if(hx>=0) {
         z = (coeff<T>::one)-(coeff<T>::erx); return z - P/Q;
     } else {
  z = (coeff<T>::erx)+P/Q; return (coeff<T>::one)+z;
     }
 }
 if (ix < erfc_traits<T>::segment[6]) {
     x = fabs(x);
      s = (coeff<T>::one)/(x*x);
     if(ix< erfc_traits<T>::segment[7]) {






  T R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<T>::ra[0]+s*coeff<T>::ra[1];s2 = s*s;
     S1 = (coeff<T>::one)+s*coeff<T>::sa[1]; s4 = s2*s2;
     R2 = coeff<T>::ra[2]+s*coeff<T>::ra[3];s6 = s4*s2;
     S2 = coeff<T>::sa[2]+s*coeff<T>::sa[3];s8 = s4*s4;
     R3 = coeff<T>::ra[4]+s*coeff<T>::ra[5];
     S3 = coeff<T>::sa[4]+s*coeff<T>::sa[5];
     R4 = coeff<T>::ra[6]+s*coeff<T>::ra[7];
     S4 = coeff<T>::sa[6]+s*coeff<T>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<T>::sa[8];

     } else {
  T R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
  if(hx<0&&ix>=erfc_traits<T>::segment[8]) return (coeff<T>::two)-(coeff<T>::tiny);






  R1 = coeff<T>::rb[0]+s*coeff<T>::rb[1];s2 = s*s;
  S1 = (coeff<T>::one)+s*coeff<T>::sb[1]; s4 = s2*s2;
  R2 = coeff<T>::rb[2]+s*coeff<T>::rb[3];s6 = s4*s2;
  S2 = coeff<T>::sb[2]+s*coeff<T>::sb[3];
  R3 = coeff<T>::rb[4]+s*coeff<T>::rb[5];
  S3 = coeff<T>::sb[4]+s*coeff<T>::sb[5];
  S4 = coeff<T>::sb[6]+s*coeff<T>::sb[7];
  R = R1 + s2*R2 + s4*R3 + s6*coeff<T>::rb[6];
  S = S1 + s2*S2 + s4*S3 + s6*S4;

     }
     z = x;

        fp_struct<T> fp_z(z);
        ap_uint<Type_BitWidth<T>::Value> data = fp_z.data() & erf_traits<T>::mask;
        fp_struct<T> fp_z_new(data);
        z = fp_z_new.to_ieee();


     r = ::hls::exp(-z*z-(T)0.5625)*
   ::hls::exp((z-x)*(z+x)+R/S);
        T r_x = r/x;
     if(hx>0) {
            if(3 == ::hls::fpclassify(r_x)) {
                return 0;
            }
            return r_x;
        } else
            return (coeff<T>::two)-r_x;
 } else {
     if(hx>0) return (coeff<T>::tiny)*(coeff<T>::tiny); else return (coeff<T>::two)-(coeff<T>::tiny);
 }
}
#701 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_erf.h"
static double erf(double x)
{
    return generic_erf(x);
}

static float erf(float x)
{
    return generic_erf(x);
}



static half erf(half x)
{
    return generic_erf((float)x);
}

static float erff(float x)
{
    return generic_erf(x);
}

static double erfc(double x)
{
    return generic_erfc(x);
}

static float erfc(float x)
{
    return generic_erfc(x);
}



static half erfc(half x)
{
    return generic_erfc((float)x);
}

static float erfcf(float x)
{
    return generic_erfc(x);
}

}
#939 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
static double erf(double x)
{
    return erf_approx::erf(x);
}
static float erf(float x)
{
    return erf_approx::erf(x);
}
static half erf(half x)
{
    return erf_approx::erf(x);
}
static float erff(float x)
{
    return erf_approx::erff(x);
}
static double erfc(double x)
{
    return erf_approx::erfc(x);
}
static float erfc(float x)
{
    return erf_approx::erfc(x);
}
static half erfc(half x)
{
    return erf_approx::erfc(x);
}
static float erfcf(float x)
{
    return erf_approx::erfcf(x);
}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_gamma.h" 1
#38 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_gamma.h"
static ap_ufixed<0 + 52, 0> lgamma_product (ap_ufixed<0 + 52, 0> t, ap_ufixed<5 + 52, 5> x, ap_uint<2> n)
{
#pragma HLS pipeline




 ap_ufixed<0 + 52, 0> ret[4] = {0};



#pragma unroll
 for ( ap_uint<3> i = 1; i < 4; i++ )
 {
#60 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_gamma.h"
  ap_ufixed<5 + 52, 5> xi = x+i;

  ap_ufixed<0 + 52, 0> quot = t/xi;



  ap_ufixed<0 + 52, 0> r = ret[i-1]*quot;
  ap_ufixed<0 + 52, 0> rpq = ret[i-1]+quot;



  ret[i] = rpq+r;


 }
 return ret[n] ;
}

static double lg_sinpi (ap_fixed<1 - 1 + 52, 1 - 1> x)
{
#pragma HLS pipeline

 double xd1 = x;
 ap_fixed<1 - 1 + 52, 1 - 1> x2 = (ap_fixed<0 + 1, 0>)0.5 - x;
 double xd2 = x2;
 if ( x[x.wl()-1] | ~x[x.wl()-2] )
  return sin(3.14159265358979323846*xd1);
 else
  return cos(3.14159265358979323846*xd2);
}

static double lg_cospi (ap_fixed<1 - 1 + 52, 1 - 1> x)
{
#pragma HLS pipeline

        double xd1 = x;
        ap_fixed<1 - 1 + 52, 1 - 1> x2 = (ap_ufixed<0 + 1, 0>)0.5 - x;
        double xd2 = x2;
 if ( x[x.wl()-1] | ~x[x.wl()-2] )
  return cos(double(3.14159265358979323846)*xd1);
 else
  return sin(double(3.14159265358979323846)*xd2);
}

static double lg_cotpi (ap_fixed<1 - 1 + 52, 1 - 1> x)
{
#pragma HLS pipeline

 return lg_cospi(x)/lg_sinpi(x);
}

static double lgamma_neg (double x, int *signgamp)
{
#pragma HLS pipeline

 const ap_ufixed<5 + 52, 5> lgamma_zeros[52] =
   {
            0x2.74ff92c01f0d8p+0,
            0x2.bf6821437b202p+0,
            0x3.24c1b793cb35ep+0,
            0x3.f48e2a8f85fcap+0,
            0x4.0a139e1665604p+0,
            0x4.fdd5de9bbabf4p+0,
            0x5.021a95fc2db64p+0,
            0x5.ffa4bd647d034p+0,
            0x6.005ac9625f234p+0,
            0x6.fff2fddae1bcp+0,
            0x7.000cff7b7f87cp+0,
            0x7.fffe5fe05673cp+0,
            0x8.0001a01459fc8p+0,
            0x8.ffffd1c425e8p+0,
            0x9.00002e3bb47d8p+0,
            0x9.fffffb606bep+0,
            0xa.0000049f93bb8p+0,
            0xa.ffffff9466eap+0,
            0xb.0000006b9915p+0,
            0xb.fffffff708938p+0,
            0xc.00000008f76c8p+0,
            0xc.ffffffff4f6ep+0,
            0xd.00000000b092p+0,
            0xd.fffffffff3638p+0,
            0xe.000000000c9c8p+0,
            0xe.ffffffffff29p+0,
            0xf.0000000000d7p+0,
            0xf.fffffffffff28p+0,
            0x1.000000000000dp+4,
            0x1.0ffffffffffffp+4,
            0x1.1000000000001p+4,
            0x1.2p+4,
            0x1.2p+4,
            0x1.3p+4,
            0x1.3p+4,
            0x1.4p+4,
            0x1.4p+4,
            0x1.5p+4,
            0x1.5p+4,
            0x1.6p+4,
            0x1.6p+4,
            0x1.7p+4,
            0x1.7p+4,
            0x1.8p+4,
            0x1.8p+4,
            0x1.9p+4,
            0x1.9p+4,
            0x1.ap+4,
            0x1.ap+4,
            0x1.bp+4,
            0x1.bp+4,
            0x1.cp+4,
   };

 fp_struct<double> xs(x);
        fp_struct<double> out;
        out.sign[0] = 0;
        out.sig = -1;
        out.exp = fp_struct<double>::EXP_INFNAN;

 ap_ufixed<5 + 51, 5> x_fix = 0;
 x_fix[x_fix.wl()-x_fix.iwl()+1] = 1;
 x_fix(51,0) = xs.sig(51,0);
 if ( xs.exp[1] ) x_fix <<= 2;
 if ( xs.exp[0] ) x_fix <<= 1;

 ap_uint<6> i;
 i(5,0) = x_fix(x_fix.wl()-1,x_fix.wl()-x_fix.iwl()-1);


 if ( x_fix(x_fix.wl()-x_fix.iwl()-1,0)==0 )

  return out.to_ieee();
 ap_uint<5> xn;
 xn(4,0) = i(5,1)+i[0];

 i -= 4;
 *signgamp = (i[1]==0) ? -1 : 1;

 ap_ufixed<5 + 52, 5> x0 = lgamma_zeros[i];


 ap_fixed<1 + 0 + 52, 1 + 0> xdiff = x0-x_fix;

 if ( i<2 ) {
  const ap_uint<2> poly_deg[8] = { 0, 1, 2, 3, 3, 2, 1, 1, };

  const ap_uint<7> poly_end[8] = { 10, 22, 35, 49, 63, 76, 88, 100, };
  const ap_fixed<1 + 12 + 52, 1 + 12> poly_coeff[112] = {
          -0x1.0b71c5c54d42fp+0, -0xc.73a1dc05f3758p-4, -0x1.ec84140851911p-4, -0xe.37c9da23847e8p-4,
          -0x1.03cd87cdc0ac6p-4, -0xe.ae9aedce12eep-4, 0x9.b11a1780cfd48p-8, -0xe.f25fc460bdebp-4,
          0x2.6e984c61ca912p-4, -0xf.83fea1c6d35p-4, 0x4.760c8c8909758p-4,

          -0xf.2930890d7d678p-4, -0xc.a5cfde054eaa8p-4, 0x3.9c9e0fdebd99cp-4, -0x1.02a5ad35619d9p+0,
          0x9.6e9b1167c164p-4, -0x1.4d8332eba090ap+0, 0x1.1c0c94b1b2b6p+0, -0x1.c9a70d138c74ep+0,
          0x1.d7d9cf1d4c196p+0, -0x2.91fbf4cd6abacp+0, 0x2.f6751f74b8ff8p+0, -0x3.e1bb7b09e3e76p+0,

          -0xd.7d28d505d618p-4, -0xe.69649a3040958p-4, 0xb.0d74a2827cd6p-4, -0x1.924b09228a86ep+0,
          0x1.d49b12bcf6175p+0, -0x3.0898bb530d314p+0, 0x4.207a6be8fda4cp+0, -0x6.39eef56d4e9p+0,
          0x8.e2e42acbccec8p+0, -0xd.0d91c1e596a68p+0, 0x1.2e20d7099c585p+4, -0x1.c4eb6691b4ca9p+4,
          0x2.96a1a11fd85fep+4,

          -0xb.74ea1bcfff948p-4, -0x1.2a82bd590c376p+0, 0x1.88020f828b81p+0, -0x3.32279f040d7aep+0,
          0x5.57ac8252ce868p+0, -0x9.c2aedd093125p+0, 0x1.12c132716e94cp+4, -0x1.ea94dfa5c0a6dp+4,
          0x3.66b61abfe858cp+4, -0x6.0cfceb62a26e4p+4, 0xa.beeba09403bd8p+4, -0x1.3188d9b1b288cp+8,
          0x2.37f774dd14c44p+8, -0x3.fdf0a64cd7136p+8,

          -0x3.d10108c27ebbp-4, 0x1.cd557caff7d2fp+0, 0x3.819b4856d36cep+0, 0x6.8505cbacfc42p+0,
          0xb.c1b2e6567a4dp+0, 0x1.50a53a3ce6c73p+4, 0x2.57adffbb1ec0cp+4, 0x4.2b15549cf400cp+4,
          0x7.698cfd82b3e18p+4, 0xd.2decde217755p+4, 0x1.7699a624d07b9p+8, 0x2.98ecf617abbfcp+8,
          0x4.d5244d44d60b4p+8, 0x8.e962bf7395988p+8,

          -0x6.b5d252a56e8a8p-4, 0x1.28d60383da3a6p+0, 0x1.db6513ada89bep+0, 0x2.e217118fa8c02p+0,
          0x4.450112c651348p+0, 0x6.4af990f589b8cp+0, 0x9.2db5963d7a238p+0, 0xd.62c03647da19p+0,
          0x1.379f81f6416afp+4, 0x1.c5618b4fdb96p+4, 0x2.9342d0af2ac4ep+4, 0x3.d9cdf56d2b186p+4,
          0x5.ab9f91d5a27a4p+4,

          -0x8.a41b1e4f36ff8p-4, 0xc.da87d3b69dbe8p-4, 0x1.1474ad5c36709p+0, 0x1.761ecb90c8c5cp+0,
          0x1.d279bff588826p+0, 0x2.4e5d003fb36a8p+0, 0x2.d575575566842p+0, 0x3.85152b0d17756p+0,
          0x4.5213d921ca13p+0, 0x5.55da7dfcf69c4p+0, 0x6.acef729b9404p+0, 0x8.483cc21dd0668p+0,

          -0xa.046d667e468f8p-4, 0x9.70b88dcc006cp-4, 0xa.a8a39421c94dp-4, 0xd.2f4d1363f98ep-4,
          0xd.ca9aa19975b7p-4, 0xf.cf09c2f54404p-4, 0x1.04b1365a9adfcp+0, 0x1.22b54ef213798p+0,
          0x1.2c52c25206bf5p+0, 0x1.4aa3d798aace4p+0, 0x1.5c3f278b504e3p+0, 0x1.7e08292cc347bp+0,
      };
  ap_uint<3> j;
  j(2,0) = x_fix(50,48);

  ap_ufixed<-3 + 4, -3> xm = 0.0625;

  ap_ufixed<-3 + 51, -3> x_fix_s = x_fix;
  ap_fixed<1 -3 + 51, 1 - 3> x_adj = xm-x_fix_s;

  ap_uint<2> deg = poly_deg[j];
  ap_uint<7> end = poly_end[j];
  ap_fixed<1 + 12 + 52, 1 + 12> g = poly_coeff[end];
#pragma unroll
  for ( ap_uint<4> j = 1; j <= 10; j++ )
   g = g*x_adj+poly_coeff[end-j];
  if ( deg[1] | deg[0] )
   g = g*x_adj+poly_coeff[end-11];
                if ( deg[1] )
                        g = g*x_adj+poly_coeff[end-12];
                if ( deg[1] & deg[0] )
                        g = g*x_adj+poly_coeff[end-13];
  ap_fixed<1 + 5 + 51, 1 + 5> x_fix_sign = x_fix;
  x_fix_sign = -x_fix_sign;
  return log1p(double(g*xdiff/(x_fix_sign-xn)));
 }
 ap_fixed<1 + 5 + 52, 1 + 5> pos = x_fix-xn;
 ap_fixed<1 + 5 + 52, 1 + 5> neg = xn-x_fix;
 ap_ufixed<-1 + 52, -1> x_idiff;
 if (~pos[57])
  x_idiff(50,0) = pos(50,0);
 else
  x_idiff(50,0) = neg(50,0);

 pos = x0-xn;
 neg = xn-x0;
 ap_ufixed<-1 + 52, -1> x0_idiff;
 if (~pos[57])
  x0_idiff(50,0) = pos(50,0);
 else
  x0_idiff(50,0) = neg(50,0);

 double log_sinpi_ratio;
 if ( x0_idiff<(x_idiff>>1) ) {

  log_sinpi_ratio = log(lg_sinpi(x0_idiff)/lg_sinpi(x_idiff));
 }
 else
 {
  ap_fixed<1 - 1 + 52, 1 - 1> x0diff2;
  if (~i[0])
   x0diff2 = xdiff>>1;
  else
   x0diff2 = (-xdiff)>>1;

  double sx0d2 = lg_sinpi(x0diff2);
  double cx0d2 = lg_cospi(x0diff2);
  log_sinpi_ratio = log1p(2*sx0d2*(-sx0d2+cx0d2*lg_cotpi(x_idiff)));
 }
 double log_gamma_ratio;
 ap_ufixed<5 + 52, 5> y0 = x0-1;


 ap_ufixed<5 + 52, 5> y = x_fix+1;


 double log_gamma_adj = 0;
 if ( i<6 )
 {
  ap_uint<2> n_up = (7-i)/2;
  y0 += n_up;
#320 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_gamma.h"
  ap_ufixed<0 + 52, 0> prodm1 = lgamma_product(xdiff,y,n_up);

  y += n_up;
  log_gamma_adj = -log1p(double(prodm1));
 }
 const ap_ufixed<2 + 52, 2> e = 0x2.b7e151628aed2p+0;





 double log_gamma_high = ((double)xdiff)*log1p(double((y0-e)/e))+(double(y-(ap_ufixed<0 + 1, 0>)0.5)*log1p(double(xdiff/y)))+log_gamma_adj;
#365 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_gamma.h"
 log_gamma_ratio = log_gamma_high ;
 return log_sinpi_ratio+log_gamma_ratio;
}
#424 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_gamma.h"
static double lgamma_r (double x, int *signgamp)
{
#pragma HLS pipeline

 fp_struct<double> xs(x);
        fp_struct<double> out;
        out.sign[0] = 0;
        out.sig = 0;
        out.exp = fp_struct<double>::EXP_INFNAN;

 *signgamp = 1;

 if ( ::hls::__isinf(x) )
  return out.to_ieee();
 if ( ::hls::__isnan(x) ) {
  out.sig = -1;
  return out.to_ieee();
 }
 if ( xs.exp==0 ) {
  if ( xs.sign[0] )
   *signgamp = -1;
  out.sig = -1;
  return out.to_ieee();
 }
 if ( xs.exp<953 ) {
  if ( xs.sign[0] )
   *signgamp = -1;
  return -log(fabs(x));
 }
 double nadj = 0;
 if ( xs.sign[0] ) {
  if ( xs.exp>=1075 ) {
   out.sig = -1;
   return out.to_ieee();
  }
         if ( (xs.exp>1 && xs.exp<4) || (xs.exp==1 && (xs.sig!=0)) || (xs.exp==4 && ~(xs.sig[51] & xs.sig[50])) )
                 return lgamma_neg(x,signgamp);
  const double pi = 3.14159265358979311600e+00;
         double t = sin(pi*x);
  fp_struct<double> ts(t);
         if ( ts.exp==0 ) {
                 out.sig = -1;
                 return out.to_ieee();
         }
         nadj = log(pi/fabs(t*x));
  if ( ts.sign[0] )
   *signgamp = -1;
  x = -x;
  xs.sign[0] = 0;
 }
 double r;
 if ( (xs.sig==0) && ((xs.exp==1023)||(xs.exp==1024)) ) {
  r = 0;
 } else if ( xs.exp<1024 ) {
  double y,z,p,p1,p2,p3;
  int i;
  const double tc = 1.46163214496836224576e+00;
  const double tc_m1 = 0.46163214496836224576e+00;
  ap_uint<20> x_sig_hi = (xs.sig>>32);
  if ( (xs.exp<1022) || ((xs.exp==1022)&&(x_sig_hi<=838860)) ) {
   r = -log(x);
   if ( (xs.exp>1022) || ((xs.exp==1022)&&(x_sig_hi>=485700)) ) {
    y = 1-x;
    i = 0;
   } else if ( (xs.exp>1020) || ((xs.exp==1020)&&(x_sig_hi>=894561)) ) {
    y = x-tc_m1;
    i = 1;
   } else {
    y = x;
    i = 2;
   }
  } else {
   r = 0;
   if ( (xs.exp>1023) || ((xs.exp==1023)&&(x_sig_hi>=767171)) ) {
    y = 2-x;
    i = 0;
   } else if ( (xs.exp>1023) || ((xs.exp==1023)&&(x_sig_hi>=242884)) ) {
    y = x-tc;
    i = 1;
   } else {
    y = x-1;
    i = 2;
   }
  }
  switch(i) {

        case 0:
        {
   const double a0 = 7.72156649015328655494e-02;
   const double a1 = 3.22467033424113591611e-01;
   const double a2 = 6.73523010531292681824e-02;
   const double a3 = 2.05808084325167332806e-02;
   const double a4 = 7.38555086081402883957e-03;
   const double a5 = 2.89051383673415629091e-03;
   const double a6 = 1.19270763183362067845e-03;
   const double a7 = 5.10069792153511336608e-04;
   const double a8 = 2.20862790713908385557e-04;
   const double a9 = 1.08011567247583939954e-04;
   const double a10 = 2.52144565451257326939e-05;
   const double a11 = 4.48640949618915160150e-05;

   z = y*y;
   p1 = a0+z*(a2+z*(a4+z*(a6+z*(a8+z*a10))));
   p2 = z*(a1+z*(a3+z*(a5+z*(a7+z*(a9+z*a11)))));
   p = y*p1+p2;
   r += (p-0.5*y); break;
        }
        case 1:
                      {
   const double tf = -1.21486290535849611461e-01;
   const double tt = -3.63867699703950536541e-18;
   const double t0 = 4.83836122723810047042e-01;
   const double t1 = -1.47587722994593911752e-01;
   const double t2 = 6.46249402391333854778e-02;
   const double t3 = -3.27885410759859649565e-02;
   const double t4 = 1.79706750811820387126e-02;
   const double t5 = -1.03142241298341437450e-02;
   const double t6 = 6.10053870246291332635e-03;
   const double t7 = -3.68452016781138256760e-03;
   const double t8 = 2.25964780900612472250e-03;
   const double t9 = -1.40346469989232843813e-03;
   const double t10 = 8.81081882437654011382e-04;
   const double t11 = -5.38595305356740546715e-04;
   const double t12 = 3.15632070903625950361e-04;
   const double t13 = -3.12754168375120860518e-04;
   const double t14 = 3.35529192635519073543e-04;

   z = y*y;
   double w = z*y;
   p1 = t0+w*(t3+w*(t6+w*(t9 +w*t12)));
   p2 = t1+w*(t4+w*(t7+w*(t10+w*t13)));
   p3 = t2+w*(t5+w*(t8+w*(t11+w*t14)));
   p = z*p1-(tt-w*(p2+y*p3));
   r += (tf + p); break;
                      }
        case 2:
                      {
   const double u0 = -7.72156649015328655494e-02;
   const double u1 = 6.32827064025093366517e-01;
   const double u2 = 1.45492250137234768737e+00;
   const double u3 = 9.77717527963372745603e-01;
   const double u4 = 2.28963728064692451092e-01;
   const double u5 = 1.33810918536787660377e-02;
   const double v1 = 2.45597793713041134822e+00;
   const double v2 = 2.12848976379893395361e+00;
   const double v3 = 7.69285150456672783825e-01;
   const double v4 = 1.04222645593369134254e-01;
   const double v5 = 3.21709242282423911810e-03;

   p1 = y*(u0+y*(u1+y*(u2+y*(u3+y*(u4+y*u5)))));
   p2 = 1+y*(v1+y*(v2+y*(v3+y*(v4+y*v5))));
   r += (-0.5*y + p1/p2);
                      }
  }
 }
 else if ( xs.exp<1026 ) {

  const double s0 = -7.72156649015328655494e-02;
  const double s1 = 2.14982415960608852501e-01;
  const double s2 = 3.25778796408930981787e-01;
  const double s3 = 1.46350472652464452805e-01;
  const double s4 = 2.66422703033638609560e-02;
  const double s5 = 1.84028451407337715652e-03;
  const double s6 = 3.19475326584100867617e-05;
  const double r1 = 1.39200533467621045958e+00;
  const double r2 = 7.21935547567138069525e-01;
  const double r3 = 1.71933865632803078993e-01;
  const double r4 = 1.86459191715652901344e-02;
  const double r5 = 7.77942496381893596434e-04;
  const double r6 = 7.32668430744625636189e-06;

  ap_uint<3> i;
  ap_uint<51> x_frac = 0;
  if (~xs.exp[0]) {
   i[2] = 0;
   i[1] = 1;
   i[0] = xs.sig[51];
   x_frac(50,0) = xs.sig(50,0);
  } else {
   i[2] = 1;
   i[1] = xs.sig[51];
   i[0] = xs.sig[50];
   x_frac(50,1) = xs.sig(49,0);
  }
  fp_struct<double> ys(double(0));
#pragma unroll
  for ( ap_uint<6> pos = 50; pos >=0; pos-- ) {
   if ( x_frac[pos] ) {
    ys.exp = pos - 51;
    ys.sig(51,51-pos) = x_frac(pos,0);
    break;
   }
  }
  double y = ys.to_ieee();



  double p = y*(s0+y*(s1+y*(s2+y*(s3+y*(s4+y*(s5+y*s6))))));
  double q = 1+y*(r1+y*(r2+y*(r3+y*(r4+y*(r5+y*r6)))));
         r = 0.5*y+p/q;
  double z = 1;
  switch(i) {
      case 7: z *= (y+6.0);
      case 6: z *= (y+5.0);
      case 5: z *= (y+4.0);
      case 4: z *= (y+3.0);
      case 3: z *= (y+2.0);
       r += log(z); break;
  }

 } else if ( xs.exp<1081 ) {

  const double w0 = 4.18938533204672725052e-01;
  const double w1 = 8.33333333333329678849e-02;
  const double w2 = -2.77777777728775536470e-03;
  const double w3 = 7.93650558643019558500e-04;
  const double w4 = -5.95187557450339963135e-04;
  const double w5 = 8.36339918996282139126e-04;
  const double w6 = -1.63092934096575273989e-03;

  double t = log(x);
  double z = 1/x;
  double y = z*z;
  double w = w0+z*(w1+y*(w2+y*(w3+y*(w4+y*(w5+y*w6)))));
         r = (x-0.5)*(t-1)+w;

 } else
         r = x*(log(x)-1);
 if ( x<0 )
  r = nadj-r;
 return r;
}


static ap_fixed<20 + 52, 20> gamma_product (ap_ufixed<4 + 52, 4> x , ap_uint<3> n )
{
#pragma HLS pipeline

 ap_fixed<20 + 52, 20> ret[6] = {0};
 ret[0] = x;


#pragma unroll
 for ( ap_uint<3> i = 1; i < 6; i++ )
 {

  ret[i] = ret[i-1]*(x+i);
 }

 return ret[n];
}

static double gamma_positive (double x, int *exp2_adj)
{
#pragma HLS pipeline

 fp_struct<double> xs(x);
 ap_ufixed<8 + 52, 8> x_fix = 1;
 x_fix(51,0) = xs.sig(51,0);
 ap_uint<3> shl;
 shl(2,0) = xs.exp(2,0);
 shl++;
 x_fix <<= shl;

 if ( xs.exp<126 )
 {
  *exp2_adj = 0;
  return exp(lgamma(x+1))/x;
 }
 else if ( (xs.exp<127)||((xs.exp==127)&&(xs.sig[51]==0)) )
 {
  *exp2_adj = 0;
  return exp(lgamma(x));
 }
 else if ( (xs.exp<129)||((xs.exp==129)&&(xs.sig(51,49)<5)) )
 {
  *exp2_adj = 0;
  ap_uint<4> nl;
  nl(3,0) = x_fix(54,51);
  nl -= 3;
  ap_uint<3> n;
  n(2,0) = nl(3,1);
  ap_ufixed<2 + 52, 2> x_adj;
  x_adj(51,0) = x_fix(51,0);
  x_adj[52] = x_fix[51];
  x_adj[53] = ~x_fix[51];



  double prod = gamma_product(x_adj ,n );
  return (exp(lgamma(double(x_adj)))*prod );
 }
 else
 {
  ap_ufixed<8 + 52, 8> x_adj = x_fix;



  double prod = 1;
  if ( (xs.exp<130)||((xs.exp==130)&&(xs.sig(51,50)<3)) )
  {
   ap_uint<4> xi = x_fix(55,52);
   ap_uint<3> n = 11-xi;
   x_adj[52] = 1;
   x_adj[53] = 1;
   x_adj[54] = 0;
   x_adj[55] = 1;
   if (x_fix(51,0)==0) {
    n++;
                                x_adj[52] = 0;
                                x_adj[53] = 0;
                                x_adj[54] = 1;
   }



   prod = gamma_product(x_fix,n);

  }
  ap_uint<8> x_adj_int;
  x_adj_int(7,0) = x_adj(59,52) + x_adj[51];
  ap_fixed<1 - 1 + 52, 1 - 1> x_adj_frac;
  x_adj_frac(51,0) = x_adj(51,0);



  ap_uint<3> x_adj_log2;
  ap_ufixed<1 + 52, 1> x_adj_mant;
#pragma unroll
  for ( ap_uint<3> pos = 6; pos >= 2; pos-- ) {
   ap_uint<9> x_adj_hi;
   x_adj_hi(8,0) = x_adj(53+pos,45+pos);
   if ( x_adj_hi > 181 ) {
    x_adj_log2 = pos;
    x_adj_mant(52,0) = x_adj(53+pos,1+pos);
   }
  }







  *exp2_adj = x_adj_log2*x_adj_int;
  double ret = ( pow(double(x_adj_mant),double(x_adj))
    * exp2(double(x_adj_log2*x_adj_frac))
    * exp(double(-x_adj))
    * sqrt(double((ap_fixed<3 + 52, 3>(3.14159265358979323846)<<1)/x_adj))
    / prod
         );

  const ap_fixed<1 - 3 + 52, 1 - 3> gamma_coeff[6] = { 0x1.5555555555555p-4, -0xb.60b60b60b60b8p-12, 0x3.4034034034034p-12,
          -0x2.7027027027028p-12, 0x3.72a3c5631fe46p-12, -0x7.daac36664f1f4p-12,
            };
  ap_fixed<1 - 3 + 52, 1 - 3> bsum = gamma_coeff[5];
  ap_fixed<16 + 52, 16> x_adj2 = x_adj*x_adj;
  for ( ap_uint<3> i = 1; i <= 5; i++ )
   bsum = bsum/x_adj2+gamma_coeff[5-i];
  ap_fixed<1 - 3 + 52, 1 - 3> exp_adj = bsum/x_adj;
  return ret+ret*expm1(double(exp_adj));
 }
}

static double tgamma (double x)
{
#pragma HLS pipeline

 fp_struct<double> xs(x);
 fp_struct<double> out;
 out.sign[0] = 0;
 out.sig = 0;
 out.exp = fp_struct<double>::EXP_INFNAN;

        ap_ufixed<1 + 52, 1> x_sig = 1;
        x_sig(51,0) = xs.sig(51,0);
        int x_exp = xs.expv();
        if ( x_exp>0 ) x_sig <<= x_exp;

 if ( (xs.exp==0) || ((xs.sign[0])&(::hls::__isinf(x))) || (::hls::__isnan(x)) || ((xs.sign[0]==1)&&(x_exp>=0)&&(x_sig==0)) )
 {
  out.sig = -1;
  return out.to_ieee();
 }
 if ( (::hls::__isinf(x)) || ((xs.sign[0]==0)&&((xs.exp>7)||((xs.exp==7)&&(xs.sig(51,47)>=11)))) )
 {
  return out.to_ieee();
 }
 else
 {
  double ret;
  if ( ~xs.sign[0] )
  {
   int exp2_adj;
   double tret = gamma_positive(x,&exp2_adj);
   ret = scalbn(tret,exp2_adj);
  }





  else
  {
                        fp_struct<double> xs(x);
                        ap_ufixed<8 + 52, 8> x_fix = 1;
                        x_fix(51,0) = xs.sig(51,0);
                        ap_uint<3> shl;
                        shl(2,0) = xs.exp(2,0);
                        shl++;
                        x_fix <<= shl;


   if ( (xs.sign[0]==1)&&((xs.exp>7)||((xs.exp==7)&&(xs.sig(51,48)>=7))) )
    ret = 0;
   else
   {
    ap_ufixed<0 + 52, 0> frac;
    frac(51,0) = x_fix(51,0);

    if ( frac[51] )
     frac = 1-frac;
    double sinpix = ((~frac[51])&(~frac[50])) ? sin(double((ap_fixed<2 + 52, 2>)3.14159265358979323846*frac)) : cos(double((ap_fixed<2 + 52, 2>)3.14159265358979323846*((ap_ufixed<0 + 52, 0>)0.5-frac)));
    int exp2_adj;
    double tret = 3.14159265358979323846/(-x*sinpix*gamma_positive(-x,&exp2_adj));
    ret = scalbn(tret,-exp2_adj);
   }
  }
  return ret;
 }
}
#973 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
static float lgamma_rf(float x, int *signgamp) {
    return hls::lgamma_r(x,signgamp);
}
static half half_lgamma_r(half x, int *signgamp) {
    return hls::lgamma_r(x,signgamp);
}
static double lgamma (double x) {
    int *signgamp = 0;
    return hls::lgamma_r(x,signgamp);
}
static float lgammaf(float x) {
    int *signgamp = 0;
    return hls::lgamma_r(x,signgamp);
}
static half half_lgamma(half x) {
    int *signgamp = 0;
    return hls::lgamma_r(x,signgamp);
}
static float tgammaf(float x) {
    return hls::tgamma(x);
}
static half half_tgamma(half x) {
    return hls::tgamma(x);
}


template <typename T>
struct hls_filter_traits {
    typedef T T_data;
    typedef T T_accum;
    static T_data shift(T_accum in) {
        return in;
    }
};

struct hls_filter_traits_Q15 {
    typedef short T_data;
    typedef int T_accum;
    static T_data shift(T_accum in) {
        return (T_data)(in >> 15);
    }
};
#1023 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h"
template <typename T_accum, typename T>
T_accum dot(T *x, T *y, int n)
{

    volatile T_accum r = 0;
    T_accum result = r;
dot_foreach_tap:
    for(int i = 0; i < n; i++) {
        result += x[i] * y[i];
    }
    return result;
}
#1050 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h"
template <typename T, typename TRAITS>
void fir_blocksrl(T *in, T *taps, T *out, T *state, int incount, int numtaps)
{
#pragma HLS inline self
fir_blocksrl_foreach_data:
    for(int n = 0; n < incount; n++) {
#pragma HLS expression_balance off
        for(int i = numtaps-1; i > 0; i--) {
            state[i] = state[i-1];
        }
        state[0] = in[n];
        out[n] = TRAITS::shift( dot<typename TRAITS::T_accum>(state, taps, numtaps));
    }
}
#1079 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h"
template <typename T>
void fir_blocksrl(T *in, T *taps, T *out, T *state, int incount, int numtaps)
{
    fir_blocksrl<T, hls_filter_traits<T> >(in, taps, out, state, incount, numtaps);
}
#1098 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h"
static void fir_blocksrl_Q15(short *in, short *taps, short *out, short *state, int incount, int numtaps)
{
    fir_blocksrl<short, hls_filter_traits_Q15>(in, taps, out, state, incount, numtaps);
}

}

namespace hls {

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_tanh.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_tanh.h"
namespace explog_based {
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_tanh.h"
  template<class T>
  T generic_tanh(T t_in){

    static const int exp_bias = fp_struct<T>::EXP_BIAS;

    fp_struct<T> din(t_in);
    T abst_in = hls::fabs(t_in);
    T resultf;

    if(din.exp==fp_struct<T>::EXP_INFNAN){

      if(din.sig != 0){
 resultf = ::hls::nan("");
      }
      else{
 resultf = (T)1.0;
      }
    }
    else if((din.exp<exp_bias-55) or
     (din.exp==exp_bias-55 and din.sig==0)){

      const T cst1 = 1.0;
      resultf = abst_in * (cst1 + abst_in);
    }
    else if(abst_in < (T)22.0){

      T x;
      if(din.exp < exp_bias){
 x = -abst_in - abst_in;
      }
      else{
 x = abst_in + abst_in;
      }

      T expx = hls::expm1(x);

      if(din.exp < exp_bias){

 const T cst2 = 2.0;
 resultf = - expx / (expx + cst2);
      }
      else{
 const T cst1 = 1.0;
 const T cst2 = 2.0;
 resultf = cst1 - cst2 / (expx + cst2);
      }
    }
    else{
      resultf = (T)1.0;
    }


    if(din.sign == 0){
      return resultf;
    }
    else{
      return -resultf;
    };
  }

  static
  double tanh(double t_in)
  {
    return generic_tanh(t_in);
  };

  static
  float tanh(float t_in)
  {
    return generic_tanh(t_in);
  };

  static half
  tanh(half t_in)
  {
    return generic_tanh(t_in);
  };

  static
  float tanhf(float t_in){
    return generic_tanh(t_in);
  };

  static
  half half_tanh(half t_in){
    return generic_tanh(t_in);
  };

}
#1108 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_atanh.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_atanh.h"
namespace explog_based {
#48 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_atanh.h"
  template<class T>
  T generic_atanh(T t_in){

    static const int exp_bias = fp_struct<T>::EXP_BIAS;

    fp_struct<T> din(t_in);
    T abst_in = hls::fabs(t_in);
    T resultf;

    if(din.exp==fp_struct<T>::EXP_INFNAN){

      resultf = ::hls::nan("");
    }
    else if((din.exp>exp_bias) or
     (din.exp==exp_bias and din.sig>0)){

      resultf = ::hls::nan("");
    }
    else if(din.exp==exp_bias and din.sig==0){

      fp_struct<T> out;
      out.sign = 0;
      out.exp = fp_struct<T>::EXP_INFNAN;
      out.sig = 0;
      resultf = out.to_ieee();
    }
    else{

      const T cst1 = 1.0;
      const T cst05 = 0.5;
      T t = abst_in + abst_in;
      T x;
      if(din.exp<exp_bias-1){
 x = t + t*abst_in/(cst1-abst_in);
      }
      else{
 x = t/(cst1-abst_in);
      };

      resultf = cst05 * hls::log1p(x);
    }


    if(din.sign == 0){
      return resultf;
    }
    else{
      return -resultf;
    };
  };

  static
  double atanh(double t_in)
  {
    return generic_atanh(t_in);
  };

  static
  float atanh(float t_in)
  {
    return generic_atanh(t_in);
  };

  static
  half atanh(half t_in)
  {
    return generic_atanh(t_in);
  };

  static
  float atanhf(float t_in){
    return generic_atanh(t_in);
  };

  static
  half half_atanh(half t_in){
    return generic_atanh(t_in);
  };

}
#1109 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2

static double tanh(double t_in)
{
  return explog_based::tanh(t_in);
}

static float tanh(float t_in)
{
  return explog_based::tanh(t_in);
}

static half tanh(half t_in)
{
  return explog_based::tanh(t_in);
}

static double atanh(double t_in)
{
  return explog_based::atanh(t_in);
}

static float atanh(float t_in)
{
  return explog_based::atanh(t_in);
}

static half atanh(half t_in)
{
  return explog_based::atanh(t_in);
}

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_acosh.h" 1
#35 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_acosh.h"
namespace explog_based {
#49 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_acosh.h"
  template<class T>
  T generic_acosh(T t_in){

    static const int exp_bias = fp_struct<T>::EXP_BIAS;

    fp_struct<T> din(t_in);
    T resultf;

    if(din.exp==fp_struct<T>::EXP_INFNAN){

      if(din.sig != 0){
 resultf = ::hls::nan("");
      }
      else{
 if(din.sign == 0){

   fp_struct<T> out;
   out.sign = 0;
   out.exp = fp_struct<T>::EXP_INFNAN;
   out.sig = 0;
   resultf = out.to_ieee();
 }
 else{
   resultf = ::hls::nan("");
 }
      }
    }
    else if((din.sign==1) or (din.exp<exp_bias)){

      resultf = ::hls::nan("");
    }
    else if((din.exp==exp_bias) and (din.sig==0)){

      resultf = (T)0.0;
    }
    else if((din.exp==exp_bias and din.sig>0) or
     (din.exp==exp_bias+1 and din.sig==0)){

      const T cst1 = 1.0;
      T t = t_in - cst1;
      T x1 = t + (T)hls::sqrt(t+t+t*t);
      resultf = hls::log1p(x1);
    }
    else{

      T x;
      if(din.exp < exp_bias+28){
 const T cst1 = 1.0;
 x = t_in + t_in - cst1/(t_in+(T)hls::sqrt(t_in*t_in-cst1));
      }
      else{
 x = t_in;
      }

      T logx = hls::log(x);

      if(din.exp < exp_bias+28){
 resultf = logx;
      }
      else{
 const T ln2 = 6.93147180559945286227e-01;
 resultf = logx + ln2;
      };
    };

    return resultf;
  };

  static
  float acosh(float t_in){
    return generic_acosh(t_in);
  };

  static
  double acosh(double t_in){
    return generic_acosh(t_in);
  };

  static
  half acosh(half t_in){
    return generic_acosh(t_in);
  };

  static
  float acoshf(float t_in){
    return generic_acosh(t_in);
  };

  static
  half half_acosh(half t_in){
    return generic_acosh(t_in);
  };

}
#1141 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_asinh.h" 1
#38 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_asinh.h"
namespace explog_based {

  template <class T>
  T generic_asinh(T x)
  {
    const T ONE_HERE = 1.0;
    const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
    const int E = fp_struct<T>::EXP_BITS;
    const double LN2 = 6.93147180559945286227e-01;
    T ln2_t(LN2);
    fp_struct<T> fx(x);
    fp_struct<T> fxa(x);
    fp_struct<T> fx2(x);
    fx2.exp+=1;
    fx2.sign=0;
    fxa.sign=0;
    T x_abs = fxa.to_ieee();
    T x2 = fx2.to_ieee();
#64 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_asinh.h"
    const int range_seg_exp = 28>>(64/W-1);
    fp_struct<T> ST1((T)1.0);
    ST1.exp += range_seg_exp;
    fp_struct<T> ST2((T)2.0);
    fp_struct<T> ST3((T)1.0);
    ST3.exp -= range_seg_exp;
    bool is1sg = false;
    bool is2sg = false;
    bool is3sg = false;

    if(fxa.exp == ((1<<E)-1))
      return x;
    else if( x_abs > ST1.to_ieee())
      is1sg = true;
    else if( x_abs > ST2.to_ieee())
      is2sg = true;
    else if( x_abs >= ST3.to_ieee())
      is3sg = true;
    else return x;

    T x_sqr = x*x;
    T in_sqrt = x_sqr+ONE_HERE;
    T out_sqrt = hls::sqrt( in_sqrt );

    T div2 = out_sqrt + x_abs;
    T div3 = out_sqrt + ONE_HERE;
    T inx_div = (T)0.0;
    T iny_div = (T)1.0;
    T out_div;
    if(is2sg){
      inx_div = ONE_HERE;
      iny_div = div2;
    }
    if(is3sg){
      inx_div = x_sqr;
      iny_div = div3;
    }
    out_div = inx_div / iny_div;

    T in_log,in_log1p, out_log;
    if(is1sg)
      in_log = x_abs;
    else
      in_log = x2+out_div;
    in_log1p = (T)1.0 + x_abs+out_div ;
    if(is3sg)
      out_log = hls::log(in_log1p);
    else
      out_log = hls::log(in_log);

    if(is1sg)
      out_log = out_log + ln2_t;

    fp_struct<T> fz(out_log);
    fz.sign = fx.sign;
    return fz.to_ieee();
  }

  static
  double asinh(double x)
  {
    return generic_asinh<double>(x);
  }

  static
  float asinhf(float x)
  {
    return generic_asinh<float>(x);
  }

  static
  half half_asinh(half x)
  {
    return generic_asinh<half>(x);
  }

  static
  float asinh(float x)
  {
    return generic_asinh<float>(x);
  }
  static
  half asinh(half x)
  {
    return generic_asinh<half>(x);
  }

}
#1142 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_math.h" 2

static double acosh(double t_in)
{
  return explog_based::acosh(t_in);
}

static float acosh(float t_in)
{
  return explog_based::acosh(t_in);
}

static half acosh(half t_in)
{
  return explog_based::acosh(t_in);
}

static double asinh(double t_in)
{
  return explog_based::asinh(t_in);
}

static float asinh(float t_in)
{
  return explog_based::asinh(t_in);
}

static half asinh(half t_in)
{
  return explog_based::asinh(t_in);
}


}
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_stream.h" 1
#79 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_stream.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/queue" 1 3
#59 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/queue" 3

#60 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/queue" 3





#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 1 3
#64 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

#91 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;





      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
#125 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      _Sequence c;

    public:




      explicit
      queue(const _Sequence& __c = _Sequence())
      : c(__c) { }
#148 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
 ;
 return c.front();
      }





      const_reference
      front() const
      {
 ;
 return c.front();
      }





      reference
      back()
      {
 ;
 return c.back();
      }





      const_reference
      back() const
      {
 ;
 return c.back();
      }
#210 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }
#236 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 c.pop_front();
      }
#251 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
    };
#264 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
#282 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }
#357 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;







    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;
      _Compare comp;

    public:




      explicit
      priority_queue(const _Compare& __x = _Compare(),
       const _Sequence& __s = _Sequence())
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }
#422 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         const _Sequence& __s = _Sequence())
 : c(__s), comp(__x)
        {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }
#459 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
 ;
 return c.front();
      }
#487 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }
#522 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }
#539 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3
    };
#556 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_queue.h" 3

}
#66 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/queue" 2 3
#80 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_stream.h" 2

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/typeinfo" 1 3
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/typeinfo" 3

#35 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/typeinfo" 3







#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
#83 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
#118 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/typeinfo" 3
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
#139 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
#155 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/typeinfo" 3
    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
#82 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_stream.h" 2
#91 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_stream.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 1 3
#45 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 3

#46 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 3

#pragma GCC visibility push(default)

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/include/stddef.h" 1 3 4
#50 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 2 3

#1 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/cxxabi_tweaks.h" 1 3
#34 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/cxxabi_tweaks.h" 3
namespace __cxxabiv1
{
  extern "C"
  {
#46 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/cxxabi_tweaks.h" 3
  __extension__ typedef int __guard __attribute__((mode (__DI__)));


  typedef void __cxa_vec_ctor_return_type;


  typedef void __cxa_cdtor_return_type;


  }
}
#52 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 2 3



namespace __cxxabiv1
{
  extern "C"
  {


  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);


  void*
  __cxa_vec_new(size_t __element_count, size_t __element_size,
  size_t __padding_size, __cxa_cdtor_type __constructor,
  __cxa_cdtor_type __destructor);

  void*
  __cxa_vec_new2(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*));

  void*
  __cxa_vec_new3(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*, size_t));


  __cxa_vec_ctor_return_type
  __cxa_vec_ctor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor);

  __cxa_vec_ctor_return_type
  __cxa_vec_cctor(void* __dest_array, void* __src_array,
    size_t __element_count, size_t __element_size,
    __cxa_cdtor_return_type (*__constructor) (void*, void*),
    __cxa_cdtor_type __destructor);


  void
  __cxa_vec_dtor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_cleanup(void* __array_address, size_t __element_count, size_t __s,
      __cxa_cdtor_type __destructor) throw();


  void
  __cxa_vec_delete(void* __array_address, size_t __element_size,
     size_t __padding_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_delete2(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*));

  void
  __cxa_vec_delete3(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*, size_t));

  int
  __cxa_guard_acquire(__guard*);

  void
  __cxa_guard_release(__guard*) throw();

  void
  __cxa_guard_abort(__guard*) throw();


  void
  __cxa_pure_virtual(void) __attribute__ ((__noreturn__));


  void
  __cxa_bad_cast();

  void
  __cxa_bad_typeid();


  int
  __cxa_atexit(void (*)(void*), void*, void*) throw();

  int
  __cxa_finalize(void*);
#185 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 3
  char*
  __cxa_demangle(const char* __mangled_name, char* __output_buffer,
   size_t* __length, int* __status);

  }
}






namespace __cxxabiv1
{

  class __fundamental_type_info : public std::type_info
  {
  public:
    explicit
    __fundamental_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__fundamental_type_info();
  };


  class __array_type_info : public std::type_info
  {
  public:
    explicit
    __array_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__array_type_info();
  };


  class __function_type_info : public std::type_info
  {
  public:
    explicit
    __function_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__function_type_info();

  protected:

    virtual bool
    __is_function_p() const;
  };


  class __enum_type_info : public std::type_info
  {
  public:
    explicit
    __enum_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__enum_type_info();
  };


  class __pbase_type_info : public std::type_info
  {
  public:
    unsigned int __flags;
    const std::type_info* __pointee;

    explicit
    __pbase_type_info(const char* __n, int __quals,
        const std::type_info* __type)
    : std::type_info(__n), __flags(__quals), __pointee(__type)
    { }

    virtual
    ~__pbase_type_info();


    enum __masks
      {
 __const_mask = 0x1,
 __volatile_mask = 0x2,
 __restrict_mask = 0x4,
 __incomplete_mask = 0x8,
 __incomplete_class_mask = 0x10
      };

  protected:
    __pbase_type_info(const __pbase_type_info&);

    __pbase_type_info&
    operator=(const __pbase_type_info&);


    virtual bool
    __do_catch(const std::type_info* __thr_type, void** __thr_obj,
        unsigned int __outer) const;

    inline virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };


  class __pointer_type_info : public __pbase_type_info
  {
  public:
    explicit
    __pointer_type_info(const char* __n, int __quals,
   const std::type_info* __type)
    : __pbase_type_info (__n, __quals, __type) { }


    virtual
    ~__pointer_type_info();

  protected:

    virtual bool
    __is_pointer_p() const;

    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  class __class_type_info;


  class __pointer_to_member_type_info : public __pbase_type_info
  {
  public:
    __class_type_info* __context;

    explicit
    __pointer_to_member_type_info(const char* __n, int __quals,
      const std::type_info* __type,
      __class_type_info* __klass)
    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }

    virtual
    ~__pointer_to_member_type_info();

  protected:
    __pointer_to_member_type_info(const __pointer_to_member_type_info&);

    __pointer_to_member_type_info&
    operator=(const __pointer_to_member_type_info&);


    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };


  class __base_class_type_info
  {
  public:
    const __class_type_info* __base_type;
    long __offset_flags;

    enum __offset_flags_masks
      {
 __virtual_mask = 0x1,
 __public_mask = 0x2,
 __hwm_bit = 2,
 __offset_shift = 8
      };


    bool
    __is_virtual_p() const
    { return __offset_flags & __virtual_mask; }

    bool
    __is_public_p() const
    { return __offset_flags & __public_mask; }

    ptrdiff_t
    __offset() const
    {



      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;
    }
  };


  class __class_type_info : public std::type_info
  {
  public:
    explicit
    __class_type_info (const char *__n) : type_info(__n) { }

    virtual
    ~__class_type_info ();






    enum __sub_kind
      {

 __unknown = 0,



 __not_contained,


 __contained_ambig,


 __contained_virtual_mask = __base_class_type_info::__virtual_mask,


 __contained_public_mask = __base_class_type_info::__public_mask,


 __contained_mask = 1 << __base_class_type_info::__hwm_bit,

 __contained_private = __contained_mask,
 __contained_public = __contained_mask | __contained_public_mask
      };

    struct __upcast_result;
    struct __dyncast_result;

  protected:

    virtual bool
    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;

    virtual bool
    __do_catch(const type_info* __thr_type, void** __thr_obj,
        unsigned __outer) const;

  public:


    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;







    inline __sub_kind
    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
        const __class_type_info* __src_type,
        const void* __src_ptr) const;
#453 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 3
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;





    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;
  };


  class __si_class_type_info : public __class_type_info
  {
  public:
    const __class_type_info* __base_type;

    explicit
    __si_class_type_info(const char *__n, const __class_type_info *__base)
    : __class_type_info(__n), __base_type(__base) { }

    virtual
    ~__si_class_type_info();

  protected:
    __si_class_type_info(const __si_class_type_info&);

    __si_class_type_info&
    operator=(const __si_class_type_info&);


    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __sub_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info*__dst, const void*__obj,
  __upcast_result& __restrict __result) const;
  };


  class __vmi_class_type_info : public __class_type_info
  {
  public:
    unsigned int __flags;
    unsigned int __base_count;




    __base_class_type_info __base_info[1];

    explicit
    __vmi_class_type_info(const char* __n, int ___flags)
    : __class_type_info(__n), __flags(___flags), __base_count(0) { }

    virtual
    ~__vmi_class_type_info();


    enum __flags_masks
      {
 __non_diamond_repeat_mask = 0x1,
 __diamond_shaped_mask = 0x2,
 __flags_unknown_mask = 0x10
      };

  protected:

    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;
  };
#557 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 3
  extern "C" void*
  __dynamic_cast(const void* __src_ptr,
   const __class_type_info* __src_type,
   const __class_type_info* __dst_type,
   ptrdiff_t __src2dst);




  extern "C" std::type_info*
  __cxa_current_exception_type() throw() __attribute__ ((__pure__));



  class __foreign_exception
  {
    virtual ~__foreign_exception() throw();
    virtual void __pure_dummy() = 0;
  };

}
#599 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 3
namespace abi = __cxxabiv1;

namespace __gnu_cxx
{
#615 "/opt/Xilinx/Vivado_HLS/2017.1/lnx64/tools/gcc/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cxxabi.h" 3
  class recursive_init_error: public std::exception
  {
  public:
    recursive_init_error() throw() { }
    virtual ~recursive_init_error() throw ();
  };
}


#pragma GCC visibility pop
#92 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_stream.h" 2



namespace hls {

template<typename __STREAM_T__>
class stream
{
  protected:
    std::string _name;
    std::deque<__STREAM_T__> _data;





  public:


    stream() {
        static unsigned _counter = 1;
        std::stringstream ss;

        char* _demangle_name = abi::__cxa_demangle(typeid(*this).name(), 0, 0, 0);
        if (_demangle_name) {
            _name = _demangle_name;
            free(_demangle_name);
        }
        else {
            _name = "hls_stream";
        }




        ss << _counter++;
        _name += "." + ss.str();
    }

    stream(const std::string name) {


        _name = name;
    }


  private:
    stream(const stream< __STREAM_T__ >& chn):
        _name(chn._name), _data(chn._data) {
    }

    stream& operator = (const stream< __STREAM_T__ >& chn) {
        _name = chn._name;
        _data = chn._data;
        return *this;
    }

  public:

    void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:


    virtual ~stream() {
        if (!_data.empty())
        {
            std::cout << "WARNING: Hls::stream '"
                      << _name
                      << "' contains leftover data,"
                      << " which may result in RTL simulation hanging."
                      << std::endl;
        }
    }


    bool empty() {



        return _data.empty();
    }

    bool full() const { return false; }


    void read(__STREAM_T__& head) {
        head = read();
    }
#202 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_stream.h"
    __STREAM_T__ read() {
        __STREAM_T__ elem;
        if (_data.empty()) {
            std::cout << "WARNING: Hls::stream '"
                      << _name
                      << "' is read while empty,"
                      << " which may result in RTL simulation hanging."
                      << std::endl;
            elem = __STREAM_T__();
        } else {
            elem = _data.front();
            _data.pop_front();
        }
        return elem;
    }



    void write(const __STREAM_T__& tail) {



        _data.push_back(tail);



    }


    bool read_nb(__STREAM_T__& head) {



        bool is_empty = _data.empty();
        if (is_empty) {
            head = __STREAM_T__();
        } else {
            __STREAM_T__ elem(_data.front());
            _data.pop_front();
            head = elem;
        }
        return !is_empty;
    }


    bool write_nb(const __STREAM_T__& tail) {
        bool is_full = full();
        write(tail);
        return !is_full;
    }


    size_t size() {
        return _data.size();
    }
};

}
#51 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2




#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_types.h" 1
#177 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_types.h"
template<int T> struct Type { typedef ap_int<T-12> name; static const int bitdepth = T-12; };
template<> struct Type<0> { typedef unsigned char name; static const int bitdepth = 8; };
template<> struct Type<1> { typedef char name; static const int bitdepth = 8; };
template<> struct Type<8> { typedef ap_uint<10> name; static const int bitdepth = 10; };
template<> struct Type<9> { typedef ap_int<10> name; static const int bitdepth = 10; };
template<> struct Type<10> { typedef ap_uint<12> name; static const int bitdepth = 12; };
template<> struct Type<11> { typedef ap_int<12> name; static const int bitdepth = 12; };
template<> struct Type<2> { typedef unsigned short name; static const int bitdepth = 16; };
template<> struct Type<3> { typedef short name; static const int bitdepth = 16; };
template<> struct Type<4> { typedef int name; static const int bitdepth = 32; };
template<> struct Type<5> { typedef float name; static const int bitdepth = 32; };
template<> struct Type<6> { typedef double name; static const int bitdepth = 64; };

template<typename PIXEL_T> struct pixel_op_type { typedef PIXEL_T T; };
template<> struct pixel_op_type<unsigned char> { typedef ap_uint<8> T; };
template<> struct pixel_op_type<char> { typedef ap_int<8> T; };
template<> struct pixel_op_type<unsigned short> { typedef ap_uint<16> T; };
template<> struct pixel_op_type<short> { typedef ap_int<16> T; };
template<> struct pixel_op_type<unsigned int> { typedef ap_uint<32> T; };
template<> struct pixel_op_type<int> { typedef ap_int<32> T; };
template<int W> struct pixel_op_type<ap_int<W> > { typedef ap_int<W> T; };
template<int W> struct pixel_op_type<ap_uint<W> > { typedef ap_uint<W> T; };
#225 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_types.h"
template<typename T> struct Name
{ static const int _min = -2147483647; static const int _max = 2147483647; };
template<> struct Name<unsigned char>
{ static const int _min = 0; static const int _max = 255; };
template<> struct Name<char>
{ static const int _min = -127; static const int _max = 127; };
template<> struct Name<unsigned short>
{ static const int _min = 0; static const int _max = 65535; };
template<> struct Name<short>
{ static const int _min = -32767; static const int _max = 32767; };
template<> struct Name<int>
{ static const int _min = -2147483647; static const int _max = 2147483647; };

template<typename T>
unsigned char Convert2uchar(T v)
{
    unsigned char result=0;
    if(v>=255)
    {
        result=255;
    }
    else if(v>=0&&v<255)
    {
        ap_fixed<9,9,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
char Convert2char(T v)
{
    char result=-127;
    if(v>=127)
    {
        result=127;
    }
    else if(v>=-127&&v<127)
    {
        ap_fixed<9,9,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
unsigned short Convert2ushort(T v)
{
    unsigned short result=0;
    if(v>=65535)
    {
        result=65535;
    }
    else if(v>=0&&v<65535)
    {
        ap_fixed<17,17,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
short Convert2short(T v)
{
    short result=-32767;
    if(v>=32767)
    {
        result=32767;
    }
    else if(v>=-32767&&v<32767)
    {
        ap_fixed<17,17,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
int Convert2int(T v)
{
    int result=-2147483647;
    if(v>=2147483647)
    {
        result=2147483647;
    }
    else if(v>=-2147483647&&v<2147483647)
    {
        ap_fixed<32,32,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
typedef ap_uint<12> HLS_SIZE_T;
typedef ap_uint<5> HLS_CHANNEL_T;

namespace hls {



template<typename T2> class sr_cast_class { };

template<> class sr_cast_class<float> {
public:
    template<typename T1>
    inline float operator()(T1 v) { return v; }
    inline float operator()(double v) { return xil_fpo_flttoflt_flt_d(v); }
};

template<> class sr_cast_class<double> {
public:
    template<typename T1>
    inline double operator()(T1 v) { return v; }
    inline double operator()(float v) { return xil_fpo_flttoflt_d_flt(v); }
};

template<int N2> class sr_cast_class<ap_int<N2> > {
public:
    template<int N1>
    inline ap_int<N2> operator()(ap_int<N1> v) {
        return ap_fixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template<int N1>
    inline ap_int<N2> operator()(ap_uint<N1> v) {
        return ap_fixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_int<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_int<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_int<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_int<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_int<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_int<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_int<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<int N2> class sr_cast_class<ap_uint<N2> > {
public:
    template<int N1>
    inline ap_uint<N2> operator()(ap_int<N1> v) {
        return ap_ufixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template<int N1>
    inline ap_uint<N2> operator()(ap_uint<N1> v) {
        return ap_ufixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_uint<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_uint<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_uint<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_uint<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_uint<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_uint<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_uint<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<> class sr_cast_class<unsigned char> : public sr_cast_class<ap_uint<8> > {
public:
    using sr_cast_class<ap_uint<8> >::operator();
};

template<> class sr_cast_class<char> : public sr_cast_class<ap_int<8> > {
public:
    using sr_cast_class<ap_int<8> >::operator();
};

template<> class sr_cast_class<unsigned short> : public sr_cast_class<ap_uint<16> > {
public:
    using sr_cast_class<ap_uint<16> >::operator();
};

template<> class sr_cast_class<short> : public sr_cast_class<ap_int<16> > {
public:
    using sr_cast_class<ap_int<16> >::operator();
};

template<> class sr_cast_class<unsigned int> : public sr_cast_class<ap_uint<32> > {
public:
    using sr_cast_class<ap_uint<32> >::operator();
};

template<> class sr_cast_class<int> : public sr_cast_class<ap_int<32> > {
public:
    using sr_cast_class<ap_int<32> >::operator();
};

template<> class sr_cast_class<unsigned long long> : public sr_cast_class<ap_uint<64> > {
public:
    using sr_cast_class<ap_uint<64> >::operator();
};

template<> class sr_cast_class<long long> : public sr_cast_class<ap_int<64> > {
public:
    using sr_cast_class<ap_int<64> >::operator();
};

template<typename T2, typename T1> inline T2 sr_cast(T1 v)
{
    ::hls::sr_cast_class<T2> V;
    return V(v);
}


typedef struct{
  unsigned char Y;
  char UV;
}yuv422_8;

typedef struct{
  unsigned char Y;
  char U;
  char V;
}yuv444_8;

typedef struct{
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgb_8;

typedef yuv422_8 yuv420_8;

typedef struct{
  char A;
  unsigned char Y;
  char UV;
}yuva422_8;

typedef struct{
  char A;
  unsigned char Y;
  char U;
  char V;
}yuva444_8;

typedef struct{
  char A;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgba_8;

typedef struct{
  char AUV;
  unsigned char Y;
}yuva420_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char UV;
}yuvd422_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char U;
  char V;
}yuvd444_8;

typedef struct{
  unsigned char D;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgbd_8;

typedef yuvd422_8 yuvd420_8;

typedef struct{
  unsigned char CMY;
}bayer_8;

typedef struct{
  unsigned char Y;
}luma_8;

}
#56 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h" 1
#45 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
namespace hls {


template<int ROWS, int COLS, typename T>
class Window {
public:
    Window() {
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
#pragma HLS ARRAY_PARTITION variable=val dim=2 complete
    };


    void shift_pixels_left();
    void shift_pixels_right();
    void shift_pixels_up();
    void shift_pixels_down();
    void insert_pixel(T value, int row, int col);
    void insert_row(T value[COLS], int row);
    void insert_top_row(T value[COLS]);
    void insert_bottom_row(T value[COLS]);
    void insert_col(T value[ROWS], int col);
    void insert_left_col(T value[ROWS]);
    void insert_right_col(T value[ROWS]);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_left();
    void shift_right();
    void shift_up();
    void shift_down();
    void insert(T value, int row, int col);
    void insert_top(T value[COLS]);
    void insert_bottom(T value[COLS]);
    void insert_left(T value[ROWS]);
    void insert_right(T value[ROWS]);



    T val[ROWS][COLS];





};
#113 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_left() {
#pragma HLS inline







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
        for(j = 0; j < COLS-1; j++) {
#pragma HLS unroll
            val[i][j] = val[i][j+1];
        }
    }
#145 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_right() {
#pragma HLS inline







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
        for(j = COLS-1; j > 0; j--) {
#pragma HLS unroll
            val[i][j] = val[i][j-1];
        }
    }
#183 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_up() {
#pragma HLS inline







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS-1; i++) {
#pragma HLS unroll
        for(j = 0; j < COLS; j++) {
#pragma HLS unroll
            val[i][j] = val[i+1][j];
        }
    }
#221 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_down() {
#pragma HLS inline







    HLS_SIZE_T i, j;
    for(i = ROWS-1; i > 0; i--) {
#pragma HLS unroll
        for(j = 0; j < COLS; j++) {
#pragma HLS unroll
            val[i][j] = val[i-1][j];
        }
    }
#259 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {
#pragma HLS inline
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 266, __PRETTY_FUNCTION__));







    val[row][col] = value;
#291 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {
#pragma HLS inline







    HLS_SIZE_T j;
    for(j = 0; j < COLS; j++) {
#pragma HLS unroll
        val[row][j] = value[j];
    }
#326 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {
#pragma HLS inline







    insert_row(value, 0);
#357 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {
#pragma HLS inline







    insert_row(value, ROWS-1);
#388 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {
#pragma HLS inline







    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
        val[i][col] = value[i];
    }
#423 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {
#pragma HLS inline







    insert_col(value, 0);
#454 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {
#pragma HLS inline







    insert_col(value, COLS-1);
#485 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::getval(int row, int col) {
#pragma HLS inline
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 492, __PRETTY_FUNCTION__));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::operator ()(int row, int col) {
#pragma HLS inline
    return getval(row, col);
}
#531 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_left() {
#pragma HLS inline
    shift_pixels_left();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_right() {
#pragma HLS inline
    shift_pixels_right();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_up() {
#pragma HLS inline
    shift_pixels_up();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_down() {
#pragma HLS inline
    shift_pixels_down();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert(T value, int row, int col) {
#pragma HLS inline
    insert_pixel(value, row, col);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top(T value[COLS]) {
#pragma HLS inline
    insert_bottom_row(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {
#pragma HLS inline
    insert_top_row(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {
#pragma HLS inline
    insert_right_col(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {
#pragma HLS inline
    insert_left_col(value);
}


template<int ROWS, int COLS, typename T, int RESHAPE=0>
class LineBuffer;

template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 0> {
public:
    LineBuffer() {
#pragma HLS array_partition variable=val dim=1 complete
#pragma HLS dependence variable=val inter false
#pragma HLS dependence variable=val intra false
    };

    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);



    T val[ROWS][COLS];





};
#676 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_down(int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 678, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = ROWS-1; i > 0; i--) {
#pragma HLS unroll
        val[i][col] = val[i-1][col];
    }
#710 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_up(int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 718, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = 0; i < ROWS-1; i++) {
#pragma HLS unroll
        val[i][col] = val[i+1][col];
    }
#750 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom_row(T value, int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 757, __PRETTY_FUNCTION__));







    val[ROWS-1][col] = value;
#782 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top_row(T value, int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 789, __PRETTY_FUNCTION__));







    val[0][col] = value;
#814 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::get_col(T value[ROWS], int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 821, __PRETTY_FUNCTION__));
    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
        value[i] = val[i][col];
    }
}




template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::getval(int row, int col) {
#pragma HLS inline
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 834, __PRETTY_FUNCTION__));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::operator ()(int row, int col) {
#pragma HLS inline
    return getval(row, col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_down(int col) {
#pragma HLS inline
    shift_pixels_down(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_up(int col) {
#pragma HLS inline
    shift_pixels_up(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom(T value, int col) {
#pragma HLS inline
    insert_top_row(value, col);
}






template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top(T value, int col) {
#pragma HLS inline
    insert_bottom_row(value, col);
}
#907 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 1> {
public:
    LineBuffer() {
#pragma HLS array_reshape variable=val dim=1
#pragma HLS dependence variable=val inter false
#pragma HLS dependence variable=val intra false
    };

    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);



    T val[ROWS][COLS];





};
#964 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_down(int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 966, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = ROWS-1; i > 0; i--) {
#pragma HLS unroll
        val[i][col] = val[i-1][col];
    }
#998 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_up(int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 1006, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = 0; i < ROWS-1; i++) {
#pragma HLS unroll
        val[i][col] = val[i+1][col];
    }
#1038 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom_row(T value, int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 1045, __PRETTY_FUNCTION__));







    val[ROWS-1][col] = value;
#1070 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top_row(T value, int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 1077, __PRETTY_FUNCTION__));







    val[0][col] = value;
#1102 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::get_col(T value[ROWS], int col) {
#pragma HLS inline
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 1109, __PRETTY_FUNCTION__));
    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
        value[i] = val[i][col];
    }
}




template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::getval(int row, int col) {
#pragma HLS inline
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h", 1122, __PRETTY_FUNCTION__));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::operator ()(int row, int col) {
#pragma HLS inline
    return getval(row, col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_down(int col) {
#pragma HLS inline
    shift_pixels_down(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_up(int col) {
#pragma HLS inline
    shift_pixels_up(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom(T value, int col) {
#pragma HLS inline
    insert_top_row(value, col);
}






template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top(T value, int col) {
#pragma HLS inline
    insert_bottom_row(value, col);
}
#1194 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_mem.h"
}
#57 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h" 1
#84 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h"
namespace hls {


template<typename T>
class Point_ {
public:
    Point_();
    Point_(T _x, T _y);
    Point_(const Point_& pt);
    ~Point_();

    T x, y;
};


template<typename T> inline Point_<T>::Point_() {}
template<typename T> inline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}
template<typename T> inline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}
template<typename T> inline Point_<T>::~Point_() {}

typedef Point_<int> Point;



template<typename T>
class Size_ {
public:
    Size_();
    Size_(T _width, T _height);
    Size_(const Size_<T>& sz);
    Size_(const Point_<T>& pt);
    T area();
    ~Size_();

    T width, height;
};


template<typename T> inline Size_<T>::Size_() {}
template<typename T> inline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}
template<typename T> inline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}
template<typename T> inline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}
template<typename T> inline T Size_<T>::area() { return width*height; }
template<typename T> inline Size_<T>::~Size_() {}

typedef Size_<int> Size;



template<typename T>
class Rect_ {
public:
    Rect_();
    Rect_(T _x, T _y, T _width, T _height);
    Rect_(const Rect_& rect);
    Rect_(const Point_<T>& pt, const Size_<T>& sz);
    T area();
    Size_<T> size();
    Point_<T> tl();
    Point_<T> tr();
    Point_<T> bl();
    Point_<T> br();
    bool bContains(const Point_<T>& pt);
    ~Rect_();

    T x, y, width, height;
};


template<typename T> inline Rect_<T>::Rect_() {}
template<typename T> inline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}
template<typename T> inline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}
template<typename T> inline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz) : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}
template<typename T> inline T Rect_<T>::area() { return width*height; }
template<typename T> inline Size_<T> Rect_<T>::size() { return Size_<T>(width, height); }
template<typename T> inline Point_<T> Rect_<T>::tl() { return Point_<T>(x, y); }
template<typename T> inline Point_<T> Rect_<T>::tr() { return Point_<T>(x+width, y); }
template<typename T> inline Point_<T> Rect_<T>::bl() { return Point_<T>(x, y+height); }
template<typename T> inline Point_<T> Rect_<T>::br() { return Point_<T>(x+width, y+height); }
template<typename T> inline bool Rect_<T>::bContains(const Point_<T>& pt) { return (pt.x >= x && pt.x < x+width && pt.y >= y && pt.y < y+height); }
template<typename T> inline Rect_<T>::~Rect_() {}

typedef Rect_<int> Rect;



template<int N, typename T>
class Scalar {
public:
    Scalar() {
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
        ((N > 0) ? static_cast<void> (0) : __assert_fail ("N > 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h", 175, __PRETTY_FUNCTION__));
    }
    Scalar(T v0) {
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
        ((N >= 1 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 1 && \"Scalar must have enough channels for constructor.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h", 179, __PRETTY_FUNCTION__));
        val[0] = v0;
    }
    Scalar(T v0, T v1) {
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
        ((N >= 2 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 2 && \"Scalar must have enough channels for constructor.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h", 184, __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1;
    }
    Scalar(T v0, T v1, T v2) {
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
        ((N >= 3 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 3 && \"Scalar must have enough channels for constructor.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h", 189, __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1; val[2] = v2;
    }
    Scalar(T v0, T v1, T v2, T v3) {
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
        ((N >= 4 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 4 && \"Scalar must have enough channels for constructor.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h", 194, __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    }

    void operator = (T value);
    Scalar<N, T> operator + (T value);
    Scalar<N, T> operator + (Scalar<N, T> s);
    Scalar<N, T> operator - (T value);
    Scalar<N, T> operator - (Scalar<N, T> s);
    Scalar<N, T> operator * (T value);
    Scalar<N, T> operator * (Scalar<N, T> s);
    Scalar<N, T> operator / (T value);
    Scalar<N, T> operator / (Scalar<N, T> s);

    T val[N];
};

template<int N, typename T>
void Scalar<N, T>::operator = (T value) {
#pragma HLS inline
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        val[k] = value;
    }
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (T value) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] + value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (Scalar<N, T> s) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] + s.val[k];
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (T value) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] - value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (Scalar<N, T> s) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] - s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (T value) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] * value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (Scalar<N, T> s) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] * s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (T value) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] / value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (Scalar<N, T> s) {
#pragma HLS inline
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
#pragma HLS unroll
        res.val[k] = val[k] / s.val[k];
    }
    return res;
}





template<typename T>
yuv422_8 Scalar_to_yuv422_8(Scalar<2, T> scl) {
#pragma HLS inline
    yuv422_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.UV = (char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuv422_8_to_Scalar(yuv422_8 pix) {
#pragma HLS inline
    Scalar<2, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.UV;
    return scl;
}


template<typename T>
yuv444_8 Scalar_to_yuv444_8(Scalar<3, T> scl) {
#pragma HLS inline
    yuv444_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.U = (char)scl.val[1];
    pix.V = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuv444_8_to_Scalar(yuv444_8 pix) {
#pragma HLS inline
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.U;
    scl.val[2] = (T)pix.V;
    return scl;
}


template<typename T>
rgb_8 Scalar_to_rgb_8(Scalar<3, T> scl) {
#pragma HLS inline
    rgb_8 pix;
    pix.R = (unsigned char)scl.val[0];
    pix.G = (unsigned char)scl.val[1];
    pix.B = (unsigned char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> rgb_8_to_Scalar(rgb_8 pix) {
#pragma HLS inline
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.R;
    scl.val[1] = (T)pix.G;
    scl.val[2] = (T)pix.B;
    return scl;
}


template<typename T>
yuva422_8 Scalar_to_yuva422_8(Scalar<3, T> scl) {
#pragma HLS inline
    yuva422_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuva422_8_to_Scalar(yuva422_8 pix) {
#pragma HLS inline
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}


template<typename T>
yuva444_8 Scalar_to_yuva444_8(Scalar<4, T> scl) {
#pragma HLS inline
    yuva444_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuva444_8_to_Scalar(yuva444_8 pix) {
#pragma HLS inline
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}


template<typename T>
rgba_8 Scalar_to_rgba_8(Scalar<4, T> scl) {
#pragma HLS inline
    rgba_8 pix;
    pix.A = (char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgba_8_to_Scalar(rgba_8 pix) {
#pragma HLS inline
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}


template<typename T>
yuva420_8 Scalar_to_yuva420_8(Scalar<2, T> scl) {
#pragma HLS inline
    yuva420_8 pix;
    pix.AUV = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuva420_8_to_Scalar(yuva420_8 pix) {
#pragma HLS inline
    Scalar<2, T> scl;
    scl.val[0] = (T)pix.AUV;
    scl.val[1] = (T)pix.Y;
    return scl;
}


template<typename T>
yuvd422_8 Scalar_to_yuvd422_8(Scalar<3, T> scl) {
#pragma HLS inline
    yuvd422_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuvd422_8_to_Scalar(yuvd422_8 pix) {
#pragma HLS inline
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}


template<typename T>
yuvd444_8 Scalar_to_yuvd444_8(Scalar<4, T> scl) {
#pragma HLS inline
    yuvd444_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuvd444_8_to_Scalar(yuvd444_8 pix) {
#pragma HLS inline
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}


template<typename T>
rgbd_8 Scalar_to_rgbd_8(Scalar<4, T> scl) {
#pragma HLS inline
    rgbd_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgbd_8_to_Scalar(rgbd_8 pix) {
#pragma HLS inline
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}


template<typename T>
bayer_8 Scalar_to_bayer_8(Scalar<1, T> scl) {
#pragma HLS inline
    bayer_8 pix;
    pix.CMY = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> bayer_8_to_Scalar(bayer_8 pix) {
#pragma HLS inline
    Scalar<1, T> scl;
    scl.val[0] = (T)pix.CMY;
    return scl;
}


template<typename T>
luma_8 Scalar_to_luma_8(Scalar<1, T> scl) {
#pragma HLS inline
    luma_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> luma_8_to_Scalar(luma_8 pix) {
#pragma HLS inline
    Scalar<1, T> scl;
    scl.val[0] = (T)pix.Y;
    return scl;
}



template<int ROWS, int COLS, int T>
class Mat {
public:
    Mat();
    Mat(int _rows, int _cols);
    Mat(Size _sz);

    void init(int _rows, int _cols);
    void assignto(Mat<ROWS, COLS, T>& mat);

    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> read();
    void read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s);
    void write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s);
    void operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s);
    void operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s);
    bool empty();

    const int type() const;
    const int depth() const;
    const int channels() const;

    HLS_SIZE_T rows, cols;

    hls::stream<typename Type<((T) & ((1 << 11) - 1))>::name> data_stream[((((T) & ((512 - 1) << 11)) >> 11) + 1)];
};


template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat() {
#pragma HLS inline
    init(ROWS, COLS);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(int _rows, int _cols) {
#pragma HLS inline
    init(_rows, _cols);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(Size _sz) {
#pragma HLS inline
    init(_sz.height, _sz.width);
}

template<int ROWS, int COLS, int T>
inline void Mat<ROWS, COLS, T>::init(int _rows, int _cols) {
#pragma HLS inline
    (((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && "The number of rows and columns must be less than the template arguments.") ? static_cast<void> (0) : __assert_fail ("(_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && \"The number of rows and columns must be less than the template arguments.\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h"
#599 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h"
    ,
 600
#599 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h"
    , __PRETTY_FUNCTION__))
                                                                                      ;
    rows = _rows;
    cols = _cols;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::assignto(Mat<ROWS, COLS, T>& mat) {
#pragma HLS inline
    mat.rows = rows;
    mat.cols = cols;
}

template<int ROWS, int COLS, int T>
Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> Mat<ROWS, COLS, T>::read() {
#pragma HLS inline
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scl;
    HLS_CHANNEL_T i;
    {



#pragma HLS protocol floating
        for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
#pragma HLS unroll
            data_stream[i] >> scl.val[i];
        }
    }
    return scl;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
#pragma HLS inline
    s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
#pragma HLS inline
#pragma HLS data_pack variable=data_stream
    HLS_CHANNEL_T i;
    {



#pragma HLS protocol floating
        for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
#pragma HLS unroll
            data_stream[i] << s.val[i];
        }
    }
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
#pragma HLS inline
    s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
#pragma HLS inline
    write(s);
}

template<int ROWS, int COLS, int T>
bool Mat<ROWS, COLS, T>::empty() {
#pragma HLS inline
    unsigned char flag = 0;
    for (HLS_CHANNEL_T i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
#pragma HLS unroll
        flag += (data_stream[i].empty()) ? 1 : 0;
    }
    ((flag == ((((T) & ((512 - 1) << 11)) >> 11) + 1) || flag == 0 && "Some channels are empty but others are not.") ? static_cast<void> (0) : __assert_fail ("flag == HLS_MAT_CN(T) || flag == 0 && \"Some channels are empty but others are not.\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h"
#673 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h"
    ,
 674
#673 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_core.h"
    , __PRETTY_FUNCTION__))
                                                         ;
    return ((flag == ((((T) & ((512 - 1) << 11)) >> 11) + 1)) ? true : false);
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::type() const {
#pragma HLS inline
    return ((T) & ((1 << 11)*512 - 1));
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::depth() const {
#pragma HLS inline
    return ((T) & ((1 << 11) - 1));
}
template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::channels() const {
#pragma HLS inline
    return ((((T) & ((512 - 1) << 11)) >> 11) + 1);
}

}
#58 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h" 1
#86 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h"
namespace hls {

enum {MORPH_RECT,MORPH_CROSS,MORPH_ELLIPSE};

class border_mode {
public:
    enum values {BORDER_CONSTANT,BORDER_REPLICATE,BORDER_REFLECT,BORDER_WRAP,BORDER_REFLECT_101};
    typedef void isBorderMode;
};

class BORDER_CONSTANT : public border_mode { public: static const values value = border_mode::BORDER_CONSTANT; };
class BORDER_REPLICATE : public border_mode { public: static const values value = border_mode::BORDER_REPLICATE; };
class BORDER_REFLECT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT; };
class BORDER_WRAP : public border_mode { public: static const values value = border_mode::BORDER_WRAP; };
class BORDER_REFLECT_101 : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101; };
class BORDER_DEFAULT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101; };
#113 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h"
static int borderInterpolate( int p, int len, int borderType )
{
#pragma HLS INLINE
    ((borderType != BORDER_WRAP::value && "BORDER_WRAP is not supported.") ? static_cast<void> (0) : __assert_fail ("borderType != BORDER_WRAP::value && \"BORDER_WRAP is not supported.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h", 116, __PRETTY_FUNCTION__));

    if( p >= 0 && p < len )
        return p;
    else if( borderType == BORDER_REPLICATE::value )
        p = p < 0 ? 0 : len - 1;
    else if( borderType == BORDER_REFLECT::value)
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {
            p=-p-1;
        }
        if( p >= len )
        {
            p=2*len-p-1;
        }
    }
    else if(borderType == BORDER_REFLECT_101::value )
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {

            p=-p;
        }
        if( p >= len )
        {

            p=2*len-p-2;
        }
    }

    else if( borderType == BORDER_CONSTANT::value )
        p = -1;
    return p;
}

template <typename anchor_T,typename kernel_T>
inline void normalizeAnchor(
        hls::Point_<anchor_T> &anchor,
        hls::Size_<kernel_T> kernel_size)
{
#pragma HLS INLINE
    if(anchor.x==-1)
        anchor.x=kernel_size.width/2;
    if(anchor.y==-1)
        anchor.y=kernel_size.height/2;

    ((anchor.x>=0) ? static_cast<void> (0) : __assert_fail ("anchor.x>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h", 167, __PRETTY_FUNCTION__));
    ((anchor.x<=kernel_size.width-1) ? static_cast<void> (0) : __assert_fail ("anchor.x<=kernel_size.width-1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h", 168, __PRETTY_FUNCTION__));
    ((anchor.y>=0) ? static_cast<void> (0) : __assert_fail ("anchor.y>=0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h", 169, __PRETTY_FUNCTION__));
    ((anchor.y<=kernel_size.height-1) ? static_cast<void> (0) : __assert_fail ("anchor.y<=kernel_size.height-1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgbase.h", 170, __PRETTY_FUNCTION__));
}
template<int SRC_T,int ROWS,int COLS>
void DuplicateImageN(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, SRC_T> _dst[],
  int num
                )
{
    int cols=_src.cols;
    int rows=_src.rows;
 loop_size: for(int k=0;k<num;k++) {
        _dst[k].rows=rows;
        _dst[k].cols=cols;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for(int i= 0;i<rows;i++)
 {
#pragma HLS LOOP_TRIPCOUNT min=20 max=2000
    loop_width: for (int j= 0;j<cols;j++)
#pragma HLS LOOP_TRIPCOUNT min=20 max=2000
  {
#pragma HLS PIPELINE
                        _src >> s;
                        for(int k=0;k<num;k++)
                        _dst[k] << s;
                }
        }
}
}
#59 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h"
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_axi_io.h" 1
#40 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h" 2

namespace hls {
#50 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h"
template<int W, int ROWS, int COLS, int T>
int AXIvideo2Mat(stream<ap_axiu<W,1,1,1> >& AXI_video_strm,
                 Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    ap_axiu<W,1,1,1> axi;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;

    ((W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("W >= depth*HLS_MAT_CN(T) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 59, __PRETTY_FUNCTION__));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 62, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 63, __PRETTY_FUNCTION__));
    bool sof = 0;
 loop_wait_for_start: while (!sof) {
#pragma HLS pipeline II=1
#pragma HLS loop_tripcount avg=0 max=0
        AXI_video_strm >> axi;
        sof = axi.user.to_int();
    }
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
        bool eol = 0;
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            if (sof || eol) {
                sof = 0;
                eol = axi.last.to_int();
            } else {

                AXI_video_strm >> axi;
                eol = axi.last.to_int();
                bool user = axi.user.to_int();
                if(user) {
                    res |= (1 << 0);
                }
            }
            if (eol && (j != cols-1)) {
                res |= (1 << 0);
            }
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXIGetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    loop_wait_for_eol: while (!eol) {
#pragma HLS pipeline II=1
#pragma HLS loop_tripcount avg=0 max=0

            AXI_video_strm >> axi;
            eol = axi.last.to_int();
            res |= (1 << 1);
        }
    }
    return res;
}



template<int W, int ROWS, int COLS, int T>
int Mat2AXIvideo(Mat<ROWS, COLS, T>& img,
                 stream<ap_axiu<W,1,1,1> >& AXI_video_strm)
{
    int res = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    ap_axiu<W,1,1,1> axi;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;

    ((W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("W >= depth*HLS_MAT_CN(T) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 119, __PRETTY_FUNCTION__));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 122, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 123, __PRETTY_FUNCTION__));
    bool sof = 1;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            if (sof) {
                axi.user = 1;
                sof = 0;
            } else {
                axi.user = 0;
            }
            if (j == (cols-1)) {
                axi.last = 1;
            } else {
                axi.last = 0;
            }
            img >> pix;
            axi.data = -1;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXISetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            axi.keep = -1;
            AXI_video_strm << axi;
        }
    }
    return res;
}




template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((cols <= rowStride) ? static_cast<void> (0) : __assert_fail ("cols <= rowStride", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 162, __PRETTY_FUNCTION__));
    ((rowStride <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("rowStride <= FB_COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 163, __PRETTY_FUNCTION__));
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 164, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 165, __PRETTY_FUNCTION__));
    ((COLS <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("COLS <= FB_COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 166, __PRETTY_FUNCTION__));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    ((fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 170, __PRETTY_FUNCTION__));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        for (HLS_SIZE_T col = 0; col < cols; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            FB_T fb_pix = fb[row*rowStride+col];
            ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            AXISetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
                AXIGetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS],
              Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS],
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, rowStride, img);
    return res;
}



template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((cols <= rowStride) ? static_cast<void> (0) : __assert_fail ("cols <= rowStride", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 228, __PRETTY_FUNCTION__));
    ((rowStride <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("rowStride <= FB_COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 229, __PRETTY_FUNCTION__));
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 230, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 231, __PRETTY_FUNCTION__));
    ((COLS <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("COLS <= FB_COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 232, __PRETTY_FUNCTION__));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    ((fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_io.h", 236, __PRETTY_FUNCTION__));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        for (HLS_SIZE_T col = 0; col < cols; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            img >> pix;
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
                AXISetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            FB_T fb_pix;
            AXIGetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
            fb[row*rowStride+col] = fb_pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
              FB_T fb[ROWS*FB_COLS])
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS])
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, rowStride);
    return res;
}

}
#60 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2

#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h" 1
#88 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
namespace hls {
#111 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
typedef ap_fixed<64,32,AP_RND> _AP_T;
typedef unsigned long long _SUM_T;

class kernel_min {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline

        if(src1<src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_max {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline

        if(src1>src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_absdiff {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        typename pixel_op_type<SRC1_T>::T src1_cast = src1;
        typename pixel_op_type<SRC2_T>::T src2_cast = src2;
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T >::ADD_T TEMP_TYPE;
        TEMP_TYPE diff = src1_cast-src2_cast;
        TEMP_TYPE mdiff = src2_cast-src1_cast;
        dst = sr_cast<DST_T>((src1_cast > src2_cast) ? diff : mdiff);
    }
};

template<typename P_T, typename SRC1_T, typename SRC2_T, typename DST_T>
void kernel_and_apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst) {
#pragma HLS inline
    dst = (sr_cast<DST_T>(src1)) & (sr_cast<DST_T>(src2));
}

template<typename P_T>
void kernel_and_apply(float& src1, float& src2, float& dst) {
#pragma HLS inline
    fp_struct<float> src1_fp(src1);
    fp_struct<float> src2_fp(src2);
    unsigned int dst_tmp = src1_fp.to_int() & src2_fp.to_int();
    fp_struct<float> dst_fp(dst_tmp);
    dst = dst_fp.to_float();
}

class kernel_and {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        kernel_and_apply<P_T>(src1, src2, dst);
    }
};

class kernel_not {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        dst = ~(sr_cast<DST_T>(src));
    }
};

class kernel_set {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        dst = sr_cast<DST_T>(val);
    }
};

class kernel_scale {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T;
        typedef typename x_traits<typename pixel_op_type<P_T>::T, MULT_T>::ADD_T ADD_T;
        MULT_T mult_t=(typename pixel_op_type<SRC1_T>::T)src * (typename pixel_op_type<P_T>::T)p0;
        ADD_T sum_t=mult_t + (typename pixel_op_type<P_T>::T)p1;

        dst = sr_cast<DST_T>(sum_t);
    }
};

class kernel_add {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::ADD_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 + (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_sub {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 - (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_subR {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC2_T>::T)src2 - (typename pixel_op_type<SRC1_T>::T)src1;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_mul {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T, typename P2_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P2_T p1=0, P2_T p2=0) {
#pragma HLS inline
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T MULT_T;
        MULT_T t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;
        typename x_traits<MULT_T, typename pixel_op_type<P_T>::T>::MULT_T t2 = t1 * (typename pixel_op_type<P_T>::T)p0;

        dst = sr_cast<DST_T>(t2);
    }
};

class kernel_mul2 {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;

        dst = sr_cast<DST_T>(t);
    }
};

class kernel_addWeighted {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T1;
        MULT_T1 t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<P_T>::T)p0;
        typedef typename x_traits<typename pixel_op_type<SRC2_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T2;
        MULT_T2 t2 = (typename pixel_op_type<SRC2_T>::T)src2 * (typename pixel_op_type<P_T>::T)p1;
        typedef typename x_traits<MULT_T1, MULT_T2>::ADD_T ADD_T;
        ADD_T sum = t1 + t2 + p2;

        dst = sr_cast<DST_T>(sum);
    }
};

class kernel_cmp {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
        switch (p0) {
            case 0:
            dst = (src1==src2 ? 255 : 0);
            break;
            case 1:
            dst = (src1 >src2 ? 255 : 0);
            break;
            case 2:
            dst = (src1>=src2 ? 255 : 0);
            break;
            case 3:
            dst = (src1 <src2 ? 255 : 0);
            break;
            case 4:
            dst = (src1<=src2 ? 255 : 0);
            break;
            case 5:
            dst = (src1!=src2 ? 255 : 0);
            break;
            default:
            break;
        }
    }
};

class kernel_sum {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
#pragma HLS inline
        sum = sum+(_SUM_T)s;
    }
};

class kernel_avgsdv {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
#pragma HLS inline
        sum=sum+ (_SUM_T)s;
        sqsum=sqsum+ ((_SUM_T)s*(_SUM_T)s);
    }
};



template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 350, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 351, __PRETTY_FUNCTION__));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name > d;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src1 >> s1;
            src2 >> s2;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s1.val[k], s2.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 381, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 382, __PRETTY_FUNCTION__));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src1 >> s1;
            src2 >> s2;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {
                    opr.template apply(s1.val[k], s2.val[k], d.val[k]);
                }
            }
            dst << d;
        }
    }
}



template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 421, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 422, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {

                opr.template apply(s.val[k], _s.val[k], d.val[k], p0, p1, p2);

            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 454, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 455, __PRETTY_FUNCTION__));
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            _T s = 0;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s, _s.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 484, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 485, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {

                    opr.template apply(s.val[k], _s.val[k], d.val[k]);

                }
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 522, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 523, __PRETTY_FUNCTION__));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
            }
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum,
            int& ncount,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 554, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 555, __PRETTY_FUNCTION__));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    ncount = 0;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            mask >> m;
            if (m.val[0]) {
            loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
                }
                ncount++;
            }
        }
    }
}


template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void reduce_opr(
        Mat<ROWS, COLS, SRC_T> &src,
        Mat<DST_ROWS, DST_COLS, DST_T> &dst,
        int dim,
        int op=1)
{
    LineBuffer<1,DST_COLS,INTER_SUM_T> dst_buffer[((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)];
#pragma HLS ARRAY_PARTITION variable=dst_buffer complete dim=1
#pragma HLS ARRAY_PARTITION variable=dst_buffer complete dim=2
    HLS_SIZE_T rows=src.rows;
    HLS_SIZE_T cols=src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 593, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 594, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),INTER_SUM_T> internal;
 loop_init: for(HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        internal.val[k]=0;
    }
 loop_height: for(HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
        loop_channels: for(HLS_CHANNEL_T k= 0;k< ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_val;
                src.data_stream[k]>>src_val;
                if(dim==0) {
                    if(i!=0) {
                        internal.val[k]=(INTER_SUM_T)dst_buffer[k].val[i][0];
                    } else {
                        if(op==1||op==2)
                            internal.val[k]=0;
                        else if(op==3||op==4)
                            internal.val[k]=src_val;
                    }
                }
                switch (op) {
                    case 1:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 2:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 3:
                    internal.val[k]=(internal.val[k]>(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
                    case 4:
                    internal.val[k]=(internal.val[k]<(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
  }
                if(dim==0) {
                    if(i==rows-1) {
                        if(op==2)
                            dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/rows;
                        else
                            dst.data_stream[k]<< (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    } else {
                        dst_buffer[k].val[i][0]=internal.val[k];
                    }
                }
            }
            if(dim==1&&j==cols-1) {
            loop_output: for(HLS_CHANNEL_T k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                    if(op==2) {
                        dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/cols;
                    } else {
                        dst.data_stream[k] << (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    }
                    internal.val[k]=0;
                }
            }
        }
    }
}



template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Min(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#664 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 666
#664 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#667 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 669
#667 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_min>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Max(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#679 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 681
#679 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#682 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 684
#682 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_max>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MinS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#694 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 695
#694 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#696 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 697
#696 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        scl.val[k] = (value);
    }
    arithm_pro<kernel_min>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MaxS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#712 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 713
#712 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#714 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 715
#714 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        scl.val[k] = (value);
    }
    arithm_pro<kernel_max>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#730 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 731
#730 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#732 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 733
#732 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    arithm_pro<kernel_add>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#745 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 746
#745 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#747 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 748
#747 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    arithm_pro<kernel_add>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#758 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 759
#758 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#760 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 761
#760 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    arithm_pro<kernel_sub>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#773 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 774
#773 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#775 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 776
#775 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    arithm_pro<kernel_sub>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#786 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 787
#786 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#788 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 789
#788 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    arithm_pro<kernel_subR>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#801 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 802
#801 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#803 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 804
#803 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    arithm_pro<kernel_subR>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#815 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 817
#815 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#818 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 820
#818 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_mul>(src1, src2, dst, scale, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#830 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 832
#830 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#833 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 835
#833 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_mul2>(src1, src2, dst, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void AddWeighted(
        Mat<ROWS, COLS, SRC1_T>& src1,
        P_T alpha,
        Mat<ROWS, COLS, SRC2_T>& src2,
        P_T beta,
        P_T gamma,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#848 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 850
#848 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#851 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 853
#851 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_addWeighted>(src1, src2, dst, alpha, beta, gamma);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Scale(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale=1.0,
        P_T shift=0.0)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#864 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 865
#864 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#866 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 867
#866 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_scale>(src, scl, dst, scale, shift, (P_T)0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void Set(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#878 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 879
#878 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#880 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 881
#880 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    arithm_pro<kernel_set>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, typename _T, int DST_T>
void Set(
        Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    arithm_pro<kernel_set>(scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Zero(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(src, s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int DST_T>
void Zero(
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void AbsDiff(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#924 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 926
#924 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#927 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 929
#927 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_absdiff>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Not(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#938 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 939
#938 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#940 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 941
#940 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_not>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Cmp(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#953 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 955
#953 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#956 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 958
#956 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_cmp>(src1, src2, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename P_T, int DST_T>
void CmpS(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T value,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#969 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 970
#969 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#971 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 972
#971 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), P_T> scl;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        scl.val[k] = (value);
    }
    arithm_pro<kernel_cmp>(src, scl, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#987 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 989
#987 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#990 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 992
#990 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_and>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1004 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1006
#1004 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                                   ;
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1007 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1009
#1007 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    arithm_pro<kernel_and>(src1, src2, dst, mask, dst_ref);
}

template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void Reduce(
         Mat<ROWS, COLS, SRC_T> &src,
         Mat<DST_ROWS, DST_COLS, DST_T> &dst,
         int dim,
         int op=1)
{
    reduce_opr<INTER_SUM_T>(src, dst, dim, op);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Range(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T start,
        P_T end)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1030 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1031
#1030 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1032 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1033
#1032 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && HLS_MAT_CN(SRC_T) == 1",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1034 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1035
#1034 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                  ;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1038, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1039, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _AP_T _dis = end-start;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                d.val[k] = _dis*(i*cols+j)/(rows*cols);
            }
            dst << d;
        }
    }
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Sum(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> res;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        res.val[k] = sr_cast<DST_T>(sum.val[k]);
    }
    return res;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum, ncount, mask);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
        _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src);
    return avg.val[0];
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src, mask);
    return avg.val[0];
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    ap_fixed<64,40,AP_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum);
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    ap_fixed<64,40,AP_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum, ncount, mask);
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<typename S_T>
class MinMaxLoc_opr
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
#pragma HLS inline
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && HLS_MAT_CN(SRC_T) == 1",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1177 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1178
#1177 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                  ;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1181, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1182, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            if (s.val[0] < _min_val) {
                _min_val = s.val[0];
                min_loc.x = j;
                min_loc.y = i;
            }
            if (s.val[0] > _max_val) {
                _max_val = s.val[0];
                max_loc.x = j;
                max_loc.y = i;
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
#pragma HLS inline
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && HLS_MAT_CN(SRC_T) == 1",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1218 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1219
#1218 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                  ;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1222, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1223, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            mask >> m;
            if (m.val[0]) {
                if (s.val[0] < (_min_val)) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
                if (s.val[0] > (_max_val)) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template< >
class MinMaxLoc_opr<float>
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
#pragma HLS inline
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && HLS_MAT_CN(SRC_T) == 1",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1268 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1269
#1268 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                  ;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1272, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1273, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (min_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() > min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() < min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }

            if (max_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() < max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() > max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
#pragma HLS inline
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && HLS_MAT_CN(SRC_T) == 1",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1331 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1332
#1331 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                  ;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1335, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1336, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            mask >> m;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (m.val[0]) {
                if (min_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() > min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() < min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }

                if (max_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() < max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() > max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc, mask);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Threshold(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name thresh,
        typename Type<((DST_T) & ((1 << 11) - 1))>::name maxval,
        int thresh_type)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1421 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1422
#1421 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1423 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1424
#1423 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                      ;
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && HLS_MAT_CN(SRC_T) == 1",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1425 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1426
#1425 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                  ;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1429, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1430, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _thresh = sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(thresh);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _maxval = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(maxval);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _zero = 0;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                switch (thresh_type) {
                    case 0:
                    d.val[k] = (s.val[k] > _thresh) ? (_maxval) : _zero;
                    break;
                    case 1:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (_maxval);
                    break;
                    case 2:
                    d.val[k] = (s.val[k] > _thresh) ? (_thresh) : s.val[k];
                    break;
                    case 3:
                    d.val[k] = (s.val[k] > _thresh) ? (s.val[k]) : _zero;
                    break;
                    case 4:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (s.val[k]);
                    break;
                    default:
                    d.val[k] = s.val[k];
                    break;
                }
            }
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T>
void Consume(
        Mat<ROWS, COLS, SRC_T>& src)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1474, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1475, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Duplicate(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1492 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,
 1493
#1492 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))
                                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst1) && HLS_ARE_SIZES_EQ(src, dst2)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1494 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1496
#1494 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1499, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1500, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            dst1 << s;
            dst2 << s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 2 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && HLS_MAT_CN(SRC_T) == 2 && HLS_MAT_CN(DST_T) == 1",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1519 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1521
#1519 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst0) && HLS_ARE_SIZES_EQ(src, dst1)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1522 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1524
#1522 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1529, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1530, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 3 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && HLS_MAT_CN(SRC_T) == 3 && HLS_MAT_CN(DST_T) == 1",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1549 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1551
#1549 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst0) && HLS_ARE_SIZES_EQ(src, dst1) && HLS_ARE_SIZES_EQ(src, dst2)",


 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1552 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,


 1555
#1552 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))


                                       ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1560, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1561, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2,
        Mat<ROWS, COLS, DST_T>& dst3)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 4 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && HLS_MAT_CN(SRC_T) == 4 && HLS_MAT_CN(DST_T) == 1",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1582 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1584
#1582 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                  ;
    (("Source and destination images must have same sizes" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols) && ((src).rows == (dst3).rows && (src).cols == (dst3).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst0) && HLS_ARE_SIZES_EQ(src, dst1) && HLS_ARE_SIZES_EQ(src, dst2) && HLS_ARE_SIZES_EQ(src, dst3)",



 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1585 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,



 1589
#1585 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))



                                       ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1594, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1595, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
            d.val[0] = s.val[3]; dst3 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 2) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && HLS_MAT_CN(SRC_T) == 1 && HLS_MAT_CN(DST_T) == 2",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1615 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1617
#1615 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                  ;
    (("Source and destination images must have same sizes" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src0, dst) && HLS_ARE_SIZES_EQ(src1, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1618 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1620
#1618 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                       ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1625, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1626, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 3) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && HLS_MAT_CN(SRC_T) == 1 && HLS_MAT_CN(DST_T) == 3",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1645 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1647
#1645 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                  ;
    (("Source and destination images must have same sizes" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src0, dst) && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",


 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1648 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,


 1651
#1648 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))


                                       ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1656, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1657, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, SRC_T>& src3,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 4) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && HLS_MAT_CN(SRC_T) == 1 && HLS_MAT_CN(DST_T) == 4",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1678 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,

 1680
#1678 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))

                                  ;
    (("Source and destination images must have same sizes" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols) && ((src3).rows == (dst).rows && (src3).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src0, dst) && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst) && HLS_ARE_SIZES_EQ(src3, dst)",



 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
#1681 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    ,



 1685
#1681 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h"
    , __PRETTY_FUNCTION__))



                                       ;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1690, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_arithm.h", 1691, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            src3 >> s; d.val[3] = s.val[0];
            dst << d;
        }
    }
}

}
#62 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h" 1
#91 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
namespace hls {

inline void assert_cn(int SRC_T,int DST_T)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC_T) == HLS_MAT_CN(DST_T)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
#95 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    ,
 96
#95 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    , __PRETTY_FUNCTION__))
                                                  ;
}
inline void assert_cn(int SRC1_T,int SRC2_T,int DST_T)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && HLS_MAT_CN(SRC1_T) == HLS_MAT_CN(DST_T) && HLS_MAT_CN(SRC2_T) == HLS_MAT_CN(DST_T)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
#100 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    ,

 102
#100 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    , __PRETTY_FUNCTION__))

                                                   ;
}
template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
inline void assert_size(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
#110 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    ,

 112
#110 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    , __PRETTY_FUNCTION__))

                                       ;
}
template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
inline void assert_cn_size(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    assert_cn(SRC1_T,SRC2_T,DST_T);
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src1, dst) && HLS_ARE_SIZES_EQ(src2, dst)",

 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
#121 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    ,

 123
#121 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    , __PRETTY_FUNCTION__))

                                       ;
}
template<int ROWS, int COLS, int SRC_T, int DST_T>
inline void assert_size(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
#130 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    ,
 131
#130 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    , __PRETTY_FUNCTION__))
                                      ;
}
template<int ROWS, int COLS, int SRC_T, int DST_T>
inline void assert_cn_size(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    assert_cn(SRC_T,DST_T);
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && HLS_ARE_SIZES_EQ(src, dst)",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
#139 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    ,
 140
#139 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h"
    , __PRETTY_FUNCTION__))
                                      ;
}
class erode_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
#pragma HLS INLINE
        out = hls::numeric_limits<DST_T>::max();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp<out)
                        out=temp;
                }
            }
        }
    }
};

class dilate_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
#pragma HLS INLINE
    out = hls::numeric_limits<DST_T>::min();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp>out)
                        out=temp;
                }
            }
        }
    }
};


template <typename SRC_T, typename FILTER_T, int SIZE=0>
struct filter2d_traits {
    typedef typename fixed_type<SRC_T>::T SRC_CAST_T;
    typedef typename fixed_type<FILTER_T>::T FILTER_CAST_T;
    typedef typename x_traits<SRC_CAST_T, FILTER_CAST_T >::MULT_T MULT_T;
    typedef typename x_traits_d<MULT_T, SIZE>::ACCUM_T ACCUM_T;
    typedef typename x_traits<ACCUM_T, ap_fixed<1,1> >::MULT_T TEMP_T;
};

template <int SIZE , int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
struct filter2d_traits<float, ap_fixed<W, I, _AP_Q, _AP_O>, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE, int W>
struct filter2d_traits<float, ap_int<W>, SIZE> {
    typedef float SRC_CAST_T;
    typedef ap_int<W> FILTER_CAST_T;
    typedef float MULT_T;
    typedef float ACCUM_T;
    typedef float TEMP_T;
};
template <int SIZE>
struct filter2d_traits<unsigned char,float, SIZE> {
    typedef unsigned char SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, unsigned char, SIZE> {
    typedef float SRC_CAST_T;
    typedef unsigned char FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, float, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, double, SIZE> {
    typedef double SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, double, SIZE> {
    typedef float SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, float, SIZE> {
    typedef double SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};

class filter2d_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out,
               const bool cast)
    {
#pragma HLS INLINE
     typename filter2d_traits<SRC_T, FILTER_T>::SRC_CAST_T src_v;
     typename filter2d_traits<SRC_T, FILTER_T>::FILTER_CAST_T filter_v;
        typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
        typename filter2d_traits<SRC_T, FILTER_T>::MULT_T temp=0;
        loop_height: for(int m = 0; m < F_HEIGHT; m++) {
            loop_width: for(int n = 0; n < F_WIDTH; n++) {
                src_v = _kernel_pixel.val[F_HEIGHT-m-1][F_WIDTH-1-n];
                filter_v = _kernel_filter.val[m][n];
                temp = src_v * filter_v;
                sum = sum + temp;
            }
        }
        out=sum;
    }

    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out)
    {
#pragma HLS INLINE
        typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
     apply(_kernel_filter,_kernel_pixel,sum,true);
     out=sr_cast<DST_T>(sum);
    }
};

template <typename SRC_T,typename SIZE_T,typename POINT_T,int HEIGHT,int WIDTH>
void getStructuringElement(
        int shape,
        Size_<SIZE_T> ksize,
        Point_<POINT_T> anchor,
        Window<HEIGHT,WIDTH,SRC_T> &result)
{
#pragma HLS inline
    int i, j;
    int r = 0, c = 0;
    ap_fixed<31,11,AP_RND> inv_r2 = 0;

    if( ksize.width==1&&ksize.height == 1 )
        shape = MORPH_RECT;

    if( shape == MORPH_ELLIPSE )
    {
        r = ksize.height/2;
        c = ksize.width/2;
        if(r!=0)
        {
            inv_r2 =(ap_fixed<31,11,AP_RND>) 1/(r*r) ;
        }
        else
            inv_r2=0;
    }
 loop_height: for( i = 0; i < ksize.height; i++ )
    {
        int j1 = 0, j2 = 0;
        if( shape == MORPH_RECT || (shape ==MORPH_CROSS && i == anchor.y) )
            j2 = ksize.width;
        else if( shape == MORPH_CROSS ) {
            j1 = anchor.x;
            j2 = j1 + 1;
        } else
        {
            int dy = i - r;
            if( abs(dy) <= r )
            {
                ap_fixed<12,12,AP_RND> dxx = (c*::hls::sqrt(((r-dy)*(r+dy))*inv_r2));
                int dx=dxx;
                j1 = (c - dx)> 0?( c - dx):0;
                j2 = (c + dx + 1)< ksize.width?(c + dx + 1):ksize.width;
            }
        }
    loop_width: for( j = 0; j < ksize.width; j++ ) {
            if(shape == MORPH_RECT || (j >= j1 && j < j2)) {
                result.val[i][j] = 1;
            } else {
                result.val[i][j] = 0;
            }
        }
    }
}


template<typename P_T,typename W_T,int W_HEIGHT, int W_WIDTH,typename BUF_T,int BUF_HEIGHT,int BUF_WIDTH >
void fill_pixelkernel(
        LineBuffer<BUF_HEIGHT,BUF_WIDTH,BUF_T> &col_buf,
        Window<W_HEIGHT,W_WIDTH,W_T> &kernel,
        Point_<P_T> curp,
        int borderType, int ref,
        int imgheight,int constval=0, bool forceconst = false)
{
#pragma HLS INLINE
 loop_fill: for(int buf_row= 0;buf_row<W_HEIGHT;buf_row++)
    {
        int locy;
        int t = borderInterpolate(curp.y,imgheight,borderType);
        locy = ref - t;
        curp.y--;
        kernel.val[buf_row][0] = (t < 0 || forceconst) ? constval : col_buf.val[locy][0];
    }
}

template<typename OPR_KERNEL, typename BORDERMODE>
class filter_opr {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
    {
#pragma HLS inline
    OPR_KERNEL fk_opr;

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    ((rows >= 8) ? static_cast<void> (0) : __assert_fail ("rows >= 8", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 405, __PRETTY_FUNCTION__));
    ((cols >= 8) ? static_cast<void> (0) : __assert_fail ("cols >= 8", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 406, __PRETTY_FUNCTION__));
    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 407, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 408, __PRETTY_FUNCTION__));

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=right_border_buf complete dim=0

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    ((anchor.x >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.x >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 423, __PRETTY_FUNCTION__));
    ((anchor.x <= K_WIDTH-1) ? static_cast<void> (0) : __assert_fail ("anchor.x <= K_WIDTH-1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 424, __PRETTY_FUNCTION__));
    ((anchor.y >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.y >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 425, __PRETTY_FUNCTION__));
    ((anchor.y <= K_HEIGHT-1) ? static_cast<void> (0) : __assert_fail ("anchor.y <= K_HEIGHT-1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 426, __PRETTY_FUNCTION__));

    int start_row;
    int row_index;
    int col_index;
    int stop_row;
    get_parameters<K_HEIGHT, K_WIDTH>(rows, anchor, start_row, stop_row, row_index, col_index);
    ((start_row >= 0) ? static_cast<void> (0) : __assert_fail ("start_row >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 433, __PRETTY_FUNCTION__));
    ((start_row <= K_HEIGHT-1) ? static_cast<void> (0) : __assert_fail ("start_row <= K_HEIGHT-1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 434, __PRETTY_FUNCTION__));

    int heightloop= rows+start_row+1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

#pragma HLS DEPENDENCE array inter false
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    ImagLoc.x=j-anchor.x;
                    int x = borderInterpolate(ImagLoc.x, cols, BORDERMODE::value);
                    ((x < cols) ? static_cast<void> (0) : __assert_fail ("x < cols", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 451, __PRETTY_FUNCTION__));


                    for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                        if((i<stop_row) && (ImagLoc.x>=cols)) {
                            col_buf[k](buf_row,0)=right_border_buf[k](buf_row,cols-1-x);
                        } else {
                            col_buf[k](buf_row,0)=k_buf[k](K_HEIGHT+buf_row,x);
                        }
                    }


                    if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                        if(i<=start_row) {
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                            _src.data_stream[k] >> src_temp;
                            for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                                int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                                if(y==i) {
                                    k_buf[k](buf_row,x)=src_temp;
                                }
                            }
                        } else if(i<stop_row) {


                            for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                                for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                    if(buf_col <= col_index) {
                                         right_border_buf[k](buf_row,buf_col)=right_border_buf[k](buf_row,buf_col-1);
                                    }
                                }
                                right_border_buf[k](buf_row,0)=col_buf[k](buf_row,0);
                            }

                            for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                                if(buf_row>row_index) {
                                    k_buf[k](buf_row,x)=k_buf[k](buf_row-1,x);
                                }
                            }
                            if(i<rows) {
                                _src.data_stream[k] >> k_buf[k](row_index,x);
                            }
                        }
                    }


              src_kernel_win[k].shift_right();

                    for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                        if(i<=stop_row) {
                            src_kernel_win[k](buf_row,0)=col_buf[k](buf_row,0);
                        }
                        else {
                            int y = borderInterpolate((i-(stop_row-rows+1)-buf_row), rows, BORDERMODE::value);
                            src_kernel_win[k](buf_row,0)=col_buf[k](rows-1-y,0);
                        }
                    }


                    if(i > start_row && j >= K_WIDTH-1) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }

private:
template<int K_HEIGHT, int K_WIDTH, typename POINT_T>
static void get_parameters(int rows, Point_<POINT_T> anchor, int &start_row, int &stop_row, int &row_index, int &col_index)
    {
#pragma HLS inline
        switch(BORDERMODE::value) {
            case BORDER_REPLICATE::value:
                start_row=K_HEIGHT-1-anchor.y;
                row_index=K_HEIGHT;
                col_index=0;
                stop_row=rows;
                break;
            case BORDER_REFLECT::value:
                col_index=K_WIDTH-1-anchor.x-1;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y-1;
                    row_index=2*K_HEIGHT-2*anchor.y;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            case BORDER_REFLECT_101::value:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            default:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
        }
    }

};

template<typename OPR_KERNEL>
class filter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
{
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
#pragma HLS inline
    OPR_KERNEL fk_opr;

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<1,K_HEIGHT,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0

    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 600, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 601, __PRETTY_FUNCTION__));


    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    ((anchor.x >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.x >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 611, __PRETTY_FUNCTION__));
    ((anchor.x <= K_WIDTH-1) ? static_cast<void> (0) : __assert_fail ("anchor.x <= K_WIDTH-1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 612, __PRETTY_FUNCTION__));
    ((anchor.y >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.y >= 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 613, __PRETTY_FUNCTION__));
    ((anchor.y <= K_HEIGHT-1) ? static_cast<void> (0) : __assert_fail ("anchor.y <= K_HEIGHT-1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 614, __PRETTY_FUNCTION__));

    int start_row=K_HEIGHT-1-anchor.y;
    int start_col=K_WIDTH-1-anchor.x;
    int heightloop= rows+start_row;
    int widthloop = cols+start_col;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                    if((j<cols) && (i<rows)) {
                        _src.data_stream[k] >> src_temp;
                    }

                    if(j<cols) {
                        for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                            col_buf[k](0,buf_row)=k_buf[k](buf_row-1,j);
                        }
                    } else {
                        for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            col_buf[k](0,buf_row)=fillvalue;
                        }
                    }

                    if(j<cols) {
                        if(i==0) {
                            for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                                k_buf[k](buf_row,j)=fillvalue;
                                col_buf[k](0,buf_row)=fillvalue;
                            }
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        } else {
                            if(i>=rows) {
                                src_temp=fillvalue;
                            }
                            k_buf[k].shift_down(j);
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        }
                    }

                    if(j==0) {
                        for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                src_kernel_win[k](buf_row,buf_col)=fillvalue;
                            }
                        }
                    } else {
                  src_kernel_win[k].shift_right();
                    }
              src_kernel_win[k].insert_right(col_buf[k].val[0]);


                    if(i >= start_row && j >= start_col) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }
};

template<typename OPR_KERNEL, typename BORDERMODE>
class sepfilter_opr {
private:

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, int SRC_T, typename DST_T,
         typename KNY_T, typename POINT_T, int K_HEIGHT>
static void column_filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        stream<DST_T> (&_dst)[CH],
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
        int cols)
{
    OPR_KERNEL fk_opr;

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[CH];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[CH];


    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[CH];

    ((rows >= 8) ? static_cast<void> (0) : __assert_fail ("rows >= 8", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 708, __PRETTY_FUNCTION__));
    ((cols >= 8) ? static_cast<void> (0) : __assert_fail ("cols >= 8", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 709, __PRETTY_FUNCTION__));
    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 710, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 711, __PRETTY_FUNCTION__));

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernelY complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winY complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=1;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int start_row;
    int row_index;
    int stop_row;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            start_row=K_HEIGHT-1-anchor.y;
            row_index=K_HEIGHT;
            stop_row=rows;
            break;
        case BORDER_REFLECT::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y-1;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        case BORDER_REFLECT_101::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        default:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
    }

    int heightloop = rows+start_row+1;
    int widthloop = cols;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

#pragma HLS DEPENDENCE array inter false
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            channelloop: for(HLS_CHANNEL_T k= 0; k < CH; k++)
            {


                for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                    col_buf[k](buf_row,0)=k_buf[k](2*K_HEIGHT-1-buf_row,j);
                }

                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                if (i<rows) {
                    _src.data_stream[k] >> src_temp;
                }

                if(i<=start_row) {
                    for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                        int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                        if(y==i) {
                            k_buf[k](buf_row,j)=src_temp;
                        }
                    }
                } else if(i<stop_row) {
                    for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                        if(buf_row>row_index) {
                            k_buf[k](buf_row,j)=k_buf[k](buf_row-1,j);
                        }
                    }
                    if(i<rows) {
                        k_buf[k](row_index,j) = src_temp;
                    }
                }

                for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                    if(i<=stop_row) {
                        src_kernel_winY[k](buf_row,0)=col_buf[k](K_HEIGHT-1-buf_row,0);
                    }
                    else {
                        int y = borderInterpolate(i-(stop_row-rows+1)-buf_row, rows, BORDERMODE::value);


                        int index = (rows-K_HEIGHT>0) ? rows-K_HEIGHT : 0;
                        src_kernel_winY[k](buf_row,0)=col_buf[k](y-index,0);
                    }
                }

                if(i > start_row) {
                    DST_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);
                    _dst[k]<<tempY;
                }
            }
        }
    }
}

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, typename SRC_T, int DST_T,
         typename KNX_T, typename POINT_T, int K_WIDTH, typename SCALE_T>
static void row_filter(
        stream<SRC_T> (&_src)[CH],
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Point_<POINT_T> _anchor,
        int rows,
        int cols,
        SCALE_T scale)
{
    OPR_KERNEL fk_opr;

    Window<1,K_WIDTH,SRC_T> src_kernel_winX[CH];

    SRC_T src_kernel_winX_temp[CH][K_WIDTH];


    Window<1,2*K_WIDTH,SRC_T> row_buf[CH];




    LineBuffer<1,K_WIDTH,SRC_T> l_border_buf[CH];
    LineBuffer<1,K_WIDTH,SRC_T> r_border_buf[CH];

    ((rows >= 8) ? static_cast<void> (0) : __assert_fail ("rows >= 8", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 842, __PRETTY_FUNCTION__));
    ((cols >= 8) ? static_cast<void> (0) : __assert_fail ("cols >= 8", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 843, __PRETTY_FUNCTION__));
    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 844, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 845, __PRETTY_FUNCTION__));

#pragma HLS ARRAY_PARTITION variable=&kernelX complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=row_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=l_border_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=r_border_buf complete dim=1

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=1;
    normalizeAnchor(anchor,kernel_size);



    int left_border;

    int right_border;

    int index;

    int start;

    int stop;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            left_border = 0;
            right_border = cols-1;
            index = anchor.x;
            break;
        case BORDER_REFLECT::value:
            left_border = (anchor.x-1>0) ? anchor.x-1: 0;
            right_border = cols-(K_WIDTH-anchor.x)+1;
            index = (2*anchor.x-1>0) ? 2*anchor.x-1: 0;
            break;
        case BORDER_REFLECT_101::value:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
        default:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
    }


    right_border = right_border<0 ? 0 : right_border;
    start = K_WIDTH+left_border;
    stop = cols+index;
    int heightloop= rows;
    int widthloop = cols+start;
    SRC_T src_temp;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

#pragma HLS DEPENDENCE array inter false
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            channelloop: for(HLS_CHANNEL_T k=0; k<CH; k++)
            {
                int x = borderInterpolate(j-index-1, cols, BORDERMODE::value);

                if (j<cols)
                    _src[k] >> src_temp;


                for (int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if (j<=left_border) {
                    l_border_buf[k](0,j) = src_temp;
                }
                if ((j>=right_border) && (j<cols)) {
                    r_border_buf[k](0,cols-1-j) = src_temp;
                }

                if ((j>left_border) && (j<=index)) {

                    src_kernel_winX_temp[k][0] = l_border_buf[k](0,x);
                } else if (j<=stop) {

                    src_kernel_winX_temp[k][0] = row_buf[k](0,0);
                } else {

                    src_kernel_winX_temp[k][0] = r_border_buf[k](0,cols-1-x);
                }

                for (int buf_col=0; buf_col<2*K_WIDTH; buf_col++) {
                    if (buf_col<index)
                        row_buf[k](0,buf_col) = row_buf[k](0,buf_col+1);
                }
                row_buf[k](0,index) = src_temp;

                for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }

                if(j >= start) {
                    typedef typename filter2d_traits<SRC_T, KNX_T, K_WIDTH*1-1>::TEMP_T tempX_T;
                    tempX_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH, typename SCALE_T>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)

{
#pragma HLS inline
#pragma HLS DATAFLOW

    typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;
    stream<tempY_T> tempY_stream[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    column_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(_src, tempY_stream, kernelY, Point_<POINT_T>(0,_anchor.y), rows, cols);

    row_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(tempY_stream, _dst, kernelX, Point_<POINT_T>(_anchor.x,0), rows, cols, scale);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)

{
#pragma HLS inline
    filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL>
class sepfilter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)
{
#pragma HLS inline
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
    OPR_KERNEL fk_opr;
    typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    Window<1,K_WIDTH,tempY_T> src_kernel_winX[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    tempY_T src_kernel_winX_temp[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)][K_WIDTH];

    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=&kernelX complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernelY complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winY complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1

    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 1038, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 1039, __PRETTY_FUNCTION__));


    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int heightloop= rows+K_HEIGHT-1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++) {


                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-anchor.y;



                for(int buf_col=K_WIDTH-1; buf_col>=1; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                    for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--) {
                        src_kernel_winY[k](buf_row,0)=k_buf[k](buf_row-1,ImagLoc.x);
                        k_buf[k](buf_row,ImagLoc.x)=k_buf[k](buf_row-1,ImagLoc.x);
                    }

                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=fillvalue;
                    if(ImagLoc.y >= 0 && ImagLoc.y < rows) {
                        _src.data_stream[k] >> temp;
                    }
                    src_kernel_winY[k](0,0)=temp;
                    k_buf[k](0,ImagLoc.x)=temp;
                }





                if(ImagLoc.x < 0 || ImagLoc.x >= cols) {

                    src_kernel_winX_temp[k][0] = fillvalue;
                } else if(i >= (K_HEIGHT-1)) {
                    tempY_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);

                    src_kernel_winX_temp[k][0] = tempY;
                }

                for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }



                if(i >= (K_HEIGHT-1) && j >= (K_WIDTH-1)) {
                    typename filter2d_traits<tempY_T, KNX_T, 1*K_WIDTH>::ACCUM_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)
{
#pragma HLS inline
    filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_flow_more(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows, int cols
        )
{
    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int ITERATIONS,int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_iter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows,int cols )
{
#pragma HLS DATAFLOW
    Mat<IMG_HEIGHT,IMG_WIDTH,DST_T> internal[ITERATIONS-1];
#pragma HLS array partition variable=internal dim=1
    filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(_src,internal[0],_kernel,anchor,rows,cols);
loop_iterations: for(int iter=0;iter<ITERATIONS-2;iter++)
    {
#pragma HLS UNROLL
        filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[iter],internal[iter+1],_kernel,anchor,rows, cols);
    }
    filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[ITERATIONS-2],_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T,
    int IMG_HEIGHT,int IMG_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
#pragma HLS inline
    int rows=_src.rows;
    int cols=_src.cols;
    Size_<int> size;
    Point_<int> anchor;
    anchor.x=1;
    anchor.y=1;
    size.width=2*1+1;
    size.height=2*1+1;
    Window<2*1+1,2*1+1,unsigned char> temp_kernel;
    getStructuringElement<unsigned char,int,int,2*1+1,2*1+1>(MORPH_RECT, size, anchor,temp_kernel);

    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int Shape_type, int ITERATIONS, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
#pragma HLS INLINE
    int rows=_src.rows;
    int cols=_src.cols;
    if((Shape_type==MORPH_RECT)&&ITERATIONS>1)
    {
        Size_<int> size;
        anchor.x=ITERATIONS*(anchor.x);
        anchor.y=ITERATIONS*(anchor.y);
        size.width=K_WIDTH+ITERATIONS*(K_WIDTH-1);
        size.height=K_HEIGHT+ITERATIONS*(K_HEIGHT-1);
        Window<K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1),KN_T> temp_kernel;
        getStructuringElement<KN_T,int,int,K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1)>(MORPH_RECT, size, anchor,temp_kernel);

        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS==1)
    {
        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS>=2)
    {
        filter_opr_iter<OPR_KERNEL, BORDERMODE, ITERATIONS,SRC_T,DST_T,KN_T,POINT_T>(_src,_dst,_kernel,anchor,rows,cols);
    }
}





template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
    assert_cn(SRC_T,DST_T);
    morp_opr<erode_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
#pragma HLS INLINE
    assert_cn(SRC_T,DST_T);
    Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<erode_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}




template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
    assert_cn(SRC_T,DST_T);
    morp_opr<dilate_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
#pragma HLS INLINE
    assert_cn(SRC_T,DST_T);
    Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<dilate_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}



template<typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor,
        SCALE_T scale)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols,scale);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}



class CvtColor_mode {
public:
    enum values {RGB2GRAY,BGR2GRAY,GRAY2RGB,GRAY2BGR,
                 BGR2XYZ, RGB2XYZ, XYZ2BGR, XYZ2RGB,
                 BGR2YCrCb, RGB2YCrCb, YCrCb2BGR, YCrCb2RGB,
                 BGR2HSV, RGB2HSV, HSV2BGR, HSV2RGB,
                 BGR2HLS, RGB2HLS, HLS2BGR, HLS2RGB};
    typedef void isCvtColorMode;
};

}

class HLS_RGB2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2GRAY; };
class HLS_BGR2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2GRAY; };
class HLS_GRAY2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2RGB; };
class HLS_GRAY2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2BGR; };

class HLS_RGB2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2XYZ; };
class HLS_BGR2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2XYZ; };
class HLS_XYZ2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2RGB; };
class HLS_XYZ2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2BGR; };

class HLS_RGB2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2YCrCb; };
class HLS_BGR2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2YCrCb; };
class HLS_YCrCb2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2RGB; };
class HLS_YCrCb2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2BGR; };

class HLS_RGB2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HSV; };
class HLS_BGR2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HSV; };
class HLS_HSV2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2RGB; };
class HLS_HSV2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2BGR; };

class HLS_RGB2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HLS; };
class HLS_BGR2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HLS; };
class HLS_HLS2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2RGB; };
class HLS_HLS2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2BGR; };

namespace hls {

    template <typename T> class CvtColor_traits {

    };

    template <> class CvtColor_traits<unsigned char> {
    public:
        typedef unsigned char T;
        typedef ap_fixed<25,3> COEFF_T;
     typedef ap_ufixed<20,1,AP_RND> INV_T;

        const int delta;
        const unsigned int hrange;
        const unsigned int scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(128), hrange(180), scale(255),
       inv_scale(0.0039215686274509804), inv_hrange(0.0333333333333333333) {};
    };
    template <int N> class CvtColor_traits< ap_uint<N> > {
    public:
        typedef ap_uint<N> T;
        typedef ap_fixed<25,3> COEFF_T;
     typedef ap_ufixed<20,1,AP_RND> INV_T;

        const int delta;
        const unsigned int hrange;
        const unsigned int scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(1 << (N-1)), hrange(180),
                            scale(::hls::numeric_limits<T>::max()),
                            inv_scale(1.0/::hls::numeric_limits<T>::max()),
                            inv_hrange(0.0333333333333333333) {};
    };
    template <> class CvtColor_traits<float> {
    public:
        typedef float T;
        typedef float COEFF_T;
        typedef float INV_T;
        const float delta;
        const float hrange;
        const float scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef float MULT_T;
        typedef float ACCUM_T;
        typedef float SUB_T;
        typedef float ADD_T;
        typedef float H_MULT_T;
        typedef float S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
    };
    template <> class CvtColor_traits<double> {
    public:
        typedef double T;
        typedef double COEFF_T;
        typedef double INV_T;
        const double delta;
        const double hrange;
        const double scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef double MULT_T;
        typedef double ACCUM_T;
        typedef double SUB_T;
        typedef double ADD_T;
        typedef double H_MULT_T;
        typedef double S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
};

template <typename SRC_T, typename DST_T>
class ColorConverter {
public:
    template <int CN1>
    static void convert(Scalar<CN1,SRC_T>& _src, DST_T& result, Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par) {
#pragma HLS inline
        typename CvtColor_traits<SRC_T>::MULT_T b,g,r;
        r=par.val[0]*_src.val[0];
        b=par.val[1]*_src.val[1];
        g=par.val[2]*_src.val[2];
        typename CvtColor_traits<SRC_T>::ACCUM_T c;
        c=r+g+b;
        result=sr_cast<DST_T> (c);
    }
};

template <typename SRC_T, typename DST_T>
class MaxMin{
public:
    template <int CN1>
    static void max(Scalar<CN1,SRC_T>& _src, DST_T& result) {
#pragma HLS inline

 for(int i=0; i<CN1; i++) {
   result=(_src.val[i]>result) ? _src.val[i] : result;
 }
    }

    template <int CN1>
    static void min(Scalar<CN1,SRC_T>& _src, DST_T& result) {
#pragma HLS inline

 for(int i=0; i<CN1; i++) {
   result=(_src.val[i]<result) ? _src.val[i] : result;
 }
    }
};

template <typename CONVERSION, typename SRC_T, typename DST_T>
class kernel_CvtColor {};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.114,0.587,0.299) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
        _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
        _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2XYZ, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parX;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parY;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parZ;
public:
    kernel_CvtColor() : parX(0.412453, 0.357580, 0.180423),
                        parY(0.212671, 0.715160, 0.072169),
                        parZ(0.019334, 0.119193, 0.950227) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parX);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parY);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parZ);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2XYZ, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2XYZ,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2RGB, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parR;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parG;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parB;
public:
    kernel_CvtColor() : parR( 3.240479, -1.53715, -0.498535),
                        parG(-0.969256, 1.875991, 0.041556),
                        parB( 0.055648, -0.204043, 1.057311) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parR);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parG);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parB);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_XYZ2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2YCrCb, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
    typename CvtColor_traits<SRC_T>::COEFF_T Cr;
    typename CvtColor_traits<SRC_T>::COEFF_T Cb;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114),Cr(.713),Cb(.564) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
        DST_T Y;
        ColorConverter<SRC_T,DST_T>::convert(_src, Y, par);
        _dst.val[0] = Y;
        _dst.val[1] = sr_cast<DST_T>((R-Y)*Cr+ CvtColor_traits<SRC_T>().delta);
        _dst.val[2] = sr_cast<DST_T>((B-Y)*Cb+ CvtColor_traits<SRC_T>().delta);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2YCrCb, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2YCrCb,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2RGB, SRC_T, DST_T> {
    typename CvtColor_traits<SRC_T>::COEFF_T parGr;
    typename CvtColor_traits<SRC_T>::COEFF_T parGb;
    typename CvtColor_traits<SRC_T>::COEFF_T parCr;
    typename CvtColor_traits<SRC_T>::COEFF_T parCb;
public:
    kernel_CvtColor() : parGr(-0.714), parGb(-0.344), parCr(1.403), parCb(1.773) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T Y = _src.val[0];
        SRC_T Cr = _src.val[1];
        SRC_T Cb = _src.val[2];
        _dst.val[0] = sr_cast<DST_T> (Y + parCr * (Cr-CvtColor_traits<SRC_T>().delta));
        _dst.val[1] = sr_cast<DST_T> (Y + parGr * (Cr-CvtColor_traits<SRC_T>().delta) + parGb * (Cb-CvtColor_traits<SRC_T>().delta));
        _dst.val[2] = sr_cast<DST_T> (Y + parCb * (Cb-CvtColor_traits<SRC_T>().delta));
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_YCrCb2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::INV_T inv_max = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;

 if(max!=0)
   inv_max = (typename CvtColor_traits<DST_T>::INV_T) 1/max;
 else
   inv_max = 0;

 S=inv_max*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = (180==CvtColor_traits<SRC_T>().hrange) ? sr_cast<DST_T>(255*S) : sr_cast<DST_T>(S);
        _dst.val[2] = max;
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HSV,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
        SRC_T H = _src.val[0];
        SRC_T S = _src.val[1];
        SRC_T V = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

#pragma HLS array_partition variable=tab dim=0 complete

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 tab[0] = V;
 tab[1] = V*(1-S_scale);
 tab[2] = V*(1-f*S_scale);
 tab[3] = V*(1-S_scale+f*S_scale);

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HSV2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 DST_T L;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::ADD_T add;
 typename CvtColor_traits<DST_T>::INV_T inv_add = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_add_comp= 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;
 add=max+min;
 L=sr_cast<DST_T>((max+min)/2);

 if(add!=0)
   inv_add = (typename CvtColor_traits<DST_T>::INV_T) 1/add;
 else
   inv_add = 0;



 if((2*(CvtColor_traits<SRC_T>().scale)-add)!=0)
   inv_add_comp = (typename CvtColor_traits<DST_T>::INV_T) 1/(2*(CvtColor_traits<SRC_T>().scale)-add);
 else
   inv_add_comp = 0;

 if(L<=CvtColor_traits<SRC_T>().delta)
   S=inv_add*diff;
 else
   S=inv_add_comp*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = L;
        _dst.val[2] = (180==CvtColor_traits<SRC_T>().hrange) ?
            sr_cast<DST_T>(CvtColor_traits<SRC_T>().scale*S) :
            sr_cast<DST_T>(S);

    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HLS,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
        SRC_T H = _src.val[0];
        SRC_T L = _src.val[1];
        SRC_T S = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

#pragma HLS array_partition variable=tab dim=0 complete

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 if(L<=0.5*CvtColor_traits<SRC_T>().scale)
   tab[0] = L+L*S_scale;

 else
    tab[0] = L+S-L*S_scale;

 tab[1] = 2*L-tab[0];
 tab[2] = tab[0]-(tab[0]-tab[1])*f;
 tab[3] = tab[1]+(tab[0]-tab[1])*f;

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HLS2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename CONVERSION,int SRC_T, int DST_T,
    int ROWS,int COLS>
void CvtColor(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst
        )
{
    kernel_CvtColor<CONVERSION,typename Type<((SRC_T) & ((1 << 11) - 1))>::name,typename Type<((DST_T) & ((1 << 11) - 1))>::name> kernel_opr;
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 1943, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 1944, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
 loop_height: for(int i= 0; i < rows; i++) {
    loop_width: for (int j= 0; j < cols; j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            _src >> _s;
            kernel_opr.apply(_s,_d);
            _dst << _d;
        }
    }
}

template<int SRC_T, int DST_T,
int ROWS,int COLS>
void Integral(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS+1, COLS+1, DST_T> &_sum
        )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 1968, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 1969, __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                _d.val[0]=0;
                sum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                _d.val[0]=sum+k_buf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
            }
            _sum<<_d;
        }
    }
}
template<int SRC_T, int DST_T,int DSTSQ_T,
    int ROWS,int COLS>
void Integral(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS+1, COLS+1, DST_T> &_sum,
  Mat<ROWS+1, COLS+1, DSTSQ_T> &_sqsum
                )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    LineBuffer<1,COLS+1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> k_sqbuf;
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2007, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2008, __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    Scalar<1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> _sqd;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                k_sqbuf.val[0][j]=0;
                _d.val[0]=0;
                _sqd.val[0]=0;
                sum=0;
                sqsum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                sqsum=sqsum+_s.val[0]*_s.val[0];

                _d.val[0]=sum+k_buf.val[0][j];
                _sqd.val[0]=sqsum+k_sqbuf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
                k_sqbuf.val[0][j]=_sqd.val[0];
            }
            _sum<<_d;
            _sqsum<<_sqd;
        }
    }
}







template <int NTAPS, int NPHASES, int COEFF_BITS,typename HT, typename VT>
void init_scale_coefficients(HT *Hcoefs, VT *Vcoefs) {

#pragma HLS inline off
    static const float A = -0.5;
    double t;
    double coeff[NPHASES][NTAPS];
    int i,j;

    for (i=0; i<NPHASES; i++) {
        t=((double) i)/NPHASES;
        coeff[i][0] = A*(t*((2-t)*t-1));
        coeff[i][1] = A*(t*t*(3*t-5)+2);
        coeff[i][2] = A*(t*((4-3*t)*t+1));
        coeff[i][3] = A*((t-1)*t*t);
    }
    for (i = 0; i < NPHASES; i++) {
        for (j = 0; j < NTAPS; j++) {
            Hcoefs[(NTAPS*i)+j] = (HT)coeff[i][j];
            Vcoefs[(NTAPS*i)+j] = (VT)coeff[i][j];
        }
    }
}

template<int NTAPS, int COEFF_BITS, int T,typename FILTER_T>
hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scale_operator(hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> *samples, FILTER_T *coeffs) {

    typedef typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::SRC_CAST_T SRCT;
    int i,j,ch;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_out;
CHAN_LOOP : for (ch =0; ch<((((T) & ((512 - 1) << 11)) >> 11) + 1); ch++) {
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::ACCUM_T t=0;
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::MULT_T temp;
    TAPS_LOOP : for (i = 0,t=0.5; i < NTAPS; i++) {
#pragma HLS inline
            typename Type<((T) & ((1 << 11) - 1))>::name sample = samples[i].val[ch];
            temp = ((SRCT)sample)*coeffs[NTAPS-1-i];
            t = t - temp ;
        }
        pix_out.val[ch] = sr_cast<typename Type<((T) & ((1 << 11) - 1))>::name> (t);
    }
    return pix_out;
}


template <int COLS, int ROWS,int DCOLS, int DROWS, int T>
void Resize_opr_bicubic(hls::Mat<ROWS, COLS, T>& _src, hls::Mat<DROWS, DCOLS, T>& _dst) {
    typedef ap_fixed<32, 16, AP_RND> FT;
    typedef short N16;
    const int NTAPS = 4;
    const int NPHASES = 16;
    const int COEFF_BITS = 16;
    const short ES = 2;
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, AP_RND>, NTAPS>::FILTER_CAST_T hcoeffs[NPHASES][NTAPS];
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, AP_RND>, NTAPS>::FILTER_CAST_T vcoeffs[NPHASES][NTAPS];
    N16 row, col;
    N16 rows, cols;
    ap_uint<32> v_phase_acc;
    ap_uint<32> h_phase_acc;

    hls::LineBuffer<NTAPS, (COLS>DCOLS?COLS:DCOLS) + 3, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > linebuf;
    hls::Window<1, NTAPS, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > h_shreg;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_in, h_fir_out, pix_out, h_fir[NTAPS], v_fir[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_in[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_out[NTAPS];
    typename Type<((T) & ((1 << 11) - 1))>::name pix_in_ch, pix_out_ch;

    N16 rows_rw = -1, cols_rw = -1;
    bool col_rd_en;
    bool row_rd_en;
    bool col_wr_en;
    bool row_wr_en;
    ap_uint<4> v_phase;
    ap_uint<4> h_phase;
#pragma HLS array_partition variable= temp_in dim=0 complete
#pragma HLS array_partition variable= temp_out dim=0 complete
#pragma HLS array_partition variable= h_fir dim=0 complete
#pragma HLS array_partition variable= v_fir dim=0 complete
#pragma HLS array_partition variable=hcoeffs dim=2 complete
#pragma HLS array_partition variable=vcoeffs dim=2 complete


    init_scale_coefficients<NTAPS, NPHASES, COEFF_BITS>(hcoeffs[0], vcoeffs[0]);

    N16 rows_in = _src.rows;
    N16 cols_in = _src.cols;
    N16 rows_out = _dst.rows;
    N16 cols_out = _dst.cols;
    FT row_ratio = (FT(rows_out)) / (FT)rows_in;
    FT col_ratio = (FT(cols_out)) / (FT)cols_in;

    int row_rate = (ap_fixed<4, 2, AP_RND>(0.5) + row_ratio * 65536);
    int col_rate = (ap_fixed<4, 2, AP_RND>(0.5) + col_ratio * 65536);
    rows = (rows_in > rows_out) ? rows_in : rows_out;
    cols = (cols_in > cols_out) ? cols_in : cols_out;
    ((rows<=ROWS || rows<=DROWS) ? static_cast<void> (0) : __assert_fail ("rows<=ROWS || rows<=DROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2145, __PRETTY_FUNCTION__));
    ((cols<=COLS || cols<=DCOLS) ? static_cast<void> (0) : __assert_fail ("cols<=COLS || cols<=DCOLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2146, __PRETTY_FUNCTION__));
    v_phase_acc = 0;

 ROW_LOOP: for (row = 0; row < rows + 3; row++) {
    COL_LOOP: for (col = 0; col < cols + 3; col++) {
#pragma HLS PIPELINE
#pragma HLS loop_flatten off
#pragma HLS DEPENDENCE array inter false
              if (col == 0) {
                  v_phase = (v_phase_acc >> 12) & 15;
                  if (row_rate < 65536) {
                      row_rd_en = true;
                      N16 drow = row * row_ratio;
                      if (rows_rw != drow) {
                          row_wr_en = true;
                          rows_rw = drow;
                      } else
                          row_wr_en = false;
                  } else {
                      row_wr_en = true;
                      N16 drow = row / row_ratio;
                      if (rows_rw != drow) {
                          row_rd_en = true;
                          rows_rw = drow;
                      } else
                          row_rd_en = false;
                  }
                  if (row_rate < 65536 || row_rd_en)
                      v_phase_acc = v_phase_acc + row_rate;
              }

              h_phase = (h_phase_acc >> 12) & 15;
              if (col_rate < 65536) {
                  col_rd_en = true;
                  N16 dcol = col * col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_wr_en = true;
                      cols_rw = dcol;
                  } else
                      col_wr_en = false;
              } else {
                  col_wr_en = true;
                  N16 dcol = col / col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_rd_en = true;
                      cols_rw = dcol;
                  } else
                      col_rd_en = false;
              }

              if (col > 0 && (col_rate < 65536 || col_rd_en))
                  h_phase_acc = h_phase_acc + col_rate;
              else
                  h_phase_acc = col_rate;

              if (col_rd_en) {
                  h_shreg.shift_left();
                  if (row_rd_en) {
                      if (row < rows && col < cols) {
                          pix_in = _src.read();
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (col >= cols && row < rows) {
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (row >= rows) {
                          for (int m = 0; m < ((((T) & ((512 - 1) << 11)) >> 11) + 1); m++)
                              pix_in.val[0] = 0;
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      }
                  }
              }

              for (int i = 0; i < NTAPS; i++) {
                  temp_in[i] = linebuf.val[i][col];
              }

              if (col_wr_en) {
                  if ((row_rd_en) || (row < ES) || (row >= rows - ES)) {
                      for (int i = NTAPS - 1; i > 0; i--) {
                          temp_out[i] = temp_in[i - 1];
                      }
H_LOOP: for (int i = 0; i < NTAPS; i++) {
            h_fir[i] =
                (col > i) ?
                h_shreg.getval(0, i) :
                h_shreg.getval(0, NTAPS - 1 - col);
        }
        h_fir_out = scale_operator<NTAPS, COEFF_BITS, T>(h_fir,
                hcoeffs[h_phase]);
        temp_out[0] = h_fir_out;
        v_fir[NTAPS - 1] = h_fir_out;
                  } else {
                      for (int i = NTAPS - 1; i >= 0; i--) {
                          temp_out[i] = temp_in[i];
                      }
                      v_fir[NTAPS - 1] = temp_in[0];
                  }
V_LOOP: for (int i = 0; i < NTAPS - 1; i++) {
            v_fir[i] =
                (row > 0) ? temp_out[NTAPS - 1 - i] : temp_out[0];
        }
              }

              for (int i = 0; i < NTAPS; i++) {
                  linebuf.val[i][col] = (row > 0) ? temp_out[i] : temp_out[0];
              }

              if (row >= 3 && col >= 3 && row_wr_en && col_wr_en) {
                  pix_out = scale_operator<NTAPS, COEFF_BITS, T>(v_fir, vcoeffs[v_phase]);
                  _dst.write(pix_out);
              }
          }
          }
}

template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize_opr_linear (
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<DROWS, DCOLS, SRC_T> &_dst )
{
    LineBuffer<2,(COLS>DCOLS?COLS:DCOLS)+1,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > k_buf;
    Window<2,2,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;
    short dcols=_dst.cols;
    short drows=_dst.rows;
    short srows=_src.rows;
    short scols=_src.cols;
    ap_fixed<32,16,AP_RND> row_rate=((ap_fixed<32,16,AP_RND> )srows)/(ap_fixed<32,16,AP_RND>)drows;
    ap_fixed<32,16,AP_RND> col_rate=((ap_fixed<32,16,AP_RND> )scols)/(ap_fixed<32,16,AP_RND>)dcols;
    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<20,2,AP_RND> ,4>::FILTER_CAST_T u,v, u1,v1;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s, temp, d;
    ap_fixed<4,2,AP_RND> par=0.5;
    ap_fixed<20,10,AP_RND> offset_row=row_rate/2-par;
    ap_fixed<20,10,AP_RND> offset_col=col_rate/2-par;
    ap_fixed<32,16,AP_RND> fx=0;
    ap_fixed<32,16,AP_RND> fy=0;

    short rows=srows > drows ? srows : (drows+1);
    short cols=scols > dcols ? scols : (dcols+1);
    ((rows<=ROWS || rows<=DROWS+1) ? static_cast<void> (0) : __assert_fail ("rows<=ROWS || rows<=DROWS+1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2284, __PRETTY_FUNCTION__));
    ((cols<=COLS || cols<=DCOLS+1) ? static_cast<void> (0) : __assert_fail ("cols<=COLS || cols<=DCOLS+1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2285, __PRETTY_FUNCTION__));

    short x=0;
    short pre_fy=-10;
    short pre_fx=-10;
    bool row_rd=false;
    bool row_wr=false;

    for(short i= 0;i<rows;i++) {
        for(short j= 0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE

            bool col_rd=false;
            bool col_wr=false;

            short dy = row_rate>1 ? (short)(i/row_rate):(i-1);
            short dx = col_rate>1 ? (short)(j/col_rate):(j-1);

            fy =(dy)*row_rate+offset_row;
            fx =(dx)*col_rate+offset_col;

            short sx=(short)fx;
            short sy=(short)fy;
            if(fx-sx>0)
                u=fx-sx;
            else
                u=0;
            if(fy-sy>0)
                v=fy-sy;
            else
                v=0;
            u1=1-u;
            v1=1-v;
            if(sx>scols-1)
            {
                sx=scols-1;
                u=0;
            }
            if(sy>srows-1)
            {
                sy=srows-1;
                v=0;
            }
            if(j==0)
            {
                x=0;
                pre_fx=-10;
                if(row_rate>1)
                {
                    row_rd=true;
                    row_wr= (sy==(i-1)) ? true : false;
                }
                else
                {
                    if(i==0){
                        row_rd=true;
                    }
                    else if(sy!=pre_fy)
                    {
                        row_rd=true;
                        pre_fy=sy;
                    }
                    else {
                        row_rd=false;
                    }
                    row_wr= i>0? true: false;
                }
            }
            if(col_rate>1)
            {
                col_rd=true;
                col_wr= (sx==(j-1)) ? true : false;
            }else{
                if(j==0){
                    col_rd=true;
                }
                else if(sx!=pre_fx)
                {
                    col_rd=true;
                    pre_fx=sx;
                }
                else
                    col_rd=false;
                col_wr= j>0? true: false;
            }
            if(col_rd)
            {
                for(int r= 0;r<2;r++)
                {
                    win.val[r][1]=win.val[r][0];
                }
                if(row_rd)
                {

                    k_buf.val[1][x]=k_buf.val[0][x];
                    win.val[1][0]=k_buf.val[0][x];
                    if(sy<srows-1&&sx<scols-1)
                    {
                        _src >> s;
                        k_buf.val[0][x]=s;
                        win.val[0][0]=k_buf.val[0][x];
                    }
                    else if(sx>=scols-1&&sy<srows-1){
                        k_buf.val[0][x]=s;
                    }
                    else if(sy>=srows-1){
                        win.val[0][0]=k_buf.val[0][x];
                    }
                }
                else
                {
                    for(int r= 0;r<2;r++)
                    {
                        win.val[r][0]=k_buf.val[r][x];
                    }
                }

                x++;
            }
            if(row_wr && col_wr)
            {
                for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
                {
                    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<15,1,AP_RND> ,4>::ACCUM_T t=0;
                    typedef typename fixed_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T SRCT;

                    t=((SRCT)win.val[1][1].val[k])*u1*v1+
                        ((SRCT)win.val[1][0].val[k])*v1*u+
                        ((SRCT)win.val[0][1].val[k])*u1*v+
                        ((SRCT)win.val[0][0].val[k])*u*v;
                    d.val[k]=sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(t);
                }
                _dst << d;
            }
        }
    }
}







template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, SRC_T> &_dst,
        int interpolation=1 )
{
    switch(interpolation) {
    case 0:
        (("hls::Resize: HLS_INTER_NEAREST not supported") ? static_cast<void> (0) : __assert_fail ("\"hls::Resize: HLS_INTER_NEAREST not supported\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2439, __PRETTY_FUNCTION__));
        break;
    case 2:
        (("hls::Resize: HLS_INTER_AREA not supported") ? static_cast<void> (0) : __assert_fail ("\"hls::Resize: HLS_INTER_AREA not supported\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2442, __PRETTY_FUNCTION__));
        break;
    case 4:
        (("hls::Resize: HLS_INTER_LANCZOS4 not supported") ? static_cast<void> (0) : __assert_fail ("\"hls::Resize: HLS_INTER_LANCZOS4 not supported\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2445, __PRETTY_FUNCTION__));
        break;
    case 3:
        Resize_opr_bicubic(_src,_dst);
        break;
    case 1:
        Resize_opr_linear(_src,_dst);
        break;
    }
}

template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScale (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2467, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2468, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(_s.val[k]*alpha+beta);
            }
            _dst<<_d;
        }
    }
}

template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScaleAbs (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2496, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2497, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
            _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(abs(_s.val[k]*alpha+beta));
            }
            _dst<<_d;
        }
    }
}
template<int XORDER, int YORDER, int SIZE, typename T>
void Sobel_kernel(Window<SIZE,SIZE,T > &kernel)
{
    int kerI[SIZE+1];
    Window<1,SIZE,T> kernelX;
    Window<SIZE,1,T> kernelY;

    for(int k=0; k<2; k++)
    {
        int order = k == 0 ? XORDER : YORDER;

        if( SIZE==3 )
        {
            if(order==0 )
                kerI[0]=1, kerI[1]=2, kerI[2]=1;
            else if( order == 1 )
                kerI[0]=-1, kerI[1]=0, kerI[2]=1;
            else
                kerI[0]=1, kerI[1]=-2, kerI[2]=1;
        }
        else
        {
            int oldval, newval;
            kerI[0] = 1;
            for(int i=0; i<SIZE; i++)
                kerI[i+1] = 0;

            for(int i=0; i<SIZE-order-1; i++)
            {
                oldval = kerI[0];
                for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j]+kerI[j-1];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }

            for(int i = 0; i < order; i++ )
            {
                oldval = -kerI[0];
                for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j-1] - kerI[j];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }
        }

        for(int i=0; i<SIZE; i++) {
         if(k==0)
             kernelX(0,i)=kerI[i];
         else
             kernelY(i,0)=kerI[i];
     }
    }

    for(int i=0; i<SIZE; i++) {
        for(int j=0; j<SIZE; j++) {
            kernel(i,j)=kernelY(i,0)*kernelX(0,j);
     }
    }

}

template<int XORDER, int YORDER, int SIZE, typename BORDERMODE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{
   (((SIZE==3 || SIZE==5||SIZE==7)) ? static_cast<void> (0) : __assert_fail ("(SIZE==3 || SIZE==5||SIZE==7)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2584, __PRETTY_FUNCTION__));

    Window<SIZE,SIZE,ap_int<8> > kernel;
    Sobel_kernel<XORDER, YORDER >(kernel);
    Point_<int> c_point;
    c_point.x=-1;
    c_point.y=-1;
    Filter2D<BORDERMODE>(_src,_dst,kernel, c_point);
}

template<int XORDER, int YORDER, int SIZE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{
    Sobel<XORDER,YORDER,SIZE,BORDER_DEFAULT>(_src, _dst);
}

template<int KH,int KW,typename K_T,typename XT, typename YT>
void getGaussianKernel(
        Window<KH,KW,K_T> &kernel,
        XT sigmaX=0,
        YT sigmaY=0
        )
{
#pragma HLS INLINE off
     float kval[KH][KW];
     float sum=0;
     if(sigmaX <= 0)
     {
         sigmaX=0.3*((KW-1)*0.5-1)+0.8;
     }
     if(sigmaY <= 0)
     {
         sigmaY=0.3*((KH-1)*0.5-1)+0.8;
     }
     for (int i = 0; i < KH; i++) {
            for (int j = 0; j < KW; j++) {
                float index1=powf( (i-(KH-1)/2),2)*1.0/(2*sigmaY*sigmaY);
                float index2=powf( (j-(KW-1)/2),2)*1.0/(2*sigmaX*sigmaX);
                float index= -index1-index2;
                kval[i][j] = expf(index);
                sum+=kval[i][j];
            }
        }
     for (int i = 0; i < KH; i++) {
         for (int j = 0; j < KW; j++) {
             kval[i][j]=kval[i][j]/sum;
             kernel.val[i][j]=kval[i][j];
         }
     }

}

template<int KH,int KW,typename BORDERMODE,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    Point_<int> anchor;
    anchor.x = -1;
    anchor.y = -1;
    Window<KW, KH, ap_fixed<16,2,AP_RND> > kernel;
    getGaussianKernel(kernel,sigmaX,sigmaY);
    Filter2D<BORDERMODE>(_src, _dst, kernel, anchor);
}

template<int KH,int KW,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    GaussianBlur<KH,KW,BORDER_DEFAULT>(_src, _dst, sigmaX, sigmaY);
}


template <int KH,int KW>
void Box_kernel_1d(
        Window<1, KW, ap_ufixed<1,1> >& kernelX,
        Window<KH, 1, ap_ufixed<1,1> >& kernelY
        )
{
    float kval[KW];

    for (int i = 0; i < KW; i++) {
        kernelX.val[0][i] = 1;
    }

    for (int i = 0; i < KH; i++) {
        kernelY.val[i][0] = 1;
    }
}

template<int KH,int KW, bool NORMALIZE,typename BORDERMODE,
  int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    Window<1, KW, ap_ufixed<1,1> > kernelX;
    Window<KH, 1, ap_ufixed<1,1> > kernelY;
    Box_kernel_1d(kernelX,kernelY);

    if( NORMALIZE)
    {
        const int BW = BitWidth<KH*KW>::Value+Type<((SRC_T) & ((1 << 11) - 1))>::bitdepth;
        const ap_ufixed<BW+1,1> scale = 1.0/(KH*KW);
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor, scale);
    }
    else
    {
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor);
    }
}

template<int KH,int KW, typename BORDERMODE, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDERMODE>(_src, _dst, anchor);
}

template<int KH,int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDER_DEFAULT>(_src, _dst, anchor);
}


template <typename T,typename FT, int KH,int KW>
void Pyr_kernel(
        Window<KH, KW, T>& kernel,
        FT factor
        )
{
    int k[25]={1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1};
    for(int i=0; i<5; i++)
        for(int j=0; j<5; j++)
            kernel.val[i][j]=k[i*5+j]*(1.0/256)*factor;
}
template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrUp_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{
    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2744, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2745, __PRETTY_FUNCTION__));
#pragma HLS inline

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=right_border_buf complete dim=0

    Point_< ap_int<14> > anchor;
    anchor.x=K_HEIGHT/2;
    anchor.y=K_WIDTH/2;
    ap_int<14> heightloop= 2*(rows+K_HEIGHT-1+K_HEIGHT);
    ap_int<14> widthloop = 2*(cols+K_WIDTH-1);
    Point_<ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE
                bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;
                ImagLoc.x=j/2-anchor.x;
                ImagLoc.y=i/2-K_HEIGHT-anchor.y;
                int x= ImagLoc.x;
                if(ImagLoc.x<0)
                    x= -ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols- ImagLoc.x-1;
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    if(oddcol)
                    {

                        for(int row= 0;row<K_HEIGHT;row++)
                            for(int col= K_WIDTH-1;col>=1;col--)
                                src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                        for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                        {

                            col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                        }

                        if((ImagLoc.y < (-anchor.y)) ||
                                (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 )) {

                            if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0);
                                src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                                for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                {
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                    src_kernel_win[k](buf_row-1,0)=temp;
                                }
                                if(oddrow)
                                {
                                    if(ImagLoc.x >= cols - K_WIDTH)
                                    {
                                        right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                                    }
                                    for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                    {
                                        typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                        k_buf[k](buf_row,x)=temp;
                                        if(ImagLoc.x >= cols - K_WIDTH)
                                        {
                                            right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                        }
                                    }
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                                    _src.data_stream[k] >> temp;
                                    k_buf[k](0,x)=temp;
                                }
                            }
                            else if(ImagLoc.x < 0)
                            {
                                for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0);
                                }
                            }
                            else if (ImagLoc.x >= cols) {
                                for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH));
                                }
                                if(!oddrow)
                                {
                                   for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                     src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                                }

                            }
                        }
                        else if(ImagLoc.y > 0 )
                        {
                            ap_int<14> ref = K_HEIGHT-1;
                            if(ImagLoc.y >= rows-1)
                                ref = rows-1;
                            ap_int<14> y = ImagLoc.y;
                            for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                            {
                                ap_int<14> t=y;
                                if(y<0)
                                    t=-y;
                                else if( y >= rows )
                                    t=2*rows-y-1;

                                ap_int<14> locy = ref - t;
                                src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                                y--;
                            }
                           if(ImagLoc.y >= rows-1&&!oddrow)
                            {
                                for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                   src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                            }
                        }

                    }

                    if(i >= 2*(K_HEIGHT + K_HEIGHT - 1) && j >= 2*(K_WIDTH-1))
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, K_HEIGHT*K_WIDTH>::ACCUM_T result=0;
                        if(oddrow)
                        {
                            if(oddcol)
                            {
                                for(int m=0; m<K_HEIGHT; m++)
                                    for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n];
                            }
                            else
                            {
                                for(int m=0; m<K_HEIGHT; m++)
                                    for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n-1];
                            }
                        }else
                        {
                            if(oddcol)
                            {
                                for(int m=0; m<K_HEIGHT-1; m++)
                                    for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n];
                            }
                            else
                            {

                                for(int m=0; m<K_HEIGHT-1; m++)
                                    for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n-1];
                            }
                        }
                        _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrUp(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{
    ((_src.rows*2== _dst.rows && _src.cols*2==_dst.cols) ? static_cast<void> (0) : __assert_fail ("_src.rows*2== _dst.rows && _src.cols*2==_dst.cols", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2923, __PRETTY_FUNCTION__));
    Window<5, 5, ap_fixed<16,2,AP_RND> > kernel;
    Pyr_kernel(kernel, 4);
    PyrUp_opr<3,3>(_src, _dst, kernel);
}

template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrDown_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{
      (((_src.rows+1)/2== _dst.rows && (_src.cols+1)/2==_dst.cols) ? static_cast<void> (0) : __assert_fail ("(_src.rows+1)/2== _dst.rows && (_src.cols+1)/2==_dst.cols", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2937, __PRETTY_FUNCTION__));
#pragma HLS inline

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    LineBuffer<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=right_border_buf complete dim=0

    Point_< ap_int<4> > anchor;
    anchor.x=K_WIDTH/2;
    anchor.y=K_HEIGHT/2;

    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2961, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 2962, __PRETTY_FUNCTION__));
    HLS_SIZE_T heightloop= rows+K_HEIGHT-1+K_HEIGHT;
    HLS_SIZE_T widthloop = cols+K_WIDTH-1;
    Point_< ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE
                bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;

                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-K_HEIGHT-anchor.y;
                int x=ImagLoc.x ;
                if(ImagLoc.x<0)
                    x=-ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols-ImagLoc.x-2;
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {

                    for(int row= 0;row<K_HEIGHT;row++)
                        for(int col= K_WIDTH-1;col>=1;col--)
                            src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                    for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                    {

                        col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                    }
                    if((ImagLoc.y < (-anchor.y)) ||
                            (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 ))
                    {

                        if(ImagLoc.x >= 0 && ImagLoc.x < cols)
                        {
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0);
                            src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                            if(ImagLoc.x >= cols - K_WIDTH)
                            {
                                right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                            }
                            for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                            {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                src_kernel_win[k](buf_row-1,0)=temp;
                                k_buf[k](buf_row,x)=temp;
                                if(ImagLoc.x >= cols - K_WIDTH)
                                {
                                    right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                }
                            }
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                            _src.data_stream[k] >> temp;
                            k_buf[k](0,x)=temp;
                        }
                        else if(ImagLoc.x < 0)
                        {
                            for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0);
                            }
                        }
                        else if (ImagLoc.x >= cols)
                        {
                            for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH));
                            }
                        }
                    }
                    else if(ImagLoc.y >= 0) {

                        ap_int<14> ref = K_HEIGHT-1;
                        if(ImagLoc.y >= rows-1)
                            ref = rows-1;
                        ap_int<14> y = ImagLoc.y;
                        for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                        {
                            ap_int<14> t = y;
                            if(y<0)
                                t=-y;
                            else if( y>= rows )
                                t=2*rows-y-2;
                            ap_int<14> locy = ref - t;
                            ((t < 0 || (locy >= 0 && locy < K_HEIGHT)) ? static_cast<void> (0) : __assert_fail ("t < 0 || (locy >= 0 && locy < K_HEIGHT)", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_imgproc.h", 3050, __PRETTY_FUNCTION__));
                            src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                            y--;
                        }
                    }

                    if(i >= (K_HEIGHT + K_HEIGHT - 1) && j >= (K_WIDTH-1))
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, 5*5>::ACCUM_T result=0;
                        if(!oddrow&&oddcol)
                        {
                            for(int m=0; m<K_HEIGHT; m++)
                                for(int n=0; n<K_WIDTH; n++)
                                    result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[m][n];
                            _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                        }
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrDown(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{
    Window<5, 5, ap_fixed<16,2,AP_RND> > kernel;
    Pyr_kernel(kernel, 1);
    PyrDown_opr<5,5>(_src, _dst, kernel);
}

}
#63 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_histogram.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_histogram.h"
namespace hls {

template<int SRC_T, int DST_T,int ROW, int COL, int N>
void Equalize(
 Mat<ROW, COL, SRC_T> &_src,
 Mat<ROW, COL, DST_T> &_dst,
    ap_uint<8> (&map)[N]
                      )
{

    const int NUM_STATES=4;
    Window<1,NUM_STATES,ap_uint<8> > addr_win;

    ap_uint<BitWidth<ROW*COL>::Value> hist_out[N];
    Window<1,NUM_STATES,ap_uint<BitWidth<ROW*COL>::Value> > hist_win;
    ap_uint<BitWidth<ROW*COL>::Value> hist;
    ap_uint<8> addr;
    ap_uint<8> addr_last;
    ap_uint<BitWidth<ROW*COL>::Value> hist_last;
    ap_uint<8> addr_flag;
    ap_uint<BitWidth<ROW*COL>::Value> hist_flag;
    ap_uint<8> addr_w;
    ap_uint<BitWidth<ROW*COL>::Value> hist_w;

    for(int i=0;i<NUM_STATES;i++) {
#pragma HLS UNROLL
        addr_win(0,i)=i;
        hist_win(0,i)=0;
    }

    for(int i=0;i<N;i++)
        hist_out[i]=0;

    int cols=_src.cols;
    int rows=_src.rows;
    ((rows<=ROW) ? static_cast<void> (0) : __assert_fail ("rows<=ROW", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_histogram.h", 74, __PRETTY_FUNCTION__));
    ((cols<=COL) ? static_cast<void> (0) : __assert_fail ("cols<=COL", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_histogram.h", 75, __PRETTY_FUNCTION__));
 loop_height: for(int i=0;i<rows;i++)
    {
    loop_width: for(int j=0;j<cols;j++)
        {
#pragma HLS PIPELINE
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
            ap_uint<4> flag=NUM_STATES;
            typename Type<((SRC_T) & ((1 << 11) - 1))>::name tempsrc=0;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name tempdst=0;
            _src.data_stream[0].read(tempsrc);
            tempdst=map[tempsrc];
            _dst.data_stream[0]<<tempdst;

            for (int m=0; m<NUM_STATES; m++) {
                if (tempsrc==addr_win(0,m)) {
                    flag = m;
                    break;
                }
            }

            latency_region:{
#pragma HLS latency min=0 max=1
            addr_last = addr_win(0,NUM_STATES-1);
            hist_last = hist_win(0,NUM_STATES-1)+1;

            for (int m=NUM_STATES-1; m>0; m--) {
                addr = addr_win(0,m-1);
                hist = hist_win(0,m-1);
                if (m==NUM_STATES/2) {
                    addr_w = addr;
                    if (m==flag+1) {
                        hist_w = hist+1;
                    } else {
                        hist_w = hist;
                    }
                }
                if (m==flag+1) {
                    addr_flag = addr;
                    hist_flag = hist+1;
                    addr_win(0,m) = addr_flag;
                    hist_win(0,m) = hist_flag;
                } else {
                    addr_win(0,m) = addr;
                    hist_win(0,m) = hist;
                }
            }

            if (flag==NUM_STATES) {
                hist_win(0,0) = hist_out[tempsrc]+1;
                addr_win(0,0) = tempsrc;
            } else if (flag==NUM_STATES-1) {
                addr_win(0,0) = addr_last;
                hist_win(0,0) = hist_last;
            } else if (flag>=NUM_STATES/2) {
                addr_win(0,0) = addr_flag;
                hist_win(0,0) = hist_flag;
            } else {
                addr_win(0,0) = addr_w;
                hist_win(0,0) = hist_w;
            }

            hist_out[addr_w] = hist_w;
            }
        }
    }
    for (int m=0; m<NUM_STATES/2; m++) {
#pragma HLS PIPELINE
        hist_out[addr_win(0,m)]=hist_win(0,m);
    }



    float scale = 1.f;
    ap_uint<BitWidth<ROW*COL>::Value> sum=0;
    bool flag = false;
 loop_normalize: for(int i=0;i<N;i++)
    {
#pragma HLS PIPELINE

        if (!flag) {
            if (hist_out[i] != 0) {
                flag = true;
                scale = 255.0f/(cols*rows - hist_out[i]);
                map[i] = 0;
                continue;
            }
        }

        sum+=hist_out[i];
        ap_uint<8> val=sr_cast< ap_uint<8> > (sum*scale);
        map[i]=val;
    }
    map[0]=0;
}

static ap_uint<8> lut[256];
template<int SRC_T, int DST_T,int ROW, int COL>
void EqualizeHist(
  Mat<ROW, COL, SRC_T> &_src,
  Mat<ROW, COL, DST_T> &_dst)
{
#pragma HLS INLINE
    Equalize(_src, _dst, lut);
}
}
#64 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h" 1
#39 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h"
namespace hls {

    template<int PSize,int KERNEL_SIZE,int NUM,typename SRC_T, typename DIFF_T>
int fast_pixel_diff(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> &win,
        SRC_T _threshold,
        ap_uint<2> (&flag_val)[NUM],
        DIFF_T (&flag_d)[NUM],
        int (&flag)[PSize][2])
{
#pragma HLS INLINE
    DIFF_T d1,d2;
    int vt1,vt2;
    int x1,x2,y1,y2;
    int result=3;
    int K=PSize/2;
    for(int index=0;index<K;index++) {
        int kernel_half=KERNEL_SIZE/2;
        x1=flag[index][0];
        y1=flag[index][1];
        x2=flag[index+K][0];
        y2=flag[index+K][1];
        d1=win.val[kernel_half][kernel_half]-win.val[ y1 ][ x1 ];
        d2=win.val[kernel_half][kernel_half]-win.val[ y2 ][ x2 ];
        flag_d[index]=d1;
        flag_d[index+K]=d2;
        flag_d[index+PSize]=d1;
        if (d1 > _threshold)
            vt1=1;
        else if(d1 < -_threshold)
            vt1=2;
        else
            vt1=0;
        if (d2 > _threshold)
            vt2=1;
        else if(d2 < -_threshold)
            vt2=2;
        else
            vt2=0;
        result &= vt1 | vt2;
        flag_val[index] = vt1;
        flag_val[index+K] = vt2;
        flag_val[index+PSize] = vt1;
    }
    flag_val[PSize/2+PSize] = flag_val[PSize/2];
    flag_d[PSize/2+PSize] = flag_d[PSize/2];
    return result;
}

    template<int PSize,int NUM, typename DIFF_T, typename SRC_T>
int coreScore(DIFF_T (&flag_d)[NUM], SRC_T _threshold)
{
#pragma HLS INLINE

    DIFF_T flag_d_min2[NUM-1];
    DIFF_T flag_d_max2[NUM-1];
    DIFF_T flag_d_min4[NUM-3];
    DIFF_T flag_d_max4[NUM-3];
    DIFF_T flag_d_min8[NUM-7];
    DIFF_T flag_d_max8[NUM-7];
#pragma HLS ARRAY_PARTITION variable=flag_d_min2 dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d_max2 dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d_min4 dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d_max4 dim=0
    if(PSize == 16) {
        for(int i=0;i<NUM-1;i++) {
            flag_d_min2[i] = reg(((flag_d[i]) < (flag_d[i+1]) ? (flag_d[i]) : (flag_d[i+1])));
            flag_d_max2[i] = reg(((flag_d[i]) > (flag_d[i+1]) ? (flag_d[i]) : (flag_d[i+1])));
        }
        for(int i=0;i<NUM-3;i++) {
            flag_d_min4[i] = reg(((flag_d_min2[i]) < (flag_d_min2[i+2]) ? (flag_d_min2[i]) : (flag_d_min2[i+2])));
            flag_d_max4[i] = reg(((flag_d_max2[i]) > (flag_d_max2[i+2]) ? (flag_d_max2[i]) : (flag_d_max2[i+2])));
        }

        for(int i=0;i<NUM-7;i++) {
            flag_d_min8[i] = reg(((flag_d_min4[i]) < (flag_d_min4[i+4]) ? (flag_d_min4[i]) : (flag_d_min4[i+4])));
            flag_d_max8[i] = reg(((flag_d_max4[i]) > (flag_d_max4[i+4]) ? (flag_d_max4[i]) : (flag_d_max4[i+4])));
        }
    } else {
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 118, __PRETTY_FUNCTION__));
    }

    DIFF_T a0 = _threshold;
    for(int i=0;i<PSize;i+=2) {
        DIFF_T a = hls::numeric_limits<DIFF_T>::max();
        if(PSize == 16) {
            a = flag_d_min8[i+1];
        } else {
            for(int j=1;j<PSize/2+1;j++) {
                a=((a) < (flag_d[i+j]) ? (a) : (flag_d[i+j]));
            }
        }
        a0 = ((a0) > (((a) < (flag_d[i]) ? (a) : (flag_d[i]))) ? (a0) : (((a) < (flag_d[i]) ? (a) : (flag_d[i]))));
        a0 = ((a0) > (((a) < (flag_d[i+PSize/2+1]) ? (a) : (flag_d[i+PSize/2+1]))) ? (a0) : (((a) < (flag_d[i+PSize/2+1]) ? (a) : (flag_d[i+PSize/2+1]))));
    }
    DIFF_T b0 = -_threshold;
    for(int i=0;i<PSize;i+=2) {
        DIFF_T b = hls::numeric_limits<DIFF_T>::min();
        if(PSize == 16) {
            b = flag_d_max8[i+1];
        } else {
            for(int j=1;j<PSize/2+1;j++) {
                b=((b) > (flag_d[i+j]) ? (b) : (flag_d[i+j]));
            }
        }
        b0 = ((b0) < (((b) > (flag_d[i]) ? (b) : (flag_d[i]))) ? (b0) : (((b) > (flag_d[i]) ? (b) : (flag_d[i]))));
        b0 = ((b0) < (((b) > (flag_d[i+PSize/2+1]) ? (b) : (flag_d[i+PSize/2+1]))) ? (b0) : (((b) > (flag_d[i+PSize/2+1]) ? (b) : (flag_d[i+PSize/2+1]))));
    }
    return ((a0) > ((DIFF_T)-b0) ? (a0) : ((DIFF_T)-b0))-1;
}

template<int PSize,int KERNEL_SIZE,typename SRC_T, typename DIFF_T>
bool fast_judge(Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & win,
                SRC_T _threshold,
                ap_uint<2> (&flag_val)[PSize+PSize/2+1],
                DIFF_T (&flag_d)[PSize+PSize/2+1],
                int (&flag)[PSize][2],
                int &core,
                bool _nonmax_supression) {
#pragma HLS ARRAY_PARTITION variable=flag_val dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d dim=0

#pragma HLS INLINE
    bool iscorner=false;
    int kernel_half=KERNEL_SIZE/2;
    int result=fast_pixel_diff<PSize>(win,_threshold,flag_val,flag_d,flag);
    int count=1;
    for(int c=1;c<PSize+PSize/2+1;c++)
    {
        if(flag_val[c-1]==flag_val[c] && flag_val[c]>0)
        {
            count++;
            if(count>PSize/2)
            {
                iscorner=true;
            }
        }
        else
        {
            count=1;
        }
    }
    if(_nonmax_supression && iscorner) {
        core=coreScore<PSize>(flag_d,_threshold);
    }
    return iscorner;
}
template<int KERNEL_SIZE,typename SRC_T>
bool fast_nonmax(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & core_win
        )
{
#pragma HLS INLINE
    bool iscorner=true;
    for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[0][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[2][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    if(core_win.val[1][1]>core_win.val[1][0]&&core_win.val[1][1]>core_win.val[1][2])
        iscorner=iscorner && true;
    else
        iscorner=iscorner && false;
    return iscorner;
}

template<int PSize,int KERNEL_SIZE,int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]) {
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<(((((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((512 - 1) << 11)) >> 11) + 1),typename Type<(((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 228, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 229, __PRETTY_FUNCTION__));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
#pragma HLS ARRAY_PARTITION variable=flag_val dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d dim=0

    int index=0;
    int offset=KERNEL_SIZE/2;
    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
            d.val[0]=0;
            if((i<rows&&j<cols)) {
                for(int r= 0;r<KERNEL_SIZE;r++) {
                    for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }

            for(int r= 0;r<3;r++)
            {
                for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;


            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {

                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    d.val[0]=255;
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(core_win.val[1][1]!=0&&i>=KERNEL_SIZE&&j>=KERNEL_SIZE)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                        d.val[0]=255;
                    }
                }
            }

            if(i>=offset&&j>=offset)
            {
                _mask<<d;
            }
        }
    }
}
template<int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
#pragma HLS INLINE
    int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_mask,_threshold,_nomax_supression,flag);
}

template<int PSize,int KERNEL_SIZE,typename T, int N, int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]
        )
{
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    int rows= _src.rows;
    int cols= _src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 345, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 346, __PRETTY_FUNCTION__));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
#pragma HLS ARRAY_PARTITION variable=flag_val dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d dim=0
    int index=0;
    int offset=KERNEL_SIZE/2;

    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
            if(i<rows&&j<cols) {
                for(int r= 0;r<KERNEL_SIZE;r++) {
                    for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }

            for(int r= 0;r<3;r++)
            {
                for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;


            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {

                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    if(index<N)
                    {
                    _keypoints[index].x=j-offset;
                    _keypoints[index].y=i-offset;
                    index++;
                    }
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(i>=KERNEL_SIZE&&j>=KERNEL_SIZE&&core_win.val[1][1]!=0)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                    if(index<N)
                    {
                        _keypoints[index].x=j-offset;
                        _keypoints[index].y=i-offset;
                        index++;
                    }
                    }
                }
            }

        }
    }
}
template<typename T, int N, int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
#pragma HLS INLINE
    int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_keypoints,_threshold,_nomax_supression,flag);
}
template<int SRC_T,int MASK_T,int ROWS,int COLS>
void PaintMask(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,MASK_T> &_mask,
        Mat<ROWS,COLS,SRC_T> &_dst,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _color
        )
{
    ((_src.rows == _mask.rows) ? static_cast<void> (0) : __assert_fail ("_src.rows == _mask.rows", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 457, __PRETTY_FUNCTION__));
    ((_src.rows == _dst.rows) ? static_cast<void> (0) : __assert_fail ("_src.rows == _dst.rows", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 458, __PRETTY_FUNCTION__));
    ((_src.cols == _mask.cols) ? static_cast<void> (0) : __assert_fail ("_src.cols == _mask.cols", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 459, __PRETTY_FUNCTION__));
    ((_src.cols == _dst.cols) ? static_cast<void> (0) : __assert_fail ("_src.cols == _dst.cols", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 460, __PRETTY_FUNCTION__));
    int rows= _src.rows;
    int cols= _src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 463, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_fast.h", 464, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MASK_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MASK_T) & ((1 << 11) - 1))>::name> m;
 loop_height: for(HLS_SIZE_T i=0;i<rows;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
            _src >> s;
            _mask >> m;
            if(m.val[0]!=0)
            {
                d = _color;
            }
            else
            {
                d = s;
            }
            _dst << d;
        }
    }
}
}
#65 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h" 1
#83 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
namespace hls {

template <int N, typename T,typename PT>
void LU( T A[N][N], PT pos[N])
{
    int imax = 0;
    T lu[N] ;
    for (int i = 0; i < N; i++)
    {
        lu[i]=0;
    }
    for (int i = 0; i < N; i++) {
        T big = 0.0;
        for (int j = 0; j < N; j++) {
            T temp = ::hls::abs((double)A[i][j]);
            if (temp > big) big = temp;
        }
        lu[i] = ((T)1.0)/big;
    }
    for (int j = 0; j < N; j++) {
        for (int i = 0; i < j; i++) {
            T sum = A[i][j];
            for (int k = 0; k < i; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
        }
        T big = 0.0;
        for (int i = j; i < N; i++) {
            T sum = A[i][j];
            for (int k = 0; k < j; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
            T dum = lu[i] *((T) ::hls::abs((double)sum));
            if (dum >= big) {
                big = dum;
                imax = i;
            }
        }
        if (j != imax&&imax<N&&imax>=0) {
            for (int i = 0; i < N; i++) {
                T mid = A[imax][i];
                A[imax][i] = A[j][i];
                A[j][i] = mid;
            }
            T mid = lu[j];
            lu[j] = lu[imax];
            lu[imax] = mid;
        }
        pos[j] = imax;
        if (j != N - 1) {
            T dum = ((T)1.0)/(A[j][j]);
            for (int i = j + 1; i < N; i++) A[i][j] *= dum;
        }
    }
}
template <int N, typename T, typename PT,typename BT>
void LUex(T A[N][N], PT pos[N],BT b[N])
{
    int ii = 0;
    for (int i = 0; i < N; i++) {
        int ip = pos[i];
        T sum=0;
        if(ip<N&& ip>=0)
        {
            sum = b[ip];
            b[ip] = b[i];
        }
        if (ii != 0)
            for (int j = ii - 1; j < i; j++) sum -= A[i][j] * b[j];
        else
            ii = i + 1;
        b[i] = sum;
    }
    for (int i = N - 1; i >= 0; i--) {
        T sum = b[i];
        for (int j = i + 1; j < N; j++) sum -= A[i][j]*b[j];
        b[i] = (sum)*((T) 1.0/A[i][i]);
    }
}


template <int N,typename T>
void Invert(T A[N][N],T Ar[N][N], int flags=0)
{
    T b[N];
    int pos[N];
    for (int i = 0; i < N; i++) {
        b[i]=0;
        pos[i]=0;
    }
    LU<N>(A,pos);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) b[j] = 0;
        b[i] = 1.0;
        LUex<N>(A,pos,b);
        for (int j = 0; j < N; j++) Ar[j][i] = b[j];
    }
}
template<int AROW, int ACOL, int BCOL, typename AT, typename BT, typename CT>
void mul(
               AT A [AROW][ ACOL],
               BT B [AROW][ BCOL],
               CT C [AROW][ BCOL]
)
{
 loop_i: for(int i=0; i<AROW; i++)
    {
    loop_j: for(int j=0; j<BCOL; j++)
        {
            CT sum=0;
        loop_k: for(int k=0; k<ACOL; k++)
                {
                sum=sum+A[i][k]*B[k][j];

            }
            C[i][j]=sum;
        }
    }
}





template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_nearest(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2


        )
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW][COLS];
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 222, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 223, __PRETTY_FUNCTION__));
    int ishift=WIN_ROW/2;
    int r[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
#pragma HLS LOOP_FLATTEN OFF
    loop_width: for( int j=0; j< cols; j++)
        {
#pragma HLS PIPELINE II=1
#pragma HLS dependence array inter false
            if(i<rows&& j<cols)
            {
                src >> s;
            }
            buf[i % WIN_ROW][j] = s;
            r[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0]+1;
                int y=m1.val[1]+1;

                bool in_range = (y>=0 && y<rows && r[y%WIN_ROW] == y && x>=0 && x<cols);
                if(in_range) {
                    d = buf[y%WIN_ROW][x];
                } else {
                    for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                        d.val[k]=0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_linear(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2


        )
{

    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW/2+1][2][COLS/2+1][2];
#pragma HLS array_partition complete variable=buf dim=2
#pragma HLS array_partition complete variable=buf dim=4
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 281, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 282, __PRETTY_FUNCTION__));
    int ishift=WIN_ROW/2;
    int r1[WIN_ROW] = {};
    int r2[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
#pragma HLS LOOP_FLATTEN OFF
    loop_width: for( int j=0; j< cols; j++)
        {
#pragma HLS PIPELINE II=1
#pragma HLS dependence array inter false
            if(i<rows&& j<cols)
            {
                src >> s;
            }
            if((i % WIN_ROW) % 2) {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            } else {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            }
            r1[i % WIN_ROW] = i;
            r2[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0];
                int y=m1.val[1];

                int ynext = y+1;

                ap_ufixed<5, 0> iu, iv;
                iu(5 -1, 0) = m2.val[0] & (32 -1);
                iv(5 -1, 0) = (m2.val[0] >> 5) & (32 -1);



                bool in_range = (y>=0 && y<rows && r1[y%WIN_ROW] == y && r2[ynext%WIN_ROW] == ynext && x>=0 && x<cols);

                int xa0, xa1, ya0, ya1;
#337 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
                ((((WIN_ROW & (WIN_ROW-1)) == 0) && "WIN_ROW must be a power of two") ? static_cast<void> (0) : __assert_fail ("((WIN_ROW & (WIN_ROW-1)) == 0) && \"WIN_ROW must be a power of two\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 337, __PRETTY_FUNCTION__));
                xa0 = x/2 + x%2;
                xa1 = x/2;
                ya0 = (y/2 + y%2)%(WIN_ROW/2);
                ya1 = (y/2)%(WIN_ROW/2);

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d00,d01,d10,d11;
                d00=buf[ya0][0][xa0][0];
                d01=buf[ya0][0][xa1][1];
                d10=buf[ya1][1][xa0][0];
                d11=buf[ya1][1][xa1][1];

                if(x%2) {
                    std::swap(d00,d01);
                    std::swap(d10,d11);
                }
                if(y%2) {
                    std::swap(d00,d10);
                    std::swap(d01,d11);
                }
                ap_ufixed<2*5 + 1, 1> k01 = (1-iv)*( iu);
                ap_ufixed<2*5 + 1, 1> k10 = ( iv)*(1-iu);
                ap_ufixed<2*5 + 1, 1> k11 = ( iv)*( iu);
                ap_ufixed<2*5 + 1, 1> k00 = 1-iv-k01;
                ((k00 + k01 + k10 + k11 == 1) ? static_cast<void> (0) : __assert_fail ("k00 + k01 + k10 + k11 == 1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 361, __PRETTY_FUNCTION__));

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;

                for(int k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    if(in_range) {
                        d.val[k] =
                            d00.val[k] * k00 +
                            d01.val[k] * k01 +
                            d10.val[k] * k10 +
                            d11.val[k] * k11;
                    } else {
                        d.val[k] = 0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2,
           int interpolation=0


        )
{
    if(interpolation==0) {
        Remap_nearest<WIN_ROW>(src, dst, map1, map2);
    } else if(interpolation==1) {
        Remap_linear<WIN_ROW>(src, dst, map1, map2);
    }
}



template <typename T>
class RangeAnalyzer {
public:
#416 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
    void operator ()(T x) {};



};
#439 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
template<typename T>
T one_over_x_approx(T x) {
    return T(1.0)/x;
}


template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_x_approx(ap_fixed<W,I,Q,O> x) {
    return 2-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 2-x;
}



template<typename T>
T one_over_one_plus_x_approx(T x) {
    return T(1.0)/(T(1.0)+x);
}


template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_one_plus_x_approx(ap_fixed<W,I,Q,O> x) {
    return 1-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_one_plus_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 1-x;
}

template <typename FRAMET, typename FRAME2T, typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, typename CMT, typename DT, typename ICMT, int N>
void computeUndistortCoordinates(Window<3,3, CMT> cameraMatrix,
                                 DT (&distCoeffs)[N],
                                 Window<3,3, ICMT> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];
#505 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    float x_gold = ((float)i*(float)ir.val[0][1] + (float)j*(float)ir.val[0][0] + (float)ir.val[0][2]);
    if(noRotation) {

        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        FRAMET winv = one_over_x_approx(w);
        float winv_gold = 1.0f/((float)i*(float)ir.val[2][1] + (float)j*(float)ir.val[2][0] + (float)ir.val[2][2]);





        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
        x_gold = x_gold*winv_gold;
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y;
    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    FRAME2T krd = FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2;

    if(N >5) kr = kr*one_over_one_plus_x_approx(krd);

    float kr_gold = (1 + (((float)k3*(float)r2 + (float)k2)*(float)r2 + (float)k1)*(float)r2)/
                    (1 + (((float)k6*(float)r2 + (float)k5)*(float)r2 + (float)k4)*(float)r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
#556 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
}

template <typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, int N>
void computeUndistortCoordinatesRef(Window<3,3, float> cameraMatrix,
                                 float (&distCoeffs)[N],
                                 Window<3,3, float> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {
    typedef float DT;
    typedef float CMT;
    typedef float FRAMET;
    typedef float FRAME2T;

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];


    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    if(noRotation) {

        ((ir.val[2][0] == 0) ? static_cast<void> (0) : __assert_fail ("ir.val[2][0] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 591, __PRETTY_FUNCTION__));
        ((ir.val[2][1] == 0) ? static_cast<void> (0) : __assert_fail ("ir.val[2][1] == 0", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 592, __PRETTY_FUNCTION__));
        ((ir.val[2][1] == 1) ? static_cast<void> (0) : __assert_fail ("ir.val[2][1] == 1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 593, __PRETTY_FUNCTION__));
        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        float winv = 1.0f/w;




        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y;

    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    if(N >5) kr = kr/
        (1 + FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
#632 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
}

template<typename T>
struct InitUndistortRectifyMap_traits {
    typedef T FRAMET;
    typedef T FRAME2T;
};

template<int W, int I>
struct InitUndistortRectifyMap_traits<ap_fixed<W,I> > {
    typedef ap_fixed<18,2> FRAMET;
    typedef ap_fixed<23,4,AP_RND,AP_SAT> FRAME2T;
};
template<typename CMT, typename DT, typename ICMT, int ROWS, int COLS, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMapInverse (
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, ICMT> ir,
                            Mat<ROWS, COLS, MAP1_T> &map1,
                            Mat<ROWS, COLS, MAP2_T> &map2,
                            int noRotation=false)
{
#pragma HLS array_partition variable=distCoeffs complete
    int rows= map1.rows;
    int cols= map1.cols;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;

    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 660, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 661, __PRETTY_FUNCTION__));

    static RangeAnalyzer<float> rau, rav;
    static RangeAnalyzer<float> rauerr, raverr;

 loop_height: for(int i=0; i< rows; i++) {
    loop_width: for(int j=0; j< cols; j++) {
#pragma HLS PIPELINE II=1
            typedef ap_uint<BitWidth<ROWS>::Value> ROWT;
            typedef ap_uint<BitWidth<COLS>::Value> COLT;
            ROWT ifixed = i;
            COLT jfixed = j;

            ap_fixed<1+BitWidth<COLS>::Value+5, 1+BitWidth<COLS>::Value, AP_RND, AP_SAT> u;
            ap_fixed<1+BitWidth<ROWS>::Value+5, 1+BitWidth<ROWS>::Value, AP_RND, AP_SAT> v;
            computeUndistortCoordinates
                <typename InitUndistortRectifyMap_traits<CMT>::FRAMET, typename InitUndistortRectifyMap_traits<CMT>::FRAME2T>
                (cameraMatrix, distCoeffs, ir, noRotation,ifixed,jfixed,u,v);
#700 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h"
            ((MAP1_T==(((3) & ((1 << 11) - 1)) + (((2)-1) << 11))) ? static_cast<void> (0) : __assert_fail ("MAP1_T==HLS_16SC2", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_undistort.h", 700, __PRETTY_FUNCTION__));
            {
                int iu = sr_cast<int>(u*32);
                int iv = sr_cast<int>(v*32);
                m1.val[0]=(iu >> 5);
                m1.val[1]=(iv >> 5);
                m2.val[0]=(unsigned short)((iv &(32 -1))*32 + (iu & (32 -1)));
            }






            map1<< m1;
            map2<< m2;
        }
    }







}
template< typename CMT, typename RT, typename DT, int ROWS, int COL, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMap(
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, RT> R,
                            Window<3,3, CMT> newcameraMatrix,
                            Mat<ROWS, COL, MAP1_T> &map1,
                            Mat<ROWS, COL, MAP2_T> &map2
                            )
{
    Window<3,3, RT> iR;
    Window<3,3, RT> ir;
    mul<3, 3, 3>(newcameraMatrix.val, R.val, iR.val);
    Invert<3>(iR.val, ir.val);
    InitUndistortRectifyMapInverse(cameraMatrix, distCoeffs,ir,map1,map2);
}
}
#66 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_hough.h" 1
#83 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_hough.h"
namespace hls {

typedef ap_fixed<19,2,AP_RND> angleAccuracy_T;

template<typename AT,typename RT>
struct Polar_
{
 AT angle;
 RT rho;
};

template<unsigned int theta,unsigned int rho,typename ACCUMT,int SRC_T, int ROW,int COL, typename S_T>
void HoughPolar(
        Mat<ROW,COL,SRC_T> &_src,
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    ACCUMT addr[180/theta];
    ACCUMT accbuf[2][180/theta];
#pragma HLS ARRAY_PARTITION variable=addr complete dim=0
#pragma HLS ARRAY_PARTITION variable=accbuf complete dim=0
    int rows=_src.rows;
    int cols=_src.cols;
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;
    unsigned int AngleN= 180/theta;
#pragma HLS ARRAY_PARTITION variable=sinval complete dim=0
#pragma HLS ARRAY_PARTITION variable=cosval complete dim=0
 loop_init_r: for(int r=0;r<rhoN+2;r++)
    {
    loop_init_n: for(int n=0;n<AngleN+2;n++)
        {
#pragma HLS PIPELINE
            accum[n][r]=0;
        }
    }

 loop_init: for(int n = 0; n < AngleN; n++ )
    {
        addr[n]=0;
        accbuf[0][n]=accum[n+1][Half_rhoN+1];
        sinval[n]=sinval[n]/rho;
        cosval[n]=cosval[n]/rho;
    }


 loop_height: for( int i = 0; i < rows; i++ )
    {
    loop_width: for( int j = 0; j < cols; j++ )
        {
#pragma HLS PIPELINE
#pragma HLS DEPENDENCE array inter false
            typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp;
            _src.data_stream[0]>>temp;
            if(temp!=0&&!(i==0&&j==0))
            {
            loop_angle: for(int n = 0; n < AngleN; n++ )
                {
                    accbuf[1][n]=accbuf[0][n];
                    ACCUMT r=j*cosval[n]+i*sinval[n];
                    r+=Half_rhoN;
                    accbuf[0][n]=accum[n+1][r+1];
                    if(r==addr[n])
                        accbuf[0][n]=accbuf[0][n]+1;

                    accum[n+1][addr[n]+1]=accbuf[1][n]+1;
                    addr[n]=r;
                }
            }

        }
    }
 loop_exit: for(int n = 0; n < AngleN; n++ )
    {
        accum[n+1][addr[n]+1]=accbuf[0][n]+1;
    }
}
template<int rho,int ROW,int COL,typename ACCUMT, typename AT, typename RT,int linesMax>
void Sort_insert(
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        Polar_<AT,RT> (&lines)[linesMax],
        unsigned int threshold,
        unsigned int theta,
        unsigned int& storenum)
{
    LineBuffer<2,((2*(COL+ROW)+1)/rho+2),ACCUMT> accum_buf;
    Window<3,3,ACCUMT> accum_win;
    ACCUMT lines_val[linesMax+1];
    ap_uint<1> lines_flag[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int AngleN= 180/theta;
    unsigned int Half_rhoN=(rhoN-1)/2;

#pragma HLS ARRAY_PARTITION variable=&accum_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=lines_val complete dim=1
#pragma HLS ARRAY_PARTITION variable=lines complete dim=0
#pragma HLS ARRAY_PARTITION variable=&accum_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=lines_flag complete dim=0

 loop_init: for(int i=0;i<linesMax;i++)
    {
        lines[i].angle=0;
        lines[i].rho=0;
        lines_val[i]=0;
        lines_flag[i]=0;
    }
        lines_val[linesMax]=0;
        lines_flag[linesMax]=0;

 loop_n: for(int n=0;n<AngleN+2;n++)
    {
    loop_r: for(int r=0;r<rhoN+2;r++)
        {
#pragma HLS DEPENDENCE array intra false
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE
            for(int row=2;row>=0;row--)
            {
                for(int col=2;col>=1;col--)
                {
                    accum_win.val[row][col]=accum_win.val[row][col-1];
                }
            }

            ACCUMT temp=accum[n][r];

            ACCUMT accum_buf0=accum_buf.val[0][r];

            accum_win.val[2][0]=accum_buf.val[1][r];
            accum_win.val[1][0]=accum_buf0;
            accum_win.val[0][0]=temp;

            accum_buf.val[1][r]=accum_buf0;

            accum_buf.val[0][r]=temp;

            if(r>=2&&r!=Half_rhoN+2&&r<rhoN+2&&n>=2&&n<AngleN+2)
            {
                if((accum_win.val[1][1]>threshold)&&(accum_win.val[1][1]>accum_win.val[1][2])&&(accum_win.val[1][1]>=accum_win.val[1][0])&&(accum_win.val[1][1]>accum_win.val[2][1])&&(accum_win.val[1][1]>=accum_win.val[0][1] ))
                {

                loop_lines: for(int i=linesMax-2;i>=0;i--)
                    {
                        ACCUMT max=lines_val[i];
                        if(accum_win.val[1][1]>max)
                        {
                            lines[i+1].rho=lines[i].rho;
                            lines[i+1].angle=lines[i].angle;
                            lines_val[i+1]=max;
                            lines_flag[i]=0;
                        }
                        else
                        {
                            lines_flag[i]=1;
                        }
                    }
                    int sum=0;
                loop_sum: for(int i=0;i<linesMax;i++)
                        sum+=lines_flag[i];

                    lines[sum].rho=r-1;
                    lines[sum].angle=n-1;
                    lines_val[sum]=accum_win.val[1][1];
                    storenum++;
                }
            }
        }
    }
}
template<typename _AT, typename _RT,typename AT, typename RT,int linesMax>
void inline GetTopLines(
        Polar_<_AT,_RT> (&_lines)[linesMax],
        Polar_<AT,RT> (&lines)[linesMax+1],
        unsigned int storenum,
        unsigned int theta,
        unsigned int rho,
        unsigned int Half_rhoN)
{
    angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
loop_lines: for(int i=0;i<linesMax;i++)
    {
        if(i<storenum)
        {
            RT r=lines[i].rho-1;
            AT n=lines[i].angle-1;
            _RT _rho = (r - Half_rhoN) * rho;
            _AT _angle = n * Angle_accuracy;
            _lines[i].rho=_rho;
            _lines[i].angle=_angle;
        }
        else
        {
                _lines[i].rho=0;
                _lines[i].angle=0;
        }
    }
}



template<unsigned int theta,unsigned int rho,typename AT,typename RT,typename ACCUMT,int SRC_T,int ROW,int COL,unsigned int linesMax, typename S_T>
void HoughLinesStandard(
        Mat<ROW,COL,SRC_T> &_src,
        Polar_<AT,RT> (&_lines)[linesMax],
        ACCUMT _accum[][(2*(COL+ROW)+1)/rho+2],
        unsigned int _threshold,
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    unsigned int storenum=0;
    Polar_<ap_uint<10>,ACCUMT > lines[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;

    HoughPolar<theta,rho>(_src,_accum, sinval, cosval);
    Sort_insert<rho,ROW,COL>(_accum,lines, _threshold,theta,storenum);
    GetTopLines(_lines,lines,storenum,theta,rho,Half_rhoN);
}
#312 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_hough.h"
template<unsigned int theta,unsigned int rho,typename AT,typename RT,int SRC_T,int ROW,int COL,unsigned int linesMax>
void HoughLines2(
        Mat<ROW,COL,SRC_T> & _src,
 Polar_<AT,RT> (&_lines)[linesMax],
 unsigned int threshold
        )
{
 static ap_uint<12> _accum[180/theta+2][(2*(COL+ROW)+1)/rho+2];
#pragma HLS ARRAY_PARTITION variable=_accum complete dim=1
        ap_fixed<19,2,AP_RND> sinval[180/theta];
        ap_fixed<19,2,AP_RND> cosval[180/theta];
        angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
 loop_init: for(int i=0;i<180/theta;i++)
        {
            sinval[i]=::hls::sinf((i*Angle_accuracy));
            cosval[i]=::hls::cosf(i*Angle_accuracy);
        }
 HoughLinesStandard<theta,rho>(_src,_lines,_accum,threshold, sinval,cosval);
}

}
#67 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_harris.h" 1
#83 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_harris.h"
namespace hls {

template<int KH,int KW, typename SRC_T>
bool IsMax(Window<KH,KW,SRC_T> & core_win)
{
#pragma HLS INLINE
    bool isMax=true;
    for(int i=0;i<KH;i++) {
        for(int j=0;j<KW;j++) {
            if(((i!=KH/2)||(j!=KW/2))&&core_win.val[i][j]>core_win.val[KH/2][KW/2])
                isMax=false;
        }
    }
    return isMax;
}
template<int KH, int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void FindMax(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name threshold
                )
{
    LineBuffer<KH-1,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf;
    Window<KH,KW,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    int ioffset=KH/2+1;
    int joffset=KH/2+1;
    for(HLS_SIZE_T i=0;i<rows+ioffset;i++)
    {
#pragma HLS LOOP_TRIPCOUNT MAX=ROWS
        for(HLS_SIZE_T j=0;j<cols+joffset;j++)
        {
#pragma HLS DEPENDENCE ARRAY INTER FALSE
#pragma HLS LOOP_TRIPCOUNT MAX=COLS
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
            d.val[0]=0;
            for(int r= 0;r<KH;r++)
            {
                for(int c=0;c<KW-1;c++)
                {
                    win.val[r][c]=win.val[r][c+1];
                }
            }
            if(i<rows&&j<cols)
            {
                win.val[0][KW-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KH-1;buf_row++)
                {
                    win.val[buf_row][KW-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KH-1][KW-1]=s.val[0];
                k_buf.val[KH-2][j]=s.val[0];
            }
            else if(j>=cols)
            {

                for(int i= 1;i< KW;i++)
                    win.val[i][KW-1]=0;
            }
            if(win.val[1][1]>=threshold&&i>=KH&&j>=KW)
            {
                bool _ismax=IsMax(win);
                if(_ismax)
                {

                    d.val[0]=255;
                }
            }

            if(i>=ioffset&&j>=joffset)
            {
                _dst<<d;
            }
        }
    }
}
template<typename KT, typename ST, int X2_T,int Y2_T,int XY_T,int DST_T,int ROWS,int COLS>
void CalCim(
  Mat<ROWS, COLS, X2_T> &_gradx,
  Mat<ROWS, COLS, Y2_T> &_grady,
  Mat<ROWS, COLS, XY_T> &_gradxy,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale
        )
{
    Scalar<((((X2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((X2_T) & ((1 << 11) - 1))>::name> gx;
    Scalar<((((Y2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((Y2_T) & ((1 << 11) - 1))>::name> gy;
    Scalar<((((XY_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((XY_T) & ((1 << 11) - 1))>::name> gxy;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _grady.rows;
    int cols= _grady.cols;
    for(HLS_SIZE_T i=0;i<rows;i++)
    {
#pragma HLS LOOP_TRIPCOUNT MAX=ROWS
        for(HLS_SIZE_T j=0;j<cols;j++)
        {
#pragma HLS DEPENDENCE ARRAY INTER FALSE
#pragma HLS LOOP_TRIPCOUNT MAX=COLS
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
            d.val[0]=0;
            _gradx>> gx;
            _grady>> gy;
            _gradxy>> gxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgx = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gx.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgy = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgxy= sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gxy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name det = lgx*lgy - lgxy*lgxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name trac= lgx + lgy;

            typename Type<((DST_T) & ((1 << 11) - 1))>::name cim = det - k*(trac)*(trac);
            d.val[0] = cim;
            _dst<<d;
        }
    }
}
template<int blockSize,int Ksize, bool NORMALIZE, class BORDERMODEL, int GT, int G2T, typename ST, typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale)
{
#pragma HLS INLINE
#pragma HLS dataflow
    ((Ksize==3||Ksize==5||Ksize==7) ? static_cast<void> (0) : __assert_fail ("Ksize==3||Ksize==5||Ksize==7", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_harris.h", 216, __PRETTY_FUNCTION__));
    int rows = _src.rows;
    int cols = _src.cols;
    Mat<ROWS,COLS,SRC_T> gray1(rows,cols);
    Mat<ROWS,COLS,SRC_T> gray2(rows,cols);

    Mat<ROWS,COLS,GT> grad_x(rows,cols);
    Mat<ROWS,COLS,GT> grad_x1(rows,cols);
    Mat<ROWS,COLS,GT> grad_x2(rows,cols);
    Mat<ROWS,COLS,GT> grad_x3(rows,cols);
    Mat<ROWS,COLS,GT> grad_x4(rows,cols);

    Mat<ROWS,COLS,GT> grad_y(rows,cols);
    Mat<ROWS,COLS,GT> grad_y1(rows,cols);
    Mat<ROWS,COLS,GT> grad_y2(rows,cols);
    Mat<ROWS,COLS,GT> grad_y3(rows,cols);
    Mat<ROWS,COLS,GT> grad_y4(rows,cols);

    Mat<ROWS,COLS,G2T> grad_xx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_yy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_xy(rows,cols);

    Mat<ROWS,COLS,G2T> grad_gx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gxy(rows,cols);

    Duplicate(_src,gray1,gray2);

    Sobel<1,0,Ksize,BORDERMODEL>(gray1,grad_x);
    Duplicate(grad_x,grad_x1,grad_x2);
    Duplicate(grad_x1,grad_x3,grad_x4);
    Sobel<0,1,Ksize,BORDERMODEL>(gray2,grad_y);
    Duplicate(grad_y,grad_y1,grad_y2);
    Duplicate(grad_y1,grad_y3,grad_y4);

    Mul(grad_x3,grad_x4,grad_xx);
    Mul(grad_y3,grad_y4,grad_yy);
    Mul(grad_x2,grad_y2,grad_xy);

    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xx,grad_gx);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_yy,grad_gy);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xy,grad_gxy);

    CalCim(grad_gx,grad_gy,grad_gxy, _dst,k, scale);
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void CornerHarris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k)
{
#pragma HLS INLINE
    ap_uint<9> sc=(1 << ((Ksize>0 ? Ksize:3)-1))*blockSize;
    ((SRC_T==(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((8) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((5) & ((1 << 11) - 1)) + (((1)-1) << 11))) ? static_cast<void> (0) : __assert_fail ("SRC_T==HLS_8UC1||SRC_T==HLS_10UC1||SRC_T==HLS_32FC1", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_harris.h", 270, __PRETTY_FUNCTION__));
    if(SRC_T==(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((8) & ((1 << 11) - 1)) + (((1)-1) << 11)))
    {
        ap_fixed<25,-7-Ksize> scale = (ap_fixed<25,2>(1.0f)/255) / sc;
        switch(Ksize) {
            case 3:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 5:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((14+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((28+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 7:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((18+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((36+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            default:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
        }

    }
    else
    {
        float scale = 1.0f / sc;
        Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((5) & ((1 << 11) - 1)) + (((1)-1) << 11)), (((5) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
    }
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        int threshold)
{
#pragma HLS INLINE
    Mat<ROWS,COLS,(((5) & ((1 << 11) - 1)) + (((1)-1) << 11))> res(_src.rows,_src.cols);
    CornerHarris<blockSize,Ksize>(_src, res, k);
    FindMax<3,3>(res,_dst,threshold);
}

}
#68 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_haar.h" 1
#41 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_haar.h"
namespace hls {

typedef ap_fixed<12,6,AP_RND> VAR_T;
typedef ap_uint<3> WEIGHT_T;
typedef unsigned int STHRESHOLD_T;
typedef short CTHRESHOLD_T;
typedef unsigned short ALPHA_T;

struct HaarRect
{
    Rect_< ap_uint<6> > r;
    WEIGHT_T weight;
};
struct HaarFeature
{
    public:
    HaarFeature()
    {
#pragma HLS ARRAY_PARTITION variable=rect complete dim=1
    };
    HaarRect rect[3];

};
template <int FEATURE_MAX>
struct HaarClassifier
{
    public:
    HaarClassifier()
    {
#pragma HLS ARRAY_PARTITION variable=haar_feature complete dim=1
        };
        unsigned short count;
        HaarFeature haar_feature[FEATURE_MAX];
        CTHRESHOLD_T threshold[FEATURE_MAX];
        ap_int<5> left[FEATURE_MAX];
        ap_int<5> right[FEATURE_MAX];
        ALPHA_T alpha[FEATURE_MAX+1];
        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarStageClassifier
{
    public:
    HaarStageClassifier()
    {
#pragma HLS ARRAY_PARTITION variable=classifier complete dim=1
        };
        unsigned char count[STAGE];
        STHRESHOLD_T threshold[STAGE];
        HaarClassifier<FEATURE_MAX> classifier[CLASSIFIER_ALL];




        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarClassifierCascade
{
    public:
        HaarClassifierCascade()
        {
        };
        unsigned short count;
        Size_<unsigned char> real_window_size;
        HaarStageClassifier<STAGE,CLASSIFIER_ALL,FEATURE_MAX> stage_classifier;
};

class HaarLoadData
{
        public:
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
HaarLoadData(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,

        const int ca_count,

        const Size_<unsigned char> ca_real_window_size,
        const int s_count[],
        const float s_threshold[],
        const int c_left[][FEATURE_MAX],
        const int c_right[][FEATURE_MAX],
        const float c_threshold[][FEATURE_MAX],
        const float c_alpha[][FEATURE_MAX+1],
        const unsigned int haar_feature[][FEATURE_MAX][4*3],
        const float haar_feature_weight[][FEATURE_MAX][3]




        )
{

        cascade.count=ca_count;

        cascade.real_window_size=ca_real_window_size;
        for(int i=0;i<STAGE;i++)
        {
                cascade.stage_classifier.count[i]=s_count[i];
                cascade.stage_classifier.threshold[i]=s_threshold[i];



        }
        for(int i=0;i<CLASSIFIER_ALL;i++)
        {

               for(int j=0;j<FEATURE_MAX;j++)
               {
                      cascade.stage_classifier.classifier[i].left[j]=c_left[i][j];
                      cascade.stage_classifier.classifier[i].right[j]=c_right[i][j];
                      cascade.stage_classifier.classifier[i].threshold[j]=c_threshold[i][j];
                      cascade.stage_classifier.classifier[i].alpha[j]=c_alpha[i][j];
                      cascade.stage_classifier.classifier[i].alpha[FEATURE_MAX]=c_alpha[i][FEATURE_MAX];

                      for(int n=0;n<3;n++)
                      {
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.x=haar_feature[i][j][n*4+0];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.y=haar_feature[i][j][n*4+1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.width=haar_feature[i][j][n*4+2];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.height=haar_feature[i][j][n*4+3];
                       }
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[0].weight=-1;
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[1].weight=haar_feature_weight[i][j][1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[2].weight=haar_feature_weight[i][j][2];
                 }
        }
}
};

template<typename SUMT, typename VART,int ROWS,int COLS>
void intergral_win(
        Window<ROWS,COLS,VART> &win_var,
        SUMT &var
        )
{
#pragma HLS INLINE
    var=0;
    for(int j=0;j<COLS;j++)
    {
        SUMT t = 0;
        for(int i=0;i<ROWS;i++)
        {
            var=var+win_var.val[i][j];
            t += win_var.val[i][j];
        }

    }
}

template< typename SRC_T,int ROWS,int COLS,int FEATURE_MAX>
ALPHA_T icvEvalHidHaarClassifier(HaarClassifier<FEATURE_MAX> & classifier,Window<ROWS,COLS,SRC_T>& win,VAR_T &variance )
{
#pragma HLS inline self off
#pragma HLS function_instantiate variable=&classifier


    int m=0,i=0;
    for(m=0;m<FEATURE_MAX;m++)
    {
        Rect_<ap_uint<6> > rr=classifier.haar_feature[i].rect[0].r;
        if(i>0||(i==0&&m==0))
        {

            CTHRESHOLD_T sum=-(win.val[rr.height][rr.width]-win.val[rr.height][rr.x]-win.val[rr.y][rr.width]+win.val[rr.y][rr.x]);
            for(int j=1;j<3;j++)
            {
                WEIGHT_T weight=classifier.haar_feature[i].rect[j].weight;
                Rect_< ap_uint<6> > rj=classifier.haar_feature[i].rect[j].r;
                sum+=(win.val[rj.height][rj.width]-win.val[rj.height][rj.x]-win.val[rj.y][rj.width]+win.val[rj.y][rj.x])*weight;
            }
            if(sum<classifier.threshold[i]*variance)
            {
                i=classifier.left[i];
            }
            else
            {
                i=classifier.right[i];
            }
        }


    }
    return classifier.alpha[-i] ;
}

template< typename SRC_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
bool RunHaarClassifierCascade(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,Window<ROWS,COLS,SRC_T>&win,VAR_T &variance )
{
#pragma HLS inline
    ALPHA_T sum=0;
    bool result=true;
    unsigned char stage_index=0;
    unsigned char stage_count=0;
    for (int i=0;i<CLASSIFIER_ALL;i++)
    {
        sum+=icvEvalHidHaarClassifier(cascade.stage_classifier.classifier[i],win,variance);
        stage_count++;
        if(cascade.stage_classifier.count[stage_index]==stage_count)
        {
            if(sum < cascade.stage_classifier.threshold[stage_index])
            {
                result =false;
            }
            sum=0;
            stage_count=0;
            stage_index++;
        }
    }
    return result;
}
template < typename T>
T TaylorExp(T &t)
{
   return (1+((T)0.5)*(t)-((T)0.125)*(t)*(t));
}

template< int K_H,int K_W,int S_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX, int DST_T>
void HaarClassifierObject_opr(
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,
  Mat<ROWS, COLS, S_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask
  )
{
    int storage_count=0;






    Window<1,K_W+1,ap_uint<16+16> > sqwin;
    Window<K_H+1,K_W+1,ap_uint<8+16> > swin;
    LineBuffer<K_H,COLS,typename Type<((S_T) & ((1 << 11) - 1))>::name> sbuf;

    int rows=_src.rows;
    int cols=_src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_haar.h", 275, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_haar.h", 276, __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> m;
    Scalar<((((S_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((S_T) & ((1 << 11) - 1))>::name> ss;

    for(int i=0;i<rows;i++)
    {
        for(int j=0;j<cols;j++)
        {
#pragma HLS loop_flatten off
#pragma HLS PIPELINE
#pragma HLS DEPENDENCE array inter false

            {
#pragma HLS expression_balance off
            sqwin.shift_left();
            swin.shift_left();
            swin.val[0][K_W]=(j == 0 ? ap_uint<24>(0) :swin.val[0][K_W-1])+sbuf.val[0][j];
            ap_uint<16> col_sum=sbuf.val[0][j];
            ap_uint<32> col_sum_sq=0;
            for(int buf_row= 1;buf_row<K_H;buf_row++)
            {
                ss.val[0]=sbuf.val[buf_row][j];
                sbuf.val[buf_row-1][j]=ss.val[0];
                col_sum += ss.val[0];
                col_sum_sq += ss.val[0] * ss.val[0];
                swin.val[buf_row][K_W] = (j == 0 ? ap_uint<24>(0) :swin.val[buf_row][K_W-1]) + col_sum;
            }
            _src >> ss;
            sbuf.val[K_H-1][j]=ss.val[0];
            col_sum += ss.val[0];
            col_sum_sq += ss.val[0] * ss.val[0];
            swin.val[K_H][K_W] = (j == 0 ? ap_uint<24>(0) : swin.val[K_H][K_W-1]) + col_sum;
            sqwin.val[0][K_W] = (j == 0 ? ap_uint<32>(0) : sqwin.val[0][K_W-1]) + col_sum_sq;
#322 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_haar.h"
            }

            m.val[0]=0;
            if(i>=K_H && j>=K_W &&( (j & 1)==0 ))
            {
                int b=K_H,s=0;

                float inv_window_area=1.0/(K_H*K_W);
                ap_uint<26> varsum=sqwin.val[0][K_W] - sqwin.val[0][0];






                ap_uint<17> meansum=swin.val[b][b]-swin.val[b][s]-swin.val[s][b]+swin.val[s][s];
                ap_fixed<32,18,AP_RND> mean=(meansum)*inv_window_area;
                ap_fixed<32,18,AP_RND> meansq=mean*mean;
                ap_fixed<32,18,AP_RND> var_a=varsum*inv_window_area;
                ap_fixed<32,18,AP_RND> variance=var_a-meansq;
                if(variance>0)
                {

                    variance = (variance/100);
                    ap_fixed<32,18,AP_RND> t=variance-1;
                    if(variance<=4)
                        variance= TaylorExp(t)+1;
                    else if(variance >4 && variance <=16)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/4;
                        variance= 2*TaylorExp(tt)+1;
                    }
                    else if(variance >16 && variance <=64)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/16;
                        variance= 4*TaylorExp(tt)+1;
                    }
                    else if(variance >64 && variance <=256)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/64;
                        variance= 8*TaylorExp(tt)+1;
                    }
                    else
                        variance=16;
                }
                else
                {
                    variance = 1;
                }

                ap_fixed<12,6,AP_RND> var=variance;
                bool Isface=RunHaarClassifierCascade(cascade,swin,var);
                if(Isface)
                {
                    if(variance>65)
                    {
                        variance=65;
                    }
                    variance=variance*1000;
                    storage_count++;

                    m.val[0]=(unsigned char)variance;
                }
            }
            _mask << m;
        }
    }

}
template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
#pragma HLS inline
#409 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_haar.h"
        HaarClassifierObject_opr<K_H,K_W>(_cascade,_src, _mask);
}

template<typename RECT_T>
void CombineStorage(Rect_<RECT_T> _storage_group[][300],int m, Rect_<RECT_T> _storage[],int num)
{
        int count=0;
        for(int i=0;i<m;i++)
        {
                for(int j=0;j<num;j++)
                {
                        if(count<num&&_storage_group[i][j].width!=0&&_storage_group[i][j].height!=0)
                        {
                            _storage[count++]=_storage_group[i][j];
                        }
                }
        }
        for(int i=0;i<num;i++)
        {
         if(i>=count)
            {
               _storage[count].x=0;
               _storage[count].y=0;
               _storage[count].width=0;
               _storage[count].height=0;

            }
         }
}
template<int SRC_T, int DST_T,int ROWS,int COLS>
void Combin_mask(
  Mat<ROWS, COLS, SRC_T> &mask0,
  Mat<ROWS/2, COLS/2, SRC_T> &mask1,
  Mat<ROWS/4, COLS/4, SRC_T> &mask2,
  Mat<ROWS/8, COLS/8, SRC_T> &mask3,
  Mat<ROWS, COLS, DST_T> &dst
                )
{
    int rows =mask0.rows;
    int cols =mask0.cols;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> m;

    int i1=0;
    int i2=0;
    int i3=0;
    for(int i=0;i<rows;i++)
    {
        int j1=0;
        int j2=0;
        int j3=0;
        for(int j=0;j<cols;j++)
        {
#pragma HLS PIPELINE
            s.val[0]=0;
            mask0>> m;
            if(m.val[0]!=0)
                s.val[0]=255;
            if(i==i1*2&&j==j1*2)
            {
                mask1>>m;
                s.val[0]=s.val[0]|m.val[0];
                j1++;
            }
            if(i==i2*4&&j==j2*4)
            {
                mask2>>m;
                s.val[0]=s.val[0]|m.val[0];
                j2++;
            }
            if(i==i3*8&&j==j3*8)
            {
                mask3>>m;
                s.val[0]=s.val[0]|m.val[0];
                j3++;
            }
            dst<<s;
        }
        if(i==i1*2)
            i1++;
        if(i==i2*4)
            i2++;
        if(i==i3*8)
            i3++;
    }
}

template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject_group(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
#pragma HLS inline
        int rows =_src.rows;
        int cols =_src.cols;
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray1(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray2(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray3(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray4(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray5(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray6(rows,cols);
        Duplicate(_src, gray1, gray2 );
        Duplicate(gray1, gray3, gray4 );
        Duplicate(gray2, gray5, gray6 );
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_3(rows/8,cols/8);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_0(rows,cols);
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_3(rows/8,cols/8);
        Resize(gray4,internal_1);
        Resize(gray5,internal_2);
        Resize(gray6,internal_3);
        HaarClassifierObject<K_H, K_W > ( gray3, mask_0, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_1, mask_1, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_2, mask_2, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_3, mask_3, _cascade);
        Combin_mask<DST_T,DST_T,ROWS,COLS>(mask_0,mask_1,mask_2,mask_3,_mask);
}

}
#69 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#1 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h" 1
#100 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h"
namespace hls {







template<int WSIZE, int NDISP, int NDISP_UNIT>
class StereoBMState {
public:

    int preFilterType;
    int preFilterSize;
    int preFilterCap;


    int SADWindowSize;
    int minDisparity;
    int numberOfDisparities;


    int textureThreshold;

    int uniquenessRatio;





    int ndisp_unit;
    int sweepFactor;
    int remainder;

    StereoBMState() {
        preFilterType = 1;
        preFilterSize = WSIZE;
        preFilterCap = 32;
        SADWindowSize = WSIZE;
        minDisparity = 0;
        numberOfDisparities = NDISP;
        textureThreshold = 10;
        uniquenessRatio = 15;
        sweepFactor = (NDISP/NDISP_UNIT) + ((NDISP%NDISP_UNIT) != 0);
        ndisp_unit = NDISP_UNIT;
        remainder = NDISP_UNIT*sweepFactor - NDISP;
    }
};

template<int PWSIZE, int SRC_T, int DST_T, int ROWS, int COLS>
void PreFilterNorm(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    int rows = src.rows;
    int cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 157, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 158, __PRETTY_FUNCTION__));

    LineBuffer<PWSIZE, COLS+PWSIZE-1, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > buff;
    Window<PWSIZE, PWSIZE, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> tmp[PWSIZE];
#pragma HLS array_partition variable=tmp complete dim=0
    int sum_cols[PWSIZE];
#pragma HLS array_partition variable=tmp complete dim=0
    int sum;

loop_sum_row:
    for (int row = 0; row < rows+PWSIZE-1; row++) {
loop_sum_init:
        for (int i = 0; i < PWSIZE; i++) {
            sum_cols[i] = 0;
        }
        sum = 0;
loop_sum_col:
        for (int col = 0; col < cols+PWSIZE-1; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> pix_in(0);
            buff.shift_down(col);
            if (!(row < (PWSIZE-1)/2 || row >= rows+(PWSIZE-1)/2 || col < (PWSIZE-1)/2 || col >= cols+(PWSIZE-1)/2)) {
                src >> pix_in;
            }
            buff.insert_bottom(pix_in, col);
            for (int i = 0; i< PWSIZE; i++) {
                tmp[i] = buff.val[i][col];
            }


            int a_sum = 0, b_sum = 0;
            for (int i = 0; i < PWSIZE; i++) {
                b_sum += tmp[i].val[0];
            }
            a_sum = sum_cols[PWSIZE-1];
            for (int j = PWSIZE-1; j > 0; j--) {
                sum_cols[j] = sum_cols[j-1];
            }
            sum_cols[0] = b_sum;
            sum = sum - a_sum + b_sum;
            win.shift_right();
            win.insert_right(tmp);

            if (row >= PWSIZE-1 && col >= PWSIZE-1) {
                int avg = sum / (PWSIZE*PWSIZE);
                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> pix_out;
                int center = win.val[PWSIZE/2][PWSIZE/2].val[0];
                pix_out.val[0] = ((((center-avg) > (-cap) ? (center-avg) : (-cap))) < (cap) ? (((center-avg) > (-cap) ? (center-avg) : (-cap))) : (cap)) + cap;
                dst << pix_out;
            }
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Clip(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 223, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 224, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    for (HLS_SIZE_T i = 0; i < rows; i++) {
        for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS pipeline II=1
            src >> s;
            for (HLS_SIZE_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                s.val[k] = s.val[k] < -cap ? 0 : s.val[k] > cap ? cap*2 : s.val[k] + cap;
                d.val[k] = s.val[k];
            }
            dst << d;
        }
    }
}

template<typename T>
T absdiff(T a, T b) {
#pragma HLS inline
    long long x = a-b;
    long long y = b-a;
    T r;
    if(x < 0) {
        r = y; ((r == y) ? static_cast<void> (0) : __assert_fail ("r == y", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 247, __PRETTY_FUNCTION__));
    } else {
        r = x; ((r == x) ? static_cast<void> (0) : __assert_fail ("r == x", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 249, __PRETTY_FUNCTION__));
    }
    return r;
}

template<int WSIZE, class T>
void UpdateTexture(
            Window<WSIZE, WSIZE, T>& window,
            T* col_tbi,
            int& text_sum,
            int row,
            int col,
            T cap)
{
#pragma HLS inline
    int tmp = 0;
    for (int i = 0; i < WSIZE; i++) {

        tmp += (i > row? 0 : absdiff(col_tbi[i], cap)) - ((col < WSIZE || i > row) ? 0 : absdiff(window.val[i][WSIZE-1], cap));
    }
    text_sum += tmp;
}

template<int WSIZE, int L_WIN_COLS, int R_WIN_COLS, typename T>
int SAD_compute_inc(
            Window<WSIZE, L_WIN_COLS, T>& l_win,
            Window<WSIZE, R_WIN_COLS, T>& r_win_s,
            int d,
            int col,
            int sad_cols_d[WSIZE])
{
#pragma HLS inline
    int a_sum = 0, b_sum = 0;

    for (int i = 0; i < WSIZE; i++) {
        b_sum += absdiff(l_win.val[i][0], r_win_s.val[i][d]);
    }

    if (col < d) b_sum = 0;

    a_sum = sad_cols_d[WSIZE-1];

    for (int j = WSIZE-1; j > 0; j--) {
        sad_cols_d[j] = sad_cols_d[j-1];
    }

    sad_cols_d[0] = b_sum;

    return (-a_sum+b_sum);
}

template<int SIZE>
class MinSAD {
public:
    template <typename T, typename T_idx>
    static void find(T a[SIZE], T_idx &loc, T &val) {
#pragma HLS inline
#pragma HLS array_partition variable=a complete dim=0
        T a1[SIZE/2];
        T a2[SIZE-SIZE/2];
        for(int i = 0; i < SIZE/2; i++) {
            a1[i] = a[i];
        }
        for(int i = 0; i < SIZE-SIZE/2; i++) {
            a2[i] = a[i+SIZE/2];
        }
        T_idx l1,l2;
        T v1,v2;
        MinSAD<SIZE/2>::find(a1,l1,v1);
        MinSAD<SIZE-SIZE/2>::find(a2,l2,v2);
        if(v1 >= v2) {
            val = v2;
            loc = l2+SIZE/2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<>
class MinSAD<1> {
public:
    template <typename T, typename T_idx>
    static void find(T a[1], T_idx &loc, T &val) {
#pragma HLS inline
#pragma HLS array_partition variable=a complete dim=0
        loc = 0;
        val = a[0];
    }
};

template<>
class MinSAD<2> {
public:
    template <typename T, typename T_idx>
    static void find(T a[2], T_idx &loc, T &val) {
#pragma HLS inline
#pragma HLS array_partition variable=a complete dim=0
        T_idx l1=0, l2=1;
        T v1=a[0], v2=a[1];
        if(v1 >= v2) {
            val = v2;
            loc = l2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void SADBlockMatching(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)




{
    int rows = left.rows;
    int cols = left.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 373, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 374, __PRETTY_FUNCTION__));
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_buff;
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_buff;
    Window<WSIZE, WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_window;
    Window<WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_window_search;
    int ndisp = state.numberOfDisparities;
    int mindisp = 0;

    typename Type<((DST_T) & ((1 << 11) - 1))>::name FILTERED = (typename Type<((DST_T) & ((1 << 11) - 1))>::name)((mindisp - 1) << 4);
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name cap = state.preFilterCap;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name l_tmp[WSIZE];
#pragma HLS array_partition variable=l_tmp complete dim=0
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name r_tmp[WSIZE];
#pragma HLS array_partition variable=r_tmp complete dim=0
    int text_sum = 0;
    int sad[NDISP_UNIT];
#pragma HLS array_partition variable=sad complete dim=0
    int sad_cols[NDISP_UNIT][WSIZE];
#pragma HLS array_partition variable=sad_cols complete dim=0
    int minsad[COLS+WSIZE-1];
    int mind[COLS+WSIZE-1];
    int skip[COLS+WSIZE-1];
    int skip_val[COLS+WSIZE-1];
    int edge_neighbor[COLS+WSIZE-1];
    int edge[COLS+WSIZE-1];
    int minsad_p[COLS+WSIZE-1];
    int minsad_n[COLS+WSIZE-1];

    int d = 0;
loop_row:
    for (int row = 0; row < rows+WSIZE-1; row++) {
loop_mux:
        for (int sweep = 0; sweep < state.sweepFactor; sweep++) {
loop_col:
            for (int col = 0; col < cols+WSIZE-1; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
                if (col == 0) {
loop_sad_init:
                    for (d = 0; d < NDISP_UNIT; d++) {
#pragma HLS unroll
                        sad[d] = 0;
                        for (int i = 0; i < WSIZE; i++) {
#pragma HLS unroll
                            sad_cols[d][i] = 0;
                        }
                    }
                }

                Scalar<1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_in(cap), r_in(cap);
                if (sweep == 0) {

                    l_buff.shift_down(col);
                    r_buff.shift_down(col);
                    if (!(row < (WSIZE-1)/2 || row >= rows+(WSIZE-1)/2 || col < (WSIZE-1)/2 || col >= cols+(WSIZE-1)/2)) {
                        left >> l_in;
                        right >> r_in;
                    }
                    l_buff.insert_bottom(l_in.val[0], col);
                    r_buff.insert_bottom(r_in.val[0], col);
loop_get_data_from_linebuff:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col];
                    }
                } else {
                    int offset = sweep * NDISP_UNIT;
loop_get_data_from_linebuff_with_offset:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col-offset < 0 ? 0 : col-offset];
                    }
                }

                UpdateTexture<WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, l_tmp, text_sum, row, col, cap);

                l_window.shift_right();
                r_window_search.shift_right();
                l_window.insert_right(l_tmp);
                r_window_search.insert_right(r_tmp);

loop_sad_compute:
                for (d = 0; d < NDISP_UNIT; d++) {
                    sad[d] += SAD_compute_inc<WSIZE, WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, r_window_search, d, col, sad_cols[d]);
                    if (sweep == state.sweepFactor-1 && d >= (NDISP_UNIT-state.remainder)) sad[d] = 2147483647;
                }


                if (row >= WSIZE-1 && col >= WSIZE-1) {
                    int skip_flag = 0;
                    Scalar<1, typename Type<((DST_T) & ((1 << 11) - 1))>::name> out_pix;
                    if (text_sum < state.textureThreshold) skip_flag = 1;
                    if ((row - WSIZE+1) < (WSIZE-1)/2 || (row - WSIZE+1) >= rows - (WSIZE-1)/2) skip_flag = 1;
                    if ((col - WSIZE+1) < NDISP-1 + (WSIZE-1)/2 || (col - WSIZE+1) >= cols - (WSIZE-1)/2) skip_flag = 1;
                    int gminsad = ((sweep > 0) ? minsad[col] : 2147483647);
                    int gmind = ((sweep > 0) ? mind[col] : 0);
                    int gskip = ((sweep > 0) ? skip[col] : 0);
                    int gskip_val = ((sweep > 0) ? skip_val[col] : 2147483647);
                    int gedge_neighbor = ((sweep > 0) ? edge_neighbor[col] : 2147483647);
                    int gedge = ((sweep > 0) ? edge[col] : sad[1]);
                    int lminsad = 2147483647;
                    int lmind = 0;
                    int gminsad_p = ((sweep > 0) ? minsad_p[col] : 2147483647);
                    int gminsad_n = ((sweep > 0) ? (gmind == sweep*NDISP_UNIT-1 ? sad[0] : minsad_n[col]) : 2147483647);
                    MinSAD<NDISP_UNIT>::find(sad, lmind, lminsad);

                    if (lminsad <= gminsad) {
                        gskip = 0;
                        if (state.uniquenessRatio > 0) {
                            int thresh = lminsad + (lminsad * state.uniquenessRatio / 100);
                            if (gminsad <= thresh && lmind+sweep*NDISP_UNIT > gmind+1) {
                                gskip = 1;
                                gskip_val = gminsad;
                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gskip_val <= thresh) {
                                gskip = 1;

                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gedge_neighbor <= thresh) {
                                gskip = 1;
                                gskip_val = gedge_neighbor;
                            }
loop_unique_search_0:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && (d < lmind-1 || d > lmind+1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }

                        gminsad_p = (lmind == 0 ? gedge : sad[lmind-1]);
                        gminsad_n = sad[lmind == NDISP_UNIT-1 ? lmind-1 : lmind+1];
                        gminsad = lminsad;
                        gmind = lmind + sweep*NDISP_UNIT;
                    } else {
                        if (state.uniquenessRatio > 0) {
                            int thresh = gminsad + (gminsad * state.uniquenessRatio / 100);
loop_unique_search_1:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && ((gmind == (sweep*NDISP_UNIT-1)) ? (d > 0) : 1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }
                    }
                    minsad[col] = gminsad;
                    mind[col] = gmind;
                    skip[col] = gskip;
                    skip_val[col] = gskip_val;
                    edge_neighbor[col] = sad[NDISP_UNIT-2];
                    edge[col] = sad[NDISP_UNIT-1];
                    minsad_p[col] = gminsad_p;
                    minsad_n[col] = gminsad_n;

                    if (sweep == state.sweepFactor-1) {
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> p = gminsad_p;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> n = gminsad_n;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> k = p + n - 2*gminsad + absdiff(p, n);
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value+8> num = p - n;
                        num = num << 8;
                        ap_int<10> delta = 0;
                        if (k != 0) delta = num/k;
                        out_pix.val[0] = ((gmind*256 + delta + 15) >> 4);

                        skip_flag |= gskip;
                        if (skip_flag) out_pix.val[0] = FILTERED;
                        disp << out_pix;
                    }
                }
            }
        }
    }
}


template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void FindStereoCorrespondenceBM(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)
{
    ((left.rows == right.rows && left.cols == right.cols && "All the images must have the same size") ? static_cast<void> (0) : __assert_fail ("left.rows == right.rows && left.cols == right.cols && \"All the images must have the same size\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 556, __PRETTY_FUNCTION__));
    ((SRC_T == (((0) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Both input images must have HLS_8UC1 format") ? static_cast<void> (0) : __assert_fail ("SRC_T == HLS_8UC1 && \"Both input images must have HLS_8UC1 format\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 557, __PRETTY_FUNCTION__));
    ((DST_T == (((3) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Disparity image must have HLS_16SC1 format") ? static_cast<void> (0) : __assert_fail ("DST_T == HLS_16SC1 && \"Disparity image must have HLS_16SC1 format\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 558, __PRETTY_FUNCTION__));
    ((state.preFilterType == 0 || state.preFilterType == 1) ? static_cast<void> (0) : __assert_fail ("state.preFilterType == HLS_STEREO_BM_NORMALIZED_RESPONSE || state.preFilterType == HLS_STEREO_BM_XSOBEL", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 559, __PRETTY_FUNCTION__));
    ((state.preFilterSize >= 5 && state.preFilterSize <= 21 && (state.preFilterSize & 1) && "preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE") ? static_cast<void> (0) : __assert_fail ("state.preFilterSize >= 5 && state.preFilterSize <= HLS_STEREO_BM_MAX_WIN_SIZE && (state.preFilterSize & 1) && \"preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 560, __PRETTY_FUNCTION__));
    ((state.preFilterCap >=1 && state.preFilterCap <= 63 && "preFilterCap must be within 1..63") ? static_cast<void> (0) : __assert_fail ("state.preFilterCap >=1 && state.preFilterCap <= 63 && \"preFilterCap must be within 1..63\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 561, __PRETTY_FUNCTION__));
    ((state.SADWindowSize >= 5 && state.SADWindowSize <= 21 && (state.SADWindowSize & 1) && state.SADWindowSize < ((left.rows) < (left.cols) ? (left.rows) : (left.cols)) && "SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height") ? static_cast<void> (0) : __assert_fail ("state.SADWindowSize >= 5 && state.SADWindowSize <= HLS_STEREO_BM_MAX_WIN_SIZE && (state.SADWindowSize & 1) && state.SADWindowSize < __HLS_MIN(left.rows, left.cols) && \"SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 562, __PRETTY_FUNCTION__));
    ((NDISP > 1 && "numberOfDisparities must be greater than 1") ? static_cast<void> (0) : __assert_fail ("NDISP > 1 && \"numberOfDisparities must be greater than 1\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 563, __PRETTY_FUNCTION__));
    ((NDISP >= NDISP_UNIT && "numberOfDisparities must be not less than ndisp_unit") ? static_cast<void> (0) : __assert_fail ("NDISP >= NDISP_UNIT && \"numberOfDisparities must be not less than ndisp_unit\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 564, __PRETTY_FUNCTION__));
    ((state.textureThreshold >= 0 && "texture threshold must be non-negative") ? static_cast<void> (0) : __assert_fail ("state.textureThreshold >= 0 && \"texture threshold must be non-negative\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 565, __PRETTY_FUNCTION__));
    ((state.uniquenessRatio >= 0 && "uniqueness ratio must be non-negative") ? static_cast<void> (0) : __assert_fail ("state.uniquenessRatio >= 0 && \"uniqueness ratio must be non-negative\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 566, __PRETTY_FUNCTION__));
    int rows = left.rows;
    int cols = left.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 569, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls/hls_video_stereobm.h", 570, __PRETTY_FUNCTION__));
    Mat<ROWS, COLS, SRC_T> _left_0(rows, cols);
    Mat<ROWS, COLS, SRC_T> _right_0(rows, cols);
#pragma HLS dataflow
    if (state.preFilterType == 0) {
        PreFilterNorm<WSIZE>(left, _left_0, state.preFilterCap);
        PreFilterNorm<WSIZE>(right, _right_0, state.preFilterCap);
    } else {
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> left_sobel(rows, cols);
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> right_sobel(rows, cols);
        Sobel<1, 0, 3>(left, left_sobel);
        Sobel<1, 0, 3>(right, right_sobel);
        Clip(left_sobel, _left_0, state.preFilterCap);
        Clip(right_sobel, _right_0, state.preFilterCap);
    }
    SADBlockMatching(_left_0, _right_0, disp, state);
}

}
#70 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_video.h" 2
#51 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h" 2



template<int ROWS, int COLS, int T>
void IplImage2hlsMat(IplImage *img, hls::Mat<ROWS, COLS, T>& hls_mat) {
    int i, j, k;
    CvScalar cv_pix;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> hls_pix;
    ((img && img->imageData && (img->nChannels == ((((T) & ((512 - 1) << 11)) >> 11) + 1)) && "Image must be valid and match the number of channels of the Mat.") ? static_cast<void> (0) : __assert_fail ("img && img->imageData && (img->nChannels == HLS_MAT_CN(T)) && \"Image must be valid and match the number of channels of the Mat.\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
#59 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    ,
 60
#59 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    , __PRETTY_FUNCTION__))
                                                                              ;
    for (i = 0; i < hls_mat.rows; i++) {
        for (j = 0; j < hls_mat.cols; j++) {
            cv_pix = cvGet2D(img, i, j);
            for (k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                hls_pix.val[k] = (typename Type<((T) & ((1 << 11) - 1))>::name)cv_pix.val[k];
            }
            hls_mat << hls_pix;
        }
    }
}

template<int ROWS, int COLS, int T>
void hlsMat2IplImage(hls::Mat<ROWS, COLS, T>& hls_mat, IplImage *img) {
    int i, j, k;
    CvScalar cv_pix;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> hls_pix;
    ((img && img->imageData && (img->nChannels == ((((T) & ((512 - 1) << 11)) >> 11) + 1)) && "Image must be valid and match the number of channels of the Mat.") ? static_cast<void> (0) : __assert_fail ("img && img->imageData && (img->nChannels == HLS_MAT_CN(T)) && \"Image must be valid and match the number of channels of the Mat.\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
#77 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    ,
 78
#77 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    , __PRETTY_FUNCTION__))
                                                                              ;
    for (i = 0; i < img->height; i++) {
        for (j = 0; j < img->width; j++) {
            hls_mat >> hls_pix;
            for (k = 0; k < img->nChannels; k++) {
                cv_pix.val[k] = (double)hls_pix.val[k];
            }
            cvSet2D(img, i, j, cv_pix);
        }
    }
}

template<int ROWS, int COLS, int T>
void cvMat2hlsMat(cv::Mat& cv_mat, hls::Mat<ROWS, COLS, T>& hls_mat) {
    IplImage img = cv_mat;
    IplImage2hlsMat(&img, hls_mat);
}

template<int ROWS, int COLS, int T>
void hlsMat2cvMat(hls::Mat<ROWS, COLS, T>& hls_mat, cv::Mat& cv_mat) {
    IplImage img = cv_mat;
    hlsMat2IplImage(hls_mat, &img);
}

template<int ROWS, int COLS, int T>
void CvMat2hlsMat(CvMat* cvmat, hls::Mat<ROWS, COLS, T>& hls_mat) {
    cv::Mat cv_mat(cvmat);
    cvMat2hlsMat(cv_mat, hls_mat);
}

template<int ROWS, int COLS, int T>
void hlsMat2CvMat(hls::Mat<ROWS, COLS, T>& hls_mat, CvMat* cvmat) {
    cv::Mat cv_mat(cvmat);
    hlsMat2cvMat(hls_mat, cv_mat);
}



template<int W>
void IplImage2AXIvideo(IplImage* img, hls::stream<ap_axiu<W,1,1,1> >& AXI_video_strm) {
    int i, j, k;
    CvScalar cv_pix;
    ap_axiu<W,1,1,1> axi;
    int depth = (img->depth & 0xff);
    ((img && img->imageData && (W >= depth*img->nChannels) && "Image must be valid and have width less than the width of the stream.") ? static_cast<void> (0) : __assert_fail ("img && img->imageData && (W >= depth*img->nChannels) && \"Image must be valid and have width less than the width of the stream.\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
#122 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    ,
 123
#122 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    , __PRETTY_FUNCTION__))
                                                                                   ;
    for (i = 0; i < img->height; i++) {
        for (j = 0; j < img->width; j++) {
            if ((i ==0) && (j == 0)) {
                axi.user = 1;
            } else {
                axi.user = 0;
            }
            if (j == (img->width -1)) {
                axi.last = 1;
            } else {
                axi.last = 0;
            }
            axi.data = -1;
            cv_pix = cvGet2D(img, i, j);
            for (k = 0; k < img->nChannels; k++) {
                switch(img->depth) {
                case 8:
                    hls::AXISetBitFields(axi, k*depth, depth, (unsigned char)cv_pix.val[k]);
                    break;
                case (0x80000000| 8):
                    hls::AXISetBitFields(axi, k*depth, depth, (char)cv_pix.val[k]);
                    break;
                case 16:
                    hls::AXISetBitFields(axi, k*depth, depth, (unsigned short)cv_pix.val[k]);
                    break;
                case (0x80000000|16):
                    hls::AXISetBitFields(axi, k*depth, depth, (short)cv_pix.val[k]);
                    break;
                case (0x80000000|32):
                    hls::AXISetBitFields(axi, k*depth, depth, (int)cv_pix.val[k]);
                    break;
                case 32:
                    hls::AXISetBitFields(axi, k*depth, depth, (float)cv_pix.val[k]);
                    break;
                case 64:
                    hls::AXISetBitFields(axi, k*depth, depth, (double)cv_pix.val[k]);
                    break;
                default:
                    hls::AXISetBitFields(axi, k*depth, depth, (unsigned char)cv_pix.val[k]);
                    break;
                }
            }
            axi.keep = -1;
            AXI_video_strm << axi;
        }
    }
}

template<int W>
void AXIvideo2IplImage(hls::stream<ap_axiu<W,1,1,1> >& AXI_video_strm, IplImage* img) {
    int i, j, k;
    ap_axiu<W,1,1,1> axi;
    CvScalar cv_pix;
    int depth = (img->depth & 0xff);
    bool sof = 0;
    ((img && img->imageData && (W >= depth*img->nChannels) && "Image must be valid and have width less than the width of the stream.") ? static_cast<void> (0) : __assert_fail ("img && img->imageData && (W >= depth*img->nChannels) && \"Image must be valid and have width less than the width of the stream.\"",
 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
#179 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    ,
 180
#179 "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h"
    , __PRETTY_FUNCTION__))
                                                                                   ;
    for (i = 0; i < img->height; i++) {
        for (j = 0; j < img->width; j++) {
            AXI_video_strm >> axi;
            if ((i == 0) && (j == 0)) {
                if (axi.user.to_int() == 1) {
                    sof = 1;
                } else {
                    j--;
                }
            }
            if (sof) {
                for (k = 0; k < img->nChannels; k++) {
                    switch(img->depth) {
                        case 8:
                        { unsigned char temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                        case (0x80000000| 8):
                        { char temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                        case 16:
                        { unsigned short temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                        case (0x80000000|16):
                        { short temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                        case (0x80000000|32):
                        { int temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                        case 32:
                        { float temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                        case 64:
                        { double temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                        default:
                        { unsigned char temp;
                            hls::AXIGetBitFields(axi, k*depth, depth, temp);
                            cv_pix.val[k] = temp;
                        }
                        break;
                    }
                }
                cvSet2D(img, i, j, cv_pix);
            }
        }
    }
}

template<int W>
void cvMat2AXIvideo(cv::Mat& cv_mat, hls::stream<ap_axiu<W,1,1,1> >& AXI_video_strm) {
    IplImage img = cv_mat;
    IplImage2AXIvideo<W>(&img, AXI_video_strm);
}

template<int W>
void AXIvideo2cvMat(hls::stream<ap_axiu<W,1,1,1> >& AXI_video_strm, cv::Mat& cv_mat) {
    IplImage img = cv_mat;
    AXIvideo2IplImage<W>(AXI_video_strm, &img);
}

template<int W>
void CvMat2AXIvideo(CvMat* cvmat, hls::stream<ap_axiu<W,1,1,1> >& AXI_video_strm) {
    cv::Mat cv_mat(cvmat);
    cvMat2AXIvideo<W>(cv_mat, AXI_video_strm);
}

template<int W>
void AXIvideo2CvMat(hls::stream<ap_axiu<W,1,1,1> >& AXI_video_strm, CvMat* cvmat) {
    cv::Mat cv_mat(cvmat);
    AXIvideo2cvMat<W>(AXI_video_strm, cv_mat);
}




template<int ROWS, int COLS, typename T>
void CvMat2hlsWindow(CvMat* cvmat, hls::Window<ROWS, COLS, T>& hls_window) {
    int i, j;
    ((cvmat && cvmat->data.ptr && "CvMat must be valid.") ? static_cast<void> (0) : __assert_fail ("cvmat && cvmat->data.ptr && \"CvMat must be valid.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h", 280, __PRETTY_FUNCTION__));
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            hls_window.val[i][j] = (T)cvmGet(cvmat, i, j);
        }
    }
}

template<int ROWS, int COLS, typename T>
void hlsWindow2CvMat(hls::Window<ROWS, COLS, T>& hls_window, CvMat* cvmat) {
    int i, j;
    ((cvmat && cvmat->data.ptr && "CvMat must be valid.") ? static_cast<void> (0) : __assert_fail ("cvmat && cvmat->data.ptr && \"CvMat must be valid.\"", "/opt/Xilinx/Vivado_HLS/2017.1/include/hls_opencv.h", 291, __PRETTY_FUNCTION__));
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            cvmSet(cvmat, i, j, (double)hls_window.val[i][j]);
        }
    }
}
#2 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp" 2

#1 "/home/dilin/vivado_hls/conv2D_fixedp/conv.h" 1


typedef ap_fixed<16,12> data_t;






void conv2Dfixp(data_t in[256*256],data_t out[256*256],data_t kernel[3*3]);
#4 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp" 2



#ifndef HLS_FASTSIM
#6 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"

#ifndef HLS_FASTSIM
#include "apatb_conv2Dfixp.h"
#endif

#6 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"
int main()
{
 cv::Mat imgU = cv::imread("/home/dilin/Desktop/izBHx.jpg",CV_LOAD_IMAGE_GRAYSCALE);
 cv::Mat img;
 imgU.convertTo(img,(((5) & ((1 << 3) - 1)) + (((1)-1) << 3)));
 data_t in[256*256];
 data_t out[256*256];
 data_t kernel[3*3] = {-1,0,1,-2,0,2,-1,0,1};

 for(int i=0;i<img.rows;i++)
 {
  for(int j=0;j<img.cols;j++)
  {
   in[i*256 +j] = img.at<float>(i,j);
  }
 }

 
#ifndef HLS_FASTSIM
#define conv2Dfixp AESL_WRAP_conv2Dfixp
#endif

#23 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"

#ifndef HLS_FASTSIM
#define conv2Dfixp AESL_WRAP_conv2Dfixp
#endif

#23 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"
conv2Dfixp
#undef conv2Dfixp
#23 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"

#undef conv2Dfixp
#23 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"
(in,out,kernel);

 for (int i = 0; i < img.rows; i++)
 {
  for (int j = 0; j < img.cols; j++)
  {
   img.at<float>(i, j) = out[i * 256 + j].to_float();
  }
 }

 cv::imwrite("/home/dilin/Desktop/out.jpg",img);

 return 0;
}
#endif
#36 "/home/dilin/vivado_hls/conv2D_fixedp/conv_test.cpp"
